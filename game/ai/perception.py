"""Lightweight perception helpers for AI modules."""

from __future__ import annotations

from typing import TYPE_CHECKING, List, Tuple

import numpy as np
import structlog

from game.world.los import line_of_sight

if TYPE_CHECKING:  # pragma: no cover - type checking only
    from polars import series
    from game.game_state import GameState

log = structlog.get_logger()


def _apply_event(map_arr: np.ndarray, x: int, y: int, intensity: float, radius: int, game_map) -> None:
    """Helper to add an event with radial falloff to a map."""
    for dx in range(-radius, radius + 1):
        for dy in range(-radius, radius + 1):
            tx, ty = x + dx, y + dy
            if not game_map.in_bounds(tx, ty):
                continue
            dist = abs(dx) + abs(dy)
            value = max(intensity - dist, 0)
            if value > 0:
                map_arr[ty, tx] += value


def gather_perception(game_state: 'GameState') -> Tuple[np.ndarray, np.ndarray, np.ndarray]:
    """Generate perception maps used by AI systems.

    Noise and scent layers are stored on ``GameMap`` and decayed every call
    before new events are applied.  Noise is generated by movement and other
    discrete actions whereas scent is produced by entities lingering in
    locations.  Line-of-sight simply reuses the visibility grid maintained by
    ``GameState.update_fov``.
    """

    game_map = game_state.game_map

    # Decay existing perception layers
    game_map.noise_map *= 0.6  # noise fades quickly
    game_map.scent_map *= 0.9  # scent lingers longer

    # Apply queued noise events
    for x, y, intensity in getattr(game_state, 'noise_events', []):
        _apply_event(game_map.noise_map, x, y, intensity, radius=2, game_map=game_map)

    # Apply queued scent events
    for x, y, intensity in getattr(game_state, 'scent_events', []):
        _apply_event(game_map.scent_map, x, y, intensity, radius=4, game_map=game_map)

    # Clear processed events
    if hasattr(game_state, 'noise_events'):
        game_state.noise_events.clear()
    if hasattr(game_state, 'scent_events'):
        game_state.scent_events.clear()

    noise_map = game_map.noise_map.copy()
    scent_map = game_map.scent_map.copy()
    # LOS uses the latest visibility grid populated by GameState.update_fov
    los_map = game_map.visible.copy()
    log.debug("Perception maps generated", shape=noise_map.shape)
    return noise_map, scent_map, los_map


def find_visible_enemies(
    entity_row: 'series',
    game_state: 'GameState',
    los_map: np.ndarray,
) -> List['series']:
    """Return a list of enemies visible to ``entity_row``.

    Entities are considered enemies if they belong to a different faction.
    Visibility is determined using both the provided ``los_map`` and a
    line-of-sight check against the game map's transparency grid.
    """

    ex, ey = entity_row.get("x"), entity_row.get("y")
    faction = entity_row.get("faction")
    game_map = game_state.game_map
    enemies: List['series'] = []

    for other in game_state.entity_registry.entities_df.iter_rows(named=True):
        if other.get("entity_id") == entity_row.get("entity_id"):
            continue
        if not other.get("is_active", False):
            continue
        if faction is not None and other.get("faction") == faction:
            continue
        ox, oy = other.get("x"), other.get("y")
        if ox is None or oy is None:
            continue
        if not game_map.in_bounds(ox, oy):
            continue
        if not los_map[oy, ox]:
            continue
        if line_of_sight(ex, ey, ox, oy, game_map.transparent):
            enemies.append(other)

    log.debug(
        "Visible enemies located",
        entity_id=entity_row.get("entity_id"),
        count=len(enemies),
    )
    return enemies


__all__ = ["gather_perception", "find_visible_enemies"]
