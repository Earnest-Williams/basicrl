"""Lightweight perception helpers for AI modules."""

from __future__ import annotations

from typing import TYPE_CHECKING, Tuple

import numpy as np
import structlog

if TYPE_CHECKING:  # pragma: no cover - type checking only
    from game.game_state import GameState

log = structlog.get_logger()


def _apply_event(map_arr: np.ndarray, x: int, y: int, intensity: float, radius: int, game_map) -> None:
    """Helper to add an event with radial falloff to a map."""
    for dx in range(-radius, radius + 1):
        for dy in range(-radius, radius + 1):
            tx, ty = x + dx, y + dy
            if not game_map.in_bounds(tx, ty):
                continue
            dist = abs(dx) + abs(dy)
            value = max(intensity - dist, 0)
            if value > 0:
                map_arr[ty, tx] += value


def gather_perception(game_state: 'GameState') -> Tuple[np.ndarray, np.ndarray, np.ndarray]:
    """Generate perception maps used by AI systems.

    Noise and scent layers are stored on ``GameMap`` and decayed every call
    before new events are applied.  Noise is generated by movement and other
    discrete actions whereas scent is produced by entities lingering in
    locations.  Line-of-sight simply reuses the visibility grid maintained by
    ``GameState.update_fov``.
    """

    game_map = game_state.game_map

    # Decay existing perception layers
    game_map.noise_map *= 0.6  # noise fades quickly
    game_map.scent_map *= 0.9  # scent lingers longer

    # Apply queued noise events
    for x, y, intensity in getattr(game_state, 'noise_events', []):
        _apply_event(game_map.noise_map, x, y, intensity, radius=2, game_map=game_map)

    # Apply queued scent events
    for x, y, intensity in getattr(game_state, 'scent_events', []):
        _apply_event(game_map.scent_map, x, y, intensity, radius=4, game_map=game_map)

    # Clear processed events
    if hasattr(game_state, 'noise_events'):
        game_state.noise_events.clear()
    if hasattr(game_state, 'scent_events'):
        game_state.scent_events.clear()

    noise_map = game_map.noise_map.copy()
    scent_map = game_map.scent_map.copy()
    # LOS uses the latest visibility grid populated by GameState.update_fov
    los_map = game_map.visible.copy()
    log.debug("Perception maps generated", shape=noise_map.shape)
    return noise_map, scent_map, los_map
