# simulation.py
#!/usr/bin/env python3

import heapq
import random
import time
import typing
import uuid
from collections import defaultdict, deque
from typing import Optional  # Import Optional here

# --- NumPy for potential future use ---
# --- Polars DataFrame Library ---
import polars as pl

# --- Numba JIT Compiler ---
from numba import njit

# --- Type Hinting Aliases ---
Position = tuple[int, int]
EntityID = str
StateDict = dict[str, typing.Any]
ActionPlan = deque["Action"]
OptionalEntity = Optional["Entity"]
OptionalPosition = Optional[Position]
OptionalPath = Optional[list[Position]]
NearestResult = tuple[EntityID | None, float]
ActionResult = Optional[str]
ItemObject = Optional[typing.Any]

# --- Item Definitions ---


class Item:
    """Base class for all items."""

    def __init__(self, name: str, kind: str, description: str = ""):
        self.id = str(uuid.uuid4())
        self.name = name
        self.kind = kind
        self.description = description

    def __repr__(self):
        return f"Item({self.name})"


class Consumable(Item):
    """Items that can be consumed for an effect."""

    def __init__(self, name: str, restores: str, amount: float, description: str = ""):
        super().__init__(name, "consumable", description)
        self.restores = restores
        self.amount = amount


class Weapon(Item):
    """Items that can be equipped to enhance attacks."""

    def __init__(self, name: str, damage: int, description: str = ""):
        super().__init__(name, "weapon", description)
        self.damage = damage


class Utility(Item):
    """Items with other uses (like torches)."""

    def __init__(self, name: str, description: str = ""):
        super().__init__(name, "utility", description)


def create_slime_mold() -> Consumable:
    return Consumable(
        "Slime Mold",
        restores="hunger",
        amount=40.0,
        description="A quivering, edible mold.",
    )


def create_health_potion() -> Consumable:
    return Consumable(
        "Health Potion",
        restores="health",
        amount=50.0,
        description="Restores some health.",
    )


def create_dagger() -> Weapon:
    return Weapon("Dagger", damage=5, description="A simple dagger.")


def create_torch() -> Utility:
    return Utility("Torch", description="Provides light (eventually).")


# --- Configuration Constants ---
GRID_SIZE: int = 15
MAX_TURNS: int = 200
START_HEALTH: float = 100.0
START_HUNGER: float = 100.0
SLIME_MOLD_HUNGER_RECOVERY: float = 40.0
HEALTH_POTION_RECOVERY: float = 50.0
BASE_AGENT_DAMAGE: int = 5
ENEMY_DMG: int = 15
SLIME_HEALTH: int = 15
SLIME_DMG: int = 5
ENEMY_START_HEALTH_RANGE: tuple[int, int] = (40, 60)
ENEMY_FLEE_THRESHOLD: float = 0.25
ENEMY_SPAWN_CHANCE: float = 0.02
FOOD_RESPAWN_CHANCE: float = 0.10
PASSIVE_HUNGER_PER_TURN: float = 0.1
STARVATION_HEALTH_DAMAGE: float = 0.5
ATTACK_HUNGER_COST: float = 0.05
DEFEND_HUNGER_COST: float = 0.05
REST_HEALTH_REGEN: float = 0.05
LOW_HEALTH_FLEE_THRESHOLD: float = START_HEALTH * 0.4
ENEMY_NEARBY_FLEE_DISTANCE: int = 8
HEALTHY_THRESHOLD: float = START_HEALTH * 0.6
CRITICAL_HEALTH_THRESHOLD: float = START_HEALTH * 0.3
PLANNING_TIMEOUT: float = 0.1
ACTION_WEIGHT_MIN: float = 0.1
ACTION_WEIGHT_MAX: float = 10.0
LEARNING_RATE_FACTOR: float = 0.15
LEARNING_SCORE_BASELINE: float = 0.6
AGENT_MAX_INVENTORY: int = 5

# --- Helper Functions ---


@njit(cache=True)
def distance(x1: int, y1: int, x2: int, y2: int) -> int:
    return abs(x1 - x2) + abs(y1 - y2)


# --- Entity Class ---


class Entity:
    """Represents agents, enemies, or items on the ground."""

    def __init__(
        self,
        x: int,
        y: int,
        kind: str,
        health: float | None = None,  # Use imported Optional
        hunger: float | None = None,  # Use imported Optional
        target: OptionalEntity = None,  # Uses alias defined with Optional
        item: Item | None = None,
    ):  # Use imported Optional
        self.id: EntityID = str(uuid.uuid4())
        self.x: int = x
        self.y: int = y
        self.kind: str = kind
        self.target: OptionalEntity = target
        self.item: Item | None = item
        self.inventory: list[Item] = []
        self.max_inventory: int = AGENT_MAX_INVENTORY if kind == "agent" else 3
        self.equipped_weapon: Weapon | None = None

        # --- Health Initialization (Corrected Indentation) ---
        if health is None:
            default_health = 0.0  # Indent level 1 (4 spaces)
            if kind == "agent":  # Indent level 2 (8 spaces)
                default_health = START_HEALTH
            elif kind == "enemy":  # Indent level 2
                default_health = float(
                    random.randint(*ENEMY_START_HEALTH_RANGE))
            elif kind == "slime":  # Indent level 2
                default_health = float(SLIME_HEALTH)
            # Items on ground have no health unless they can be destroyed?
            self.health: float = default_health  # Indent level 1
        else:
            self.health: float = float(health)  # Indent level 1

        # --- Hunger Initialization (Corrected Indentation) ---
        if hunger is None:
            # Assume relevant entities start full, others have no hunger concept
            self.hunger: float = (
                START_HUNGER if kind in ["agent", "enemy", "slime"] else 0.0
            )  # Indent level 1
        else:
            self.hunger: float = float(hunger)  # Indent level 1
        # --- END INDENTATION FIX ---

    def get_position(self) -> Position:
        return (self.x, self.y)

    def get_effective_damage(self) -> int:
        if self.equipped_weapon:
            return self.equipped_weapon.damage
        elif self.kind == "agent":
            return BASE_AGENT_DAMAGE
        elif self.kind == "enemy":
            return ENEMY_DMG
        elif self.kind == "slime":
            return SLIME_DMG
        return 0

    def __repr__(self) -> str:
        details = []
        if self.kind in ["agent", "enemy", "slime"]:
            details.append(f"H:{self.health:.1f}")
            details.append(f"U:{self.hunger:.1f}")
        if self.item:
            details.append(f"Item:{self.item.name}")
        if self.equipped_weapon:
            details.append(f"W:{self.equipped_weapon.name}")
        if self.inventory:
            details.append(f"Inv:{len(self.inventory)}/{self.max_inventory}")
        detail_str = ", ".join(details)
        return (
            f"{self.kind.capitalize()}({self.id[:4]} @ ({self.x},{self.y})"
            + (f", {detail_str}" if detail_str else "")
            + ")"
        )


# --- World Class ---


class World:
    # (World methods remain the same as previous correct version)
    def __init__(self, size: int):
        self.size: int = size
        self.grid: list[list[OptionalEntity]] = [
            [None for _ in range(size)] for _ in range(size)
        ]
        self.entities: dict[EntityID, Entity] = {}
        self.entity_df: pl.DataFrame = self._create_empty_entity_df()
        self.entities_by_kind: defaultdict[
            str, dict[EntityID, Entity]
        ] = defaultdict(dict)
        self.agent: OptionalEntity = None
        self.turn: int = 0
        self._free_tiles: set[Position] = set(
            (x, y) for x in range(size) for y in range(size)
        )

    def _create_empty_entity_df(self) -> pl.DataFrame:
        schema = {
            "id": pl.Utf8,
            "x": pl.Int32,
            "y": pl.Int32,
            "kind": pl.Utf8,
            "health": pl.Float32,
            "hunger": pl.Float32,
        }
        return pl.DataFrame(schema=schema)

    def is_valid(self, x: int, y: int) -> bool:
        return 0 <= x < self.size and 0 <= y < self.size

    def get_entity_at(self, x: int, y: int) -> OptionalEntity:
        if not self.is_valid(x, y):
            return None
        return self.grid[x][y]

    def get_entity_object(self, entity_id: EntityID) -> OptionalEntity:
        return self.entities.get(entity_id)

    def add_entity(self, entity: Entity) -> bool:
        pos = entity.get_position()
        existing_entity = self.grid[pos[0]][pos[1]]
        if not self.is_valid(pos[0], pos[1]) or (
            existing_entity is not None and existing_entity.kind != "item"
        ):
            if (
                existing_entity
                and existing_entity.kind == "item"
                and entity.kind == "item"
            ):
                pass
            else:
                return False
        if entity.kind != "item" and existing_entity and existing_entity.kind == "item":
            pass
        self.grid[pos[0]][pos[1]] = entity
        self._free_tiles.discard(pos)
        self.entities[entity.id] = entity
        self.entities_by_kind[entity.kind][entity.id] = entity
        if entity.kind != "item":
            new_entity_data = {
                "id": [entity.id],
                "x": [entity.x],
                "y": [entity.y],
                "kind": [entity.kind],
                "health": [entity.health],
                "hunger": [entity.hunger],
            }
            new_df = pl.DataFrame(
                new_entity_data, schema=self.entity_df.schema)
            self.entity_df = pl.concat(
                [self.entity_df, new_df], how="vertical")
        if entity.kind == "agent":
            self.agent = entity
        return True

    def remove_entity(self, entity: Entity):
        entity_id = entity.id
        if entity_id in self.entities:
            pos = self.entities[entity_id].get_position()
            del self.entities[entity_id]
            if self.is_valid(pos[0], pos[1]) and self.grid[pos[0]][pos[1]] == entity:
                self.grid[pos[0]][pos[1]] = None
                self._free_tiles.add(pos)
            self.entities_by_kind[entity.kind].pop(entity_id, None)
            if entity.kind != "item":
                self.entity_df = self.entity_df.filter(
                    pl.col("id") != entity_id)
            if self.agent and entity_id == self.agent.id:
                self.agent = None

    def update_entity_health(self, entity_id: EntityID, new_health: float):
        entity_obj = self.get_entity_object(entity_id)
        clamped_health = max(0.0, min(START_HEALTH, new_health))
        if entity_obj and entity_obj.kind != "item":
            entity_obj.health = clamped_health
            self.entity_df = self.entity_df.with_columns(
                pl.when(pl.col("id") == entity_id)
                .then(pl.lit(clamped_health, dtype=pl.Float32))
                .otherwise(pl.col("health"))
                .alias("health")
            )

    def update_entity_hunger(self, entity_id: EntityID, new_hunger: float):
        entity_obj = self.get_entity_object(entity_id)
        clamped_hunger = max(0.0, min(START_HUNGER, new_hunger))
        if entity_obj and entity_obj.kind != "item":
            entity_obj.hunger = clamped_hunger
            self.entity_df = self.entity_df.with_columns(
                pl.when(pl.col("id") == entity_id)
                .then(pl.lit(clamped_hunger, dtype=pl.Float32))
                .otherwise(pl.col("hunger"))
                .alias("hunger")
            )

    def move_entity(self, entity: Entity, new_x: int, new_y: int) -> bool:
        if entity.kind == "item":
            return False
            entity_id = entity.id
            current_pos = entity.get_position()
            target_entity = self.grid[new_x][new_y]
        if not self.is_valid(new_x, new_y):
            return False
        if target_entity is not None and target_entity.kind != "item":
            return False
        if (
            not self.is_valid(current_pos[0], current_pos[1])
            or self.grid[current_pos[0]][current_pos[1]] != entity
        ):
            return False
        self.grid[current_pos[0]][current_pos[1]] = None
        self._free_tiles.add(current_pos)
        self.grid[new_x][new_y] = entity
        self._free_tiles.discard((new_x, new_y))
        entity.x, entity.y = new_x, new_y
        self.entity_df = self.entity_df.with_columns(
            pl.when(pl.col("id") == entity_id)
            .then(pl.lit(new_x, dtype=pl.Int32))
            .otherwise(pl.col("x"))
            .alias("x"),
            pl.when(pl.col("id") == entity_id)
            .then(pl.lit(new_y, dtype=pl.Int32))
            .otherwise(pl.col("y"))
            .alias("y"),
        )
        return True

    def get_entities_by_kind_df(self, kind: str) -> pl.DataFrame:
        return self.entity_df.filter(pl.col("kind") == kind)

    def get_nearest_entity(
        self, source_entity: Entity, kind: str, max_dist: int | None = None
    ) -> NearestResult:
        sx, sy = source_entity.get_position()
        if kind != "item":
            target_df = self.get_entities_by_kind_df(kind)
            if target_df.height == 0:
                return None, float("inf")
            distances = (target_df["x"] - sx).abs() + \
                (target_df["y"] - sy).abs()
            target_df_with_dist = target_df.select(
                pl.col("*"), distances.alias("dist"))
            if max_dist is not None:
                target_df_filtered = target_df_with_dist.filter(
                    pl.col("dist") <= max_dist
                )
                if target_df_filtered.height == 0:
                    return None, float("inf")
                    target_df_to_search = target_df_filtered
            else:
                target_df_to_search = target_df_with_dist
            min_dist_idx = target_df_to_search["dist"].arg_min()
            if min_dist_idx is not None:
                nearest_id = target_df_to_search["id"][min_dist_idx]
                min_distance = target_df_to_search["dist"][min_dist_idx]
                return nearest_id, float(min_distance)
            else:
                return None, float("inf")
        else:
            min_d = float("inf")
            nearest_id = None
            for entity_id_loop, entity_obj in self.entities_by_kind.get(
                kind, {}
            ).items():
                d = distance(sx, sy, entity_obj.x, entity_obj.y)
                if d < min_d and (max_dist is None or d <= max_dist):
                    min_d = d
                    nearest_id = entity_id_loop
            return nearest_id, min_d

    def find_path(self, start_pos: Position, goal_pos: Position) -> OptionalPath:
        start_x, start_y = start_pos
        goal_x, goal_y = goal_pos
        if not self.is_valid(start_x, start_y) or not self.is_valid(goal_x, goal_y):
            return None
        goal_entity = self.get_entity_at(goal_x, goal_y)
        if (
            goal_entity
            and goal_entity.kind not in ["item", "agent"]
            and start_pos != goal_pos
        ):
            return None
        open_set: list[tuple[float, int, Position]] = [
            (distance(start_x, start_y, goal_x, goal_y), 0, start_pos)
        ]
        came_from: dict[Position, Position] = {}
        g_score: defaultdict[Position, float] = defaultdict(
            lambda: float("inf"))
        g_score[start_pos] = 0.0
        count = 1
        while open_set:
            _, _, current_pos = heapq.heappop(open_set)
            current_x, current_y = current_pos
            if current_pos == goal_pos:
                path: list[Position] = []  # Corrected line
                temp_pos = current_pos
                while temp_pos in came_from:
                    path.append(temp_pos)
                    temp_pos = came_from[temp_pos]
                return path[::-1]
            for dx, dy in [(0, 1), (1, 0), (0, -1), (-1, 0)]:
                neighbor_pos = (current_x + dx, current_y + dy)
                neighbor_x, neighbor_y = neighbor_pos
                if not self.is_valid(neighbor_x, neighbor_y):
                    continue
                neighbor_entity = self.grid[neighbor_x][neighbor_y]
                if (
                    neighbor_entity is not None
                    and neighbor_entity.kind != "item"
                    and neighbor_pos != goal_pos
                ):
                    continue
                tentative_g_score = g_score[current_pos] + 1.0
                if tentative_g_score < g_score[neighbor_pos]:
                    came_from[neighbor_pos] = current_pos
                    g_score[neighbor_pos] = tentative_g_score
                    h_score = float(
                        distance(neighbor_x, neighbor_y, goal_x, goal_y))
                    f_score = tentative_g_score + h_score
                    heapq.heappush(open_set, (f_score, count, neighbor_pos))
                    count += 1
        return None

    def _get_random_free_pos(self) -> OptionalPosition:
        if not self._free_tiles:
            return None
        try:
            return random.choice(list(self._free_tiles))
        except IndexError:
            return None

    def populate_world(
        self, num_food: int, num_enemies: int, num_slimes: int = 3, num_items: int = 2
    ):
        agent_start_pos = self._get_random_free_pos()
        if agent_start_pos:
            agent = Entity(
                agent_start_pos[0],
                agent_start_pos[1],
                "agent",
                health=START_HEALTH,
                hunger=START_HUNGER,
            )
            self.add_entity(agent)
        else:
            print("Fatal Error: No space to place agent!")
            return
        for _ in range(num_enemies):
            pos = self._get_random_free_pos()
            if pos:
                enemy = Entity(
                    pos[0],
                    pos[1],
                    "enemy",
                    health=float(random.randint(*ENEMY_START_HEALTH_RANGE)),
                    hunger=START_HUNGER,
                )
                self.add_entity(enemy)
        for _ in range(num_slimes):
            pos = self._get_random_free_pos()
            if pos:
                slime = Entity(
                    pos[0],
                    pos[1],
                    "slime",
                    health=float(SLIME_HEALTH),
                    hunger=START_HUNGER,
                )
                self.add_entity(slime)
        for _ in range(num_items):
            pos = self._get_random_free_pos()
            if pos:
                item_type = random.choice(
                    [create_health_potion, create_dagger])
                item_obj = item_type()
                item_entity = Entity(
                    pos[0], pos[1], "item", health=0.0, hunger=0.0, item=item_obj
                )
                self.add_entity(item_entity)

    def reset(
        self,
        num_food: int = 0,
        num_enemies: int = 4,
        num_slimes: int = 3,
        num_items: int = 2,
    ):
        self.grid = [[None for _ in range(self.size)]
                     for _ in range(self.size)]
        self.entities = {}
        self.entity_df = self._create_empty_entity_df()
        self.entities_by_kind = defaultdict(dict)
        self.agent = None
        self.turn = 0
        self._free_tiles = set(
            (x, y) for x in range(self.size) for y in range(self.size)
        )
        self.populate_world(num_food, num_enemies, num_slimes, num_items)

    def spawn_random_enemy(self):
        pos = self._get_random_free_pos()
        if pos:
            if random.random() < 0.4:
                new_enemy = Entity(
                    pos[0],
                    pos[1],
                    "slime",
                    health=float(SLIME_HEALTH),
                    hunger=START_HUNGER,
                )
            else:
                new_enemy = Entity(
                    pos[0],
                    pos[1],
                    "enemy",
                    health=float(random.randint(*ENEMY_START_HEALTH_RANGE)),
                    hunger=START_HUNGER,
                )
            self.add_entity(new_enemy)


# --- GOAP Action Class ---
CostCalculator = typing.Callable[["World", "Entity"], float]
PreconditionsChecker = typing.Callable[[StateDict], bool]
EffectsApplier = typing.Callable[[StateDict], StateDict]
Executor = typing.Callable[["World", "Entity"], bool]


class Action:
    def __init__(
        self,
        name: str,
        cost_calculator: CostCalculator,
        preconditions_checker: PreconditionsChecker,
        effects_applier: EffectsApplier,
        executor: Executor,
    ):
        self.name: str = name
        self.calculate_cost: CostCalculator = cost_calculator
        self.check_preconditions: PreconditionsChecker = preconditions_checker
        self.apply_effects_to_state: EffectsApplier = effects_applier
        self.execute: Executor = executor

    def __repr__(self) -> str:
        return f"Action({self.name})"


# --- GOAP Planner ---


class GOAPPlanner:
    def __init__(self, available_actions: list[Action]):
        self.actions: list[Action] = available_actions
        self.action_weights: defaultdict[str, float] = defaultdict(lambda: 1.0)

    def plan(
        self, world: World, agent: Entity, goal_state: StateDict
    ) -> list[Action] | None:
        start_time = time.time()
        initial_state = self._get_world_state_representation(world, agent)
        open_list: list[
            tuple[float, int, StateDict, list[Action], float]
        ] = [(self._heuristic(initial_state, goal_state), 0, initial_state, [], 0.0)]
        closed_set: set[tuple[tuple[str, typing.Any], ...]] = set()
        counter = 1
        while open_list:
            if time.time() - start_time > PLANNING_TIMEOUT:
                return None
            f_score, _, current_state, action_plan, cost_so_far = heapq.heappop(
                open_list
            )
            if self._goal_satisfied(current_state, goal_state):
                return action_plan
            state_tuple = tuple(sorted(current_state.items()))
            if state_tuple in closed_set:
                continue
                closed_set.add(state_tuple)
            for action in self.actions:
                if action.check_preconditions(current_state):
                    action_base_cost = action.calculate_cost(world, agent)
                    if action_base_cost == float("inf"):
                        continue
                    weighted_cost = action_base_cost * \
                        self.action_weights[action.name]
                    next_state = action.apply_effects_to_state(
                        current_state.copy())
                    next_state_tuple = tuple(sorted(next_state.items()))
                    if next_state_tuple in closed_set:
                        continue
                    new_cost = cost_so_far + weighted_cost
                    h = self._heuristic(next_state, goal_state)
                    new_f_score = new_cost + h
                    new_plan = action_plan + [action]
                    heapq.heappush(
                        open_list,
                        (new_f_score, counter, next_state, new_plan, new_cost),
                    )
                    counter += 1
        return None

    def _get_world_state_representation(self, world: World, agent: Entity) -> StateDict:
        nearest_item_id, item_dist = world.get_nearest_entity(agent, "item")
        item_is_adjacent = item_dist <= 1.0
        enemy_id, enemy_dist = world.get_nearest_entity(agent, "enemy")
        slime_id, slime_dist = world.get_nearest_entity(agent, "slime")
        nearest_hostile_id = None
        nearest_hostile_dist = float("inf")
        if enemy_id and enemy_dist < nearest_hostile_dist:
            nearest_hostile_dist = enemy_dist
            nearest_hostile_id = enemy_id
        if slime_id and slime_dist < nearest_hostile_dist:
            nearest_hostile_dist = slime_dist
            nearest_hostile_id = slime_id
        adjacent_hostile = nearest_hostile_dist <= 1.0
        inventory_count = len(agent.inventory)
        inventory_full = inventory_count >= agent.max_inventory
        has_slime_mold = any(
            isinstance(item, Consumable) and item.name == "Slime Mold"
            for item in agent.inventory
        )
        has_health_potion = any(
            isinstance(item, Consumable) and item.name == "Health Potion"
            for item in agent.inventory
        )
        has_weapon_in_inv = any(isinstance(item, Weapon)
                                for item in agent.inventory)
        weapon_equipped = agent.equipped_weapon is not None
        return {
            "agent_health": agent.health,
            "agent_hunger": agent.hunger,
            "is_starving": agent.hunger <= 0,
            "agent_pos": agent.get_position(),
            "is_healthy": agent.health > HEALTHY_THRESHOLD,
            "is_critically_injured": agent.health < CRITICAL_HEALTH_THRESHOLD,
            "nearest_item_dist": item_dist,
            "item_is_adjacent": item_is_adjacent,
            "can_find_item": nearest_item_id is not None,
            "nearest_enemy_dist": nearest_hostile_dist,
            "enemy_is_adjacent": adjacent_hostile,
            "can_find_enemy": nearest_hostile_id is not None,
            "inventory_count": inventory_count,
            "inventory_full": inventory_full,
            "has_slime_mold": has_slime_mold,
            "has_health_potion": has_health_potion,
            "has_weapon_in_inv": has_weapon_in_inv,
            "weapon_equipped": weapon_equipped,
        }

    # --- FIXED _goal_satisfied ---
    def _goal_satisfied(self, current_state: StateDict, goal_state: StateDict) -> bool:
        """Checks if the current state satisfies the goal state (corrected logic)."""
        if not goal_state:
            return True
        for key, desired_value in goal_state.items():
            if key not in current_state:
                return False  # Goal requires a state not present

            current_value = current_state[key]  # Assign ONLY if key exists

            # Determine if this specific condition is satisfied
            satisfied = False
            if isinstance(desired_value, bool):
                satisfied = current_value == desired_value
            elif callable(desired_value):
                satisfied = desired_value(current_value)
            else:  # Assume direct comparison for other types
                satisfied = current_value == desired_value

            # If *any* condition is not satisfied, the goal is not met
            if not satisfied:
                return False
        # If loop completes without returning False, all conditions were met
        return True

    # --- END FIX ---

    def _heuristic(self, state: StateDict, goal_state: StateDict) -> float:
        cost: float = 0.0
        for key, desired_value in goal_state.items():
            current_value = state.get(key)
            is_satisfied = False
            if isinstance(desired_value, bool):
                is_satisfied = current_value == desired_value
            elif callable(desired_value):
                is_satisfied = (
                    desired_value(
                        current_value) if current_value is not None else False
                )
            else:
                is_satisfied = current_value == desired_value
            if not is_satisfied:
                cost += 1.0
        if goal_state.get("is_not_starving", False) and state.get("is_starving", True):
            cost += 2.0
            if state.get("has_slime_mold"):
                cost += 0.1
            elif state.get("can_find_item"):
                cost += state.get("nearest_item_dist", 0) / 2.0
        if goal_state.get("is_healthy", False) and not state.get("is_healthy", False):
            cost += 1.0
            if state.get("has_health_potion"):
                cost += 0.1
            elif state.get("can_find_item"):
                cost += state.get("nearest_item_dist", 0) / 3.0
        if goal_state.get("flee_goal_achieved", False) and state.get(
            "can_find_enemy", False
        ):
            cost += ENEMY_NEARBY_FLEE_DISTANCE - state.get(
                "nearest_enemy_dist", ENEMY_NEARBY_FLEE_DISTANCE
            )
        if goal_state.get("has_weapon_equipped", False) and not state.get(
            "weapon_equipped", False
        ):
            if state.get("has_weapon_in_inv"):
                cost += 0.5
            elif state.get("can_find_item"):
                cost += state.get("nearest_item_dist", 0) / 4.0
        return cost

    def update_weights(
        self, executed_action_names: list[str], success_metric: float
    ):
        if not executed_action_names:
            return
            learning_adjustment = (
                success_metric - LEARNING_SCORE_BASELINE
            ) * LEARNING_RATE_FACTOR
            updated_names = set()
        for name in executed_action_names:
            if name in updated_names:
                continue
                current_weight = self.action_weights[name]
                new_weight = current_weight * (1.0 + learning_adjustment)
            self.action_weights[name] = max(
                ACTION_WEIGHT_MIN, min(new_weight, ACTION_WEIGHT_MAX)
            )
            updated_names.add(name)


# --- Agent Class ---


class AgentAI:
    # (AgentAI methods remain the same as previous correct version)
    def __init__(self, world: World):
        self.world: World = world
        self.actions: list[Action] = self._define_actions()
        self.planner: GOAPPlanner = GOAPPlanner(self.actions)
        self.current_plan: ActionPlan = deque()
        self.current_goal: StateDict | None = None
        self.last_executed_plan_actions: list[str] = []
        self.last_action_name: ActionResult = None

    def _define_actions(self) -> list[Action]:
        actions_list = []

        def _get_target_pos(w: World, a: Entity, kind: str) -> OptionalPosition:
            target_id, _ = w.get_nearest_entity(a, kind)

            if target_id:
                target_obj = w.get_entity_object(target_id)
                return target_obj.get_position() if target_obj else None
            return None

        def _execute_move_to(w: World, a: Entity, target_pos: OptionalPosition) -> bool:
            if not target_pos:
                return False
            path = w.find_path(a.get_position(), target_pos)
            if path:
                return w.move_entity(a, path[0][0], path[0][1])
            return False

        def cost_simple(w: World, a: Entity) -> float:
            return 1.0

        def cost_attack(w: World, a: Entity) -> float:
            return 1.5

        def cost_explore(w: World, a: Entity) -> float:
            return 2.0

        def cost_flee(w: World, a: Entity) -> float:
            return 0.5

        def cost_wait(w: World, a: Entity) -> float:
            return 0.1

        def cost_pickup(w: World, a: Entity) -> float:
            return 0.8

        def cost_consume(w: World, a: Entity) -> float:
            return 0.5

        def cost_equip(w: World, a: Entity) -> float:
            return 0.6

        def cost_move_via_distance(w: World, a: Entity, kind: str) -> float:
            _, dist = w.get_nearest_entity(a, kind)
            return dist + 0.1 if dist != float("inf") else float("inf")

        def pre_always_true(state: StateDict) -> bool:
            return True

        def pre_can_find_enemy(state: StateDict) -> bool:
            return state.get("can_find_enemy", False)

        def pre_enemy_adjacent(state: StateDict) -> bool:
            return state.get("enemy_is_adjacent", False)

        def pre_can_flee(state: StateDict) -> bool:
            return (
                state.get("can_find_enemy", False)
                and state.get("nearest_enemy_dist", float("inf"))
                < ENEMY_NEARBY_FLEE_DISTANCE
            )

        def pre_item_adjacent(state: StateDict) -> bool:
            return state.get("item_is_adjacent", False)

        def pre_inventory_not_full(state: StateDict) -> bool:
            return not state.get("inventory_full", True)

        def pre_has_slime_mold(state: StateDict) -> bool:
            return state.get("has_slime_mold", False)

        def pre_has_health_potion(state: StateDict) -> bool:
            return state.get("has_health_potion", False)

        def pre_has_weapon_in_inv(state: StateDict) -> bool:
            return state.get("has_weapon_in_inv", False)

        def pre_weapon_not_equipped(state: StateDict) -> bool:
            return not state.get("weapon_equipped", True)

        def effect_update_position(state: StateDict) -> StateDict:
            state["agent_pos"] = None
            state["enemy_is_adjacent"] = False
            state["item_is_adjacent"] = False
            state["nearest_food_dist"] = (
                state.get("nearest_food_dist", float("inf")) + 1
            )
            state["nearest_enemy_dist"] = (
                state.get("nearest_enemy_dist", float("inf")) + 1
            )
            state["nearest_item_dist"] = (
                state.get("nearest_item_dist", float("inf")) + 1
            )
            return state

        def effect_attack_enemy(state: StateDict) -> StateDict:
            state["enemy_is_adjacent"] = False
            state["can_find_enemy"] = False
            state["nearest_enemy_dist"] = float("inf")
            return state

        def effect_explore(state: StateDict) -> StateDict:
            state = effect_update_position(state)
            state["explored_something"] = True
            return state

        def effect_flee(state: StateDict) -> StateDict:
            state["enemy_is_adjacent"] = False
            state["nearest_enemy_dist"] = state.get(
                "nearest_enemy_dist", 0) + 5
            state["flee_goal_achieved"] = True
            return state

        def effect_wait(state: StateDict) -> StateDict:
            state["is_resting"] = True
            state["is_healthy"] = True
            return state

        def effect_pickup_item(state: StateDict) -> StateDict:
            state["inventory_count"] = state.get("inventory_count", 0) + 1
            state["inventory_full"] = state["inventory_count"] >= AGENT_MAX_INVENTORY
            state["item_is_adjacent"] = False
            state["can_find_item"] = False
            state["nearest_item_dist"] = float("inf")
            state["has_slime_mold"] = True
            state["has_health_potion"] = True
            state["has_weapon_in_inv"] = True
            return state

        def effect_consume_slime_mold(state: StateDict) -> StateDict:
            state["agent_hunger"] = START_HUNGER
            state["is_starving"] = False
            state["inventory_count"] = state.get("inventory_count", 1) - 1
            state["inventory_full"] = False
            state["has_slime_mold"] = False
            return state

        def effect_consume_health_potion(state: StateDict) -> StateDict:
            state["agent_health"] = START_HEALTH
            state["is_healthy"] = True
            state["is_critically_injured"] = False
            state["inventory_count"] = state.get("inventory_count", 1) - 1
            state["inventory_full"] = False
            state["has_health_potion"] = False
            return state

        def effect_equip_weapon(state: StateDict) -> StateDict:
            state["weapon_equipped"] = True
            state["has_weapon_in_inv"] = False
            state["inventory_count"] = state.get("inventory_count", 1) - 1
            state["inventory_full"] = False
            return state

        def execute_attack_adjacent_enemy(w: World, a: Entity) -> bool:
            enemy_id, dist = w.get_nearest_entity(a, "enemy", max_dist=1)
            if not enemy_id:
                enemy_id, dist = w.get_nearest_entity(a, "slime", max_dist=1)
            if enemy_id:
                enemy_obj = w.get_entity_object(enemy_id)
                if enemy_obj:
                    damage_dealt = a.get_effective_damage()
                    new_enemy_health = max(
                        0.0, enemy_obj.health - damage_dealt)
                    w.update_entity_health(enemy_id, new_enemy_health)
                    new_attacker_hunger = max(
                        0.0, a.hunger - ATTACK_HUNGER_COST)
                    w.update_entity_hunger(a.id, new_attacker_hunger)
                    if new_enemy_health <= 0:
                        if enemy_obj.kind == "slime":
                            mold_item = create_slime_mold()
                            item_entity = Entity(
                                enemy_obj.x, enemy_obj.y, "item", item=mold_item
                            )
                            w.add_entity(item_entity)
                            print(f"Slime dropped {mold_item.name}")
                        w.remove_entity(enemy_obj)
                    return True
            return False

        def execute_explore(w: World, a: Entity) -> bool:
            possible_moves: list[Position] = []
            ax, ay = a.get_position()
            for dx in [-1, 0, 1]:
                for dy in [-1, 0, 1]:
                    if dx == 0 and dy == 0:
                        continue
                    nx, ny = ax + dx, ay + dy
                    if w.is_valid(nx, ny) and w.grid[nx][ny] is None:
                        possible_moves.append((nx, ny))
            if possible_moves:
                nx, ny = random.choice(possible_moves)
                return w.move_entity(a, nx, ny)
            return False

        def execute_flee(w: World, a: Entity) -> bool:
            enemy_id, enemy_dist = w.get_nearest_entity(
                a, "enemy", max_dist=ENEMY_NEARBY_FLEE_DISTANCE
            )
            slime_id, slime_dist = w.get_nearest_entity(
                a, "slime", max_dist=ENEMY_NEARBY_FLEE_DISTANCE
            )
            nearest_hostile_id = None
            nearest_hostile_dist = float("inf")
            nearest_hostile_obj = None
            if enemy_id and enemy_dist < nearest_hostile_dist:
                nearest_hostile_dist = enemy_dist
                nearest_hostile_id = enemy_id
            if slime_id and slime_dist < nearest_hostile_dist:
                nearest_hostile_dist = slime_dist
                nearest_hostile_id = slime_id
            if not nearest_hostile_id:
                return execute_explore(w, a)
            nearest_hostile_obj = w.get_entity_object(nearest_hostile_id)
            if not nearest_hostile_obj:
                return execute_explore(w, a)
            agent_pos = a.get_position()
            enemy_pos = nearest_hostile_obj.get_position()
            best_flee_spot = None
            max_dist_from_enemy = -1
            possible_moves = []
            current_dist = distance(
                agent_pos[0], agent_pos[1], enemy_pos[0], enemy_pos[1]
            )
            for dx in [-1, 0, 1]:
                for dy in [-1, 0, 1]:
                    if dx == 0 and dy == 0:
                        continue
                    nx, ny = agent_pos[0] + dx, agent_pos[1] + dy
                    target_tile_entity = w.get_entity_at(nx, ny)
                    if w.is_valid(nx, ny) and (
                        target_tile_entity is None or target_tile_entity.kind == "item"
                    ):
                        dist_from_enemy = distance(
                            nx, ny, enemy_pos[0], enemy_pos[1])
                        possible_moves.append(((nx, ny), dist_from_enemy))
                        if dist_from_enemy > max_dist_from_enemy:
                            max_dist_from_enemy = dist_from_enemy
                            best_flee_spot = (nx, ny)
            if best_flee_spot and max_dist_from_enemy > current_dist:
                return w.move_entity(a, best_flee_spot[0], best_flee_spot[1])
            elif possible_moves:
                possible_moves.sort(key=lambda item: item[1], reverse=True)
                best_move = possible_moves[0][0]
                return w.move_entity(a, best_move[0], best_move[1])
            return False

        def execute_wait(w: World, a: Entity) -> bool:
            return True

        def execute_pickup_item(w: World, a: Entity) -> bool:
            item_id, dist = w.get_nearest_entity(a, "item", max_dist=1)
            if item_id and len(a.inventory) < a.max_inventory:
                item_entity = w.get_entity_object(item_id)
                if item_entity and item_entity.item:
                    print(f"Agent picking up {item_entity.item.name}")
                    a.inventory.append(item_entity.item)
                    w.remove_entity(item_entity)
                    return True
            return False

        def execute_consume_slime_mold(w: World, a: Entity) -> bool:
            for i, item in enumerate(a.inventory):
                if isinstance(item, Consumable) and item.name == "Slime Mold":
                    print(f"Agent consuming {item.name}")
                    new_hunger = min(START_HUNGER, a.hunger + item.amount)
                    w.update_entity_hunger(a.id, new_hunger)
                    a.inventory.pop(i)
                    return True
            return False

        def execute_consume_health_potion(w: World, a: Entity) -> bool:
            for i, item in enumerate(a.inventory):
                if isinstance(item, Consumable) and item.name == "Health Potion":
                    print(f"Agent consuming {item.name}")
                    new_health = min(START_HEALTH, a.health + item.amount)
                    w.update_entity_health(a.id, new_health)
                    a.inventory.pop(i)
                    return True
            return False

        def execute_equip_weapon(w: World, a: Entity) -> bool:
            weapon_to_equip = None
            weapon_index = -1
            for i, item in enumerate(a.inventory):
                if isinstance(item, Weapon):
                    weapon_to_equip = item
                    weapon_index = i
                    break
            if weapon_to_equip:
                if a.equipped_weapon:
                    if len(a.inventory) < a.max_inventory:
                        a.inventory.append(a.equipped_weapon)
                        print(f"Agent unequipping {a.equipped_weapon.name}")
                    else:
                        print(
                            f"Inventory full, cannot unequip {
                                a.equipped_weapon.name} to equip {weapon_to_equip.name}"
                        )
                        return False
                a.equipped_weapon = a.inventory.pop(weapon_index)
                print(f"Agent equipping {a.equipped_weapon.name}")
                return True
            return False

        actions_list = [
            Action(
                "MoveToNearestItem",
                lambda w, a: cost_move_via_distance(w, a, "item"),
                lambda s: s.get("can_find_item", False)
                and not s.get("inventory_full", True),
                effect_update_position,
                lambda w, a: _execute_move_to(
                    w, a, _get_target_pos(w, a, "item")),
            ),
            Action(
                "PickupItem",
                cost_pickup,
                lambda s: s.get("item_is_adjacent", False)
                and not s.get("inventory_full", True),
                effect_pickup_item,
                execute_pickup_item,
            ),
            Action(
                "ConsumeSlimeMold",
                cost_consume,
                pre_has_slime_mold,
                effect_consume_slime_mold,
                execute_consume_slime_mold,
            ),
            Action(
                "ConsumeHealthPotion",
                cost_consume,
                pre_has_health_potion,
                effect_consume_health_potion,
                execute_consume_health_potion,
            ),
            Action(
                "EquipWeapon",
                cost_equip,
                lambda s: s.get("has_weapon_in_inv", False)
                and not s.get("weapon_equipped", True),
                effect_equip_weapon,
                execute_equip_weapon,
            ),
            Action(
                "MoveToNearestEnemy",
                lambda w, a: cost_move_via_distance(w, a, "enemy"),
                pre_can_find_enemy,
                effect_update_position,
                lambda w, a: _execute_move_to(
                    w, a, _get_target_pos(w, a, "enemy")),
            ),
            Action(
                "AttackAdjacentEnemy",
                cost_attack,
                pre_enemy_adjacent,
                effect_attack_enemy,
                execute_attack_adjacent_enemy,
            ),
            Action(
                "Explore",
                cost_explore,
                pre_always_true,
                effect_explore,
                execute_explore,
            ),
            Action("Flee", cost_flee, pre_can_flee, effect_flee, execute_flee),
            Action("Wait", cost_wait, pre_always_true,
                   effect_wait, execute_wait),
        ]
        return actions_list
