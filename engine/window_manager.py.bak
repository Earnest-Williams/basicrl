# engine/window_manager.py
import math
from PySide6.QtWidgets import QWidget, QLabel, QVBoxLayout, QMenuBar, QMenu, QSizePolicy
from PySide6.QtGui import QImage, QPixmap, QKeyEvent, QWheelEvent, QAction, QResizeEvent
from PySide6.QtCore import Qt, QTimer  # Import QTimer for delayed resize update
from PIL import ImageDraw, Image

from engine.rendering import render_console
from engine.tileset_loader import load_tiles
from engine.console import Console

from typing import TYPE_CHECKING

if TYPE_CHECKING:
    from engine.main_loop import MainLoop


class WindowManager(QWidget):
    def __init__(
        self,
        initial_tileset_path: str,
        initial_tiles: dict[int, Image.Image],
        initial_tile_width: int,
        initial_tile_height: int,
        console_width: int,  # These are now MAX map dimensions
        console_height: int,
    ):
        super().__init__()
        self.current_tileset_path = initial_tileset_path
        self.tiles: dict[int, Image.Image] = initial_tiles
        self.tile_width: int = initial_tile_width
        self.tile_height: int = initial_tile_height
        self.map_width: int = console_width  # Store full map dimensions
        self.map_height: int = console_height

        # Console object represents the VIEWPORT, created/resized in update_frame
        self.console: Console | None = None

        self.setWindowTitle("Basic Roguelike")
        # Don't set fixed size - make window resizable
        # Set a reasonable initial size (e.g., based on initial tile size)
        initial_width = self.map_width * self.tile_width
        initial_height = self.map_height * self.tile_height
        self.resize(
            max(300, initial_width // 2), max(300, initial_height // 2)
        )  # Example initial size

        self.layout = QVBoxLayout()
        self.layout.setContentsMargins(0, 0, 0, 0)
        self.setLayout(self.layout)

        self.menu_bar = QMenuBar(self)
        self.layout.setMenuBar(self.menu_bar)
        self.build_menus()

        self.label = QLabel()
        # Ensure the label expands to fill available space
        self.label.setSizePolicy(
            QSizePolicy.Policy.Expanding, QSizePolicy.Policy.Expanding
        )
        # Do NOT scale contents - we will render exactly the pixels needed
        self.label.setScaledContents(False)
        self.label.setAlignment(
            Qt.AlignmentFlag.AlignCenter
        )  # Center pixmap if label is larger
        self.layout.addWidget(self.label)

        self.main_loop: "MainLoop" | None = None
        self.last_image: Image.Image | None = None  # For debug overlay

        # Timer to delay frame update slightly after resize spam
        self._resize_timer = QTimer(self)
        self._resize_timer.setSingleShot(True)
        self._resize_timer.setInterval(100)  # 100ms delay
        self._resize_timer.timeout.connect(self.update_frame)

    def build_menus(self) -> None:
        """Builds the application menus."""
        tileset_menu = QMenu("Tileset", self)
        png_path = "fonts/classic_roguelike_sliced"
        use_png_action = QAction("Use PNG Tileset (8x8 base)", self)
        use_png_action.triggered.connect(lambda: self.load_tileset(png_path, 8, 8))
        tileset_menu.addAction(use_png_action)

        svg_path = "fonts/classic_roguelike_sliced_svgs"
        initial_svg_render_size = 8
        use_svg_action = QAction(
            f"Use SVG Tileset (render @ {initial_svg_render_size}x{initial_svg_render_size} base)",
            self,
        )
        use_svg_action.triggered.connect(
            lambda: self.load_tileset(
                svg_path, initial_svg_render_size, initial_svg_render_size
            )
        )
        tileset_menu.addAction(use_svg_action)
        self.menu_bar.addMenu(tileset_menu)

    def load_tileset(self, folder: str, width: int, height: int) -> None:
        """Loads a tileset, updating internal state for future rendering."""
        if not self.main_loop:
            return
        try:
            self.current_tileset_path = folder
            # Just load the tiles, don't assign width/height yet
            loaded_tiles, _ = load_tiles(folder, width, height)
            self.tiles = loaded_tiles
            # Store the intended tile dimensions for rendering
            self.tile_width = width
            self.tile_height = height
            # Trigger a frame update which will recalculate viewport etc.
            self.update_frame()
        except Exception as e:
            print(f"Error loading tileset '{folder}': {e}")

    def set_main_loop(self, main_loop: "MainLoop") -> None:
        """Sets the main game loop and triggers initial rendering."""
        self.main_loop = main_loop
        # Initial render needed after layout is shown
        # Use QTimer to ensure layout has dimensions
        QTimer.singleShot(0, self.update_frame)

    def resizeEvent(self, event: QResizeEvent) -> None:
        """Handle window resize events."""
        # Use timer to avoid rapid updates during drag-resizing
        self._resize_timer.start()
        super().resizeEvent(event)

    def update_frame(self) -> None:
        """Calculates viewport, updates console, renders, and displays."""
        if (
            not self.main_loop
            or not self.label.width() > 0
            or not self.label.height() > 0
        ):
            # Wait until main_loop is set and label has valid dimensions
            # Schedule another attempt if needed
            # QTimer.singleShot(50, self.update_frame)
            return

        label_w = self.label.width()
        label_h = self.label.height()

        # Calculate how many tiles fit in the current label size
        visible_cols = max(1, label_w // self.tile_width)
        visible_rows = max(1, label_h // self.tile_height)

        # Create or resize the viewport console object
        if (
            self.console is None
            or self.console.width != visible_cols
            or self.console.height != visible_rows
        ):
            self.console = Console(visible_cols, visible_rows)

        # Determine camera center (e.g., player position)
        player_pos = self.main_loop.game_state.player_position
        if player_pos:
            cam_x, cam_y = player_pos
        else:  # Fallback if player pos not found
            cam_x, cam_y = self.map_width // 2, self.map_height // 2

        # Calculate top-left map coordinates of the viewport, keeping camera centered
        viewport_x = max(
            0, min(cam_x - visible_cols // 2, self.map_width - visible_cols)
        )
        viewport_y = max(
            0, min(cam_y - visible_rows // 2, self.map_height - visible_rows)
        )

        try:
            # Update the viewport console buffer via MainLoop
            self.main_loop.update_console(
                viewport_x, viewport_y, visible_cols, visible_rows
            )

            # Render the viewport console
            img = render_console(
                self.console,  # Render the viewport console
                self.tiles,
                self.tile_width,
                self.tile_height,
            )
            self.last_image = img  # Cache for debug

            # Display the rendered viewport image
            img_rgba = img.convert("RGBA")
            data = img_rgba.tobytes("raw", "RGBA")
            qimg = QImage(data, img.width, img.height, QImage.Format_RGBA8888)
            pixmap = QPixmap.fromImage(qimg)
            self.label.setPixmap(pixmap)  # Display exact rendered pixels

            # Update debug overlay AFTER rendering is successful
            self.update_debug()

        except Exception as e:
            print(f"Error during frame update cycle: {e}")
            import traceback

            traceback.print_exc()

    def keyPressEvent(self, event: QKeyEvent) -> None:
        """Handles key press events."""
        if event.key() == Qt.Key_Escape or event.key() == Qt.Key_Q:
            self.close()
        elif self.main_loop:
            action: dict | None = None
            key = event.key()

            if key == Qt.Key_Up or key == Qt.Key_K or key == Qt.Key_W:
                action = {"type": "move", "dx": 0, "dy": -1}
            elif key == Qt.Key_Down or key == Qt.Key_J or key == Qt.Key_S:
                action = {"type": "move", "dx": 0, "dy": 1}
            elif key == Qt.Key_Left or key == Qt.Key_H or key == Qt.Key_A:
                action = {"type": "move", "dx": -1, "dy": 0}
            elif key == Qt.Key_Right or key == Qt.Key_L or key == Qt.Key_D:
                action = {"type": "move", "dx": 1, "dy": 0}
            elif key == Qt.Key_Period:
                action = {"type": "wait"}

            if action:
                processed = self.main_loop.handle_action(action)
                if processed:
                    self.update_frame()  # Full redraw needed after action

    def wheelEvent(self, event: QWheelEvent) -> None:
        """Handles mouse wheel events for zooming by changing tile size."""
        if not self.main_loop:
            return

        if event.modifiers() & Qt.ControlModifier:
            # TODO: Implement centered zoom logic here if desired
            # 1. Get map coordinate at mouse pointer/center of screen *before* zoom
            # 2. Apply zoom (change tile size)
            # 3. Reload tileset at new size
            # 4. In update_frame (called after load), adjust viewport_x/y
            #    to keep the coordinate from step 1 at the same screen position.
            # --- Basic Implementation (no centering yet) ---
            delta = event.angleDelta().y()
            change = 1 if delta > 0 else -1

            new_width = max(2, self.tile_width + change)
            new_height = max(2, self.tile_height + change)

            if new_width != self.tile_width or new_height != self.tile_height:
                # Reload tiles at the new target size. This will trigger update_frame.
                self.load_tileset(self.current_tileset_path, new_width, new_height)

    def update_debug(self) -> None:
        """Overlays debug information."""
        if (
            not self.last_image
            or not self.main_loop
            or not self.main_loop.game_state
            or not self.console
        ):
            return

        # Draw overlay on a *copy* of the last rendered image
        img = self.last_image.copy()
        draw = ImageDraw.Draw(img)

        try:
            turn_count = self.main_loop.game_state.turn_count
            player_id = self.main_loop.game_state.player_id
            pos = self.main_loop.game_state.entity_registry.get_position(player_id)
            player_pos_str = f"({pos[0]},{pos[1]})" if pos else "N/A"
            registry_size = len(self.main_loop.game_state.entity_registry.entities_df)
            viewport_size = f"{self.console.width}x{self.console.height}"  # Show viewport console size
        except Exception as e:
            print(f"Error getting debug info: {e}")
            debug_text = "Debug info error"
        else:
            debug_text = (
                f"Turn: {turn_count} | Player: {player_pos_str} | "
                f"Entities: {registry_size} | Viewport: {viewport_size} | "
                f"Render Tiles: {self.tile_width}x{self.tile_height}"
            )

        text_font = None
        text_x: int = 5
        text_y: int = 5
        text_color: tuple[int, int, int, int] = (255, 255, 255, 255)
        bg_color: tuple[int, int, int, int] = (0, 0, 0, 180)
        box_height: int = 15

        draw.rectangle([(0, 0), (img.width, box_height)], fill=bg_color)
        draw.text((text_x, text_y), debug_text, fill=text_color, font=text_font)

        try:
            # Update the pixmap with the image containing the overlay
            img_rgba = img.convert("RGBA")
            data = img_rgba.tobytes("raw", "RGBA")
            qimg = QImage(data, img.width, img.height, QImage.Format_RGBA8888)
            pixmap = QPixmap.fromImage(qimg)
            self.label.setPixmap(pixmap)
        except Exception as e:
            print(f"Error updating debug overlay display: {e}")
