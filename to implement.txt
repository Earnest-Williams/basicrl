this is the start of our AI system for our cave dwelling species

# --- Core Libraries ---
import numpy as np          # For map grids, spatial calculations
import polars as pl         # For managing mob state data efficiently
import ray                  # For parallel AI processing [cite: 7]
from numba import njit      # For accelerating critical functions [cite: 5]
from enum import Enum, auto # For state/type definitions
import orjson               # For fast serialization/persistence [cite: 5]
# Assume flow field calculation modules (e.g., pathfinding.flowfields) exist

# --- Enums ---
class AIType(Enum):
    NONE = auto()
    STAYHOME = auto() # Uses HOME logic + stays put
    HOME = auto()     # Moves towards home, basic combat/wander
    ORTHO = auto()    # Orthogonal movement only
    CHARGE = auto()   # Direct charge (uses flow field towards target)
    PATHTO = auto()   # General pathing (uses flow field towards target)
    FLANK = auto()    # Tries to move perpendicular to target vector (complex flow field lookup)
    RANGECOWARD = auto()
    COWARD = auto()   # Uses flee flow field primarily
    MOUSE = auto()
    STRAIGHTLINE = auto()
    SMARTKOBOLD = auto()

class StrategyState(Enum):
    SAMEROOM = auto()
    FETCHITEMS = auto()
    AMBUSH = auto()
    KILL = auto()
    KILLCHASE = auto()
    PARTY = auto()
    # ... other states

class YellType(Enum):
    # ... define yell types
    pass

# --- Data Structures ---
# World Map: Managed via NumPy arrays
# Example:
# terrain_map: np.ndarray (dtype=uint8, representing tile types)
# item_map: np.ndarray (dtype=int32/uint32, representing item IDs or indices)
# flow_field_player: np.ndarray (dtype=float32, shape=(height, width, 2), vectors towards player)
# flow_field_flee_player: np.ndarray (dtype=float32, shape=(height, width, 2), vectors away from player)
# flow_field_home[mob_faction_id]: np.ndarray (Dict mapping faction/group to home flow field)

# Mob State: Managed via Polars DataFrame (mobs_df)
# Columns: entity_id, x, y, hp, ai_type (Enum), strategy_state (Enum), target_entity_id, home_x, home_y,
#          flee_timer, inventory_items (list/struct?), saw_murder (bool), heard_yell_flags (bitmask?), ...,
#          current_flow_field (string/enum referencing which field to use)

# --- Core Parallel Processing Entry Point ---

@ray.remote # Define a Ray actor or task for processing a chunk of mobs
def process_mob_ai_chunk(mobs_chunk_df: pl.DataFrame, world_map_data: dict, global_state: dict) -> pl.DataFrame:
    """
    Processes AI for a subset of mobs. Operates on Polars DataFrame chunk.
    Receives necessary world data (NumPy arrays, global info like player pos).
    Returns DataFrame chunk with updated states and actions to take.
    """
    actions = [] # List to store actions generated by this chunk
    updated_rows = [] # List to store updated mob data rows for merging back

    avatar_pos = global_state['avatar_pos'] # Example global state

    for mob_row in mobs_chunk_df.iter_rows(named=True):
        # Extract necessary data from mob_row (dict)
        mob_id = mob_row['entity_id']
        ai_type = mob_row['ai_type']

        # --- AI Logic Execution ---
        # 1. Handle fleeing override
        if mob_row['flee_timer'] > 0:
             mob_row['flee_timer'] -= 1
             action = ai_flee_from_avatar(mob_row, avatar_pos, world_map_data['flow_field_flee_player'])
             if action:
                 actions.append((mob_id, action))
                 updated_rows.append(mob_row) # Append potentially modified row
                 continue # Skip rest of AI if fled

        # 2. Dispatch to specific AI handler
        # Using a dictionary for dispatch is cleaner than a large if/elif
        ai_handler = AI_DISPATCH_TABLE.get(ai_type, ai_default_handler)
        action, updated_mob_row = ai_handler(mob_row, mobs_chunk_df, world_map_data, global_state)

        if action:
            actions.append((mob_id, action))
        if updated_mob_row: # If handler modified state
             updated_rows.append(updated_mob_row)
        else: # If handler only produced action, still need original row context if merging later
             # This depends on how results are merged. Maybe always return the row.
             updated_rows.append(mob_row)


    # Combine updated rows back into a DataFrame chunk
    # How actions are returned/merged needs careful design (e.g., list of tuples, or action columns in DF)
    updated_chunk_df = pl.DataFrame(updated_rows) # Simplified merge
    return updated_chunk_df, actions


FUNCTION process_all_mob_ai(mobs_df: pl.DataFrame, world_map_data: dict, global_state: dict):
    """
    Main function to update AI for all mobs in parallel using Ray.
    """
    num_chunks = ray.available_resources().get("CPU", 1) # Determine chunks based on cores
    mob_chunks = np.array_split(mobs_df, num_chunks) # Split DataFrame

    # --- Pre-calculate Flow Fields (can also be done less frequently) ---
    # Example: Update player-centric fields every turn if player moved
    if global_state['player_moved']:
        # These functions operate on NumPy grids, potentially @njit accelerated
        world_map_data['flow_field_player'] = pathfinding.flowfields.calculate_flow_field(
            target_pos=global_state['avatar_pos'],
            walkable_map=world_map_data['terrain_map'], # Pass NumPy array
            # ... other params
        )
        world_map_data['flow_field_flee_player'] = pathfinding.flowfields.calculate_flee_field(
             source_pos=global_state['avatar_pos'],
             walkable_map=world_map_data['terrain_map'],
             # ... other params
        )
        # TODO: Update home fields if needed

    # --- Distribute AI processing tasks ---
    # Ensure world_map_data and global_state are efficiently shared (Ray object store)
    world_map_ref = ray.put(world_map_data)
    global_state_ref = ray.put(global_state)

    futures = [process_mob_ai_chunk.remote(chunk, world_map_ref, global_state_ref) for chunk in mob_chunks]
    results = ray.get(futures)

    # --- Merge Results ---
    updated_mob_chunks = [res[0] for res in results]
    all_actions = [action for res in results for action in res[1]] # Flatten actions list

    # Concatenate updated DataFrame chunks using Polars
    updated_mobs_df = pl.concat(updated_mob_chunks)

    # TODO: Apply actions to the game state (e.g., update positions in main mobs_df based on movement actions)
    # This action application step might involve complex logic and needs careful design
    # to handle conflicts and interactions based on 'all_actions'.

    RETURN updated_mobs_df # Return the DataFrame with potentially updated internal AI states


# --- AI Handler Function Examples (using Polars row data) ---

FUNCTION ai_handle_charge(mob_row: dict, all_mobs_df: pl.DataFrame, world_map_data: dict, global_state: dict):
    """ Handler for AI_CHARGE type mobs. """
    action = None
    updated_row = mob_row.copy() # Work on a copy to update state

    # 1. Ranged Attack Check (if capable)
    if mob_can_range_attack(updated_row): # Check capability based on row data
        target_entity_id = updated_row.get('target_entity_id') # Usually avatar
        if target_entity_id is not None:
            # Query target position (potentially from all_mobs_df or global_state)
            target_pos = get_entity_pos(target_entity_id, all_mobs_df, global_state)
            if target_pos:
                 action = attempt_range_attack(updated_row, target_pos, world_map_data['terrain_map'])
                 if action: return action, updated_row

    # 2. Movement using Flow Field
    # Determine target (e.g., avatar)
    target_pos = global_state['avatar_pos'] # Simplified: always target avatar
    flow_field = world_map_data['flow_field_player'] # Use player flow field

    # Get move direction from flow field at mob's current position
    dx, dy = get_flow_direction(mob_row['x'], mob_row['y'], flow_field)

    if dx != 0 or dy != 0:
        # Generate 'bump' action (handles move or melee if target is adjacent)
        action = {'type': 'bump', 'dx': dx, 'dy': dy}
    else:
        # No movement direction or already at target, maybe wait?
        action = {'type': 'wait'}

    return action, updated_row # Return action and potentially updated state row

FUNCTION ai_handle_home(mob_row: dict, all_mobs_df: pl.DataFrame, world_map_data: dict, global_state: dict):
     """ Handler for AI_HOME type mobs. """
     action = None
     updated_row = mob_row.copy()
     home_pos = (mob_row['home_x'], mob_row['home_y'])
     current_pos = (mob_row['x'], mob_row['y'])

     # 1. Ranged Attack (if possible)
     # ... (similar to ai_handle_charge) ...
     if action: return action, updated_row

     # 2. Basic Charge (optional, based on original logic)
     # ... (could call ai_handle_charge logic here if needed) ...

     # 3. Random Wait
     # Need access to RNG state associated with this mob/thread if deterministic per mob
     # Or use a simpler global RNG (less deterministic per mob)
     # Assume get_random_float() exists and is context-aware
     if get_random_float() < 0.7:
          return {'type': 'wait'}, updated_row

     # 4. Move Towards Home using Flow Field
     # Need faction/group ID to select correct home flow field
     faction_id = mob_row.get('faction_id', 'default') # Example
     home_flow_field = world_map_data['flow_field_home'].get(faction_id)

     if home_flow_field is not None and current_pos != home_pos:
          dx, dy = get_flow_direction(mob_row['x'], mob_row['y'], home_flow_field)
          if dx != 0 or dy != 0:
               action = {'type': 'walk', 'dx': dx, 'dy': dy} # Use 'walk' if avoiding combat
     else:
          # At home or no field, wander randomly (simple adjacent move)
          dx, dy = get_random_adjacent_move()
          action = {'type': 'walk', 'dx': dx, 'dy': dy}

     return action, updated_row


FUNCTION ai_handle_smartkobold(mob_row: dict, all_mobs_df: pl.DataFrame, world_map_data: dict, global_state: dict):
     """ Handler for SMARTKOBOLD AI using its state machine. """
     action = None
     updated_row = mob_row.copy() # IMPORTANT: Work on a copy

     # Cache avatar visibility/position
     visible_enemies = find_visible_enemies(updated_row, all_mobs_df, world_map_data['terrain_map'], global_state) # Returns list or None
     avatar_visible_row = None # Polars row/dict if avatar visible
     if visible_enemies:
         # Find avatar specifically if needed
         avatar_entity_id = global_state['avatar_entity_id']
         for enemy in visible_enemies: # Assuming visible_enemies are rows/dicts
             if enemy['entity_id'] == avatar_entity_id:
                 avatar_visible_row = enemy
                 break

     # --- 1. Twitch Reactions ---
     action_taken, updated_row = process_twitch_reactions(updated_row, avatar_visible_row, global_state)
     if action_taken:
         return action_taken, updated_row # Return immediately if twitch resulted in action

     # --- 2. Tactical Combat ---
     if avatar_visible_row: # Only run tactics if avatar (primary enemy) is visible
         action_taken, updated_row = process_tactics(updated_row, avatar_visible_row, all_mobs_df, world_map_data, global_state)
         if action_taken:
             return action_taken, updated_row

     # --- 3. Strategy State Execution ---
     strategy_state = updated_row['strategy_state']

     # Dispatch to strategy state handler (using dict mapping StrategyState Enum to function)
     strategy_handler = STRATEGY_DISPATCH_TABLE.get(strategy_state, strategy_default_handler)
     action_taken, updated_row = strategy_handler(updated_row, avatar_visible_row, all_mobs_df, world_map_data, global_state)

     return action_taken, updated_row


# --- Helper Function Signatures (Illustrative) ---

@njit # Accelerate grid operations
FUNCTION get_flow_direction(x: int, y: int, flow_field: np.ndarray) -> tuple[int, int]:
    """ Looks up the vector direction from a pre-calculated NumPy flow field array. """
    # Bounds checks needed
    vec_x, vec_y = flow_field[y, x]
    # Convert float vector to integer direction (e.g., dominant axis)
    # ... logic to determine best dx, dy in [-1, 0, 1] ...
    dx = int(np.sign(vec_x)) if abs(vec_x) > abs(vec_y) * 0.5 else 0 # Example heuristic
    dy = int(np.sign(vec_y)) if abs(vec_y) > abs(vec_x) * 0.5 else 0 # Example heuristic
    # Refine to ensure only one is non-zero if needed, or allow diagonals
    # Handle zero vectors (at target or obstacles)
    return dx, dy

@njit # Accelerate grid operations
FUNCTION is_walkable(x: int, y: int, terrain_map: np.ndarray) -> bool:
    """ Checks terrain map (NumPy array) for walkability. """
    # Bounds check + terrain type check
    pass

@njit # Accelerate grid operations
FUNCTION line_of_sight(x0, y0, x1, y1, terrain_map: np.ndarray) -> bool:
     """ Numba-accelerated LOS check using Bresenham/raycasting on NumPy grid. """
     pass

FUNCTION attempt_range_attack(mob_row: dict, target_pos: tuple, terrain_map: np.ndarray) -> dict | None:
     """ Checks LOS using Numba func, range, ammo etc. Returns fire action or None. """
     # Needs mob range/weapon data from mob_row
     # Calls line_of_sight()
     pass

FUNCTION ai_flee_from_avatar(mob_row: dict, avatar_pos: tuple, flee_flow_field: np.ndarray) -> dict | None:
     """ Uses the flee flow field to move away from the avatar. """
     dx, dy = get_flow_direction(mob_row['x'], mob_row['y'], flee_flow_field)
     if dx != 0 or dy != 0:
         # Check if move is valid (don't flee into walls)
         next_x, next_y = mob_row['x'] + dx, mob_row['y'] + dy
         if is_walkable(next_x, next_y, flee_flow_field.shape, terrain_map): # Pass map shape too
             return {'type': 'walk', 'dx': dx, 'dy': dy}
     return {'type': 'wait'} # Cannot flee, wait.


FUNCTION find_visible_enemies(mob_row, all_mobs_df, terrain_map, global_state) -> list[dict] | None:
     """
     Finds enemies within sight range and LOS.
     Uses Polars to filter nearby mobs, then Numba LOS checks.
     """
     # 1. Rough filter using Polars based on distance (squared distance is faster)
     sight_range_sq = mob_row['sight_range'] ** 2
     potential_targets = all_mobs_df.filter(
          ((pl.col('x') - mob_row['x'])**2 + (pl.col('y') - mob_row['y'])**2 <= sight_range_sq) &
          (pl.col('faction_id') != mob_row['faction_id']) # Example faction check
     )
     # 2. Precise LOS check on potential targets using Numba function
     visible = []
     for target_row in potential_targets.iter_rows(named=True):
          if line_of_sight(mob_row['x'], mob_row['y'], target_row['x'], target_row['y'], terrain_map):
               visible.append(target_row)
     return visible if visible else None


# --- State Saving/Loading ---
FUNCTION save_game_state(filename: str, mobs_df: pl.DataFrame, world_map_data: dict, global_state: dict, rng_state: dict):
     """ Saves game state using orjson for speed and NumPy/Polars compatibility. """
     state = {
         'mobs_df_ipc': mobs_df.write_ipc(None), # Serialize DataFrame to IPC format bytes
         'world_map_data': {k: v.tolist() if isinstance(v, np.ndarray) else v for k, v in world_map_data.items()}, # Convert NumPy arrays for JSON
         'global_state': global_state,
         'rng_state': rng_state,
         # Add versioning info
     }
     with open(filename, "wb") as f:
          # orjson handles bytes and basic types efficiently
          f.write(orjson.dumps(state, option=orjson.OPT_SERIALIZE_NUMPY)) # Use NumPy option if available


FUNCTION load_game_state(filename: str) -> tuple[pl.DataFrame, dict, dict, dict]:
     """ Loads game state using orjson. """
     with open(filename, "rb") as f:
          state = orjson.loads(f.read())

     # Deserialize DataFrame from IPC bytes
     mobs_df = pl.read_ipc(state['mobs_df_ipc'])

     # Convert lists back to NumPy arrays
     world_map_data = {k: np.array(v) if isinstance(v, list) else v for k, v in state['world_map_data'].items()}

     global_state = state['global_state']
     rng_state = state['rng_state']

     # TODO: Version checking

     return mobs_df, world_map_data, global_state, rng_state

# --- Dispatch Tables (Populate at initialization) ---
AI_DISPATCH_TABLE = {
    AIType.CHARGE: ai_handle_charge,
    AIType.HOME: ai_handle_home,
    AIType.SMARTKOBOLD: ai_handle_smartkobold,
    # ... map other AIType enums to their handler functions ...
}

STRATEGY_DISPATCH_TABLE = {
    # StrategyState.FETCHITEMS: handle_fetch_items_strategy,
    # ... map StrategyState enums to their handler functions ...
}

# Default handlers if needed
FUNCTION ai_default_handler(mob_row, all_mobs_df, world_map_data, global_state): return {'type': 'wait'}, mob_row
FUNCTION strategy_default_handler(mob_row, avatar_visible_row, all_mobs_df, world_map_data, global_state): return {'type': 'wait'}, mob_row


A pathfinding system we're working on for our cave dwelling species.

import heapq
import time
from typing import List, Tuple, Optional, Set

import numpy as np

# --- Numba Acceleration (Install Numba: pip install numba) ---
try:
    from numba import njit
except ImportError:
    print("Warning: Numba not installed. Pathfinding will be significantly slower.")
    # Define a dummy decorator if Numba is not available
    def njit(func=None, **options):
        if func:
            return func
        else:
            def decorator(f):
                return f
            return decorator

# --- Type Aliases ---
GridPosition = Tuple[int, int]

# --- Constants ---
# Define direction vectors (dy, dx) for easier indexing (y first)
#                 N      NE     E      SE     S      SW     W      NW
DIRECTIONS_8: np.ndarray = np.array([
    [-1, 0], [-1, 1], [0, 1], [1, 1], [1, 0], [1, -1], [0, -1], [-1, -1]
], dtype=np.int8)

# Cost for moving diagonally (sqrt(2)) - use approximation or exact
DIAGONAL_MOVE_COST: float = np.sqrt(2.0) # Or 1.414

# --- Core Pathfinding Logic ---

@njit(cache=True, fastmath=True)
def _dijkstra_integration_numba(
    passable_map: np.ndarray, # bool[:]
    terrain_cost_map: np.ndarray, # float[:]
    integration_field: np.ndarray, # float[:] - Modified in place
    initial_sources: List[GridPosition]
) -> bool:
    """
    Performs Dijkstra's algorithm to compute the integration field (cost_so_far).
    Operates directly on NumPy arrays for Numba acceleration.

    Args:
        passable_map: 2D boolean array (True if passable).
        terrain_cost_map: 2D float array of base cost to enter each cell.
        integration_field: 2D float array, initialized to infinity, filled with costs.
        initial_sources: List of (y, x) tuples for starting points.

    Returns:
        True if the algorithm ran, False otherwise (e.g., no valid sources).
    """
    height, width = passable_map.shape
    if not initial_sources:
        return False # No sources to start from

    # Priority Queue: stores (cost, y, x)
    # Numba doesn't directly support heapq with tuples easily in nopython mode yet (as of late 2023/early 2024).
    # Workaround: Use a list-based min-heap manually or pass heapq back to object mode,
    # or use a Numba-compatible priority queue library if available.
    # For simplicity here, we'll use a standard Python list and sort/find min manually inside the loop,
    # which is *less efficient* than heapq but Numba-compatible.
    # A *better* Numba approach would use more complex heap logic.
    # OR: Structure the main loop in Python, calling Numba helpers for neighbor checks.

    # --- Simplified Numba PQ Workaround (Less efficient than heapq!) ---
    # This demonstrates the array logic but sacrifices PQ efficiency in pure Numba.
    # Consider structuring the main loop in Python if heapq is critical.
    pq = [] # Using list as a proxy PQ: [(cost, y, x)]

    # Initialize sources
    for y_s, x_s in initial_sources:
        if 0 <= y_s < height and 0 <= x_s < width and passable_map[y_s, x_s]:
            integration_field[y_s, x_s] = 0.0
            # Using negative index for quick find-min later (less ideal)
            pq.append((-0.0, y_s, x_s))
        else:
            # Optionally print a warning for invalid sources
            pass

    if not pq:
        return False # No valid sources found

    pq.sort(reverse=True) # Sort initially to pop the smallest cost (largest neg index)

    while pq:
        # --- Manual Min-Heap Pop (Inefficient but Numba compatible) ---
        cost_neg, y, x = pq.pop() # Get highest cost (lowest neg)
        cost = -cost_neg
        # --- End Workaround ---

        # If we found a shorter path already, skip
        if cost > integration_field[y, x]:
            continue

        # Explore neighbors
        for i in range(DIRECTIONS_8.shape[0]):
            dy, dx = DIRECTIONS_8[i]
            ny, nx = y + dy, x + dx

            # Check bounds
            if 0 <= ny < height and 0 <= nx < width:
                # Check passability
                if passable_map[ny, nx]:
                    # Calculate move cost
                    move_cost = terrain_cost_map[ny, nx] # Base cost to enter neighbor
                    if dy != 0 and dx != 0: # Diagonal move
                        move_cost *= DIAGONAL_MOVE_COST

                    new_cost = cost + move_cost

                    # If found a cheaper path to the neighbor
                    if new_cost < integration_field[ny, nx]:
                        integration_field[ny, nx] = new_cost
                        # --- Manual Min-Heap Push Workaround ---
                        # Find insertion point and insert (or just append and resort later)
                        # Appending and resorting periodically is simpler for Numba
                        pq.append((-new_cost, ny, nx))
                        # --- End Workaround ---

        # Resort PQ periodically (very inefficient substitute for proper heapq)
        # Only resort if list grows large, e.g. every 100 iterations, reduces overhead slightly
        # This is a major simplification for Numba compatibility; real use might
        # need a different structure or a Numba-compatible heap library.
        if len(pq) > 100 and len(pq) % 100 == 0: # Heuristic resort trigger
             pq.sort(reverse=True)


    return True


@njit(cache=True, fastmath=True)
def _calculate_flow_vectors_numba(
    integration_field: np.ndarray,
    passable_map: np.ndarray, # Need this to avoid flowing into walls
    flow_x: np.ndarray, # int8[:] - Modified in place
    flow_y: np.ndarray, # int8[:] - Modified in place
):
    """
    Calculates the flow vectors based on the integration field.
    Points each cell towards the neighbour with the lowest integration cost.

    Args:
        integration_field: Completed integration cost field.
        passable_map: Boolean map of passable terrain.
        flow_x: 2D int8 array to store dx flow component.
        flow_y: 2D int8 array to store dy flow component.
    """
    height, width = integration_field.shape
    infinity = np.inf # Or a sufficiently large number if inf causes issues

    for y in range(height):
        for x in range(width):
            # Skip impassable cells or cells with no path
            if not passable_map[y, x] or integration_field[y, x] == infinity:
                flow_x[y, x] = 0
                flow_y[y, x] = 0
                continue

            min_cost = integration_field[y, x] # Start with current cell's cost
            best_dx, best_dy = 0, 0

            # Check all 8 neighbours
            for i in range(DIRECTIONS_8.shape[0]):
                dy, dx = DIRECTIONS_8[i]
                ny, nx = y + dy, x + dx

                # Check bounds
                if 0 <= ny < height and 0 <= nx < width:
                    neighbor_cost = integration_field[ny, nx]
                    # Check if neighbor is reachable and has lower cost
                    if neighbor_cost < min_cost:
                        min_cost = neighbor_cost
                        best_dx, best_dy = dx, dy
                # Implicitly handles flowing into impassable neighbours because their
                # integration_field cost will remain infinity (or very high).

            flow_x[y, x] = best_dx
            flow_y[y, x] = best_dy


class FlowFieldPathfinder:
    """
    Manages creation of Integration and Flow Fields using NumPy and Numba.
    Suitable for roguelike environments with non-visual navigation.
    """
    def __init__(self, passable_map: np.ndarray, terrain_cost_map: np.ndarray):
        """
        Initializes the pathfinder with static map data.

        Args:
            passable_map: 2D NumPy boolean array (True=passable).
            terrain_cost_map: 2D NumPy float array (cost to enter cell).
                              Impassable cells should ideally have cost inf or NaN,
                              or rely solely on passable_map checks. Cost > 0.
        """
        if passable_map.shape != terrain_cost_map.shape:
            raise ValueError("Passable map and terrain cost map must have the same shape.")
        if not np.issubdtype(passable_map.dtype, np.bool_):
             raise TypeError("passable_map must be a boolean NumPy array.")
        if not np.issubdtype(terrain_cost_map.dtype, np.floating):
             raise TypeError("terrain_cost_map must be a floating-point NumPy array.")

        self.passable: np.ndarray = passable_map.copy()
        self.terrain_cost: np.ndarray = terrain_cost_map.copy()
        # Ensure costs are positive
        self.terrain_cost[self.terrain_cost <= 0] = 1.0 # Set non-positive costs to 1

        self.height, self.width = self.passable.shape

        # Initialize fields - these will be computed on demand
        self.integration_field: np.ndarray = np.full(self.passable.shape, np.inf, dtype=np.float32)
        self.flow_x: np.ndarray = np.zeros(self.passable.shape, dtype=np.int8)
        self.flow_y: np.ndarray = np.zeros(self.passable.shape, dtype=np.int8)

        self._last_sources: Optional[List[GridPosition]] = None


    def compute_field(self, stimulus_sources: List[GridPosition]) -> bool:
        """
        Computes the Integration and Flow Fields based on stimulus source locations.

        Args:
            stimulus_sources: A list of (y, x) tuples representing the source(s)
                             of the sound, scent, etc.

        Returns:
            True if the field was successfully computed, False otherwise.
        """
        if not stimulus_sources:
            print("Warning: No stimulus sources provided.")
            # Reset fields? Or leave them as they were? Resetting seems safer.
            self.integration_field.fill(np.inf)
            self.flow_x.fill(0)
            self.flow_y.fill(0)
            self._last_sources = None
            return False

        # --- Optimization: Check if sources haven't changed ---
        # Simple check, could be more robust (e.g., checking content hash)
        if self._last_sources and set(stimulus_sources) == set(self._last_sources):
             print("Skipping field computation: sources unchanged.")
             return True

        print(f"Computing flow field from {len(stimulus_sources)} sources...")
        start_time = time.time()

        # 1. Reset and Initialize Integration Field
        self.integration_field.fill(np.inf)
        valid_sources = [s for s in stimulus_sources if 0 <= s[0] < self.height and 0 <= s[1] < self.width]
        if not valid_sources:
             print("Warning: All provided stimulus sources are out of bounds.")
             self._last_sources = list(stimulus_sources) # Store attempted sources
             return False

        # --- Use Python heapq for Dijkstra's main loop for efficiency ---
        # The Numba function is kept for the neighbor logic if needed,
        # but driving the PQ from Python is often better.
        pq = [] # List acting as min-heap: [(cost, y, x)]

        for y_s, x_s in valid_sources:
             if self.passable[y_s, x_s]:
                  cost = 0.0
                  self.integration_field[y_s, x_s] = cost
                  heapq.heappush(pq, (cost, y_s, x_s))
             else:
                  print(f"Warning: Source at ({y_s}, {x_s}) is on impassable terrain.")

        if not pq:
             print("Warning: No valid stimulus sources on passable terrain.")
             self._last_sources = list(stimulus_sources)
             return False


        # 2. Run Dijkstra to create Integration Field
        processed_count = 0
        while pq:
            cost, y, x = heapq.heappop(pq)
            processed_count += 1

            # If we found a shorter path already (due to duplicates in PQ), skip
            if cost > self.integration_field[y, x]:
                continue

            # Explore neighbors
            for i in range(DIRECTIONS_8.shape[0]):
                dy, dx = DIRECTIONS_8[i]
                ny, nx = y + dy, x + dx

                # Check bounds and passability
                if 0 <= ny < self.height and 0 <= nx < self.width and self.passable[ny, nx]:
                    move_cost = self.terrain_cost[ny, nx] # Cost to enter neighbor
                    if dy != 0 and dx != 0: # Diagonal move
                        move_cost *= DIAGONAL_MOVE_COST

                    new_cost = cost + move_cost

                    if new_cost < self.integration_field[ny, nx]:
                        self.integration_field[ny, nx] = new_cost
                        heapq.heappush(pq, (new_cost, ny, nx))

        integration_time = time.time()
        print(f"  Integration field computed ({processed_count} nodes processed) in {integration_time - start_time:.4f}s")


        # 3. Calculate Flow Vectors using Numba helper
        self.flow_x.fill(0) # Reset flow field
        self.flow_y.fill(0)
        _calculate_flow_vectors_numba(
            self.integration_field, self.passable, self.flow_x, self.flow_y
        )

        flow_time = time.time()
        print(f"  Flow vectors calculated in {flow_time - integration_time:.4f}s")
        print(f"Total field computation time: {flow_time - start_time:.4f}s")

        self._last_sources = list(stimulus_sources) # Store successfully used sources
        return True

    def get_flow_vector(self, y: int, x: int) -> GridPosition:
        """Returns the optimal flow vector (dx, dy) for a given cell."""
        if 0 <= y < self.height and 0 <= x < self.width:
            return (int(self.flow_x[y, x]), int(self.flow_y[y, x])) # Cast necessary? int8 stored
        else:
            # Out of bounds, return no movement
            return (0, 0)

    def get_flow_field(self) -> Tuple[np.ndarray, np.ndarray]:
        """Returns the complete flow field arrays (dx, dy components)."""
        return self.flow_x, self.flow_y

    def get_integration_field(self) -> np.ndarray:
         """Returns the computed integration field (cost to reach source)."""
         return self.integration_field


# --- Example Usage ---
if __name__ == "__main__":

    # 1. Create Map Data (NumPy arrays)
    map_h, map_w = 50, 70
    passable = np.ones((map_h, map_w), dtype=bool)
    costs = np.ones((map_h, map_w), dtype=np.float32)

    # Add some walls
    passable[map_h // 2, map_w // 4 : map_w * 3 // 4] = False
    passable[map_h // 4 : map_h * 3 // 4, map_w // 2] = False
    passable[10:15, 10:15] = False # Box wall

    # Add some high-cost terrain (mud)
    costs[20:30, 40:60] = 5.0 # Mud costs 5x

    print(f"Created map: {map_w}x{map_h}")

    # 2. Initialize Pathfinder
    pathfinder = FlowFieldPathfinder(passable, costs)

    # 3. Define Stimulus Source(s) (e.g., player position, sound event)
    # Remember: (y, x) format
    sources: List[GridPosition] = [(map_h // 2, map_w // 2 + 5)]

    # Check source validity
    if not pathfinder.passable[sources[0]]:
         print(f"Warning: Source {sources[0]} is initially impassable!")
         # Example: Find nearest passable tile if needed
         # sources = find_nearest_passable(sources, pathfinder.passable)


    # 4. Compute the field
    success = pathfinder.compute_field(sources)

    # 5. Get Flow Vector for an Agent
    if success:
        agent_pos_y, agent_pos_x = 10, 10
        if pathfinder.passable[agent_pos_y, agent_pos_x]:
            flow_dx, flow_dy = pathfinder.get_flow_vector(agent_pos_y, agent_pos_x)
            print(f"Agent at ({agent_pos_y}, {agent_pos_x}) should move by: ({flow_dx}, {flow_dy})")

            # Example: Check cost from agent position
            cost_from_agent = pathfinder.get_integration_field()[agent_pos_y, agent_pos_x]
            print(f"Cost from agent position to source: {cost_from_agent:.2f}")
        else:
            print(f"Agent at ({agent_pos_y}, {agent_pos_x}) is on impassable terrain.")


        # --- Optional: Simple Text Visualization ---
        print("\nVisualizing Flow Field (Sample):")
        flow_x_field, flow_y_field = pathfinder.get_flow_field()
        viz_step = 3 # Draw arrow every N cells
        dir_symbols = {
            (-1, 0): '^', (-1, 1): '/', (0, 1): '>', (1, 1): '\\',
            (1, 0): 'v', (1, -1): '/', (0, -1): '<', (-1, -1): '\\',
            (0, 0): 'Â·' # No movement / source / unreachable
        }
        for y in range(0, map_h, viz_step):
            row_str = ""
            for x in range(0, map_w, viz_step):
                if not passable[y, x]:
                    row_str += "###"
                elif (y,x) in sources:
                     row_str += " S "
                else:
                    dy = int(flow_y_field[y, x])
                    dx = int(flow_x_field[y, x])
                    symbol = dir_symbols.get((dy, dx), '?')
                    # Add space for alignment
                    row_str += f" {symbol} "
            print(row_str)

        # --- Example: Recompute with different source ---
        print("\nRecomputing with source at (5, 5)...")
        success_new = pathfinder.compute_field([(5, 5)])
        if success_new:
             flow_dx_new, flow_dy_new = pathfinder.get_flow_vector(agent_pos_y, agent_pos_x)
             print(f"Agent at ({agent_pos_y}, {agent_pos_x}) should now move by: ({flow_dx_new}, {flow_dy_new})")
