Project Path: basicrl

Source Tree:

```txt
basicrl
├── __init__.py
├── basicrl_project.txt
├── config
│   ├── config.yaml
│   ├── effects.yaml
│   ├── items.yaml
│   ├── keybindings.toml
│   └── settings.toml
├── data
│   ├── items.json
│   └── monsters.json
├── engine
│   ├── __init__.py
│   ├── action_handler.py
│   ├── main_loop.py
│   ├── renderer.py
│   ├── tileset_loader.py
│   ├── window_manager.py
│   └── window_manager_modules
│       ├── input_handler.py
│       ├── tileset_manager.py
│       └── ui_overlay_manager.py
├── environment.yml
├── fixem.py
├── game
│   ├── __init__.py
│   ├── effects
│   │   ├── __init__.py
│   │   ├── executor.py
│   │   └── handlers.py
│   ├── entities
│   │   ├── __init__.py
│   │   ├── components.py
│   │   └── registry.py
│   ├── game_state.py
│   ├── items
│   │   ├── __init__.py
│   │   └── registry.py
│   ├── systems
│   │   ├── __init__.py
│   │   ├── ai_system.py
│   │   ├── combat_system.py
│   │   ├── equipment_system.py
│   │   ├── movement_system.py
│   │   └── pathfinding
│   │       └── flowfield.py
│   └── world
│       ├── __init__.py
│       ├── fov.py
│       ├── game_map.py
│       └── procgen.py
├── main.lprof
├── main.py
├── output.log
├── prototypes
│   └── roaming_entity_demo.py
├── requirements.txt
├── run.sh
├── simulation_output.txt
├── tile_mapper
│   ├── 1.json
│   ├── 2.json
│   ├── test.txt
│   ├── tile_editor_config.json
│   ├── tile_mapper_app.py
│   ├── tile_mapper_config.py
│   ├── tile_mapper_core.py
│   ├── tile_mapper_dialogs.py
│   ├── tile_mapper_gui.py
│   ├── tile_mapper_utils.py
│   └── tile_mapper_widgets.py
├── to implement.txt
└── utils
    ├── README.md
    ├── __init__.py
    └── helpers.py

```

`basicrl/basicrl_project.txt`:

```txt
Okay, here is a combined document detailing the current status of the `basicrl` project, the envisioned final game, and the outstanding TODO list, incorporating the information from our recent discussion.

---

**BasicRL Project Status and Roadmap (As of 2025-05-01)**

This document provides a snapshot of the `basicrl` project, outlining its current implementation state, the envisioned final product, and a detailed list of tasks yet to be completed.

**Part 1: Current State of `basicrl`**

`basicrl` is currently a foundational engine and framework for a tile-based roguelike game, built with a strong emphasis on performance and data management using Python, PySide6, Polars, and NumPy.

**Key Implemented Components:**

1.  **Core Engine:**
    * **Window Management (`WindowManager`):** PySide6-based window managing display, input, resizing, and zooming. Integrates with `keybindings.toml`.
    * **Main Loop (`MainLoop`):** Coordinates game turns, rendering, and action processing.
    * **Rendering (`Renderer`):** Renders the game viewport (map, items, entities) using PIL, including Numba-accelerated lighting and optional height visualization.
    * **Action Handling (`ActionHandler`):** Processes player input actions (move, wait, pickup, drop, equip, unequip, use, etc.) via standardized dictionaries, calling appropriate systems.
    * **Tileset Loading (`TilesetLoader`):** Loads PNG/SVG tilesets.
    * **Configuration:** Loads settings from YAML (`config.yaml`, `items.yaml`, `effects.yaml`) and TOML (`keybindings.toml`, `settings.toml`).

2.  **Game World & State:**
    * **Game State (`GameState`):** Central state manager holding map, registries, RNG, logs, turn count, and UI state (`PLAYER_TURN`, `INVENTORY_VIEW`).
    * **Map (`GameMap`):** NumPy-based representation of the world including tiles, height, ceilings, visibility, and explored status.
    * **Field of View (`fov.py`):** Numba-accelerated shadowcasting considering transparency and basic height differences. Updates both `visible` and `explored` maps.
    * **Procedural Generation (`procgen.py`):** BSP-based dungeon generator creating rooms and corridors with basic height assignments.

3.  **Entities (`EntityRegistry`):**
    * Manages entities via a Polars DataFrame (`ENTITY_SCHEMA`).
    * Tracks core components (position, stats, status effects) and specialized equipment fields (`body_plan`, `equipped_item_ids`).
    * Provides CRUD and component access functions. Recent fixes resolved Polars casting and list retrieval issues.

4.  **Items & Equipment (`ItemRegistry`, `EquipmentSystem`):**
    * **Item Registry:** Polars DataFrame (`ITEM_SCHEMA`) managing item instances, locations (`ground`, `inventory`, `equipped`, `attached`), ownership, mount points, attachable info, and dynamic components (fuel, durability, etc.). Loads templates from `items.yaml`.
    * **Equipment System:** Dedicated module handling equip/unequip/attach/detach logic, respecting entity `body_plan` and item `mount_points`/`attachable_info`.

5.  **Effects (`EffectExecutor`, `handlers.py`):**
    * Executes effects defined in `effects.yaml`, handling targeting, costs, and conditions.
    * Implemented handlers include heal, damage (single/AOE), resource modification, status application (single/AOE), dig, recall ammo. Placeholders exist for spawning.

6.  **Input & UI (`WindowManager`):**
    * Handles keyboard input, largely driven by `keybindings.toml`.
    * Manages UI state transitions.
    * Renders an inventory overlay with equipped/inventory items and supports basic interaction (navigation, E/U/D keys).
    * Displays debug text and height visualization key overlays.

7.  **Utilities:**
    * **RNG (`GameRNG`):** Deterministic, seeded RNG with save/load capabilities and Perlin noise.

**Current Limitations / What's Missing:**

* **Combat:** Minimal implementation; lacks detailed mechanics (attacks, defense, etc.).
* **AI:** Placeholder structure; no active decision-making or pathfinding integration.
* **Player Progression:** No skills, XP, or leveling.
* **World Interaction:** No functional doors, containers, traps, etc.
* **Advanced Systems:** Stealth, magic, factions, detailed physics are absent.
* **UI Polish:** Inventory is basic; lacks targeting, character screen, look mode.
* **Saving/Loading:** Not yet implemented.

---

**Part 2: Envisioned Final Game**

The completed `basicrl` aims to be a **deeply systemic and emergent roguelike/RPG**, emphasizing simulation over scripting to create a dynamic and interactive world.

**Key Pillars & Experience:**

1.  **High-Fidelity Simulation:** Gameplay will emerge from interacting systems:
    * **Environment:** Height, ceilings, light, sound, heat, and potentially fluids/gases will tangibly affect gameplay, visibility, stealth, and environmental interactions.
    * **Entities:** AI-driven entities (using parallel processing via Ray) will exhibit complex behaviors based on needs, goals, factions, and environmental stimuli, navigating via sophisticated flow-field pathfinding.
    * **Physics/Magic:** Actions will follow consistent physical rules or well-defined magical effects managed by the robust effect system.

2.  **Complex Itemization & Equipment:** Items and gear are central:
    * **Meaningful Anatomy:** The `body_plan` allows diverse creatures and potential dynamic changes (like limb loss), making equipment choices crucial and slot-dependent.
    * **Modular Gear:** The attachment system allows combining items (scopes on weapons, gems on rings, pouches on belts) to modify functionality or grant new effects.
    * **Resource Management:** Items will have depletable resources (durability, fuel, charges), requiring player management.

3.  **Emergent Gameplay:** The game will provide a toolbox of interacting systems, encouraging creative problem-solving:
    * Exploiting simulated elements like light, sound, and environment for stealth, combat, or traversal.
    * Engaging in complex combat scenarios influenced by AI tactics and environmental factors.
    * Managing a detailed inventory where function, slots, and attachments matter.

4.  **Performance & Scale:** The technical foundation (Polars, Numba, Ray) is designed to support a large-scale, persistent world with numerous interacting entities and detailed environmental states without sacrificing performance.

**In essence, the finished game aims to be:**

* A challenging, thinking player's game rewarding observation and systemic understanding.
* Highly replayable due to procedural generation and emergent possibilities.
* Grounded in a data-driven simulation, minimizing brittle scripting for dynamic, believable behavior.

---

**Part 3: Project TODO List**

**(Grouped by Area)**

**I. Core Engine & Infrastructure**

* **Saving/Loading:**
    * Implement robust game state saving/loading (`GameState`, registries, map, RNG).
    * Implement save file versioning.
* **Configuration:**
    * Load active keybinding sets from config.
    * Define schema/loader for entity templates.
* **Performance:**
    * Profile and optimize critical loops.
    * Investigate memory-mapping for large states.
* **Testing:**
    * Implement unit and integration tests.

**II. Game Systems**

* **AI System:**
    * Implement parallel AI processing loop (Ray).
    * Implement specific AI type handlers (Charge, Home, SmartKobold, etc.).
    * Implement `find_visible_enemies` with LOS.
    * Implement `StrategyState` machine and dispatch.
    * Implement target selection logic.
    * Implement flee logic (using flee flow field).
    * Implement social AI (yelling, reactions).
    * Implement faction/allegiance system.
* **Combat System (`game/systems/combat_system.py`):**
    * Implement melee/ranged attack actions.
    * Implement detailed damage calculation (armor, resistance).
    * Integrate status effect application from combat.
    * Implement full entity death handling (drops, XP, etc.).
* **Equipment & Inventory System:**
    * Implement inventory capacity checks (considering stacks/weight) [ref source 57-59].
    * Implement Attach/Detach UI keybindings/actions [ref source 306].
    * Implement `handle_limb_loss` [ref source 697].
    * Apply passive effects on equip/unequip/attach/detach [ref source 659, 670, 685, 697].
    * Implement item durability.
    * Implement item identification/curses.
* **Player Progression:**
    * Design and implement skills, XP, leveling, attributes.
* **Magic/Abilities System:**
    * Define spell/ability data structures and logic.
    * Implement casting, costs, cooldowns.
* **Stealth System:**
    * Implement light/noise based detection.
    * Implement entity stealth states.
* **Time & Turn Management:**
    * Implement status effect duration updates [ref source 523].
    * Implement resource consumption (hunger, fuel) [ref source 524].
    * Implement timed event scheduling.

**III. World & Environment**

* **Map Generation (`procgen.py`):**
    * Add more feature variety.
    * Implement multi-level generation.
    * Refine corridor generation.
    * Implement complex height heuristics [ref source 1397].
* **World Interaction:**
    * Implement doors, containers, traps.
    * Implement environmental interactions (pushing, climbing).
* **Height System Enhancements (Deferred):**
    * Complex movement cost (slope) [ref source 1384].
    * Falling mechanics [ref source 1386].
    * Skill/item-based traversal [ref source 1387].
    * Entity-specific height/traversal [ref source 1388-1391].
    * Advanced physics (projectiles, fluids, gas) [ref source 1393-1396].
* **Pathfinding (`FlowFieldPathfinder`):**
    * Integrate height cost into pathfinding.
    * Implement home/faction-specific flow fields [ref source 1285, 1304].
* **Effect System (`effects/`):**
    * Implement visibility checks for messages [ref source 379, 405, 413, 417].
    * Refine effect targeting logic.
    * Implement entity template loading/spawning [ref source 434].
    * Implement portal logic [ref source 430, 432].

**IV. UI & Rendering**

* **Inventory UI (`WindowManager`):**
    * Add Attach/Detach keybindings/logic.
    * Implement scrolling for large lists.
    * Add item sorting/filtering/comparison.
* **Targeting UI (`WindowManager`):**
    * Implement targeting mode [ref source 305].
* **Message Log:**
    * Implement scrolling/history view.
* **Other UI Screens:**
    * Character information screen.
    * Look/Examine mode.
* **Rendering (`renderer.py`):**
    * Consider alternative height indicators [ref source 1400].

---

This provides a unified view of where the project stands and where it's headed.

```

`basicrl/config/config.yaml`:

```yaml
# config/config.yaml
# Main configuration file for the basic roguelike

# -- Display & Tileset --
initial_tileset_folder: "fonts/classic_roguelike_sliced_svgs" # Path relative to project root
initial_tile_width: 16
initial_tile_height: 16
minimum_tile_size: 4 # Smallest allowed tile size during runtime changes
scroll_scale_debounce_ms: 200 # Delay for applying zoom changes

# -- Map Dimensions --
map_width: 80
map_height: 50

# -- Procedural Generation --
# Seed for dungeon generation (integer or null for random based on time)
dungeon_seed: null

# -- Player Settings --
player_glyph: 113 # User specified
player_start_hp: 30
# CORRECTED value to 4 per user instruction.
player_fov_radius: 4

# -- Engine Settings --
resize_debounce_ms: 100 # Delay for redrawing after window resize

# -- Lighting Parameters (NEW) --
lighting:
  ambient_level: 0.15     # Base light level for explored, non-visible tiles (0.0 to 1.0)
  min_fov_level: 0.25     # Minimum light level for tiles just inside FOV radius (0.0 to 1.0)
  falloff_power: 1.5      # Controls how quickly light dims with distance (higher = faster falloff)

# -- Height Visualization --
height_visualization:
  enabled_by_default: false
  max_relative_difference: 10 # +/- 5 meters (at 0.5m per unit)
  color_high: [255, 255, 0]   # Yellowish (RGB)
  color_mid:  [0, 255, 0]     # Greenish - NOTE: Likely unused if blend=0 at diff=0
  color_low:  [0, 128, 255]   # Bluish
  blend_factor: 0.3           # 30% blend intensity

# -- Gameplay Rules --
gameplay_rules:
  max_traversable_step: 2  # 2 units = 1 meter step limit

# Add other game parameters here as needed
```

`basicrl/config/effects.yaml`:

```yaml
# config/effects.yaml
# Defines reusable effect mechanics

effects:

  # --- Healing / Restoration ---
  heal_hp_1d4:
    type: "active"
    target_category: "user"
    logic_handler: "heal_target" # Link to function in game/effects/handlers.py
    params: { base_heal: 0, dice: "1d4", variance: 0 }
    description: "Heals a small amount of HP (1d4)."

  heal_hp_10d5:
    type: "active"
    target_category: "user"
    logic_handler: "heal_target"
    params: { base_heal: 0, dice: "10d5", variance: 0 }
    description: "Heals a significant amount of HP (10d5)."

  # --- Resource Effects ---
  restore_fullness_5:
    type: "active"
    target_category: "user"
    logic_handler: "modify_resource" # Link to function
    params: { resource: "fullness", change: 5 }
    description: "Restores 5 units of fullness."

  # --- Item Specific Effects ---
  recall_projectile_on_miss:
    type: "triggered"
    trigger_event: "on_ranged_miss"
    target_category: "projectile" # Special target category
    conditions:
      - { check: "target_was_living", value: False }
    logic_handler: "recall_ammo" # Link to function
    params: {} # Ammo type determined contextually from weapon
    description: "Returns projectile if it misses a living target."

  # --- Add more effect definitions as needed ---

```

`basicrl/config/items.yaml`:

```yaml
# config/items.yaml
# Defines base item templates for the basic roguelike (Updated for new equip system)

templates:

  # --- Weapons ---
  simple_dagger:
    name: "Simple Dagger"
    glyph: 84 # '/'
    color_fg: [192, 192, 192]
    item_type: "Weapon"
    equip_slot: "main_hand" # Specific slot
    flags: ["WEAPON", "MELEE", "COMMON", "EQUIPPABLE"]
    attributes:
      weight: 1.0
      cost: 5
      damage_dice: "1d4"
      # Daggers usually don't have mount points unless magical
    effects: {}

  recall_crossbow:
    name: "Recall Crossbow"
    glyph: 89 # '}'
    color_fg: [148, 0, 211]
    item_type: "Launcher"
    equip_slot: "main_hand" # Assumes two-handed for now, could be off_hand if smaller
    flags: ["WEAPON", "RANGED", "RARE", "MAGICAL", "EQUIPPABLE"]
    attributes:
      weight: 4.0
      cost: 500
      damage_dice: "1d8"
      ammo_type: "bolt"
      # Could potentially have a mount point for a scope?
      # mount_points:
      #   - id: "scope_rail"
      #     compatible_types: ["CrossbowScope"]
    effects:
      triggered: ["recall_projectile_on_miss"]

  # --- Armor ---
  leather_armor:
    name: "Leather Armor"
    glyph: 92 # '['
    color_fg: [139, 69, 19]
    item_type: "Armor"
    equip_slot: "upper_body_outer" # Use new specific slot
    flags: ["ARMOR", "COMMON", "EQUIPPABLE"]
    attributes:
      weight: 5.0
      cost: 50
      armor_class: 2
      # max_durability: 100
    effects: {}

  padded_trousers:
    name: "Padded Trousers"
    glyph: 92 # 'h' - Placeholder
    color_fg: [160, 82, 45] # Sienna
    item_type: "Legwear"
    equip_slot: "lower_body_outer" # Specific slot
    flags: ["ARMOR", "COMMON", "EQUIPPABLE"]
    attributes:
      weight: 2.0
      cost: 25
      armor_class: 1
    effects: {}

  leather_boots:
    name: "Leather Boots"
    glyph: 93 # 'b' - Placeholder
    color_fg: [139, 69, 19]
    item_type: "Footwear"
    equip_slot: "feet" # Specific slot
    flags: ["ARMOR", "COMMON", "EQUIPPABLE"]
    attributes:
      weight: 1.5
      cost: 20
      armor_class: 0 # Minimal AC, maybe stealth bonus/penalty?
    effects: {}

  safety_goggles: # NEW Example
    name: "Safety Goggles"
    glyph: 59 # ';'
    color_fg: [100, 100, 140]
    item_type: "Eyewear"
    equip_slot: "eyes" # New specific slot
    flags: ["EQUIPPABLE", "PROTECTION"]
    attributes:
      weight: 0.3
      cost: 40
      # Could add resistance effect here
    effects: {}


  # --- Consumables / Usables ---
  cookies:
    name: "Cookies"
    glyph: 37 # '%'
    color_fg: [160, 82, 45]
    item_type: "Food"
    flags: ["EDIBLE", "CONSUMABLE", "COMMON"] # Not equippable
    attributes:
      weight: 1
      cost: 10
      max_stack: 20
    effects:
      active_consumable: ["heal_hp_1d4", "restore_fullness_5"]

  health_crystal:
    name: "Health Crystal"
    glyph: 42 # '*'
    color_fg: [0, 255, 0]
    item_type: "Crystal"
    flags: ["USABLE", "CONSUMABLE", "COMMON", "MAGICAL"] # Not equippable
    attributes:
      weight: 2
      cost: 100
      max_stack: 10
    effects:
      active_consumable: ["heal_hp_10d5"]
    messages:
      use: "The crystal dissolves in your hand, filling you with vitality."

  flask_of_oil: # NEW Example (Consumable targeting Item)
    name: "Flask of Oil"
    glyph: 33 # '!'
    color_fg: [255, 223, 0]
    item_type: "Consumable"
    flags: ["CONSUMABLE", "FLAMMABLE", "LIQUID"]
    attributes:
      weight: 0.8
      cost: 10
      max_stack: 5
    effects:
      active_consumable: ["refuel_lantern_500"] # Needs corresponding effect handler
    messages:
      use: "You carefully pour the oil." # Use action should target the lantern


  # --- Host Equipment (Belts, Backpacks, Rings) ---
  sturdy_belt: # NEW Example
    name: "Sturdy Belt"
    glyph: 45 # '-'
    color_fg: [139, 69, 19]
    item_type: "Belt"
    equip_slot: "belt" # Specific slot
    flags: ["EQUIPPABLE", "CONTAINER_HOST"]
    attributes:
      weight: 1.0
      cost: 30
      mount_points: # List of mount point definitions
        - id: "belt_loop_front"
          compatible_types: ["small_pouch", "dagger_sheath"]
          description: "Front loop"
        - id: "belt_loop_left"
          compatible_types: ["small_pouch", "tool_holster", "lantern_hook_compatible"]
        - id: "belt_loop_right"
          compatible_types: ["small_pouch", "tool_holster"]
    effects: {}

  simple_ring: # NEW Example
    name: "Simple Band"
    glyph: 61 # '='
    color_fg: [218, 165, 32] # Gold
    item_type: "Ring"
    # equip_slot: "finger_any" # Use a general type indicator if desired
    # Alternative: List specific slots it CAN go into
    compatible_equip_slots: ["finger_0", "finger_1", "finger_2", "finger_3", "finger_4", "finger_5", "finger_6", "finger_7", "finger_8", "finger_9"]
    flags: ["EQUIPPABLE", "JEWELRY"]
    attributes:
      weight: 0.1
      cost: 20
      mount_points:
        - id: "center_setting"
          compatible_types: ["small_gem", "medium_gem"]
    effects: {}

  # --- Attachable Items ---
  small_leather_pouch: # NEW Example
    name: "Small Leather Pouch"
    glyph: 40 # '('
    color_fg: [160, 82, 45]
    item_type: "SmallPouch" # Used in compatible_types checks
    flags: ["CONTAINER", "ATTACHABLE"] # Not directly equippable to entity
    attributes:
      weight: 0.5
      cost: 15
      pouch_capacity: 5 # Assumes separate inventory logic for containers
      attachable_info:
        compatible_mount_types: ["belt_loop_front", "belt_loop_left", "belt_loop_right"] # Matches belt IDs
    effects: {}

  faceted_ruby: # NEW Example
    name: "Faceted Ruby"
    glyph: 42 # '*'
    color_fg: [255, 0, 0]
    item_type: "SmallGem" # Used in compatible_types checks
    flags: ["GEM", "ATTACHABLE", "VALUABLE"]
    attributes:
      weight: 0.05
      cost: 250
      attachable_info:
        compatible_mount_types: ["small_gem_setting", "center_setting"] # Matches ring/amulet IDs
    effects: {} # Attaching might grant effects

  # --- Items that can be Held OR Attached ---
  torch: # UPDATED
    name: "Torch"
    glyph: 126 # '~'
    color_fg: [255, 165, 0]
    item_type: "LightSource"
    equip_slot: "off_hand" # Now held in a hand slot
    flags: ["LIGHT", "EQUIPPABLE", "WOOD", "FLAMMABLE"] # Only equippable, not attachable
    attributes:
      weight: 0.5
      cost: 10
      max_charge: 1000 # Fuel/duration
      light_radius: 6
      light_color_r: 255
      light_color_g: 165
      light_color_b: 0
    effects: {}

  hooded_lantern: # NEW Example
    name: "Hooded Lantern"
    glyph: 157 # '¥'
    color_fg: [180, 180, 180]
    item_type: "LightSource"
    equip_slot: "off_hand" # Option 1: Held
    flags: ["LIGHT", "EQUIPPABLE", "ATTACHABLE", "REQUIRES_FUEL", "METAL"]
    attributes:
      weight: 1.5
      cost: 50
      max_fuel: 2000 # Requires current_fuel component in ITEM_SCHEMA
      # current_fuel initialized to max_fuel? Or 0? Assume starts full.
      light_radius: 7
      light_color_r: 230
      light_color_g: 200
      light_color_b: 150
      attachable_info: # Option 2: Attached
        # Define the type of hook this lantern uses/needs
        compatible_mount_types: ["lantern_hook_compatible"]
    effects: {}

  # --- Add more item templates as needed ---

```

`basicrl/config/keybindings.toml`:

```toml
# config/keybindings.toml
# Keybindings for the main game, grouped into sets.

# This set is typically always active
[bindings.common]
toggle_height_vis = { key = "V", mods = [], desc = "Toggle Height Visualization", action_type="ui" }
show_help         = { key = "F1", mods = [], desc = "Show This Help", action_type="ui" }
quit_game_alt     = { key = "Escape", mods = [], desc = "Quit Game (Esc)", action_type="ui" }
pickup            = { key = "G", mods = [], desc = "Get / Pickup Item", action_type="action" }
wait              = { key = "Period", mods = [], desc = "Wait / Skip Turn", action_type="action" }
wait_alt          = { key = "Space", mods = [], desc = "Wait / Skip Turn", action_type="action" }
wait_alt2         = { key = "KP_5", mods = [], desc = "Wait / Skip Turn (Numpad)", action_type="action" }
inventory         = { key = "I", mods = [], desc = "Open/Close Inventory", action_type="ui" }

# Modern WASD style bindings
[bindings.modern]
move_n    = { key = "W", mods = [], desc = "Move North", action_type="move", dx=0, dy=-1 }
move_s    = { key = "S", mods = [], desc = "Move South", action_type="move", dx=0, dy=1 }
move_w    = { key = "A", mods = [], desc = "Move West", action_type="move", dx=-1, dy=0 }
move_e    = { key = "D", mods = [], desc = "Move East", action_type="move", dx=1, dy=0 }
move_nw   = { key = "Q", mods = [], desc = "Move North-West", action_type="move", dx=-1, dy=-1 }
move_ne   = { key = "E", mods = [], desc = "Move North-East", action_type="move", dx=1, dy=-1 }
move_sw   = { key = "Z", mods = [], desc = "Move South-West", action_type="move", dx=-1, dy=1 }
move_se   = { key = "C", mods = [], desc = "Move South-East", action_type="move", dx=1, dy=1 }

# Vi HJKL style bindings
[bindings.vi]
move_n    = { key = "K", mods = [], desc = "Move North (Vi)", action_type="move", dx=0, dy=-1 }
move_s    = { key = "J", mods = [], desc = "Move South (Vi)", action_type="move", dx=0, dy=1 }
move_w    = { key = "H", mods = [], desc = "Move West (Vi)", action_type="move", dx=-1, dy=0 }
move_e    = { key = "L", mods = [], desc = "Move East (Vi)", action_type="move", dx=1, dy=0 }
move_nw   = { key = "Y", mods = [], desc = "Move North-West (Vi)", action_type="move", dx=-1, dy=-1 }
move_ne   = { key = "U", mods = [], desc = "Move North-East (Vi)", action_type="move", dx=1, dy=-1 }
move_sw   = { key = "B", mods = [], desc = "Move South-West (Vi)", action_type="move", dx=-1, dy=1 }
move_se   = { key = "N", mods = [], desc = "Move South-East (Vi)", action_type="move", dx=1, dy=1 }

# Numpad bindings (can be active alongside modern or vi)
[bindings.numpad]
move_n    = { key = "KP_8", mods = [], desc = "Move North (Numpad)", action_type="move", dx=0, dy=-1 }
move_s    = { key = "KP_2", mods = [], desc = "Move South (Numpad)", action_type="move", dx=0, dy=1 }
move_w    = { key = "KP_4", mods = [], desc = "Move West (Numpad)", action_type="move", dx=-1, dy=0 }
move_e    = { key = "KP_6", mods = [], desc = "Move East (Numpad)", action_type="move", dx=1, dy=0 }
move_nw   = { key = "KP_7", mods = [], desc = "Move North-West (Numpad)", action_type="move", dx=-1, dy=-1 }
move_ne   = { key = "KP_9", mods = [], desc = "Move North-East (Numpad)", action_type="move", dx=1, dy=-1 }
move_sw   = { key = "KP_1", mods = [], desc = "Move South-West (Numpad)", action_type="move", dx=-1, dy=1 }
move_se   = { key = "KP_3", mods = [], desc = "Move South-East (Numpad)", action_type="move", dx=1, dy=1 }

# Arrow key bindings (can be active alongside others)
[bindings.arrows]
move_n    = { key = "Up", mods = [], desc = "Move North (Arrow)", action_type="move", dx=0, dy=-1 }
move_s    = { key = "Down", mods = [], desc = "Move South (Arrow)", action_type="move", dx=0, dy=1 }
move_w    = { key = "Left", mods = [], desc = "Move West (Arrow)", action_type="move", dx=-1, dy=0 }
move_e    = { key = "Right", mods = [], desc = "Move East (Arrow)", action_type="move", dx=1, dy=0 }
move_nw   = { key = "Home", mods = [], desc = "Move North-West (Keypad)", action_type="move", dx=-1, dy=-1 }
move_ne   = { key = "PageUp", mods = [], desc = "Move North-East (Keypad)", action_type="move", dx=1, dy=-1 }
move_sw   = { key = "End", mods = [], desc = "Move South-West (Keypad)", action_type="move", dx=-1, dy=1 }
move_se   = { key = "PageDown", mods = [], desc = "Move South-East (Keypad)", action_type="move", dx=1, dy=1 }

```

`basicrl/engine/action_handler.py`:

```py
# engine/action_handler.py
"""
Handles processing of player actions, validating them against game rules,
and triggering appropriate game state changes or effect executions. Includes falling
and melee attack initiation.
"""
from typing import Any, Dict, Tuple  # Added Tuple

import structlog

from game.effects.executor import execute_effect
from game.entities.registry import EntityRegistry

# Use absolute imports for game modules
from game.game_state import GameState
from game.items.registry import ItemRegistry
from game.world.game_map import GameMap

# Import equipment system safely
try:
    from game.systems import equipment_system
except ImportError:
    _log_early = structlog.get_logger()
    _log_early.error("CRITICAL: Failed to import game.systems.equipment_system.")

    class DummyEquipmentSystem:
        def __getattr__(self, name):
            def method(*args, **kwargs):
                log = (
                    structlog.get_logger()
                )  # Logger inside method to avoid early init issues
                log.error(f"Equipment system not loaded. Call to {name} failed.")
                return False

            return method

    equipment_system = DummyEquipmentSystem()

# --- Import the combat system safely ---
try:
    from game.systems import combat_system
except ImportError:
    _log_early = structlog.get_logger()
    _log_early.error("CRITICAL: Failed to import game.systems.combat_system.")

    # Define dummy function
    class DummyCombatSystem:
        def handle_melee_attack(self, *args, **kwargs):
            log = structlog.get_logger()  # Logger inside method
            log.error("Combat system not loaded. Call to handle_melee_attack failed.")
            # If combat fails, the action (attack attempt) effectively does nothing
            # but should still consume the turn. We return False here to indicate
            # the *system* failed, but process_player_action will handle turn cost.
            # Returning False here aligns better with other system failures.
            return False

    combat_system = DummyCombatSystem()
# --- End Import ---


log = structlog.get_logger(__name__)  # Define module logger after potential early logs


# --- Fall Parameters ---
FALL_DAMAGE_THRESHOLD: int = 3  # Units (e.g., 1.5 meters)
FALL_DAMAGE_PER_UNIT_HEIGHT: float = 2.0  # Damage per unit height beyond threshold
MAX_FALL_DEPTH: int = 20  # Max tiles to check downwards


# --- Fall Handling Helper ---
def _handle_fall(
    entity_id: int,
    start_pos_h: Tuple[int, int, int],  # x, y, h
    fall_trigger_pos: Tuple[int, int, int],  # nx, ny, nh
    gs: GameState,
    max_step: int,  # Pass max_traversable_step
) -> bool:
    """
    Handles the logic when an entity moves off an edge too steep to step down.
    Returns True if the fall occurred (consuming a turn), False otherwise.
    """
    start_x, start_y, start_h = start_pos_h
    trigger_x, trigger_y, trigger_h = fall_trigger_pos
    entity_reg: EntityRegistry = gs.entity_registry  # Add type hint
    game_map: GameMap = gs.game_map  # Add type hint

    log.debug(
        "Entity falling",
        entity_id=entity_id,
        from_pos=(start_x, start_y, start_h),
        trigger_pos=(trigger_x, trigger_y, trigger_h),
    )
    gs.add_message("You fall!", (255, 100, 0))  # Simple message for now

    landing_x, landing_y, landing_h = trigger_x, trigger_y, trigger_h
    current_check_y = trigger_y

    # Trace downwards to find landing spot
    for depth in range(MAX_FALL_DEPTH):
        next_y = current_check_y + 1

        # Check map bounds
        if not game_map.in_bounds(landing_x, next_y):
            log.debug(
                "Fall hit bottom of map", entity_id=entity_id, last_y=current_check_y
            )
            landing_y = current_check_y
            landing_h = int(game_map.height_map[landing_y, landing_x])
            break

        # Get height of the tile below the current check position
        tile_below_h = int(game_map.height_map[next_y, landing_x])
        # Check step down from current potential landing spot
        step_down_delta = abs(landing_h - tile_below_h)

        # Check if the step down from the *current* landing spot is stable
        if step_down_delta <= max_step:
            # Found stable ground below *this* position
            log.debug(
                "Fall landing spot found",
                entity_id=entity_id,
                pos=(landing_x, landing_y, landing_h),
                depth=depth,
            )
            break  # Land at current landing_x, landing_y
        else:
            # Continue falling, update the 'current landing spot' for the next iteration's check
            current_check_y = next_y  # Move check position down first
            landing_y = current_check_y
            landing_h = tile_below_h

        # Check if we hit max depth after potentially updating position
        if depth == MAX_FALL_DEPTH - 1:
            log.warning(
                "Max fall depth reached, landing entity",
                entity_id=entity_id,
                pos=(landing_x, landing_y, landing_h),
            )
            break  # Land entity at the last checked position

    # Calculate fall distance
    total_fall_distance = start_h - landing_h
    log.debug(
        "Fall calculated",
        entity_id=entity_id,
        distance=total_fall_distance,
        landing_pos=(landing_x, landing_y),
    )

    # Apply damage if fallen far enough
    if total_fall_distance > FALL_DAMAGE_THRESHOLD:
        damage = int(
            (total_fall_distance - FALL_DAMAGE_THRESHOLD) * FALL_DAMAGE_PER_UNIT_HEIGHT
        )
        if damage > 0:
            log.debug("Applying fall damage", entity_id=entity_id, damage=damage)
            current_hp = entity_reg.get_entity_component(entity_id, "hp")
            if current_hp is not None:
                new_hp = max(0, current_hp - damage)
                entity_reg.set_entity_component(entity_id, "hp", new_hp)
                # TODO: Check visibility for message?
                gs.add_message(f"You take {damage} falling damage!", (255, 0, 0))
                if new_hp <= 0:
                    # TODO: Handle entity death properly (drops, removal etc)
                    log.info("Entity died from fall damage", entity_id=entity_id)
                    name = (
                        entity_reg.get_entity_component(entity_id, "name")
                        or "Something"
                    )
                    gs.add_message(f"The {name} dies from the fall!", (255, 50, 50))
                    entity_reg.delete_entity(entity_id)  # Mark inactive for now
                    # Even if the entity dies, the fall action still counts as the turn's action
                    # No need to move the now-inactive entity
                    return True
            else:
                log.warning(
                    "Cannot apply fall damage, entity has no HP", entity_id=entity_id
                )

    # Move entity to landing spot only if it didn't die
    move_success = entity_reg.set_position(entity_id, landing_x, landing_y)
    if not move_success:
        log.error(
            "Failed to set entity position after fall",
            entity_id=entity_id,
            landing_pos=(landing_x, landing_y),
        )
        # Entity might be stuck mid-air logically, but we still consumed the turn attempting to fall
        return True

    return True  # Falling consumes a turn


# --- Action Helper Functions ---
def _handle_player_move(dx: int, dy: int, gs: GameState, max_step: int) -> bool:
    """
    Attempts to move the player entity based on dx, dy.
    Handles bumping into entities (attack) and falling.
    Returns True if move, attack, or fall is successful and turn should be consumed.
    """
    log.debug("Attempting _handle_player_move", dx=dx, dy=dy)
    player_id = gs.player_id
    gm: GameMap = gs.game_map  # Add type hints for clarity
    entity_registry: EntityRegistry = gs.entity_registry

    current_pos = entity_registry.get_position(player_id)
    if current_pos is None:
        log.warning("Move failed: Player pos not found", player_id=player_id)
        return False
    current_x, current_y = current_pos
    new_x, new_y = current_x + dx, current_y + dy
    log_context = {
        "player_id": player_id,
        "from_pos": current_pos,
        "to_pos": (new_x, new_y),
    }

    # 1. Check Map Bounds
    if not gm.in_bounds(new_x, new_y):
        log.debug("Map bounds check FAILED")
        return False

    # 4. Check for Blocking Entities FIRST (before terrain checks, as bump/attack takes precedence)
    blocking_id = entity_registry.get_blocking_entity_at(new_x, new_y)
    if blocking_id is not None and blocking_id != player_id:
        log.debug("Entity blocking path, initiating attack", blocker_id=blocking_id)
        # --- Call Combat System ---
        try:
            # Call the imported combat_system's function
            # Assume attack always consumes turn for now
            combat_system.handle_melee_attack(player_id, blocking_id, gs)
            return True  # Attack happened, turn consumed
        except Exception as e_combat:
            log.error(
                "Exception during combat system call",
                error=str(e_combat),
                exc_info=True,
                attacker=player_id,
                defender=blocking_id,
            )
            gs.add_message("An error occurred during combat!", (255, 0, 0))
            return False  # Don't consume turn if combat system failed internally
        # --- End Call ---

    # If no blocking entity, proceed to terrain checks:

    # 2. Check Tile Walkability
    if not gm.is_walkable(new_x, new_y):
        log.debug("Walkability check FAILED")
        gs.add_message("That way is blocked by terrain.", (255, 127, 0))
        return False

    # 3. Check Height Difference & Fall
    try:
        # Use numpy's item() for potentially faster scalar access, default to array indexing
        h1 = int(gm.height_map.item(current_y, current_x))
        h2 = int(gm.height_map.item(new_y, new_x))
        delta_h = h2 - h1

        if abs(delta_h) > max_step:
            if delta_h > max_step:  # Step Up Too High
                log.debug(
                    "Height check FAILED (Step Up)", delta_h=delta_h, max_step=max_step
                )
                gs.add_message("That step is too high.", (255, 127, 0))
                return False
            else:  # delta_h < -max_step (Drop Too Steep) -> Handle Fall
                log.debug(
                    "Height check indicates fall", delta_h=delta_h, max_step=max_step
                )
                start_pos_h_tuple = (current_x, current_y, h1)
                fall_trigger_pos_tuple = (new_x, new_y, h2)
                # Call the fall handler - it returns True if turn is consumed
                return _handle_fall(
                    player_id, start_pos_h_tuple, fall_trigger_pos_tuple, gs, max_step
                )
        # If step is within limits (abs(delta_h) <= max_step), proceed normally
    except IndexError:
        log.error("IndexError during height check", **log_context)
        return False
    except Exception as e_h:
        log.error(
            "Exception during height check",
            error=str(e_h),
            exc_info=True,
            **log_context,
        )
        return False

    # 5. Perform Move (Only reached if no block, walkable, and height is okay)
    success = entity_registry.set_position(player_id, new_x, new_y)
    if success:
        log.debug("Player moved successfully", **log_context)
        return True  # Movement successful, turn consumed
    else:
        # This case should be rare if checks passed
        log.error(
            "Setting player position failed unexpectedly after checks", **log_context
        )
        return False


def _handle_player_pickup(gs: GameState) -> bool:
    """
    Attempts to pick up an item from the ground at the player's location.
    Returns True if pickup is successful and turn should be consumed.
    """
    player_id = gs.player_id
    player_pos = gs.player_position
    if not player_pos:
        log.warning("Pickup action failed: player pos not found")
        return False  # Cannot act

    px, py = player_pos
    items_at_feet = gs.item_registry.get_items_at(px, py)

    if items_at_feet.height == 0:
        gs.add_message("There is nothing here to pick up.", (150, 150, 150))
        return False  # No items, no turn consumed

    # Simple: pick up the first item found (index 0 visually)
    # Consider adding logic for multiple items later (e.g., UI prompt)
    try:
        item_to_pickup = items_at_feet.row(0, named=True)
        item_id = item_to_pickup["item_id"]
        item_name = item_to_pickup["name"]
    except Exception as e:
        log.error(
            "Error accessing item data at feet",
            error=str(e),
            pos=(px, py),
            items_df_head=items_at_feet.head(1),
            exc_info=True,
        )
        gs.add_message("Error trying to pick up item.", (255, 0, 0))
        return False

    log.debug("Attempting pickup", item_id=item_id, name=item_name)

    # --- TODO: Re-implement inventory capacity check here ---
    # entity_reg = gs.entity_registry
    # item_reg = gs.item_registry
    # capacity = entity_reg.get_entity_component(player_id, "inventory_capacity")
    # if capacity is not None:
    #     current_inventory_count = item_reg.get_entity_inventory(player_id).height
    #     # Note: This doesn't account for stacking yet. Needs more complex logic
    #     #       if capacity is weight-based or slot-based with stacking.
    #     if current_inventory_count >= capacity:
    #         gs.add_message("Your inventory is full.", (255, 50, 50))
    #         return False # Cannot pickup, no turn consumed
    # --- End TODO ---

    # Move item to inventory using ItemRegistry
    success = gs.item_registry.move_item(
        item_id=item_id,
        new_location="inventory",
        owner_entity_id=player_id,
        # x, y, equipped_slot, etc., are cleared automatically by move_item
    )
    if success:
        gs.add_message(f"You pick up the {item_name}.", (200, 200, 200))
        return True  # Pickup successful, turn consumed
    else:
        # Should be rare if item exists at location and capacity check passed
        gs.add_message(f"You can't pick up the {item_name}.", (255, 50, 50))
        log.error("Failed to move item to inventory during pickup", item_id=item_id)
        return False  # Failed pickup, no turn consumed


def _handle_player_drop(item_id_to_drop: int, gs: GameState) -> bool:
    """
    Attempts to drop an item from the player's inventory to the ground.
    Returns True if drop is successful and turn should be consumed.
    """
    player_id = gs.player_id
    player_pos = gs.player_position
    item_reg: ItemRegistry = gs.item_registry  # Add type hint

    if not player_pos:
        log.warning("Drop action failed: player pos not found", player_id=player_id)
        gs.add_message("Cannot drop item: Your position is unknown.", (255, 0, 0))
        return False  # Cannot act

    px, py = player_pos

    # Verify the item is actually in the player's inventory
    item_owner = item_reg.get_item_component(item_id_to_drop, "owner_entity_id")
    item_loc = item_reg.get_item_component(item_id_to_drop, "location_type")

    if item_owner != player_id or item_loc != "inventory":
        log.warning(
            "Drop action failed: Item not in player inventory.",
            item_id=item_id_to_drop,
            owner=item_owner,
            location=item_loc,
            player_id=player_id,
        )
        gs.add_message("You aren't holding that item.", (255, 100, 100))
        return False  # Item not valid for dropping

    item_name = item_reg.get_item_component(item_id_to_drop, "name") or "the item"
    log.debug("Attempting drop", item_id=item_id_to_drop, name=item_name, pos=(px, py))

    # Use move_item to change location to ground at player's coords
    success = item_reg.move_item(
        item_id=item_id_to_drop,
        new_location="ground",
        x=px,
        y=py,
        # owner_entity_id, equipped_slot, etc., are cleared automatically by move_item
    )

    if success:
        gs.add_message(f"You drop the {item_name}.", (200, 200, 200))
        return True  # Drop successful, turn consumed
    else:
        # Should be rare if checks passed
        gs.add_message(f"You can't drop the {item_name}.", (255, 50, 50))
        log.error(
            "Failed to move item to ground during drop",
            item_id=item_id_to_drop,
            pos=(px, py),
        )
        return False  # Failed drop, no turn consumed


# --- Main Action Processing Function ---
def process_player_action(
    action: Dict[str, Any],
    gs: GameState,
    max_traversable_step: int,  # Pass necessary config directly
) -> bool:
    """
    Processes a player action dictionary, validates it, and performs the action.
    Calls appropriate handlers (movement, pickup, drop) or systems (equipment, effects).
    Returns True if the player successfully acted and consumed a turn.
    """
    action_type = action.get("type")
    player_id = gs.player_id  # Get player ID for convenience
    player_acted = False  # Default: action does not consume a turn unless successful
    log.debug(
        f"ActionHandler: Processing action type: {action_type}",
        player_id=player_id,
        action_details=action,
    )

    match action_type:
        case "move":
            dx, dy = action.get("dx", 0), action.get("dy", 0)
            if dx != 0 or dy != 0:
                # _handle_player_move now includes attack and fall checks
                player_acted = _handle_player_move(dx, dy, gs, max_traversable_step)

        case "wait":
            gs.add_message("You wait.", (128, 128, 128))
            player_acted = True  # Waiting always consumes a turn
            log.debug("Player action", type="wait")

        case "pickup":
            player_acted = _handle_player_pickup(gs)

        case "drop":
            item_id = action.get("item_id")
            if item_id is None:
                log.warning("Drop action failed: No item_id specified.")
                gs.add_message("Drop what?", (255, 100, 100))
                player_acted = False
            else:
                # Ensure item_id is correctly typed if needed, though Polars handles it
                try:
                    item_id_int = int(item_id)  # Polars IDs are typically numeric
                    player_acted = _handle_player_drop(item_id_int, gs)
                except (ValueError, TypeError):
                    log.error(
                        "Drop action failed: Invalid item_id format.", item_id=item_id
                    )
                    gs.add_message("Invalid item specified.", (255, 0, 0))
                    player_acted = False

        case "use":
            item_id = action.get("item_id")
            target_info = action.get(
                "target", {}
            )  # Optional target pos/entity for effects
            if item_id is None:
                log.warning("Use action failed: No item_id specified")
                gs.add_message("Use what?", (255, 100, 100))
                player_acted = False
            else:
                # Assume the UI layer ensured the player *has* this item in inventory
                # and that the item *is* usable before generating this action.
                log.debug("Attempting to use item", item_id=item_id, target=target_info)

                # Prepare context for effect execution
                player_pos = gs.player_position
                if not player_pos:
                    log.warning(
                        "Cannot execute 'use' action: Player position unknown.",
                        item_id=item_id,
                    )
                    gs.add_message(
                        "Cannot use item: Your position is unknown.", (255, 0, 0)
                    )
                    player_acted = False
                else:
                    context = {
                        "game_state": gs,
                        "rng": gs.rng_instance,
                        "source_entity_id": player_id,
                        "item_instance_id": item_id,  # Pass original (maybe non-int) ID if needed
                        "source_pos": player_pos,  # Use checked position
                        **target_info,  # Add target_pos, target_entity_id if present
                    }

                    # Get effects from template
                    template = gs.item_registry.get_template(
                        gs.item_registry.get_item_template_id(item_id)
                    )
                    if not template:  # Should ideally be caught by UI, but double check
                        log.error("Template missing for 'use' action", item_id=item_id)
                        player_acted = False
                    else:
                        effect_ids_to_run = template.get("effects", {}).get(
                            "active", []
                        ) + template.get("effects", {}).get("active_consumable", [])

                        if not effect_ids_to_run:
                            item_name = template.get("name", "item")
                            gs.add_message(
                                f"You can't use the {item_name}.", (255, 100, 100)
                            )
                            player_acted = False
                        else:
                            # Execute effects
                            executed_any = False
                            for effect_id in effect_ids_to_run:
                                # Shallow copy is usually fine.
                                if execute_effect(effect_id, context.copy()):
                                    executed_any = True
                                else:
                                    # Effect failed (cost, condition, target, error). Message should have been added.
                                    log.debug(
                                        "Effect execution failed during 'use' action",
                                        effect_id=effect_id,
                                        item_id=item_id,
                                    )
                                    # Optionally stop processing further effects if one fails?
                            # If at least one effect succeeded, action consumes a turn
                            player_acted = executed_any
                            if not executed_any:
                                log.debug(
                                    "No effects successfully executed for item use",
                                    item_id=item_id,
                                )
                                # Avoid adding "Nothing happens" message here, assume effect handlers/checks add specific failure messages.

        case "equip":
            item_id = action.get("item_id")  # Item ID from inventory
            if item_id is None:
                log.warning("Equip action failed: No item_id specified.")
                gs.add_message("Equip what?", (255, 100, 100))
                player_acted = False
            else:
                # Call the equipment system function
                player_acted = equipment_system.equip_item(player_id, item_id, gs)

        case "unequip":
            item_id = action.get("item_id")  # Item ID currently equipped
            if item_id is None:
                log.warning("Unequip action failed: No item_id specified.")
                gs.add_message("Unequip what?", (255, 100, 100))
                player_acted = False
            else:
                # Call the equipment system function
                player_acted = equipment_system.unequip_item(player_id, item_id, gs)

        case "attach":
            item_to_attach_id = action.get("item_to_attach_id")
            target_host_item_id = action.get("target_host_item_id")
            if item_to_attach_id is None or target_host_item_id is None:
                log.warning("Attach action failed: Missing item IDs.")
                gs.add_message("Attach what to what?", (255, 100, 100))
                player_acted = False
            else:
                # Call the equipment system function
                player_acted = equipment_system.attach_item(
                    player_id, item_to_attach_id, target_host_item_id, gs
                )

        case "detach":
            item_to_detach_id = action.get("item_to_detach_id")
            if item_to_detach_id is None:
                log.warning("Detach action failed: Missing item ID.")
                gs.add_message("Detach what?", (255, 100, 100))
                player_acted = False
            else:
                # Call the equipment system function
                player_acted = equipment_system.detach_item(
                    player_id, item_to_detach_id, gs
                )

        case _:
            log.warning(
                "Unknown action type received",
                received_action=action_type,
                action_details=action,
            )
            player_acted = False  # Unknown action doesn't consume a turn

    # --- Post-Action Processing ---
    if player_acted:
        log.debug("Player action resulted in turn", action_type=action_type)
        # Optionally advance game time, trigger NPC turns etc. handled elsewhere (e.g., MainLoop after this returns True)
    else:
        log.debug("Player action did not result in turn", action_type=action_type)

    return player_acted

```

`basicrl/engine/main_loop.py`:

```py
# engine/main_loop.py
# Added typing imports
from typing import TYPE_CHECKING, Any, Dict, Self

import numpy as np
import structlog
from PIL import Image

# Use absolute imports for game modules
from game.game_state import GameState

# Use relative import for sibling module within the same package ('engine')
# Import the renderer module and the RenderConfig dataclass
from . import action_handler, renderer
from .renderer import RenderConfig  # Import the dataclass

if TYPE_CHECKING:
    # Relative import for sibling module within the same package ('engine')
    from .window_manager import WindowManager

log = structlog.get_logger()


class MainLoop:
    """
    Coordinates the main game logic, including turn processing,
    action handling, and orchestrating rendering updates.
    """

    def __init__(
        self: Self,
        game_state: GameState,
        window: "WindowManager",
        # Rendering options passed through
        vis_enabled_default: bool,
        vis_max_diff: int,
        vis_color_high: list,
        vis_color_mid: list,
        vis_color_low: list,
        vis_blend_factor: float,
        max_traversable_step: int,
        lighting_ambient: float,
        lighting_min_fov: float,
        lighting_falloff: float,
    ):
        """
        Initializes the MainLoop.

        Args:
            game_state: The central GameState object.
            window: The WindowManager instance handling display and input.
            vis_enabled_default: Initial state for height visualization.
            vis_max_diff: Max height difference for visualization.
            vis_color_high: Color for high areas in height vis (RGB list).
            vis_color_mid: Color for mid areas in height vis (RGB list).
            vis_color_low: Color for low areas in height vis (RGB list).
            vis_blend_factor: Blend factor for height visualization.
            max_traversable_step: Max height difference walkable by entities.
            lighting_ambient: Ambient light level (0.0-1.0).
            lighting_min_fov: Minimum light level at FOV edge (0.0-1.0).
            lighting_falloff: Exponent for light falloff calculation.
        """
        # Store core components
        self.game_state: GameState = game_state
        self.window: "WindowManager" = window
        self.show_height_visualization: bool = vis_enabled_default

        # Store config values needed by components managed here
        self._cfg_max_traversable_step: int = max_traversable_step

        # Store rendering configs needed by Renderer (to pass them later)
        self._cfg_vis_max_diff = vis_max_diff
        self._cfg_height_color_high_np = np.array(vis_color_high, dtype=np.uint8)
        self._cfg_height_color_mid_np = np.array(vis_color_mid, dtype=np.uint8)
        self._cfg_height_color_low_np = np.array(vis_color_low, dtype=np.uint8)
        self._cfg_vis_blend_factor = np.float32(vis_blend_factor)
        self._cfg_ambient_light = np.float32(lighting_ambient)
        self._cfg_min_fov_light = np.float32(lighting_min_fov)
        self._cfg_light_falloff = np.float32(lighting_falloff)

        log.info("MainLoop initialized successfully")

    def handle_action(self: Self, action: dict[str, Any]) -> bool:
        """
        Receives an action, processes it via the action_handler,
        and updates game state if the action consumed a turn.
        Returns True if the player acted and consumed a turn, False otherwise.
        """
        gs = self.game_state
        player_acted = False

        try:
            player_acted = action_handler.process_player_action(
                action, gs, self._cfg_max_traversable_step
            )
        except Exception as e:
            log.error(
                "Exception during action processing",
                action=action,
                error=str(e),
                exc_info=True,
            )
            gs.add_message("An internal error occurred.", (255, 0, 0))
            player_acted = False  # Error means no valid turn taken

        if player_acted:
            log.debug("Player action resulted in turn", action_type=action.get("type"))
            gs.advance_turn()
            player_pos = gs.player_position
            if player_pos:
                gs.update_fov()
            else:
                log.warning("Player position lost after action, clearing FOV.")
                gs.game_map.visible[:] = False
            # Trigger redraw via WindowManager after state changes
            self.window.update_frame()
            return True
        else:
            log.debug(
                "Player action did not result in turn", action_type=action.get("type")
            )
            return False

    # --- MODIFIED: Update Console Signature ---
    def update_console(
        self: Self,
        # Accept all args passed from WindowManager
        game_state: GameState,
        viewport_x: int,
        viewport_y: int,
        viewport_width: int,  # In tiles
        viewport_height: int,  # In tiles
        tile_arrays: Dict[int, np.ndarray | None],
        tile_fg_colors: np.ndarray,
        tile_bg_colors: np.ndarray,
        tile_indices_render: np.ndarray,
        max_defined_tile_id: int,
        tile_w: int,
        tile_h: int,
        coord_arrays: Dict[str, np.ndarray],
    ) -> Image.Image | None:
        # --- End MODIFIED Signature ---
        """
        Orchestrates rendering by gathering data and calling the renderer module.
        Called by WindowManager.update_frame(). Returns image or None on error.
        """
        gs = game_state  # Use the passed game_state

        # Calculate FOV radius squared (needed for RenderConfig)
        fov_radius = np.float32(gs.fov_radius)
        fov_radius_sq = fov_radius * fov_radius if fov_radius >= 0 else np.float32(-1.0)

        # --- Create RenderConfig instance ---
        render_config = RenderConfig(
            show_height_vis=self.show_height_visualization,
            vis_max_diff=self._cfg_vis_max_diff,
            vis_color_high_np=self._cfg_height_color_high_np,
            vis_color_mid_np=self._cfg_height_color_mid_np,
            vis_color_low_np=self._cfg_height_color_low_np,
            vis_blend_factor=self._cfg_vis_blend_factor,
            lighting_ambient=self._cfg_ambient_light,
            lighting_min_fov=self._cfg_min_fov_light,
            lighting_falloff=self._cfg_light_falloff,
            fov_radius_sq=fov_radius_sq,  # Pass pre-calculated value
        )
        # --- End Create RenderConfig ---

        # --- Call Renderer ---
        try:
            # Pass arguments to the renderer function
            image = renderer.render_viewport(
                game_state=gs,
                tile_arrays=tile_arrays,
                tile_fg_colors=tile_fg_colors,
                tile_bg_colors=tile_bg_colors,
                tile_indices_render=tile_indices_render,
                max_defined_tile_id=max_defined_tile_id,
                tile_w=tile_w,
                tile_h=tile_h,
                viewport_x=viewport_x,
                viewport_y=viewport_y,
                viewport_width=viewport_width,
                viewport_height=viewport_height,
                coord_arrays=coord_arrays,
                render_config=render_config,  # Pass the config object
            )
            return image
        except Exception as e:
            log.error(
                "Error during renderer.render_viewport call",
                error=str(e),
                exc_info=True,
            )
            # Return an error image (size calculation is tricky here, use WM size)
            pw = self.window.label.width()
            ph = self.window.label.height()
            return Image.new(
                "RGBA", (max(1, pw), max(1, ph)), (255, 0, 0, 255)
            )  # Red indicates error

```

`basicrl/engine/renderer.py`:

```py
# engine/renderer.py
"""
Handles rendering the game state to a PIL Image, using pre-calculated data
and optimized techniques.
"""
# Standard Library Imports
import math
from dataclasses import dataclass
from typing import TYPE_CHECKING, Dict as PyDict, List

# Third-party Imports
import numpy as np
import polars as pl
import structlog
from PIL import Image

# Numba for acceleration
try:
    from numba import float32, njit, uint8
    from numba.typed import Dict as NumbaDict # For type hinting Numba dict if needed

    _NUMBA_AVAILABLE = True
except ImportError:
    _NUMBA_AVAILABLE = False
    NumbaDict = dict # Fallback type hint
    def njit(func=None, **options):
        if func:
            return func
        return lambda f: f
    uint8 = np.uint8
    float32 = np.float32

# Local Application Imports
# Ensure GameState and GameMap are importable
try:
    from game.game_state import GameState
    from game.world.game_map import GameMap
except ImportError:
     # Attempt fallback imports if needed
     try:
          from basicrl.game.game_state import GameState
          from basicrl.game.world.game_map import GameMap
     except ImportError:
          GameState = object # Define dummies if import fails
          GameMap = object
          structlog.get_logger().error("CRITICAL: Failed to import GameState or GameMap in renderer.")


if TYPE_CHECKING:
    pass

log = structlog.get_logger()

NJIT_SENTINEL_TILE_ARRAY_SHAPE = (0, 0, 4)


# --- Numba Helper Functions ---
@njit(
    float32(float32, float32, float32, float32), cache=True, fastmath=True, nogil=True
)
def _calculate_light_intensity_scalar(
    dist_sq: np.float32,
    radius_sq: np.float32,
    falloff_power: np.float32,
    min_light_level: np.float32,
) -> np.float32:
    """Calculates light intensity based on distance squared."""
    if radius_sq < 0:
        return np.float32(1.0)
    if dist_sq > radius_sq:
        return np.float32(0.0)
    if dist_sq < 1e-6:
        return np.float32(1.0)
    if radius_sq <= 1e-6:
        return np.float32(0.0)

    dist = math.sqrt(dist_sq)
    radius = math.sqrt(radius_sq)
    falloff_ratio = dist / radius
    light_value = max(np.float32(0.0), np.float32(1.0 - falloff_ratio)) ** falloff_power
    intensity = max(light_value, min_light_level)
    return max(np.float32(0.0), min(np.float32(1.0), intensity))


_calculate_light_intensity_vectorized = np.vectorize(
    _calculate_light_intensity_scalar,
    otypes=[np.float32],
    excluded=["radius_sq", "falloff_power", "min_light_level"],
)


@njit("uint8[:](uint8[:], float32)", cache=True, fastmath=True, nogil=True)
def _interpolate_color_numba_vector(
    base_color: np.ndarray, intensity: np.float32
) -> np.ndarray:
    """Interpolates an RGB color towards black based on intensity."""
    intensity_clamped = max(np.float32(0.0), min(np.float32(1.0), intensity))
    result = np.empty(3, dtype=uint8)
    for i in range(3):
        result[i] = max(0, min(255, int(base_color[i] * intensity_clamped)))
    return result

# --- End Numba Helpers ---


@dataclass
class RenderConfig:
    """Configuration settings passed to the renderer."""
    show_height_vis: bool
    vis_max_diff: int
    vis_color_high_np: np.ndarray
    vis_color_mid_np: np.ndarray
    vis_color_low_np: np.ndarray
    vis_blend_factor: np.float32
    lighting_ambient: np.float32
    lighting_min_fov: np.float32
    lighting_falloff: np.float32
    fov_radius_sq: np.float32


def _prepare_base_layers(
    game_map: GameMap,
    viewport_x: int,
    viewport_y: int,
    viewport_width: int,
    viewport_height: int,
    max_defined_tile_id: int,
    tile_fg_colors: np.ndarray,
    tile_bg_colors: np.ndarray,
    tile_indices_render: np.ndarray,
) -> tuple[
    np.ndarray, np.ndarray, np.ndarray, np.ndarray,
    np.ndarray, np.ndarray, np.ndarray, tuple[int, int],
]:
    """Prepares base color and glyph index arrays for the viewport."""
    if not isinstance(game_map, GameMap) or GameMap is object:
        log.error("_prepare_base_layers called with invalid GameMap")
        dummy_shape = (max(1, viewport_height), max(1, viewport_width))
        return ( np.zeros((*dummy_shape, 3), dtype=np.uint8), np.zeros((*dummy_shape, 3), dtype=np.uint8),
                 np.zeros(dummy_shape, dtype=np.uint16), np.zeros(dummy_shape, dtype=bool),
                 np.zeros(dummy_shape, dtype=bool), np.zeros(dummy_shape, dtype=np.int16),
                 np.zeros(dummy_shape, dtype=bool), dummy_shape )

    map_y_slice = slice(viewport_y, viewport_y + viewport_height)
    map_x_slice = slice(viewport_x, viewport_x + viewport_width)
    safe_y_slice = slice(max(0, map_y_slice.start), min(game_map.height, map_y_slice.stop))
    safe_x_slice = slice(max(0, map_x_slice.start), min(game_map.width, map_x_slice.stop))
    actual_vp_h = safe_y_slice.stop - safe_y_slice.start
    actual_vp_w = safe_x_slice.stop - safe_x_slice.start

    if actual_vp_h <= 0 or actual_vp_w <= 0:
        log.warning("Viewport calculation resulted in zero size.", vp_slice_y=map_y_slice, vp_slice_x=map_x_slice, map_shape=(game_map.height, game_map.width))
        dummy_shape = (max(1, actual_vp_h), max(1, actual_vp_w))
        return ( np.zeros((*dummy_shape, 3), dtype=np.uint8), np.zeros((*dummy_shape, 3), dtype=np.uint8),
                 np.zeros(dummy_shape, dtype=np.uint16), np.zeros(dummy_shape, dtype=bool),
                 np.zeros(dummy_shape, dtype=bool), np.zeros(dummy_shape, dtype=np.int16),
                 np.zeros(dummy_shape, dtype=bool), dummy_shape )

    map_visible_vp = game_map.visible[safe_y_slice, safe_x_slice]
    map_explored_vp = game_map.explored[safe_y_slice, safe_x_slice]
    map_tiles_vp = game_map.tiles[safe_y_slice, safe_x_slice]
    map_height_vp = game_map.height_map[safe_y_slice, safe_x_slice]
    vp_h, vp_w = map_visible_vp.shape

    visible_mask = map_visible_vp
    explored_mask = map_explored_vp & (~visible_mask)
    drawn_mask = visible_mask | explored_mask

    base_fg = np.zeros((vp_h, vp_w, 3), dtype=np.uint8)
    base_bg = np.zeros((vp_h, vp_w, 3), dtype=np.uint8)
    glyph_indices = np.zeros((vp_h, vp_w), dtype=np.uint16)

    render_data_valid = (
         tile_fg_colors is not None and tile_bg_colors is not None and
         tile_indices_render is not None and max_defined_tile_id >= 0 and
         len(tile_fg_colors) > max_defined_tile_id and
         len(tile_bg_colors) > max_defined_tile_id and
         len(tile_indices_render) > max_defined_tile_id
    )

    if not render_data_valid:
         log.error("Render data arrays invalid in _prepare_base_layers")
         drawn_mask.fill(False)
    elif np.any(drawn_mask):
        try:
            tile_ids_in_vp_raw = map_tiles_vp[drawn_mask]
            valid_tile_ids_in_vp = np.clip(tile_ids_in_vp_raw, 0, max_defined_tile_id)
            base_fg[drawn_mask] = tile_fg_colors[valid_tile_ids_in_vp]
            base_bg[drawn_mask] = tile_bg_colors[valid_tile_ids_in_vp]
            glyph_indices[drawn_mask] = tile_indices_render[valid_tile_ids_in_vp]
        except IndexError as e:
             log.error("IndexError during color/glyph assignment in _prepare_base_layers", error=str(e), exc_info=True)
             drawn_mask.fill(False)

    return ( base_fg, base_bg, glyph_indices, visible_mask, drawn_mask,
             map_height_vp, map_visible_vp, (vp_h, vp_w) )


def _calculate_lighting(
    base_fg: np.ndarray, base_bg: np.ndarray, visible_mask: np.ndarray,
    vp_h: int, vp_w: int, viewport_x: int, viewport_y: int,
    player_x: int, player_y: int, config: RenderConfig
) -> tuple[np.ndarray, np.ndarray, np.ndarray]:
    """Calculates lighting intensity and applies it."""
    intensity_map = np.full((vp_h, vp_w), config.lighting_ambient, dtype=np.float32)
    if np.any(visible_mask):
        vp_rel_y, vp_rel_x = np.indices((vp_h, vp_w))
        map_abs_x_vp = vp_rel_x + viewport_x
        map_abs_y_vp = vp_rel_y + viewport_y
        dx = map_abs_x_vp[visible_mask] - player_x
        dy = map_abs_y_vp[visible_mask] - player_y
        dist_sq_map_visible = (dx * dx + dy * dy).astype(np.float32)
        visible_intensities = _calculate_light_intensity_vectorized(
            dist_sq=dist_sq_map_visible, radius_sq=config.fov_radius_sq,
            falloff_power=config.lighting_falloff, min_light_level=config.lighting_min_fov,
        )
        intensity_map[visible_mask] = visible_intensities
    intensity_broadcast = intensity_map[..., None]
    lit_fg = (base_fg * intensity_broadcast).astype(np.uint8)
    lit_bg = (base_bg * intensity_broadcast).astype(np.uint8)
    return lit_fg, lit_bg, intensity_map


def _apply_height_visualization(
    lit_fg: np.ndarray, lit_bg: np.ndarray, drawn_mask: np.ndarray,
    map_height_vp: np.ndarray, player_height: int, config: RenderConfig
) -> tuple[np.ndarray, np.ndarray]:
    """Applies height visualization tinting."""
    if not config.show_height_vis:
        return lit_fg, lit_bg

    final_fg = lit_fg.copy()
    final_bg = lit_bg.copy()
    relative_height_vp = map_height_vp - player_height
    max_diff = np.float32(config.vis_max_diff)
    blend = config.vis_blend_factor
    drawn_and_valid_diff = drawn_mask & (max_diff > np.float32(0.0))

    if not np.any(drawn_and_valid_diff):
         return final_fg, final_bg

    # Apply high color blend
    high_mask = ( drawn_and_valid_diff & (relative_height_vp > 0) & (relative_height_vp <= max_diff) )
    if np.any(high_mask):
        t = (relative_height_vp[high_mask] / max_diff).astype(np.float32)[..., None]
        target_color_f32 = config.vis_color_high_np.astype(np.float32)
        current_fg_f32 = final_fg[high_mask].astype(np.float32)
        current_bg_f32 = final_bg[high_mask].astype(np.float32)
        blend_t = blend * t
        final_fg[high_mask] = np.clip( current_fg_f32 * (np.float32(1.0) - blend_t) + target_color_f32 * blend_t, 0, 255 ).astype(np.uint8)
        final_bg[high_mask] = np.clip( current_bg_f32 * (np.float32(1.0) - blend_t) + target_color_f32 * blend_t, 0, 255 ).astype(np.uint8)

    # Apply low color blend
    low_mask = ( drawn_and_valid_diff & (relative_height_vp < 0) & (relative_height_vp >= -max_diff) )
    if np.any(low_mask):
        t = (-relative_height_vp[low_mask] / max_diff).astype(np.float32)[..., None]
        target_color_f32 = config.vis_color_low_np.astype(np.float32)
        current_fg_f32 = final_fg[low_mask].astype(np.float32)
        current_bg_f32 = final_bg[low_mask].astype(np.float32)
        blend_t = blend * t
        final_fg[low_mask] = np.clip( current_fg_f32 * (np.float32(1.0) - blend_t) + target_color_f32 * blend_t, 0, 255 ).astype(np.uint8)
        final_bg[low_mask] = np.clip( current_bg_f32 * (np.float32(1.0) - blend_t) + target_color_f32 * blend_t, 0, 255 ).astype(np.uint8)

    return final_fg, final_bg


@njit(cache=True, nogil=True)
def _render_map_tiles(
    output_image_array: np.ndarray,
    glyph_indices: np.ndarray,
    drawn_mask: np.ndarray,
    final_fg: np.ndarray,
    final_bg: np.ndarray,
    tile_arrays: NumbaDict,
    vp_h: int,
    vp_w: int,
    tile_h: int,
    tile_w: int,
) -> None:
    tile_buffer = np.empty((tile_h, tile_w, 4), dtype=uint8)
    for vp_y in range(vp_h):
        for vp_x in range(vp_w):
            if not drawn_mask[vp_y, vp_x]:
                continue

            tile_bg_color_rgb = final_bg[vp_y, vp_x]
            tile_buffer[:, :, 0] = tile_bg_color_rgb[0]
            tile_buffer[:, :, 1] = tile_bg_color_rgb[1]
            tile_buffer[:, :, 2] = tile_bg_color_rgb[2]
            tile_buffer[:, :, 3] = 255

            tile_glyph_idx = glyph_indices[vp_y, vp_x]

            # Numba-safe tile access: no .get(), no hasattr
            if tile_glyph_idx in tile_arrays:
                tile_rgba_array = tile_arrays[tile_glyph_idx]
                if (
                    tile_rgba_array.shape == (tile_h, tile_w, 4)
                    and tile_rgba_array.shape != NJIT_SENTINEL_TILE_ARRAY_SHAPE
                ):
                    glyph_alpha_channel = tile_rgba_array[:, :, 3]
                    glyph_draw_mask_2d = glyph_alpha_channel > 10
                    mask_rows, mask_cols = np.where(glyph_draw_mask_2d)

                    tile_fg_color_rgb = final_fg[vp_y, vp_x]
                    for i in range(mask_rows.shape[0]):
                        r, c = mask_rows[i], mask_cols[i]
                        tile_buffer[r, c, 0] = tile_fg_color_rgb[0]
                        tile_buffer[r, c, 1] = tile_fg_color_rgb[1]
                        tile_buffer[r, c, 2] = tile_fg_color_rgb[2]
                        tile_buffer[r, c, 3] = glyph_alpha_channel[r, c]

            px_start_y = vp_y * tile_h
            px_start_x = vp_x * tile_w
            dest_slice_y = slice(px_start_y, px_start_y + tile_h)
            dest_slice_x = slice(px_start_x, px_start_x + tile_w)
            output_image_array[dest_slice_y, dest_slice_x, :] = tile_buffer
            


def _render_ground_items(
    output_image_array: np.ndarray, items_to_render: List[PyDict],
    tile_arrays: NumbaDict | PyDict, intensity_map: np.ndarray,
    viewport_x: int, viewport_y: int, vp_h: int, vp_w: int, tile_w: int, tile_h: int,
) -> None:
    """Draws ground items onto the output buffer."""
    for item_data in items_to_render:
        map_x = item_data.get("x")
        map_y = item_data.get("y")
        item_glyph_idx = item_data.get("glyph")
        color_r = item_data.get("color_fg_r", 255)
        color_g = item_data.get("color_fg_g", 0)
        color_b = item_data.get("color_fg_b", 255)

        if ( map_x is None or map_y is None or item_glyph_idx is None or item_glyph_idx <= 0 ):
            continue

        cons_x = map_x - viewport_x
        cons_y = map_y - viewport_y
        if not (0 <= cons_y < vp_h and 0 <= cons_x < vp_w):
            continue

        item_tile_rgba_array = tile_arrays.get(item_glyph_idx)
        if ( item_tile_rgba_array is None or item_tile_rgba_array.shape == NJIT_SENTINEL_TILE_ARRAY_SHAPE or
             item_tile_rgba_array.shape != (tile_h, tile_w, 4) ):
            continue

        item_intensity = np.float32(intensity_map[cons_y, cons_x])
        base_item_fg_rgb = np.array([color_r, color_g, color_b], dtype=np.uint8)
        lit_item_fg_rgb = _interpolate_color_numba_vector( base_item_fg_rgb, item_intensity )

        px_start_y = cons_y * tile_h
        px_start_x = cons_x * tile_w
        # *** FIXED: Semicolon removed ***
        dest_slice_y = slice(px_start_y, px_start_y + tile_h)
        dest_slice_x = slice(px_start_x, px_start_x + tile_w)

        target_pixel_block = output_image_array[dest_slice_y, dest_slice_x]
        item_alpha_channel = item_tile_rgba_array[:, :, 3]
        item_draw_mask = item_alpha_channel > 10

        target_pixel_block[item_draw_mask, 0] = lit_item_fg_rgb[0]
        target_pixel_block[item_draw_mask, 1] = lit_item_fg_rgb[1]
        target_pixel_block[item_draw_mask, 2] = lit_item_fg_rgb[2]
        target_pixel_block[item_draw_mask, 3] = item_alpha_channel[item_draw_mask]


def _render_entities(
    output_image_array: np.ndarray, game_state: GameState,
    tile_arrays: NumbaDict | PyDict, intensity_map: np.ndarray,
    vp_h: int, vp_w: int, viewport_x: int, viewport_y: int,
    player_x: int, player_y: int, tile_w: int, tile_h: int, config: RenderConfig,
) -> None:
    """Draws entities onto the output buffer."""
    if not isinstance(game_state, GameState) or GameState is object:
        log.error("_render_entities called with invalid GameState object")
        return
    entity_registry = game_state.entity_registry
    gm = game_state.game_map
    active_entities_df = entity_registry.get_active_entities()

    entities_in_vp_bounds = active_entities_df.filter(
        (pl.col("x") >= viewport_x) & (pl.col("x") < viewport_x + vp_w) &
        (pl.col("y") >= viewport_y) & (pl.col("y") < viewport_y + vp_h) &
        (pl.col("glyph") > 0)
    )

    if entities_in_vp_bounds.height == 0:
        return

    for entity_row in entities_in_vp_bounds.iter_rows(named=True):
        map_ex = entity_row["x"]
        map_ey = entity_row["y"]
        # Check bounds before accessing visibility map
        if not (0 <= map_ey < gm.height and 0 <= map_ex < gm.width):
             log.warning("Entity position out of bounds during render", entity_id=entity_row.get("entity_id"), pos=(map_ex, map_ey))
             continue
        if not gm.visible[map_ey, map_ex]:
            continue

        glyph_idx = entity_row["glyph"]
        entity_tile_rgba_array = tile_arrays.get(glyph_idx)
        if ( entity_tile_rgba_array is None or entity_tile_rgba_array.shape == NJIT_SENTINEL_TILE_ARRAY_SHAPE or
             entity_tile_rgba_array.shape != (tile_h, tile_w, 4) ):
            continue

        cons_ex = map_ex - viewport_x
        cons_ey = map_ey - viewport_y
        # Check if calculated console coords are valid before indexing intensity_map
        if not (0 <= cons_ey < vp_h and 0 <= cons_ex < vp_w):
            log.warning("Entity console coords out of bounds", entity_id=entity_row.get("entity_id"), cons_pos=(cons_ex, cons_ey), vp_dims=(vp_w, vp_h))
            continue # Should not happen if initial filter is correct, but safety check
        e_intensity_f32 = intensity_map[cons_ey, cons_ex]

        base_fg_e_rgb = np.array( [ entity_row["color_fg_r"], entity_row["color_fg_g"], entity_row["color_fg_b"] ], dtype=np.uint8, )
        lit_fg_e_rgb = _interpolate_color_numba_vector(base_fg_e_rgb, e_intensity_f32)

        px_start_y = cons_ey * tile_h
        px_start_x = cons_ex * tile_w
        # *** FIXED: Semicolon removed ***
        dest_slice_y = slice(px_start_y, px_start_y + tile_h)
        dest_slice_x = slice(px_start_x, px_start_x + tile_w)

        target_pixel_block = output_image_array[dest_slice_y, dest_slice_x]
        entity_alpha_channel = entity_tile_rgba_array[:, :, 3]
        entity_draw_mask = entity_alpha_channel > 10

        target_pixel_block[entity_draw_mask, 0] = lit_fg_e_rgb[0]
        target_pixel_block[entity_draw_mask, 1] = lit_fg_e_rgb[1]
        target_pixel_block[entity_draw_mask, 2] = lit_fg_e_rgb[2]
        target_pixel_block[entity_draw_mask, 3] = entity_alpha_channel[entity_draw_mask]


# --- Main Rendering Function ---
def render_viewport(
    game_state: GameState,
    tile_arrays: NumbaDict | PyDict,
    tile_fg_colors: np.ndarray,
    tile_bg_colors: np.ndarray,
    tile_indices_render: np.ndarray,
    max_defined_tile_id: int,
    tile_w: int,
    tile_h: int,
    viewport_x: int,
    viewport_y: int,
    viewport_width: int,
    viewport_height: int,
    coord_arrays: PyDict[str, np.ndarray],
    render_config: RenderConfig,
) -> Image.Image | None:
    """
    Renders the visible portion of the game world to a PIL Image.
    """
    log.debug("render_viewport called",
              vp_x=viewport_x, vp_y=viewport_y, vp_w=viewport_width, vp_h=viewport_height,
              tile_dims=f"{tile_w}x{tile_h}", max_tile_id=max_defined_tile_id,
              tile_arrays_type=type(tile_arrays), tile_arrays_len=len(tile_arrays) if tile_arrays is not None else 'None',
              fg_colors_shape=tile_fg_colors.shape if tile_fg_colors is not None else 'None',
              bg_colors_shape=tile_bg_colors.shape if tile_bg_colors is not None else 'None',
              indices_shape=tile_indices_render.shape if tile_indices_render is not None else 'None',
              coord_keys=list(coord_arrays.keys()) if coord_arrays is not None else 'None')

    # --- Input Validation ---
    if not isinstance(game_state, GameState) or GameState is object:
        log.error("render_viewport called with invalid GameState object")
        pw = max(1, viewport_width * max(1, tile_w)); ph = max(1, viewport_height * max(1, tile_h))
        return Image.new("RGBA", (pw, ph), (255,0,0,255))
    gs = game_state; gm = gs.game_map
    if tile_w <= 0 or tile_h <= 0 or tile_arrays is None or max_defined_tile_id < 0:
        log.warning( "Cannot render: Invalid params/cache", tile_w=tile_w, tile_h=tile_h,
                     has_arrays=(tile_arrays is not None), max_id=max_defined_tile_id )
        pw = max(1, viewport_width * max(1, tile_w)); ph = max(1, viewport_height * max(1, tile_h))
        return Image.new("RGBA", (pw, ph), (0, 0, 0, 255))
    player_pos = gs.player_position
    if player_pos is None:
        log.warning("Cannot render: Player position not found")
        pw = max(1, viewport_width * max(1, tile_w)); ph = max(1, viewport_height * max(1, tile_h))
        return Image.new("RGBA", (pw, ph), (0, 0, 0, 255))
    player_x, player_y = player_pos; player_height = 0
    try:
        if gm.in_bounds(player_x, player_y): player_height = int(gm.height_map[player_y, player_x])
        else: log.error("Player position out of map bounds", player_pos=player_pos, map_shape=(gm.height, gm.width)); player_height = 0
    except IndexError: log.error("IndexError getting player height", player_pos=player_pos, map_shape=(gm.height, gm.width)); player_height = 0

    # --- Prepare Base Data ---
    try:
        ( base_fg, base_bg, glyph_indices, visible_mask, drawn_mask,
          map_height_vp, map_visible_vp, (vp_h, vp_w),
        ) = _prepare_base_layers(
            gm, viewport_x, viewport_y, viewport_width, viewport_height,
            max_defined_tile_id, tile_fg_colors, tile_bg_colors, tile_indices_render
        )
        if vp_h <= 0 or vp_w <= 0:
            log.warning("Calculated viewport height/width is zero or negative.", vp_h=vp_h, vp_w=vp_w)
            return Image.new("RGBA", (1, 1), (0,0,0,0))
    except Exception as e:
        log.error("Error during _prepare_base_layers call or unpack", error=str(e), exc_info=True)
        pw = max(1, viewport_width * max(1, tile_w)); ph = max(1, viewport_height * max(1, tile_h))
        return Image.new("RGBA", (pw, ph), (255,0,0,255))

    # --- Apply Lighting and Height Visualization ---
    lit_fg, lit_bg, intensity_map = _calculate_lighting(
        base_fg, base_bg, visible_mask, vp_h, vp_w, viewport_x, viewport_y, player_x, player_y, render_config
    )
    final_fg, final_bg = _apply_height_visualization(
        lit_fg, lit_bg, drawn_mask, map_height_vp, player_height, render_config
    )

    # --- Prepare Output Buffer ---
    output_pixel_h = vp_h * tile_h; output_pixel_w = vp_w * tile_w
    if output_pixel_h <= 0 or output_pixel_w <= 0:
        log.warning("Calculated output pixel size is zero or negative", w=output_pixel_w, h=output_pixel_h)
        return Image.new("RGBA", (1, 1), (0, 0, 0, 0))
    output_image_array = np.zeros((output_pixel_h, output_pixel_w, 4), dtype=np.uint8)

    # --- Fill Background ---
    try:
        if not coord_arrays or "tile_coord_y" not in coord_arrays or "tile_coord_x" not in coord_arrays:
             raise KeyError("Coordinate arrays missing or invalid.")
        tile_coord_y = coord_arrays["tile_coord_y"]; tile_coord_x = coord_arrays["tile_coord_x"]
        if tile_coord_y.shape != (output_pixel_h, output_pixel_w) or tile_coord_x.shape != (output_pixel_h, output_pixel_w):
             raise ValueError(f"Coordinate array shape mismatch. Expected:{(output_pixel_h, output_pixel_w)}, Got: y{tile_coord_y.shape},x{tile_coord_x.shape}")
        if final_bg.shape != (vp_h, vp_w, 3):
             raise ValueError(f"Background color shape mismatch. Expected:{(vp_h, vp_w, 3)}, Got:{final_bg.shape}")
        output_image_array[:, :, :3] = final_bg[tile_coord_y, tile_coord_x]
        output_image_array[:, :, 3] = 255
    except (KeyError, IndexError, ValueError) as e:
        log.error( "Error preparing output buffer with background", error=str(e), exc_info=True,
                   final_bg_shape=final_bg.shape if final_bg is not None else 'None', output_shape=output_image_array.shape,
                   coord_y_shape=coord_arrays.get("tile_coord_y", np.array([])).shape, coord_x_shape=coord_arrays.get("tile_coord_x", np.array([])).shape,
                   vp_dims=(vp_h, vp_w) )
        return Image.new("RGBA", (max(1, output_pixel_w), max(1, output_pixel_h)), (100, 0, 100, 255)) # Purple error

    # --- Render Map Tiles ---
    try:
        if not tile_arrays: log.warning("_render_map_tiles skipped: tile_arrays dictionary is empty.")
        elif np.sum(drawn_mask) == 0: log.debug("_render_map_tiles skipped: drawn_mask is all False.")
        else:
             _render_map_tiles( output_image_array, glyph_indices, drawn_mask, final_fg, final_bg,
                                tile_arrays, vp_h, vp_w, tile_w, tile_h )
    except Exception as e:
        log.error("Error during _render_map_tiles call", error=str(e), exc_info=True)

    # --- Render Ground Items ---
    items_to_render_list: List[PyDict] = []
    if np.any(map_visible_vp):
         try:
             vp_x_min, vp_y_min = viewport_x, viewport_y; vp_x_max, vp_y_max = viewport_x + vp_w, viewport_y + vp_h
             items_in_vp_df = gs.item_registry.items_df.filter( (pl.col("x") >= vp_x_min) & (pl.col("x") < vp_x_max) & (pl.col("y") >= vp_y_min) & (pl.col("y") < vp_y_max) & (pl.col("location_type") == "ground") & pl.col("is_active") & (pl.col("glyph") > 0) )
             if items_in_vp_df.height > 0:
                 top_items_df = items_in_vp_df.group_by(["x", "y"]).last()
                 item_coords_x_abs = top_items_df["x"].to_numpy(); item_coords_y_abs = top_items_df["y"].to_numpy()
                 item_coords_x_vp = item_coords_x_abs - viewport_x; item_coords_y_vp = item_coords_y_abs - viewport_y
                 valid_indices_mask = (item_coords_x_vp >= 0) & (item_coords_x_vp < vp_w) & (item_coords_y_vp >= 0) & (item_coords_y_vp < vp_h)
                 visible_item_mask = np.zeros(len(item_coords_x_vp), dtype=bool)
                 if np.any(valid_indices_mask):
                      valid_item_rel_y = item_coords_y_vp[valid_indices_mask].astype(np.intp); valid_item_rel_x = item_coords_x_vp[valid_indices_mask].astype(np.intp)
                      # Ensure indexing into map_visible_vp is safe
                      if map_visible_vp.shape == (vp_h, vp_w):
                           visible_item_mask[valid_indices_mask] = map_visible_vp[valid_item_rel_y, valid_item_rel_x]
                      else: log.warning("map_visible_vp shape mismatch, cannot check item visibility.", map_vis_shape=map_visible_vp.shape, expected=(vp_h, vp_w))
                 visible_items_df = top_items_df.filter(pl.Series(values=visible_item_mask))
                 if visible_items_df.height > 0: items_to_render_list = visible_items_df.select( ["x", "y", "glyph", "color_fg_r", "color_fg_g", "color_fg_b", "item_id"] ).to_dicts()
         except Exception as e: log.error("Error querying/processing ground items", error=str(e), exc_info=True)
    if items_to_render_list:
         try: _render_ground_items( output_image_array, items_to_render_list, tile_arrays, intensity_map, viewport_x, viewport_y, vp_h, vp_w, tile_w, tile_h )
         except Exception as e: log.error("Error during _render_ground_items", error=str(e), exc_info=True)

    # --- Render Entities ---
    try:
        _render_entities( output_image_array, gs, tile_arrays, intensity_map, vp_h, vp_w, viewport_x, viewport_y, player_x, player_y, tile_w, tile_h, render_config )
    except Exception as e:
        log.error("Error during _render_entities", error=str(e), exc_info=True)

    # --- Final Image Conversion ---
    try:
        final_image = Image.fromarray(output_image_array, "RGBA")
        return final_image
    except Exception as e:
        log.error( "Error converting final array to PIL Image", error=str(e), exc_info=True )
        return Image.new("RGBA", (max(1, output_pixel_w), max(1, output_pixel_h)), (50, 50, 50, 255)) # Dark grey error

```

`basicrl/engine/tileset_loader.py`:

```py
# === engine/tileset_loader.py ===
import io
from pathlib import Path

import numpy as np
import structlog  # Added
from cairosvg import svg2png  # For SVG rasterization
from PIL import Image

log = structlog.get_logger()  # Added


def clean_tile_background(img: Image.Image) -> Image.Image:
    """Clean PNG background color (21,21,21) to transparent."""
    if img.mode != "RGBA":
        img = img.convert("RGBA")
    data = np.array(img)

    # Only wipe pixels matching exact (21,21,21) background color
    mask = np.all(data[:, :, :3] == (21, 21, 21), axis=2)
    data[mask, 3] = 0  # Set alpha to 0 (transparent)

    return Image.fromarray(data, "RGBA")


def rasterize_svg(svg_path: Path, width: int, height: int) -> Image.Image:
    """Convert an SVG file to a PIL Image at the specified size."""
    log.debug("Rasterizing SVG", path=str(svg_path), width=width, height=height)
    try:
        png_bytes = svg2png(url=str(svg_path), output_width=width, output_height=height)
        img = Image.open(io.BytesIO(png_bytes)).convert("RGBA")
        return img  # SVGs already have correct transparency
    except Exception as e:
        log.error(
            "Failed to rasterize SVG", path=str(svg_path), error=str(e), exc_info=True
        )
        # Return a blank placeholder image on error? Or re-raise?
        # Returning placeholder to avoid crashing load_tiles entirely.
        return Image.new(
            "RGBA", (width, height), (255, 0, 255, 255)
        )  # Magenta placeholder


def load_tiles(
    folder: str, tile_width: int, tile_height: int
) -> tuple[dict[int, Image.Image], bool]:
    """
    Loads tiles from a folder of PNG or SVG files.
    PNGs are cleaned and resized.
    SVGs are rasterized to correct size.

    Returns:
        tiles: A dictionary {tile_index: PIL Image}
        is_svg: Whether any SVGs were found
    """
    log.info("Loading tileset", path=folder, width=tile_width, height=tile_height)
    path = Path(folder)
    if not path.is_dir():
        # Log error before raising
        log.error("Invalid tileset folder path", path=str(path))
        raise ValueError(f"Invalid tileset folder: {folder}")

    tiles = {}
    is_svg = False
    png_count = 0
    svg_count = 0
    svg_paths = {}  # Store paths for second pass

    # First pass: collect all files, process PNGs
    try:
        for file in path.iterdir():
            if not file.is_file():
                continue

            try:
                tile_id = int(
                    file.stem.split("_")[-1]
                )  # Assumes format like name_ID.ext
            except (ValueError, IndexError):
                log.warning(
                    "Skipping file with unexpected name format", filename=file.name
                )
                continue

            if file.suffix.lower() == ".png":
                try:
                    img = Image.open(file).convert("RGBA")
                    cleaned_img = clean_tile_background(img)
                    resized_img = cleaned_img.resize(
                        (tile_width, tile_height), Image.Resampling.NEAREST
                    )
                    tiles[tile_id] = resized_img
                    png_count += 1
                except Exception as e:
                    log.warning(
                        "Failed to process PNG tile", filename=file.name, error=str(e)
                    )

            elif file.suffix.lower() == ".svg":
                svg_paths[tile_id] = file
                is_svg = True
                svg_count += 1
            # Else: ignore other file types silently or log debug message

    except Exception as e:
        log.error(
            "Error iterating tileset directory",
            path=str(path),
            error=str(e),
            exc_info=True,
        )
        # Re-raise or return empty dict? Returning empty seems safer.
        return {}, False

    log.debug("Initial file scan complete", png_found=png_count, svg_found=svg_count)

    # Second pass: rasterize SVGs if present
    if is_svg:
        log.info("Rasterizing SVG tiles...")
        rasterized_count = 0
        for tile_id, svg_path in svg_paths.items():
            rasterized = rasterize_svg(svg_path, tile_width, tile_height)
            if rasterized:  # Check if rasterization returned an image
                tiles[tile_id] = rasterized
                rasterized_count += 1
        log.info("SVG rasterization complete", count=rasterized_count)

    log.info(
        "Tileset loading finished",
        path=folder,
        total_tiles=len(tiles),
        png_count=png_count,
        svg_count=svg_count,
    )
    return tiles, is_svg

```

`basicrl/engine/window_manager.py`:

```py
# engine/window_manager.py
# Standard library imports
import time
from pathlib import Path
from typing import TYPE_CHECKING, Any
from typing import Dict as PyDict
from typing import List, Tuple

# Third-party imports
import numpy as np
from PIL import Image

# PySide6 imports
from PySide6.QtCore import Qt, QTimer, QRect # Added QRect
from PySide6.QtGui import (
    QAction, QColor, QCursor, QImage, QKeyEvent,
    QPalette, QPixmap, QResizeEvent, QWheelEvent,
)
from PySide6.QtWidgets import (
    QApplication, QLabel, QMenu, QMenuBar, QMessageBox,
    QSizePolicy, QVBoxLayout, QWidget, QScrollArea # Added QScrollArea
)

# --- Modularized Imports ---
from engine.window_manager_modules.input_handler import InputHandler
from engine.window_manager_modules.tileset_manager import TilesetManager
from engine.window_manager_modules.ui_overlay_manager import UIOverlayManager

# --- Type Checking ---
if TYPE_CHECKING:
    from engine.main_loop import MainLoop

# --- Logging Setup ---
import structlog
log = structlog.get_logger(__name__)
# ---

DEFAULT_MIN_TILE_SIZE = 4
DEFAULT_SCROLL_SCALE_DEBOUNCE_MS = 200
DEFAULT_RESIZE_DEBOUNCE_MS = 100
DEFAULT_INITIAL_WINDOW_WIDTH = 1024
DEFAULT_INITIAL_WINDOW_HEIGHT = 768

# lerp_color function
def lerp_color(self, color1: tuple, color2: tuple, t: float) -> tuple:
    """
    Linearly interpolate between two RGB colors.
    
    Args:
        color1: Starting RGB color tuple
        color2: Ending RGB color tuple
        t: Interpolation factor (0.0 to 1.0)
    
    Returns:
        Interpolated RGB color tuple
    """
    # Ensure t is clamped between 0 and 1
    t = max(0.0, min(1.0, t))
    
    # Interpolate each color component
    r = int(color1[0] + (color2[0] - color1[0]) * t)
    g = int(color1[1] + (color2[1] - color1[1]) * t)
    b = int(color1[2] + (color2[2] - color1[2]) * t)
    
    # Clamp values between 0 and 255
    r = max(0, min(255, r))
    g = max(0, min(255, g))
    b = max(0, min(255, b))
    
    return (r, g, b)


class WindowManager(QWidget):
    def __init__(
        self,
        app_config: PyDict[str, Any],
        keybindings_config: PyDict[str, Any],
        initial_tileset_path: str,
        initial_tile_width: int,
        initial_tile_height: int,
        map_width: int,
        map_height: int,
        min_tile_size_cfg: int = DEFAULT_MIN_TILE_SIZE,
        scroll_debounce_cfg: int = DEFAULT_SCROLL_SCALE_DEBOUNCE_MS,
        resize_debounce_cfg: int = DEFAULT_RESIZE_DEBOUNCE_MS,
    ):
        super().__init__()
        self.app_config = app_config
        self.keybindings_config = keybindings_config
        log.info("Initializing WindowManager...")

        self.min_tile_size = min_tile_size_cfg
        self.scroll_debounce_ms = scroll_debounce_cfg
        self.resize_debounce_ms = resize_debounce_cfg
        self.map_width = map_width
        self.map_height = map_height

        # Instantiate TilesetManager
        self.tileset_manager = TilesetManager(
            initial_tileset_path=initial_tileset_path,
            initial_tile_width=initial_tile_width,
            initial_tile_height=initial_tile_height,
            min_tile_size_cfg=min_tile_size_cfg,
        )

        # Rendering coord cache
        self._render_coord_cache: PyDict[str, np.ndarray] = {}
        self._cached_vp_pixel_dims: Tuple[int, int] | None = None
        self._cached_tile_dims: Tuple[int, int] | None = None

        # --- UI Setup ---
        self.setWindowTitle("Basic Roguelike")
        self.resize(DEFAULT_INITIAL_WINDOW_WIDTH, DEFAULT_INITIAL_WINDOW_HEIGHT)
        self.layout = QVBoxLayout()
        self.layout.setContentsMargins(0, 0, 0, 0)
        self.setLayout(self.layout)
        self.menu_bar = QMenuBar(self)
        self.layout.setMenuBar(self.menu_bar)
        self.build_menus()

        # Main display label within a scroll area
        self.scroll_area = QScrollArea() # Defined scroll_area
        self.scroll_area.setBackgroundRole(QPalette.ColorRole.Dark)
        self.scroll_area.setWidgetResizable(False) # Important for fixed size content
        self.scroll_area.setAlignment(Qt.AlignmentFlag.AlignCenter)
        self.layout.addWidget(self.scroll_area) # Add scroll area to layout

        self.label = QLabel() # The widget that shows the rendered map
        self.label.setSizePolicy(QSizePolicy.Policy.Expanding, QSizePolicy.Policy.Expanding) # Let it expand if needed
        self.label.setScaledContents(False) # Do not scale the pixmap
        self.label.setAlignment(Qt.AlignmentFlag.AlignCenter) # Center if smaller than area
        self.label.setAutoFillBackground(True)
        pal = self.label.palette()
        pal.setColor(QPalette.ColorRole.Window, QColor(Qt.GlobalColor.black))
        self.label.setPalette(pal)
        # Set the label *inside* the scroll area
        self.scroll_area.setWidget(self.label)
        # --- End UI Setup ---

        self.main_loop: "MainLoop" | None = None
        self.last_rendered_image: Image.Image | None = None

        # Timers
        self._resize_timer = QTimer(self)
        self._resize_timer.setSingleShot(True)
        self._resize_timer.setInterval(self.resize_debounce_ms)
        self._resize_timer.timeout.connect(self.update_frame)
        self._pending_tile_size_change: int = 0
        self._scroll_scale_timer = QTimer(self)
        self._scroll_scale_timer.setSingleShot(True)
        self._scroll_scale_timer.setInterval(self.scroll_debounce_ms)
        self._scroll_scale_timer.timeout.connect(self._apply_scroll_scaling)

        # Active keybindings
        self.active_keybinding_sets: List[str] = [
            "common", "modern", "numpad", "arrows",
        ]
        log.info("Active keybinding sets", sets=self.active_keybinding_sets)

        # Instantiate other handlers
        self.input_handler = InputHandler(self.keybindings_config, self)
        self.ui_overlay_manager = UIOverlayManager(self)

        log.debug("WindowManager __init__ complete")


    def _update_render_coord_cache(self, vp_pixel_w: int, vp_pixel_h: int) -> None:
        """Updates the cache mapping output pixels to viewport tile coords."""
        current_tile_w = self.tileset_manager.tile_width
        current_tile_h = self.tileset_manager.tile_height
        current_tile_dims = (current_tile_w, current_tile_h)
        current_vp_pixel_dims = (vp_pixel_w, vp_pixel_h)

        if ( self._cached_vp_pixel_dims == current_vp_pixel_dims and
             self._cached_tile_dims == current_tile_dims and
             self._render_coord_cache ):
            return # Cache is still valid

        log_context = {
             "vp_pixel_w": vp_pixel_w, "vp_pixel_h": vp_pixel_h,
             "tile_w": current_tile_w, "tile_h": current_tile_h
        }
        log.info("Updating render coordinate cache...", **log_context)

        start_time = time.perf_counter()
        try:
            # Ensure dimensions are valid before creating large arrays
            if vp_pixel_h <= 0 or vp_pixel_w <= 0:
                 raise ValueError("Viewport pixel dimensions must be positive.")
            if current_tile_h <= 0 or current_tile_w <= 0:
                 raise ValueError("Tile dimensions must be positive.")

            px_y_indices, px_x_indices = np.indices(
                (vp_pixel_h, vp_pixel_w), dtype=np.int16
            )
            tile_coord_y = (px_y_indices // current_tile_h).astype(np.int16)
            tile_coord_x = (px_x_indices // current_tile_w).astype(np.int16)

            self._render_coord_cache = {
                "tile_coord_y": tile_coord_y,
                "tile_coord_x": tile_coord_x,
            }
            self._cached_vp_pixel_dims = current_vp_pixel_dims
            self._cached_tile_dims = current_tile_dims

            # *** ADDED LOGGING ***
            log.debug(
                "Render coordinate cache updated",
                duration_ms=(time.perf_counter() - start_time) * 1000,
                coord_y_shape=tile_coord_y.shape,
                coord_x_shape=tile_coord_x.shape,
                **log_context
            )
            # *** END LOGGING ***

        except (ValueError, MemoryError, Exception) as e: # Catch potential errors
            log.error(
                "Failed to update render coordinate cache", error=e, exc_info=True, **log_context
            )
            # Reset cache on failure
            self._render_coord_cache = {}
            self._cached_vp_pixel_dims = None
            self._cached_tile_dims = None


    def build_menus(self) -> None:
        # (Implementation unchanged)
        log.debug("Building menus...")
        tileset_menu = QMenu("Tileset", self)
        try: script_dir = Path(__file__).parent.resolve(); project_root = script_dir.parent
        except NameError: project_root = Path(".")
        png_path_str = str(project_root / "fonts" / "classic_roguelike_sliced")
        use_png_action = QAction("Use PNG Tileset (8x8 base)", self)
        use_png_action.triggered.connect( lambda: self.handle_load_tileset_action(png_path_str, 8, 8) )
        tileset_menu.addAction(use_png_action)
        svg_path_str = str(project_root / "fonts" / "classic_roguelike_sliced_svgs")
        initial_svg_render_size = 16
        use_svg_action = QAction(f"Use SVG Tileset (@{initial_svg_render_size}x)", self)
        use_svg_action.triggered.connect( lambda: self.handle_load_tileset_action( svg_path_str, initial_svg_render_size, initial_svg_render_size ) )
        tileset_menu.addAction(use_svg_action)
        self.menu_bar.addMenu(tileset_menu)
        log.debug("Menus built")

    def handle_load_tileset_action(self, folder: str, width: int, height: int) -> None:
        """Callback for menu actions to load tilesets via the manager."""
        # (Implementation unchanged)
        success = self.tileset_manager.load_new_tileset(folder, width, height)
        if success:
            self._cached_vp_pixel_dims = None; self._cached_tile_dims = None
            self._render_coord_cache = {}; self.update_frame()
        else: QMessageBox.critical( self, "Tileset Error", f"Failed to load tileset from:\n{folder}" )

    def set_main_loop(self, main_loop: "MainLoop") -> None:
        # (Implementation unchanged)
        self.main_loop = main_loop
        log.info("MainLoop instance set in WindowManager")
        QTimer.singleShot(0, self.update_frame) # Trigger initial frame render

    def resizeEvent(self, event: QResizeEvent) -> None:
        # (Implementation unchanged - uses debounce timer)
        log.debug("Resize event detected", new_size=event.size())
        self._resize_timer.start() # Debounced update_frame call
        super().resizeEvent(event)

    def update_frame(self) -> None:
        """Updates and redraws the main display label."""
        frame_start_time = time.perf_counter()
        if ( not self.main_loop or not self.main_loop.game_state or
             not self.tileset_manager or not self.isVisible() ):
            log.debug( "Skipping frame update: Components not ready or window not visible.",
                       has_loop=(self.main_loop is not None),
                       has_gs=(hasattr(self.main_loop, 'game_state') if self.main_loop else False),
                       has_tsm=(self.tileset_manager is not None),
                       is_visible=self.isVisible() )
            # self.label.clear() # Maybe don't clear if just invisible?
            return

        # Use scroll area viewport size for calculations, not label size
        viewport_w = self.scroll_area.viewport().width()
        viewport_h = self.scroll_area.viewport().height()
        current_tile_w = self.tileset_manager.tile_width
        current_tile_h = self.tileset_manager.tile_height

        if viewport_w <= 0 or viewport_h <= 0 or current_tile_w <= 0 or current_tile_h <= 0:
            log.warning( "Skipping frame: Invalid viewport/tile dimensions",
                         vp_w=viewport_w, vp_h=viewport_h,
                         tile_w=current_tile_w, tile_h=current_tile_h )
            self.label.clear() # Clear display if dimensions are invalid
            return

        gs = self.main_loop.game_state
        # Calculate visible tiles based on viewport size
        visible_cols = max(1, viewport_w // current_tile_w)
        visible_rows = max(1, viewport_h // current_tile_h)

        # Calculate camera/viewport position based on player
        player_pos = gs.player_position
        cam_x, cam_y = ( player_pos if player_pos else (gs.map_width // 2, gs.map_height // 2) )

        # Calculate viewport tile coordinates (top-left corner)
        # Ensure viewport doesn't go out of map bounds
        render_cols = min(visible_cols, gs.map_width) # Cannot render more tiles than map width
        render_rows = min(visible_rows, gs.map_height)
        viewport_tile_x = max(0, min(cam_x - render_cols // 2, gs.map_width - render_cols))
        viewport_tile_y = max(0, min(cam_y - render_rows // 2, gs.map_height - render_rows))

        # Calculate actual number of tiles to render based on map limits
        vp_render_tile_w = min(render_cols, gs.map_width - viewport_tile_x)
        vp_render_tile_h = min(render_rows, gs.map_height - viewport_tile_y)

        if vp_render_tile_w <= 0 or vp_render_tile_h <= 0:
            log.warning("Calculated viewport tile dimensions are zero or negative",
                         w=vp_render_tile_w, h=vp_render_tile_h)
            self.label.clear()
            return

        # Calculate the required pixel size of the output image
        output_pixel_w = vp_render_tile_w * current_tile_w
        output_pixel_h = vp_render_tile_h * current_tile_h

        # Update coordinate cache if necessary
        try:
            self._update_render_coord_cache(output_pixel_w, output_pixel_h)
        except Exception as cache_err:
            log.error("Render coordinate cache update failed", error=cache_err, exc_info=True)
            # Attempt to display error on screen? For now, clear.
            self.label.clear()
            return # Cannot render without valid cache

        if not self._render_coord_cache:
            log.error("Render coordinate cache is empty, cannot render.")
            self.label.clear()
            return

        # Fetch render data from TilesetManager
        render_data = self.tileset_manager.get_render_data()
        if render_data["max_defined_tile_id"] < 0:
            log.error("TilesetManager reported invalid render data cache.")
            self.label.clear()
            return

        # Call MainLoop's update_console to get the rendered image
        try:
            rendered_image: Image.Image | None = self.main_loop.update_console(
                game_state=gs,
                viewport_x=viewport_tile_x, # Pass calculated viewport tile coords
                viewport_y=viewport_tile_y,
                viewport_width=vp_render_tile_w, # Pass calculated viewport tile dimensions
                viewport_height=vp_render_tile_h,
                # Pass data from TilesetManager
                tile_arrays=render_data["tile_arrays"],
                tile_fg_colors=render_data["tile_fg_colors"],
                tile_bg_colors=render_data["tile_bg_colors"],
                tile_indices_render=render_data["tile_indices_render"],
                max_defined_tile_id=render_data["max_defined_tile_id"],
                tile_w=render_data["tile_w"], # Current tile dimensions
                tile_h=render_data["tile_h"],
                # Pass coordinate cache
                coord_arrays=self._render_coord_cache,
            )
        except Exception as e:
            # Catch errors during the update_console call itself
            log.error("Error during main_loop.update_console call", error=e, exc_info=True)
            rendered_image = None # Ensure image is None on error

        # Process the result
        if rendered_image:
            self.last_rendered_image = rendered_image
            # Add overlays using UIOverlayManager
            img_with_overlays = self.ui_overlay_manager.render_overlays(
                self.last_rendered_image, gs, self.main_loop
            )
            # Display final image on the label
            try:
                img_rgba = img_with_overlays.convert("RGBA")
                data = img_rgba.tobytes("raw", "RGBA")
                qimg = QImage(
                    data, img_with_overlays.width, img_with_overlays.height,
                    QImage.Format.Format_RGBA8888,
                )
                if qimg.isNull():
                    log.error("QImage conversion failed.")
                    self.label.clear() # Clear label if conversion fails
                else:
                    # Resize the label to match the image size before setting pixmap
                    self.label.setFixedSize(qimg.width(), qimg.height())
                    self.label.setPixmap(QPixmap.fromImage(qimg))

            except Exception as e:
                 log.error("Error converting/displaying final image", error=e, exc_info=True)
                 self.label.clear()

        else:
            log.warning("MainLoop returned no base image.")
            self.label.clear() # Clear display if no image returned
            self.last_rendered_image = None

        log.debug( "Frame update finished", duration_ms=(time.perf_counter() - frame_start_time) * 1000 )


    def keyPressEvent(self, event: QKeyEvent) -> None:
        # (Implementation unchanged)
        if ( not self.main_loop or not self.main_loop.game_state or not self.input_handler ):
            event.ignore(); return
        key_handled = self.input_handler.process_key_event( event, self.main_loop.game_state,
                                                             self.main_loop, self.active_keybinding_sets )
        if not key_handled: super().keyPressEvent(event)

    def show_help_dialog(self) -> None:
        # (Implementation unchanged)
        bindings_sets = self.keybindings_config.get("bindings", {})
        help_text = "<h2>Controls Help</h2>"
        if not bindings_sets: help_text += "<p><i>Error: No keybindings found!</i></p>"
        else:
            def _format_control_string(binding_dict: PyDict[str, Any]) -> str:
                key_str = binding_dict.get("key", "?"); mods_list = binding_dict.get("mods", [])
                display_key = key_str.replace("KP_", "Numpad "); mods_str = "+".join(m.capitalize() for m in mods_list if m)
                prefix_parts = [mods_str] if mods_str else []; prefix_parts.append(f"'{display_key}'"); return " + ".join(prefix_parts)
            grouped_bindings: PyDict[str, List[str]] = {}
            for set_name, set_dict in bindings_sets.items():
                if not isinstance(set_dict, dict): continue
                for action_name, action_dict in set_dict.items():
                    if not isinstance(action_dict, dict): continue
                    description = action_dict.get("desc")
                    if description:
                        formatted_control = _format_control_string(action_dict)
                        if description not in grouped_bindings: grouped_bindings[description] = []
                        if formatted_control not in grouped_bindings[description]: grouped_bindings[description].append(formatted_control)
            help_text += "<ul>"
            for desc_key in sorted(grouped_bindings.keys()):
                controls_str = " / ".join(sorted(grouped_bindings[desc_key])); help_text += f"<li>{controls_str}: {desc_key}</li>"
            help_text += "</ul>"
        msg_box = QMessageBox(self); msg_box.setWindowTitle("Help - Controls"); msg_box.setTextFormat(Qt.TextFormat.RichText)
        msg_box.setText(help_text); msg_box.setIcon(QMessageBox.Icon.Information); msg_box.setStandardButtons(QMessageBox.StandardButton.Ok)
        msg_box.exec()

    # --- UI Callback methods ---
    def ui_open_inventory_view(self) -> None:
        # (Implementation unchanged)
        if self.main_loop and self.main_loop.game_state:
            self.main_loop.game_state.change_ui_state("INVENTORY_VIEW")
            self.ui_overlay_manager.reset_inventory_state()
            self.update_frame()

    def ui_toggle_height_visualization(self) -> None:
        # (Implementation unchanged)
        if self.main_loop:
            self.main_loop.show_height_visualization = ( not self.main_loop.show_height_visualization )
            log.info( "Height vis toggled", enabled=self.main_loop.show_height_visualization )
            self.update_frame()

    def ui_quit_game(self) -> None:
        # (Implementation unchanged)
        app_instance = QApplication.instance()
        if app_instance: app_instance.quit()

    def ui_return_to_player_turn(self) -> None:
        # (Implementation unchanged)
        if self.main_loop and self.main_loop.game_state:
            self.main_loop.game_state.change_ui_state("PLAYER_TURN")
            self.ui_overlay_manager.reset_inventory_state()
            self.update_frame()

    def ui_show_help_dialog(self) -> None:
        # (Implementation unchanged)
        self.show_help_dialog()

    # --- wheelEvent ---
    def wheelEvent(self, event: QWheelEvent) -> None:
        # (Implementation unchanged)
        if not self.main_loop: return
        modifiers = event.modifiers(); angle_delta = event.angleDelta()
        if modifiers & Qt.KeyboardModifier.ControlModifier: # Zooming
            delta_y = angle_delta.y(); change = 1 if delta_y > 0 else -1 if delta_y < 0 else 0
            if change != 0: self._pending_tile_size_change += change; self._scroll_scale_timer.start(self.scroll_debounce_ms)
        else: super().wheelEvent(event)

    def _apply_scroll_scaling(self) -> None:
        """Applies pending zoom changes."""
        # Ensure scroll_area exists before using it
        if not hasattr(self, 'scroll_area') or not self.scroll_area:
            log.error("_apply_scroll_scaling called without scroll_area")
            self._pending_tile_size_change = 0
            return
        # (Rest of implementation unchanged)
        if ( not self.main_loop or self._pending_tile_size_change == 0 or not self.tileset_manager ): return
        viewport_widget = self.scroll_area.viewport()
        if not viewport_widget: log.warning("Scroll area viewport missing for zoom"); self._pending_tile_size_change = 0; return
        h_bar = self.scroll_area.horizontalScrollBar(); v_bar = self.scroll_area.verticalScrollBar()
        mouse_pos_in_viewport = viewport_widget.mapFromGlobal(QCursor.pos())
        content_x_at_mouse_before = h_bar.value() + mouse_pos_in_viewport.x()
        content_y_at_mouse_before = v_bar.value() + mouse_pos_in_viewport.y()
        old_tile_w = self.tileset_manager.tile_width; old_tile_h = self.tileset_manager.tile_height
        if old_tile_w <= 0 or old_tile_h <= 0: log.error("Old tile size invalid"); return
        grid_x_at_mouse = content_x_at_mouse_before / old_tile_w; grid_y_at_mouse = content_y_at_mouse_before / old_tile_h
        target_width = old_tile_w + self._pending_tile_size_change; target_height = old_tile_h + self._pending_tile_size_change
        min_sz = self.min_tile_size; max_sz = self.app_config.get("max_tile_size", 64)
        new_width = max(min_sz, min(target_width, max_sz)); new_height = max(min_sz, min(target_height, max_sz))
        accumulated_change = self._pending_tile_size_change; self._pending_tile_size_change = 0
        if new_width != old_tile_w or new_height != old_tile_h:
            log.info( "Applying zoom", change=accumulated_change, old=f"{old_tile_w}x{old_tile_h}", new=f"{new_width}x{new_height}" )
            success = self.tileset_manager.load_new_tileset( self.tileset_manager.current_tileset_path, new_width, new_height )
            if success:
                self._cached_vp_pixel_dims = None; self._cached_tile_dims = None; self._render_coord_cache = {}
                # update_frame is triggered by load_new_tileset if successful
                def recenter_view_after_zoom():
                    QApplication.processEvents() # Allow resize events to process
                    current_h_bar = self.scroll_area.horizontalScrollBar(); current_v_bar = self.scroll_area.verticalScrollBar()
                    new_content_x_at_grid = grid_x_at_mouse * self.tileset_manager.tile_width
                    new_content_y_at_grid = grid_y_at_mouse * self.tileset_manager.tile_height
                    current_h_bar.setValue( int(new_content_x_at_grid - mouse_pos_in_viewport.x()) )
                    current_v_bar.setValue( int(new_content_y_at_grid - mouse_pos_in_viewport.y()) )
                    log.debug("Recentered view after successful zoom.")
                QTimer.singleShot(0, recenter_view_after_zoom)
            else: log.error("Zoom failed because tileset failed to load new size.")
        else: log.debug("Zoom resulted in no size change (min/max limits?).")

```

`basicrl/engine/window_manager_modules/input_handler.py`:

```py
# engine/window_manager_modules/input_handler.py
"""
Handles processing of raw keyboard inputs, mapping them to game actions
or UI commands based on keybindings and game state.
"""
# Standard Imports
from typing import TYPE_CHECKING, Any
from typing import Dict as PyDict
from typing import List

# Third-party Imports
import structlog

# PySide6 Imports
from PySide6.QtCore import Qt
from PySide6.QtGui import QKeyEvent

# --- Type Checking Imports ---
if TYPE_CHECKING:
    # Use absolute paths relative to project root (basicrl)
    from engine.main_loop import MainLoop
    from engine.window_manager import (
        WindowManager,
    )  # Adjust if WindowManager moves later
    from game.game_state import GameState

log = structlog.get_logger(__name__)


class InputHandler:
    """
    Processes keyboard events and translates them into game actions or UI calls.
    """

    def __init__(
        self,
        keybindings_config: PyDict[str, Any],
        window_manager_ref: "WindowManager",  # WindowManager stays in engine/
    ):
        self.keybindings_config: PyDict[str, Any] = keybindings_config
        self.window_manager_ref: "WindowManager" = window_manager_ref
        log.debug("InputHandler initialized.")

    # --- Key Parsing Methods ---
    def _get_qt_key_enum(self, key_str: str | None) -> Qt.Key | None:
        """Converts a key string (e.g., "A", "F1", "KP_1") to a Qt.Key enum value."""
        if not key_str:
            return None
        qt_key = getattr(Qt.Key, f"Key_{key_str}", None)
        if qt_key:
            return qt_key
        if key_str.startswith("KP_"):
            kp_suffix = key_str[3:]
            qt_key_kp_full = getattr(Qt.Key, f"Key_{key_str}", None)
            if qt_key_kp_full:
                return qt_key_kp_full
            if kp_suffix.isdigit():
                qt_key = getattr(Qt.Key, f"Key_{kp_suffix}", None)
                if qt_key:
                    return qt_key
            qt_key_suffix_only = getattr(Qt.Key, f"Key_{kp_suffix}", None)
            if qt_key_suffix_only:
                return qt_key_suffix_only
        if len(key_str) == 1:
            qt_key_upper = getattr(Qt.Key, f"Key_{key_str.upper()}", None)
            if qt_key_upper:
                return qt_key_upper
        key_str_lower = key_str.lower()
        common_map = {
            "up": Qt.Key.Key_Up,
            "down": Qt.Key.Key_Down,
            "left": Qt.Key.Key_Left,
            "right": Qt.Key.Key_Right,
            "home": Qt.Key.Key_Home,
            "end": Qt.Key.Key_End,
            "pageup": Qt.Key.Key_PageUp,
            "pagedown": Qt.Key.Key_PageDown,
            "space": Qt.Key.Key_Space,
            "period": Qt.Key.Key_Period,
            "return": Qt.Key.Key_Return,
            "enter": Qt.Key.Key_Enter,
            "escape": Qt.Key.Key_Escape,
            "tab": Qt.Key.Key_Tab,
            "backspace": Qt.Key.Key_Backspace,
            "delete": Qt.Key.Key_Delete,
        }
        if key_str_lower in common_map:
            return common_map[key_str_lower]
        log.warning("Could not map key string to Qt.Key", key_str=key_str)
        return None

    def _get_qt_modifier_enum(self, mods_list: List[str]) -> Qt.KeyboardModifier:
        """Converts a list of modifier strings (e.g., ["Ctrl", "Shift"]) to Qt.KeyboardModifiers."""
        modifier = Qt.KeyboardModifier.NoModifier
        if not mods_list:
            return modifier
        for mod_str in mods_list:
            mod_lower = mod_str.lower()
            if mod_lower == "ctrl" or mod_lower == "control":
                modifier |= Qt.KeyboardModifier.ControlModifier
            elif mod_lower == "shift":
                modifier |= Qt.KeyboardModifier.ShiftModifier
            elif mod_lower == "alt":
                modifier |= Qt.KeyboardModifier.AltModifier
        return modifier

    def _get_action_for_key(
        self,
        key_code: int,
        modifiers: Qt.KeyboardModifier,
        active_keybinding_sets: List[str],
    ) -> PyDict[str, Any] | None:
        """Finds the action dictionary corresponding to a key press and active binding sets."""
        bindings = self.keybindings_config.get("bindings", {})
        for set_name in active_keybinding_sets:
            binding_set = bindings.get(set_name)
            if not binding_set or not isinstance(binding_set, dict):
                continue
            for action_name, binding_data in binding_set.items():
                if not isinstance(binding_data, dict):
                    continue
                bound_key_str: str | None = binding_data.get("key")
                bound_key_enum: Qt.Key | None = self._get_qt_key_enum(bound_key_str)
                bound_mods_list: List[str] = binding_data.get("mods", [])
                required_mod_enum: Qt.KeyboardModifier = self._get_qt_modifier_enum(
                    bound_mods_list
                )
                if key_code == bound_key_enum and modifiers == required_mod_enum:
                    action_type: str | None = binding_data.get("action_type")
                    if action_type == "move":
                        return {
                            "type": "move",
                            "dx": binding_data.get("dx", 0),
                            "dy": binding_data.get("dy", 0),
                        }
                    elif action_type == "action":
                        # Use the action_name from the keybinding as the 'type'
                        return {"type": action_name}
                    elif action_type == "ui":
                        return {"type": "ui", "ui_action": action_name}
                    else:
                        log.warning(
                            "Unknown action_type in keybinding",
                            action_name=action_name,
                            type=action_type,
                        )
                        return None
        return None

    # --- End Key Parsing Methods ---

    def process_key_event(
        self,
        event: QKeyEvent,
        game_state: "GameState",
        main_loop_ref: "MainLoop",
        active_keybinding_sets: List[str],
    ) -> bool:
        """
        Processes a QKeyEvent.
        Returns True if the key was handled, False otherwise.
        Calls methods on window_manager_ref for UI interactions.
        """
        key = event.key()
        mods = event.modifiers()
        log.debug(
            "Processing key event",
            key_text=event.text(),
            key_enum_val=key,
            mods_val=mods,
            ui_state=game_state.ui_state,
        )

        action_to_dispatch: PyDict[str, Any] | None = None
        key_handled = False

        # Universal Escape handling
        if key == Qt.Key.Key_Escape:
            if game_state.ui_state != "PLAYER_TURN":
                log.info(
                    "Escape pressed, returning to player turn.",
                    from_state=game_state.ui_state,
                )
                self.window_manager_ref.ui_return_to_player_turn()
                key_handled = True
            else:
                quit_action = self._get_action_for_key(
                    key, mods, ["common"] # Only check common for quit on Esc
                )
                if quit_action and quit_action.get("ui_action") == "quit_game_alt":
                    log.info("Quit key (Escape) pressed in PLAYER_TURN.")
                    self.window_manager_ref.ui_quit_game()
                    key_handled = True
            if key_handled:
                return True

        # Universal Help handling
        help_action_lookup = self._get_action_for_key(key, mods, active_keybinding_sets)
        if help_action_lookup and help_action_lookup.get("ui_action") == "show_help":
            self.window_manager_ref.ui_show_help_dialog()
            return True

        # State-dependent input processing
        match game_state.ui_state:
            case "PLAYER_TURN":
                looked_up_action = self._get_action_for_key(
                    key, mods, active_keybinding_sets
                )
                if looked_up_action:
                    action_name = looked_up_action.get("type") # e.g., 'move', 'wait', 'pickup', 'ui'
                    ui_action_name = looked_up_action.get("ui_action") # Only present if type is 'ui'

                    # Explicitly handle known action types
                    if action_name == "move":
                        action_to_dispatch = looked_up_action
                        key_handled = True
                    elif action_name in ["wait", "pickup", "wait_alt", "wait_alt2"]:
                        # *** MODIFIED: Simplify action assignment ***
                        canonical_action_name = action_name
                        if action_name.startswith("wait"):
                            canonical_action_name = "wait"

                        if canonical_action_name == action_name:
                            # No change needed, use the original dict
                            action_to_dispatch = looked_up_action
                        else:
                            # Create a simple dict with the canonical name
                            action_to_dispatch = {"type": canonical_action_name}
                        # *** END MODIFICATION ***
                        key_handled = True
                    elif action_name == "ui":
                        # Handle UI-specific actions triggered from player turn
                        if ui_action_name == "inventory":
                            self.window_manager_ref.ui_open_inventory_view()
                            key_handled = True
                        elif ui_action_name == "toggle_height_vis":
                            self.window_manager_ref.ui_toggle_height_visualization()
                            key_handled = True
                        # Add other UI actions...
                        else:
                            log.warning(
                                "Unhandled UI action from PLAYER_TURN",
                                ui_action=ui_action_name,
                            )
                            key_handled = False
                    else:
                        # Log unknown action *names* here
                        log.warning(
                            "Unknown action name received in PLAYER_TURN",
                            action_name=action_name,
                            action_data=looked_up_action,
                        )
                        key_handled = False

            case "INVENTORY_VIEW":
                nav_map = {
                    Qt.Key.Key_Down: "down",
                    Qt.Key.Key_J: "down",
                    Qt.Key.Key_S: "down",
                    Qt.Key.Key_Up: "up",
                    Qt.Key.Key_K: "up",
                    Qt.Key.Key_W: "up",
                }
                action_key_map = {
                    Qt.Key.Key_E: "equip_unequip",
                    Qt.Key.Key_U: "use",
                    Qt.Key.Key_D: "drop",
                    # TODO: Add Attach/Detach keys here
                }
                if key in nav_map:
                    self.window_manager_ref.ui_overlay_manager.navigate(nav_map[key])
                    key_handled = True
                elif key in action_key_map:
                    action_to_dispatch = (
                        self.window_manager_ref.ui_overlay_manager.get_action_for_key(
                            action_key_map[key]
                        )
                    )
                    key_handled = True
                else:
                    key_handled = False

            case "TARGETING":
                log.debug("Key in TARGETING state - NI")
                key_handled = False
            case _:
                log.warning(
                    "Key pressed in unknown UI state", state=game_state.ui_state
                )
                key_handled = False

        # Dispatch game action if generated
        if action_to_dispatch:
            log.debug("Dispatching action to main loop", action=action_to_dispatch)
            turn_taken = main_loop_ref.handle_action(action_to_dispatch)
            if game_state.ui_state == "INVENTORY_VIEW":
                self.window_manager_ref.update_frame()

        elif key_handled and game_state.ui_state != "PLAYER_TURN":
            self.window_manager_ref.update_frame()

        return key_handled

```

`basicrl/engine/window_manager_modules/tileset_manager.py`:

```py
# engine/window_manager_modules/tileset_manager.py
"""
Manages loading, caching, and providing access to tileset data,
including Numba-compatible NumPy arrays.
"""
# Standard Imports
from pathlib import Path
from typing import Any
from typing import Dict as PyDict

# Third-party Imports
import numpy as np
import structlog
from numba import types as nb_types
from numba.typed import Dict as NumbaTypedDict
from PIL import Image

# Local Application Imports
# Use absolute paths from project root (basicrl)
from engine.tileset_loader import load_tiles
# Ensure GameMap and TILE_TYPES can be imported for schema validation/population
try:
    from game.world.game_map import TILE_TYPES
except ImportError:
    # Fallback if necessary, but ideally structure allows direct import
    try:
        from basicrl.game.world.game_map import TILE_TYPES
    except ImportError:
        TILE_TYPES = {} # Fallback to empty if not found
        structlog.get_logger().error("Could not import TILE_TYPES for TilesetManager.")


log = structlog.get_logger(__name__)

SENTINEL_TILE_ARRAY_SHAPE = (0, 0, 4)
SENTINEL_TILE_ARRAY = np.empty(SENTINEL_TILE_ARRAY_SHAPE, dtype=np.uint8)


class TilesetManager:
    """Handles loading and caching of tile assets."""

    def __init__(
        self,
        initial_tileset_path: str,
        initial_tile_width: int,
        initial_tile_height: int,
        min_tile_size_cfg: int,
    ):
        log.info("Initializing TilesetManager...")
        self.min_tile_size: int = min_tile_size_cfg
        self.current_tileset_path: str = ""
        self.tiles: PyDict[int, Image.Image] = {} # PIL images {tile_index: Image}
        self.tile_width: int = 0
        self.tile_height: int = 0

        # --- Numba Cache and Render Data ---
        # Define the type for the Numba dictionary values (3D NumPy array)
        # Using nb_types.uint8[:,:,::1] specifies C-contiguous arrays which is common
        _array_value_type = nb_types.uint8[:, :, ::1]
        self.tile_arrays: NumbaTypedDict = NumbaTypedDict.empty(
            key_type=nb_types.int_, value_type=_array_value_type
        ) # Numba dict {tile_index: np.ndarray[h, w, 4]}
        self.max_defined_tile_id: int = -1
        self._tile_fg_colors: np.ndarray | None = None # [max_id+1, 3] uint8
        self._tile_bg_colors: np.ndarray | None = None # [max_id+1, 3] uint8
        self._tile_indices_render: np.ndarray | None = None # [max_id+1] uint16
        # --- End Numba Cache ---

        # Perform initial load
        self.load_new_tileset(
            initial_tileset_path, initial_tile_width, initial_tile_height
        )
        log.debug("TilesetManager initialized.")

    def load_new_tileset(self, folder: str, width: int, height: int) -> bool:
        """Loads a new tileset from the specified folder and dimensions."""
        target_abs_path_str = "unknown"
        try:
            clamped_width = max(self.min_tile_size, width)
            clamped_height = max(self.min_tile_size, height)

            # Resolve path correctly
            target_path_obj = Path(folder)
            if not target_path_obj.is_absolute():
                try: # Assume relative to project root if possible
                    # Adjust based on actual file structure if needed
                    base_path = Path(__file__).parent.parent.parent
                except NameError:
                    base_path = Path(".") # Fallback
                target_abs_path = (base_path / folder).resolve()
            else:
                target_abs_path = target_path_obj.resolve()
            target_abs_path_str = str(target_abs_path)

            if (
                clamped_width == self.tile_width
                and clamped_height == self.tile_height
                and target_abs_path_str == self.current_tileset_path
            ):
                log.info(
                    "Tileset unchanged, skipping reload.", path=target_abs_path_str
                )
                return True # Considered successful as state is correct

            log.info(
                "Loading tileset",
                path=target_abs_path_str,
                w=clamped_width,
                h=clamped_height,
            )
            # Assuming load_tiles returns: Dict[int, Image.Image], bool
            loaded_tiles, _ = load_tiles(
                target_abs_path_str, clamped_width, clamped_height
            )

            self.current_tileset_path = target_abs_path_str
            # Ensure loaded_tiles is the correct type before assignment
            if isinstance(loaded_tiles, dict):
                 self.tiles = loaded_tiles
            else:
                 log.error("load_tiles did not return a dictionary.", received_type=type(loaded_tiles))
                 self.tiles = {} # Reset to empty on error
                 # Consider raising an error or returning False earlier

            self.tile_width = clamped_width
            self.tile_height = clamped_height

            self._update_tile_array_cache() # Update Numba cache

            log.info(
                "Tileset loaded successfully",
                path=target_abs_path_str,
                final_w=self.tile_width,
                final_h=self.tile_height,
                count=len(self.tiles),
            )
            return True

        except Exception as e:
            log.error(
                "Error loading tileset in TilesetManager",
                path_param=folder,
                abs_path=target_abs_path_str,
                error=str(e),
                exc_info=True,
            )
            # Decide whether to keep old state or reset
            # Resetting might be safer if load failed badly
            # self.tiles = {}; self.tile_width = 0; self.tile_height = 0;
            # self._update_tile_array_cache() # Ensure cache is cleared/reset too
            return False

    def _update_tile_array_cache(self) -> None:
        """Updates the Numba-compatible NumPy array cache and render data."""
        log.debug("Updating tile array cache (Numba typed.Dict & render data)...")
        pil_tile_count = 0
        numba_tile_count = 0
        # Ensure type consistency with __init__
        _array_value_type = nb_types.uint8[:, :, ::1]

        # Reset caches
        self.max_defined_tile_id = -1
        self._tile_fg_colors = None
        self._tile_bg_colors = None
        self._tile_indices_render = None
        temp_tile_arrays: NumbaTypedDict = NumbaTypedDict.empty(
            key_type=nb_types.int_, value_type=_array_value_type
        )

        # 1. Update render data cache (fg/bg colors, glyph indices) from TILE_TYPES
        if TILE_TYPES and isinstance(TILE_TYPES, dict):
            try:
                # Filter out non-integer keys just in case
                valid_tile_ids = [k for k in TILE_TYPES.keys() if isinstance(k, int)]
                if not valid_tile_ids:
                     log.warning("TILE_TYPES dictionary contains no integer keys.")
                     self.max_defined_tile_id = -1
                else:
                     self.max_defined_tile_id = max(valid_tile_ids)
            except Exception as e:
                 log.error("Error finding max key in TILE_TYPES", error=str(e), data=TILE_TYPES)
                 self.max_defined_tile_id = -1

            array_size = self.max_defined_tile_id + 1
            if array_size > 0:
                self._tile_fg_colors = np.zeros((array_size, 3), dtype=np.uint8)
                self._tile_bg_colors = np.zeros((array_size, 3), dtype=np.uint8)
                self._tile_indices_render = np.zeros(array_size, dtype=np.uint16)
                valid_ids_loaded = 0
                for tile_id_val, tile_type_data in TILE_TYPES.items():
                    if not isinstance(tile_id_val, int): continue # Skip non-int keys

                    if 0 <= tile_id_val <= self.max_defined_tile_id:
                        # Safely access attributes using getattr with defaults
                        fg_color = getattr(tile_type_data, 'color_fg', (255,0,255))
                        bg_color = getattr(tile_type_data, 'color_bg', (0,0,0))
                        tile_index = getattr(tile_type_data, 'tile_index', 0) # Default to glyph 0

                        if isinstance(fg_color, tuple) and len(fg_color) == 3:
                             self._tile_fg_colors[tile_id_val] = fg_color
                        if isinstance(bg_color, tuple) and len(bg_color) == 3:
                             self._tile_bg_colors[tile_id_val] = bg_color
                        self._tile_indices_render[tile_id_val] = int(tile_index)

                        valid_ids_loaded += 1
                log.debug(
                    "Tile render cache populated",
                    loaded_ids=valid_ids_loaded,
                    max_id=self.max_defined_tile_id,
                    array_size=array_size,
                    fg_shape=self._tile_fg_colors.shape,
                    bg_shape=self._tile_bg_colors.shape,
                    idx_shape=self._tile_indices_render.shape,
                )
            else:
                log.warning(
                    "max_defined_tile_id resulted in non-positive array size",
                    max_id=self.max_defined_tile_id
                )
        else:
            log.warning("TILE_TYPES is empty or invalid, cannot populate render cache.")

        # 2. Update Numba array cache from loaded PIL tiles
        if not self.tiles or self.tile_width <= 0 or self.tile_height <= 0:
            log.warning("Cannot update Numba cache: Invalid tiles or dimensions.")
            self.tile_arrays = temp_tile_arrays # Assign empty dict
            return

        pil_tile_count = len(self.tiles)
        for tile_index, img in self.tiles.items():
            if img is None:
                temp_tile_arrays[tile_index] = SENTINEL_TILE_ARRAY
                continue
            try:
                if img.size != (self.tile_width, self.tile_height):
                    img = img.resize(
                        (self.tile_width, self.tile_height), Image.Resampling.NEAREST
                    )
                if img.mode != "RGBA":
                    img = img.convert("RGBA")

                tile_np_array = np.array(img, dtype=np.uint8)
                # Ensure C-contiguity for Numba compatibility if needed
                if not tile_np_array.flags['C_CONTIGUOUS']:
                    tile_np_array = np.ascontiguousarray(tile_np_array)

                # Check final shape AFTER potential conversion/resizing
                if tile_np_array.shape == (self.tile_height, self.tile_width, 4):
                    temp_tile_arrays[tile_index] = tile_np_array
                    numba_tile_count += 1
                else:
                    log.warning(
                        f"Tile {tile_index} final shape {tile_np_array.shape} != expected ({self.tile_height}, {self.tile_width}, 4). Storing sentinel."
                    )
                    temp_tile_arrays[tile_index] = SENTINEL_TILE_ARRAY
            except Exception as e:
                log.warning(
                    f"Could not convert tile {tile_index} for Numba: {e}", exc_info=True
                )
                temp_tile_arrays[tile_index] = SENTINEL_TILE_ARRAY

        self.tile_arrays = temp_tile_arrays
        log.info(
            "TilesetManager cache updated",
            pil_count=pil_tile_count,
            numba_count=numba_tile_count,
        )

    def get_render_data(self) -> PyDict[str, Any]:
        """Returns the data needed by the renderer."""
        # Check if caches are valid
        cache_ready = (
            self._tile_fg_colors is not None
            and self._tile_bg_colors is not None
            and self._tile_indices_render is not None
            and self.max_defined_tile_id >= 0
            and self.tile_arrays is not None # Check Numba dict itself
        )

        # *** ADDED LOGGING ***
        log.debug("TilesetManager.get_render_data called.",
                  cache_ready=cache_ready,
                  max_id=self.max_defined_tile_id,
                  fg_colors_valid=self._tile_fg_colors is not None,
                  bg_colors_valid=self._tile_bg_colors is not None,
                  indices_valid=self._tile_indices_render is not None,
                  tile_arrays_items=len(self.tile_arrays) if self.tile_arrays is not None else 'None')

        if not cache_ready:
            log.error("Render data cache is not ready in TilesetManager.")
            # Return empty/default data to avoid crashing renderer
            _array_type = nb_types.uint8[:, :, ::1] # Match type
            return {
                "tile_arrays": NumbaTypedDict.empty(key_type=nb_types.int_, value_type=_array_type),
                "tile_fg_colors": np.zeros((1, 3), dtype=np.uint8),
                "tile_bg_colors": np.zeros((1, 3), dtype=np.uint8),
                "tile_indices_render": np.zeros(1, dtype=np.uint16),
                "max_defined_tile_id": -1, # Indicate invalid cache
                "tile_w": self.tile_width,
                "tile_h": self.tile_height,
            }

        return {
            "tile_arrays": self.tile_arrays,
            "tile_fg_colors": self._tile_fg_colors,
            "tile_bg_colors": self._tile_bg_colors,
            "tile_indices_render": self._tile_indices_render,
            "max_defined_tile_id": self.max_defined_tile_id,
            "tile_w": self.tile_width,
            "tile_h": self.tile_height,
        }

```

`basicrl/engine/window_manager_modules/ui_overlay_manager.py`:

```py
# engine/window_manager_modules/ui_overlay_manager.py
"""
Manages the rendering of UI overlays like debug text, inventory, etc.
Also handles inventory state management (cursor position, item mapping).
"""
# Standard Imports
from typing import TYPE_CHECKING, Any
from typing import Dict as PyDict
from typing import List, Tuple

# Third-party Imports
import polars as pl
import structlog
from PIL import Image, ImageDraw, ImageFont

# --- Type Checking Imports ---
if TYPE_CHECKING:
    # Use absolute paths relative to project root (basicrl)
    from engine.main_loop import MainLoop
    from engine.window_manager import (
        WindowManager,
    )  # Needs reference for config/fonts/state
    from game.game_state import GameState

log = structlog.get_logger(__name__)


class UIOverlayManager:
    """Handles rendering and state for UI overlays."""

    def __init__(self, window_manager_ref: "WindowManager"):
        self.window_manager_ref: "WindowManager" = window_manager_ref
        # Inventory state
        self.inventory_cursor: int = 0
        self.inventory_scroll_offset: int = 0  # For future scrolling
        # Map from display line index to (item_id | None, is_equipped_flag)
        self._inventory_ui_map: PyDict[int, Tuple[int | None, bool]] = {}
        log.debug("UIOverlayManager initialized.")

    def reset_inventory_state(self) -> None:
        """Resets cursor and map when inventory is opened/closed."""
        self.inventory_cursor = 0
        self.inventory_scroll_offset = 0
        self._inventory_ui_map.clear()
        log.debug("Inventory UI state reset.")

    def render_overlays(
        self, base_image: Image.Image, gs: "GameState", main_loop_ref: "MainLoop"
    ) -> Image.Image:
        """Adds all relevant overlays to the base rendered image."""
        if not base_image:
            log.error("Received None base_image for overlays.")
            try:  # Attempt to get size from window manager for blank image
                w = self.window_manager_ref.label.width()
                h = self.window_manager_ref.label.height()
                return Image.new("RGBA", (max(1, w), max(1, h)), (0, 0, 0, 0))
            except Exception:
                return Image.new("RGBA", (100, 100), (0, 0, 0, 0))  # Fallback size
    
        img_copy = base_image.copy()  # Work on a copy
        draw = ImageDraw.Draw(img_copy)
    
        # Font Loading (Consider centralizing or caching in WindowManager/Config)
        text_font = None
        try:
            # TODO: Get font path/size from config via window_manager_ref.app_config
            text_font = ImageFont.truetype("arial.ttf", 10)
        except IOError:
            text_font = ImageFont.load_default()
    
        # 1. Debug Text Overlay
        bg_rect_debug = self._render_debug_overlay(draw, text_font, gs, main_loop_ref)
    
        # 2. Height Visualization Key Overlay
        if main_loop_ref.show_height_visualization:
            self._render_height_key_overlay(
                draw, text_font, bg_rect_debug, main_loop_ref
            )
    
        # 3. Inventory Overlay
        if gs.ui_state == "INVENTORY_VIEW":
            # FIXED: Pass text_font instead of undefined font variable
            img_copy = self._render_inventory_overlay(img_copy, draw, text_font, gs)
    
        # 4. Message Log Overlay (Future)
        # self._render_message_log(draw, text_font, gs)
    
        return img_copy
        

    def _render_debug_overlay(
        self,
        draw: ImageDraw.ImageDraw,
        font: ImageFont.FreeTypeFont,
        gs: "GameState",
        ml: "MainLoop",
    ) -> Tuple[int, int, int, int]:
        """Renders the debug text overlay. Returns bounding box of background."""
        try:
            wm = self.window_manager_ref  # Shortcut for readability
            turn = gs.turn_count
            player_pos = gs.player_position
            pos_str = f"({player_pos[0]},{player_pos[1]})" if player_pos else "N/A"

            entities_count_str = "?"
            try:  # Safely get entity count
                if gs.entity_registry:
                    entities_count_str = str(
                        gs.entity_registry.entities_df.filter(
                            pl.col("is_active")
                        ).height
                    )
            except Exception as e:
                log.warning("Could not get entity count for debug overlay", error=e)

            label_w = wm.label.width()
            label_h = wm.label.height()

            # --- CORRECTED: Get tile dimensions from TilesetManager via WindowManager ---
            if wm.tileset_manager:
                current_tile_w = wm.tileset_manager.tile_width
                current_tile_h = wm.tileset_manager.tile_height
            else:  # Fallback if manager isn't ready (shouldn't happen)
                current_tile_w = 1
                current_tile_h = 1
                log.error(
                    "TilesetManager not available on WindowManager for debug overlay."
                )
            # --- END CORRECTION ---

            vp_cols = max(1, label_w // current_tile_w) if current_tile_w > 0 else "?"
            vp_rows = max(1, label_h // current_tile_h) if current_tile_h > 0 else "?"

            debug_text = (
                f"T:{turn} P:{pos_str} E:{entities_count_str} "
                f"VP:{vp_cols}x{vp_rows} TR:{current_tile_w}x{current_tile_h} "  # Use fetched dimensions
                f"V:{'H' if ml.show_height_visualization else '-'} S:{gs.ui_state}"
            )

            text_x = 5
            text_y = 5
            text_color = (255, 255, 0, 255)  # Yellow
            bg_color = (0, 0, 0, 180)  # Semi-transparent black

            try:  # Calculate text bounding box
                if hasattr(draw, "textbbox"):
                    bbox = draw.textbbox((text_x, text_y), debug_text, font=font)
                elif hasattr(draw, "textlength"):
                    w = draw.textlength(debug_text, font=font)
                    h = (
                        font.getbbox("Ay")[3] - font.getbbox("Ay")[1]
                        if hasattr(font, "getbbox")
                        else 12
                    )
                    bbox = (text_x, text_y, text_x + w, text_y + h)
                else:
                    w = len(debug_text) * 6
                    h = 12
                    bbox = (text_x, text_y, text_x + w, text_y + h)
            except Exception as e:
                log.error("Error calculating debug text bounding box", error=e)
                bbox = (text_x, text_y, text_x + 100, text_y + 15)  # Fallback bbox

            # Draw background and text
            bg_rect = (bbox[0] - 2, bbox[1] - 2, bbox[2] + 2, bbox[3] + 2)
            draw.rectangle(bg_rect, fill=bg_color)
            draw.text((text_x, text_y), debug_text, fill=text_color, font=font)
            return bg_rect  # Return background rect for positioning other elements

        except Exception as e_get_dbg:
            log.error("Error getting debug info for overlay", error=str(e_get_dbg))
            return (0, 0, 0, 0)  # Return empty rect on error

    def _render_height_key_overlay(
        self,
        draw: ImageDraw.ImageDraw,
        font: ImageFont.FreeTypeFont,
        debug_bg_rect: Tuple[int, int, int, int],
        ml: "MainLoop",
    ) -> None:
        """Renders the height visualization key."""
        # This method remains the same as before, using ml (MainLoop ref) for config values
        try:
            wm = self.window_manager_ref  # Needed for lerp_color helper
            ch_np = ml._cfg_height_color_high_np
            cm_np = ml._cfg_height_color_mid_np
            cl_np = ml._cfg_height_color_low_np
            ch = tuple(map(int, ch_np)) if ch_np is not None else (255, 255, 0)
            cm = tuple(map(int, cm_np)) if cm_np is not None else (0, 255, 0)
            cl = tuple(map(int, cl_np)) if cl_np is not None else (0, 128, 255)

            max_diff_units = ml._cfg_vis_max_diff
            max_diff_meters = max_diff_units / 2.0
            key_width = 15
            key_height = 100
            key_x = 10
            key_y = debug_bg_rect[3] + 5  # Position below debug text
            label_offset = 5
            line_color = (200, 200, 200, 255)

            for i in range(key_height):
                t_norm = (
                    (((key_height - 1 - i) / (key_height - 1)) * 2.0 - 1.0)
                    if key_height > 1
                    else 0.0
                )
                # --- Call lerp_color through WindowManager reference ---
                current_bar_color = (
                    wm.lerp_color(cm, ch, t_norm)
                    if t_norm >= 0
                    else wm.lerp_color(cm, cl, -t_norm)
                )
                # --- End Call ---
                draw.line(
                    [(key_x, key_y + i), (key_x + key_width - 1, key_y + i)],
                    fill=current_bar_color + (255,),
                )

            mid_y_pos = key_y + key_height // 2
            draw.line(
                [(key_x - 2, mid_y_pos), (key_x + key_width + 1, mid_y_pos)],
                fill=(255, 255, 255, 255),
                width=1,
            )
            text_label_x = key_x + key_width + label_offset
            draw.text(
                (text_label_x, key_y - 4),
                f"+{max_diff_meters:.1f}m",
                fill=line_color,
                font=font,
            )
            draw.text((text_label_x, mid_y_pos - 4), "0m", fill=line_color, font=font)
            draw.text(
                (text_label_x, key_y + key_height - 10),
                f"-{max_diff_meters:.1f}m",
                fill=line_color,
                font=font,
            )
        except Exception as e_key_draw:
            log.error(
                "Error drawing height key overlay", error=str(e_key_draw), exc_info=True
            )

    def _render_inventory_overlay(
        self,
        base_image: Image.Image,
        draw: ImageDraw.ImageDraw,
        font: ImageFont.FreeTypeFont,
        gs: "GameState",
    ) -> Image.Image:
        """Renders the inventory overlay. Reuses the passed draw object."""
        # (Implementation unchanged from previous step)
        player_id = gs.player_id
        item_reg = gs.item_registry
        entity_reg = gs.entity_registry
        if not item_reg or not entity_reg:
            log.error("Registries missing for inventory.")
            return base_image
        title_font = font
        line_height = 15
        panel_padding = 10
        title_height = 20
        panel_width = 350
        try:
            title_font = ImageFont.truetype("arialbd.ttf", font.size + 2)
        except IOError:
            pass
        all_displayable_items = self._get_combined_inventory_list(gs)
        actual_item_count = sum(
            1
            for item_tuple in all_displayable_items
            if item_tuple[0] is not None and item_tuple[1] is not None
        )
        if actual_item_count == 0:
            panel_height = 60
            panel_x = max(10, (base_image.width - panel_width) // 2)
            panel_y = max(10, (base_image.height - panel_height) // 2)
            bg_color = (0, 0, 0, 200)
            draw.rectangle(
                [panel_x, panel_y, panel_x + panel_width, panel_y + panel_height],
                fill=bg_color,
                outline=(150, 150, 150, 255),
            )
            draw.text(
                (panel_x + panel_padding, panel_y + panel_padding),
                "Inventory Empty",
                fill=(200, 200, 200, 255),
                font=font,
            )
            return base_image
        num_display_lines = 0
        has_equipped_items = any(
            item[0] is not None and item[2] and item[1] is not None
            for item in all_displayable_items
        )
        has_inventory_items = any(
            item[0] is not None and not item[2] and item[1] is not None
            for item in all_displayable_items
        )
        num_display_lines += 1
        num_display_lines += len(
            [
                item
                for item in all_displayable_items
                if item[0] is not None and item[2] and item[1] is not None
            ]
        )
        # Equipped + header
        if not has_equipped_items:
            num_display_lines += 1  # Placeholder
        num_display_lines += 1
        num_display_lines += 1  # Spacer + Inv Header
        num_display_lines += len(
            [
                item
                for item in all_displayable_items
                if item[0] is not None and not item[2] and item[1] is not None
            ]
        )
        # Inventory items
        if not has_inventory_items:
            num_display_lines += 1  # Placeholder
        panel_height = (
            title_height + (num_display_lines * line_height) + (2 * panel_padding)
        )
        panel_x = max(10, (base_image.width - panel_width) // 2)
        panel_y = max(10, (base_image.height - panel_height) // 2)
        bg_color = (0, 0, 0, 200)
        border_color = (150, 150, 150, 255)
        draw.rectangle(
            [panel_x, panel_y, panel_x + panel_width, panel_y + panel_height],
            fill=bg_color,
            outline=border_color,
            width=1,
        )
        title_text = "INVENTORY"
        title_color = (255, 255, 255, 255)
        try:
            if hasattr(draw, "textbbox"):
                title_bbox = draw.textbbox((0, 0), title_text, font=title_font)
                title_w = title_bbox[2] - title_bbox[0]
            elif hasattr(draw, "textlength"):
                title_w = draw.textlength(title_text, font=title_font)
            else:
                title_w = len(title_text) * 7
        except:
            title_w = len(title_text) * 7
        draw.text(
            (panel_x + (panel_width - title_w) // 2, panel_y + panel_padding),
            title_text,
            fill=title_color,
            font=title_font,
        )
        current_y = panel_y + panel_padding + title_height
        text_x = panel_x + panel_padding
        header_color = (200, 200, 50, 255)
        item_color = (220, 220, 220, 255)
        cursor_color = (0, 255, 255, 255)
        placeholder_color = (150, 150, 150, 255)
        list_index = 0
        self._inventory_ui_map.clear()
        draw.text((text_x, current_y), "-- Equipped --", fill=header_color, font=font)
        current_y += line_height
        self._inventory_ui_map[list_index] = (None, False)
        list_index += 1
        equipped_items_tuples = [
            item
            for item in all_displayable_items
            if item[0] is not None and item[2] and item[1] is not None
        ]
        if equipped_items_tuples:
            for line, item_id, is_equipped in equipped_items_tuples:
                color = (
                    cursor_color if list_index == self.inventory_cursor else item_color
                )
                prefix = "> " if list_index == self.inventory_cursor else "  "
                draw.text((text_x, current_y), prefix + line, fill=color, font=font)
                current_y += line_height
                self._inventory_ui_map[list_index] = (item_id, is_equipped)
                list_index += 1
        else:
            draw.text(
                (text_x + 5, current_y),
                "(Nothing equipped)",
                fill=placeholder_color,
                font=font,
            )
            current_y += line_height
            self._inventory_ui_map[list_index] = (None, False)
            list_index += 1
        current_y += line_height // 2
        draw.text((text_x, current_y), "-- Inventory --", fill=header_color, font=font)
        current_y += line_height
        self._inventory_ui_map[list_index] = (None, False)
        list_index += 1
        inventory_items_tuples = [
            item
            for item in all_displayable_items
            if item[0] is not None and not item[2] and item[1] is not None
        ]
        if inventory_items_tuples:
            for line, item_id, is_equipped in inventory_items_tuples:
                color = (
                    cursor_color if list_index == self.inventory_cursor else item_color
                )
                prefix = "> " if list_index == self.inventory_cursor else "  "
                draw.text((text_x, current_y), prefix + line, fill=color, font=font)
                current_y += line_height
                self._inventory_ui_map[list_index] = (item_id, is_equipped)
                list_index += 1
        else:
            draw.text(
                (text_x + 5, current_y), "(Empty)", fill=placeholder_color, font=font
            )
            current_y += line_height
            self._inventory_ui_map[list_index] = (None, False)
            list_index += 1
        return base_image

    def _get_combined_inventory_list(
        self, gs: "GameState"
    ) -> List[Tuple[str | None, int | None, bool]]:
        """Generates the list of items for display, using GameState."""
        # (Implementation unchanged from previous step)
        combined_list: List[Tuple[str | None, int | None, bool]] = []
        player_id = gs.player_id
        item_reg = gs.item_registry
        entity_reg = gs.entity_registry
        if not item_reg or not entity_reg:
            return combined_list
        equipped_ids = entity_reg.get_equipped_ids(player_id)
        if equipped_ids:
            try:
                equipped_items_df = item_reg.items_df.filter(
                    pl.col("item_id").is_in(equipped_ids)
                    & (pl.col("location_type") == "equipped")
                    & pl.col("is_active")
                ).sort("equipped_slot")
                for item_data in equipped_items_df.iter_rows(named=True):
                    if isinstance(item_data, dict):
                        name = item_data.get("name", "?")
                        slot = item_data.get("equipped_slot", "?")
                        line = f"{name} ({slot})"
                        combined_list.append((line, item_data.get("item_id"), True))
            except Exception as e:
                log.error("Inv List: Equip fetch error", error=e)
        try:
            inv_items_df = item_reg.get_entity_inventory(player_id)
            active_inv_items_df = inv_items_df.filter(pl.col("is_active"))
            if active_inv_items_df.height > 0:
                for item_data in active_inv_items_df.sort("name").iter_rows(named=True):
                    if isinstance(item_data, dict):
                        name = item_data.get("name", "?")
                        qty = item_data.get("quantity", 1)
                        line = f"{name}" + (f" (x{qty})" if qty > 1 else "")
                        combined_list.append((line, item_data.get("item_id"), False))
        except Exception as e:
            log.error("Inv List: Inv fetch error", error=e)
        return combined_list

    # --- Inventory Interaction Logic ---
    def navigate(self, direction: str) -> None:
        """Handles inventory cursor movement."""
        # (Implementation unchanged from previous step)
        if not self._inventory_ui_map:
            log.debug("Inv map empty, cannot navigate.")
            return
        item_count = len(self._inventory_ui_map)
        if item_count <= 1:
            return
        current_idx = self.inventory_cursor
        start_idx = current_idx
        if direction == "down":
            while True:
                current_idx = (current_idx + 1) % item_count
                item_data = self._inventory_ui_map.get(current_idx)
                if item_data and item_data[0] is not None:
                    self.inventory_cursor = current_idx
                    break
                if current_idx == start_idx:
                    break
        elif direction == "up":
            while True:
                current_idx = (current_idx - 1 + item_count) % item_count
                item_data = self._inventory_ui_map.get(current_idx)
                if item_data and item_data[0] is not None:
                    self.inventory_cursor = current_idx
                    break
                if current_idx == start_idx:
                    break
        # Redraw will be triggered by InputHandler via WindowManager.update_frame()

    def get_action_for_key(self, action_type: str) -> PyDict[str, Any] | None:
        """Gets the game action dictionary for the selected inventory item."""
        # (Implementation unchanged from previous step)
        selected_data = self._inventory_ui_map.get(self.inventory_cursor)
        if not selected_data or selected_data[0] is None:
            return None
        item_id: int = selected_data[0]
        is_equipped: bool = selected_data[1]
        action: PyDict[str, Any] | None = None
        gs = self.window_manager_ref.main_loop.game_state
        if action_type == "equip_unequip":
            action = {"type": "unequip" if is_equipped else "equip", "item_id": item_id}
        elif action_type == "use":
            if not is_equipped:
                action = {"type": "use", "item_id": item_id}
            else:
                (
                    gs.add_message("Cannot use equipped items directly.", (255, 100, 0))
                    if gs
                    else None
                )
        elif action_type == "drop":
            action = {"type": "drop", "item_id": item_id}
        # TODO: Add attach/detach cases
        return action

```

`basicrl/environment.yml`:

```yml
# environment.yml
# Conda environment definition for the basic roguelike project.

name: basicrl

channels:
  - conda-forge
  - defaults

dependencies:
  - python=3.11
  - numpy>=1.23
  - polars>=0.19
  - numba>=0.57
  # ADDED structlog
  - structlog>=23.0
  - orjson>=3.9
  - pyyaml>=6.0
  # ADDED PySide6 and Pillow for GUI and image handling
  - pyside6>=6.5
  - pillow>=9.0
  # ADDED cairosvg for SVG rendering
  - cairosvg>=2.7
  - pip
#  - pip:
      # Add pip-installed packages below as needed
      # - tdl

```

`basicrl/fixem.py`:

```py
import os
import subprocess
import time
from collections import defaultdict
from concurrent.futures import ThreadPoolExecutor, as_completed
from pathlib import Path

# Remove Optional if no longer needed, keep List/Tuple/Dict for clarity if preferred
from typing import Dict, List, Tuple

# --- Configuration ---
# Run from the root directory containing your 'simple_rl' source folder
TARGET_DIR = Path.cwd()
# Directories/Patterns to EXCLUDE from scanning/formatting
EXCLUDE_PATTERNS = [
    ".git",
    ".venv",
    "venv",
    ".direnv",
    "__pycache__",
    "site-packages",
    "node_modules",
    "build",
    "dist",
    ".mypy_cache",
    ".pytest_cache",
    ".ruff_cache",
    # Add any other specific vendor/build/dependency directories
]
# Number of formatting passes to run
NUM_PASSES = 2
# Tools and their arguments - ORDER MATTERS HERE
TOOLS_IN_ORDER: List[Tuple[str, List[str]]] = [
    # Run isort first for import sorting
    ("isort", ["isort"]),
    # Run black for major formatting
    ("black", ["black", "-q"]),  # Quiet mode
    # Run ruff last for linting, fixing, and minor formatting
    ("ruff", ["ruff", "check", "--fix", "--exit-non-zero-on-fix"]),
]

# --- Helper Functions ---


# Use PEP 604 for Optional type hint
def run_tool(tool_cmd: List[str], file: Path) -> Tuple[str, int, str | None]:
    """
    Runs a command on a file, returns tool name, return code, and stderr if error.
    Handles tools that exit non-zero on success (if changes were made).
    """
    cmd_list = tool_cmd + [str(file)]
    tool_name = tool_cmd[0]
    stderr_output: str | None = None  # Use PEP 604
    try:
        process = subprocess.run(
            cmd_list, check=False, capture_output=True, text=True, encoding="utf-8"
        )

        # Identify true errors vs. non-zero exit indicating changes made
        is_error = False
        if process.returncode != 0:
            change_indicating_tools = {"isort", "black", "ruff"}
            if tool_name not in change_indicating_tools:
                is_error = True
            elif process.stderr:
                stderr_lower = process.stderr.lower()
                if (
                    "error:" in stderr_lower
                    or "fatal:" in stderr_lower
                    or "traceback" in stderr_lower
                ):
                    is_error = True

        if is_error:
            stderr_output = (
                process.stderr.strip()
                if process.stderr
                else f"Exited with code {process.returncode}"
            )

        return tool_name, process.returncode, stderr_output

    except FileNotFoundError:
        return (
            tool_name,
            -1,
            f"Tool '{tool_name}' not found. Is it installed and in PATH?",
        )
    except Exception as e:
        return tool_name, -1, f"Unexpected error running {tool_name}: {e}"


# Return type reflects nested type hints
def process_file(file: Path) -> Tuple[str, List[str]]:
    """
    Runs the configured sequence of tools multiple times on a single file.
    Returns the file path and a list of fatal errors encountered during any pass.
    """
    fatal_errors: list[str] = []  # Use list directly
    file_path_str = str(file)

    for pass_num in range(1, NUM_PASSES + 1):
        pass_had_fatal_error = False
        # print(f"  Pass {pass_num}/{NUM_PASSES} for {file.name}") # Optional verbose logging
        for tool_key, tool_cmd in TOOLS_IN_ORDER:
            tool_name, ret_code, err_msg = run_tool(tool_cmd, file)
            if err_msg:  # If run_tool determined it was a fatal error
                error_line = f"[Pass {pass_num}] {tool_name}: {err_msg}"
                if (
                    error_line not in fatal_errors
                ):  # Avoid duplicate messages across passes
                    fatal_errors.append(error_line)
                pass_had_fatal_error = True
                break  # Stop processing this file if a fatal error occurred in this pass

        if pass_had_fatal_error:
            break  # Don't run subsequent passes if one failed fatally

    return file_path_str, fatal_errors


def find_python_files(directory: Path) -> List[Path]:
    """Finds Python files, excluding specified patterns."""
    found_files: list[Path] = []  # Use list directly
    print(f"Searching for Python files in: {directory}")
    files_skipped_exclusions = 0
    for p in directory.rglob("*.py"):
        try:
            # Check against exclusion patterns
            is_excluded = False
            abs_path_parts = p.resolve().parts
            for pattern in EXCLUDE_PATTERNS:
                if pattern in abs_path_parts:
                    is_excluded = True
                    files_skipped_exclusions += 1
                    break
            if not is_excluded:
                found_files.append(p)
        except OSError as e:
            print(f"Warning: Could not process path {p}: {e}")

    print(
        f"  Found {len(found_files)} files after skipping {files_skipped_exclusions} due to exclusions."
    )
    return found_files


def main():
    start_time = time.time()
    files = find_python_files(TARGET_DIR)
    if not files:
        print("No Python files found to process.")
        return

    num_workers = os.cpu_count() or 1
    print(
        f"\nProcessing {len(files)} files using {num_workers} workers over {NUM_PASSES} passes each..."
    )

    errors: Dict[str, List[str]] = defaultdict(list)  # Use list directly
    files_processed = 0
    files_with_errors = 0

    with ThreadPoolExecutor(max_workers=num_workers) as executor:
        futures = [executor.submit(process_file, f) for f in files]
        for future in as_completed(futures):
            files_processed += 1
            try:
                file_path_str, file_fatal_errors = future.result()
                if file_fatal_errors:
                    errors[file_path_str].extend(file_fatal_errors)
                    files_with_errors += 1
                # Progress indicator
                progress_percent = (files_processed / len(files)) * 100
                print(
                    f"[{files_processed}/{len(files)}, {progress_percent:.1f}%] Processed: {Path(file_path_str).name}{' *ERROR*' if file_fatal_errors else ''}   ",
                    end="\r",
                )

            except Exception as e:
                print(f"\n[FATAL ERROR] Error retrieving result for a file: {e}")
                files_with_errors += 1

    print("\n" + "=" * 40)
    print("Processing Complete")
    print("=" * 40)

    if errors:
        print(f"\nEncountered fatal errors in {files_with_errors} file(s):")
        for file_path, file_errors in sorted(errors.items()):
            try:
                rel_path = Path(file_path).relative_to(TARGET_DIR)
            except ValueError:
                rel_path = file_path
            print(f"\n* File: {rel_path}")
            for error_detail in file_errors:
                print(f"  {error_detail}")
    else:
        print("\nAll files processed without reported fatal errors.")

    print("\n---")
    print(f"Recommendation: Run 'mypy {TARGET_DIR}' separately for type checking.")
    end_time = time.time()
    print(f"\nTotal time: {end_time - start_time:.2f} seconds.")


if __name__ == "__main__":
    main()

```

`basicrl/game/effects/executor.py`:

```py
# game/effects/executor.py
from typing import TYPE_CHECKING, Any, Dict

import structlog

# Import handlers dictionary
from .handlers import EFFECT_LOGIC_HANDLERS  # Keep this import

if TYPE_CHECKING:
    # No longer need ItemRegistry specific import here, accessed via GameState
    # from ..game.items.registry import ItemRegistry
    # Add EntityRegistry import for type hinting if needed, though accessed via gs
    from ..game.entities.registry import EntityRegistry
    from ..game_state import GameState

log = structlog.get_logger()

# --- Helper function stubs ---


def _check_targeting(effect_definition: dict, context: dict) -> bool:
    # ... (targeting logic remains the same) ...
    log.debug("Targeting check skipped (placeholder)")
    return True


def _check_and_deduct_costs(effect_definition: dict, context: Dict[str, Any]) -> bool:
    """
    Checks if costs (item charges, mana, fullness, etc.) can be met
    and deducts them if possible.
    """
    gs: "GameState" | None = context.get("game_state")  # Type hint with | None
    source_id = context.get("source_entity_id")
    item_id = context.get("item_instance_id")  # Still needed for item_charge cost

    costs = effect_definition.get("cost", [])
    if not costs:
        return True  # No cost defined

    if not gs:
        log.error("Cost check failed: game_state missing from context")
        return False

    # Ensure entity_registry is available
    entity_registry: "EntityRegistry" = gs.entity_registry
    if not entity_registry:
        log.error("Cost check failed: entity_registry missing from game_state")
        return False

    # --- Check all costs first ---
    can_pay = True
    failure_reason = ""
    for cost_info in costs:
        cost_type = cost_info.get("type")
        amount = cost_info.get("amount", 1)  # Default amount to 1 if missing
        if amount <= 0:
            continue  # Skip zero or negative costs

        log.debug("Checking cost", type=cost_type, amount=amount)

        if cost_type == "item_charge":
            if item_id is None:
                log.warning(
                    "Cost check failed: item_charge cost requires item_instance_id"
                )
                can_pay = False
                failure_reason = "Item charge required but no item specified"
                break
            # Ensure item_registry exists
            if not gs.item_registry:
                log.error(
                    "Cost check failed: item_registry missing for item_charge cost"
                )
                can_pay = False
                failure_reason = "Internal error: ItemRegistry missing"
                break
            current_charge = gs.item_registry.get_item_component(
                item_id, "current_charge"
            )
            if current_charge is None or current_charge < amount:
                log.debug(
                    "Cost check failed: Insufficient item charge",
                    item=item_id,
                    needed=amount,
                    has=current_charge,
                )
                can_pay = False
                failure_reason = "Insufficient item charge"
                break

        elif cost_type in ("mana", "fullness"):  # Handle generic resources
            if source_id is None:
                log.warning(
                    f"Cost check failed: {cost_type} cost requires source_entity_id"
                )
                can_pay = False
                failure_reason = (
                    f"{cost_type.capitalize()} cost requires a source entity"
                )
                break
            current_value = entity_registry.get_entity_component(source_id, cost_type)
            if current_value is None or current_value < amount:
                log.debug(
                    f"Cost check failed: Insufficient {cost_type}",
                    source=source_id,
                    needed=amount,
                    has=current_value,
                )
                can_pay = False
                failure_reason = f"Insufficient {cost_type}"
                break
        # --- Add elif for other cost types (e.g., hp) here ---
        # elif cost_type == "hp": ...
        else:
            log.warning("Cost check failed: Unknown cost type", type=cost_type)
            can_pay = False
            failure_reason = f"Unknown cost type '{cost_type}'"
            break

    if not can_pay:
        # Add message to player if the check failed for the player
        if source_id == gs.player_id:
            # Provide a more specific message if possible
            message = failure_reason or "You lack the required resources."
            gs.add_message(message.capitalize() + ".", (255, 100, 100))
        return False

    # --- Deduct costs (only if all checks passed) ---
    log.debug("Deducting costs", costs=costs)
    deduction_failed = False
    for cost_info in costs:
        cost_type = cost_info.get("type")
        amount = cost_info.get("amount", 1)
        if amount <= 0:
            continue

        if cost_type == "item_charge":
            # Re-get value just before setting for safety
            current_charge = gs.item_registry.get_item_component(
                item_id, "current_charge"
            )
            # Check again in case of race condition (if threading added later)
            if current_charge is None or current_charge < amount:
                log.error(
                    "Charge deduction failed: charge changed between check and deduct",
                    item=item_id,
                )
                deduction_failed = True
                break  # Abort deduction
            success = gs.item_registry.set_item_component(
                item_id, "current_charge", current_charge - amount
            )
            if not success:
                log.error("Failed to deduct item charge", item=item_id)
                deduction_failed = True
                break

        elif cost_type in ("mana", "fullness"):  # Handle generic resources
            # Re-get value
            current_value = entity_registry.get_entity_component(source_id, cost_type)
            if current_value is None or current_value < amount:
                log.error(
                    f"{cost_type.capitalize()} deduction failed: value changed between check and deduct",
                    source=source_id,
                )
                deduction_failed = True
                break
            new_value = current_value - amount
            success = entity_registry.set_entity_component(
                source_id, cost_type, new_value
            )
            if not success:
                log.error(f"Failed to deduct {cost_type}", source=source_id)
                deduction_failed = True
                break
            log.debug(
                f"Deducted {cost_type}",
                source=source_id,
                amount=amount,
                new_value=new_value,
            )
        # --- Add elif for other cost deductions here ---

    # --- IMPORTANT: Handle Deduction Failure ---
    # If any deduction failed, we have a problem. The state might be inconsistent.
    # Ideally, this would involve a transaction system to roll back previous deductions.
    # For now, we log a critical error and return False, potentially leaving the
    # game state inconsistent (e.g., charge deducted but mana deduction failed).
    if deduction_failed:
        log.critical(
            "Deduction phase failed mid-way! Game state may be inconsistent.",
            failed_cost_type=cost_type,
            source=source_id,
            item=item_id,
        )
        # Cannot easily undo previous deductions without more complex state management.
        return False  # Indicate overall failure

    log.debug("Costs deducted successfully")
    return True


def _check_conditions(effect_definition: dict, context: Dict[str, Any]) -> bool:
    # ... (conditions logic remains the same) ...
    log.debug("All conditions met")  # Assuming it passes for now
    return True


def _is_consumable_effect(effect_id: str, context: Dict[str, Any]) -> bool:
    # ... (consumption check logic remains the same) ...
    item_id = context.get("item_instance_id")
    if not item_id:
        return False
    gs: "GameState" | None = context.get("game_state")
    if not gs or not gs.item_registry:
        return False
    template_id = gs.item_registry.get_item_template_id(item_id)
    if not template_id:
        return False
    template = gs.item_registry.get_template(template_id)
    if not template:
        return False
    if effect_id in template.get("effects", {}).get("active_consumable", []):
        return True
    return False


def _consume_item(item_id: int, context: Dict[str, Any]):
    # ... (item consumption logic remains the same) ...
    gs: "GameState" | None = context.get("game_state")
    if not gs or not gs.item_registry:
        return
    quantity = gs.item_registry.get_item_component(item_id, "quantity")
    if quantity is None:
        log.warning("Cannot consume item: quantity is None", item_id=item_id)
        return
    if quantity > 1:
        log.debug("Decrementing consumable quantity", item_id=item_id, old_qty=quantity)
        gs.item_registry.set_item_component(item_id, "quantity", quantity - 1)
    else:
        log.debug("Deleting consumed item", item_id=item_id)
        gs.item_registry.delete_item(item_id)


# --- Main Executor ---


def execute_effect(effect_id: str, context: Dict[str, Any]) -> bool:
    """
    Executes a defined effect based on its ID and the provided context.
    Includes checks for targeting, costs, and conditions.
    """
    log.debug(
        "Executing effect", effect_id=effect_id, context_keys=list(context.keys())
    )

    gs: "GameState" | None = context.get("game_state")  # Use | None
    if not gs:
        log.error(
            "execute_effect failed: 'game_state' missing from context",
            effect_id=effect_id,
        )
        return False

    effect_definition = gs.effect_definitions.get(effect_id)
    if not effect_definition:
        log.warning("execute_effect failed: Unknown effect_id", effect_id=effect_id)
        return False

    # --- Execute Pre-Checks ---
    if not _check_targeting(effect_definition, context):
        log.debug("Effect targeting check failed", effect_id=effect_id)
        return False

    if not _check_conditions(effect_definition, context):
        log.debug("Effect condition check failed", effect_id=effect_id)
        return False

    # --- Check and Deduct Costs ---
    # This function now potentially adds messages on failure
    if not _check_and_deduct_costs(effect_definition, context):
        log.debug("Effect cost check failed or deduction failed", effect_id=effect_id)
        # Message is now added inside _check_and_deduct_costs if needed
        return False

    # --- Find and Execute Logic Handler ---
    logic_handler_id = effect_definition.get("logic_handler")
    if not logic_handler_id:
        log.warning("Effect definition missing 'logic_handler'", effect_id=effect_id)
        return False

    handler_func = EFFECT_LOGIC_HANDLERS.get(logic_handler_id)
    if not handler_func:
        log.error(
            "execute_effect failed: Unknown logic_handler in registry",
            effect_id=effect_id,
            logic_handler=logic_handler_id,
        )
        return False

    # --- Execute Core Logic ---
    try:
        params = effect_definition.get("params", {})
        handler_func(context, params)
        log.debug(
            "Effect handler executed successfully",
            effect_id=effect_id,
            handler=logic_handler_id,
        )

        # --- Handle Consumption (After successful execution) ---
        if _is_consumable_effect(effect_id, context):
            item_id = context.get("item_instance_id")
            if item_id:
                _consume_item(item_id, context)

        return True  # Indicate successful execution attempt

    except Exception as e:
        log.error(
            "Exception during effect handler execution",
            effect_id=effect_id,
            handler=logic_handler_id,
            error=str(e),
            exc_info=True,
        )
        # --- Rollback Consideration ---
        # Since deductions happened before execution, a failure here leaves state inconsistent.
        # A true rollback mechanism would be needed for atomicity.
        # For now, log the error. The effect failed, but costs were paid.
        gs.add_message(
            "An unexpected error occurred!", (255, 0, 0)
        )  # Generic error message
        return False  # Indicate failure

```

`basicrl/game/effects/handlers.py`:

```py
# game/effects/handlers.py
# Contains the actual Python functions that implement effect logic.

import re
from typing import TYPE_CHECKING, Any, Dict, List, Tuple

import structlog

# Imports for type hinting and GameRNG
from game_rng import GameRNG

if TYPE_CHECKING:

    # Corrected relative import path assuming handlers.py is inside effects folder
    from ..game_state import GameState

log = structlog.get_logger()

# --- Dice Rolling Utility ---
DICE_PATTERN = re.compile(r"(\d+)?d(\d+)(?:([+-])(\d+))?")


def _roll_dice(dice_str: str | None, rng: GameRNG | None) -> int:
    if not dice_str:
        return 0
    if not rng:
        log.warning("Dice roll attempted without RNG context!")
        return 0
    match = DICE_PATTERN.match(dice_str)
    if match:
        num_dice_str, sides_str, operator, bonus_str = match.groups()
        num_dice = int(num_dice_str) if num_dice_str else 1
        sides = int(sides_str)
        bonus = int(f"{operator}{bonus_str}") if operator and bonus_str else 0
        if sides <= 0:
            return bonus
        if num_dice <= 0:
            return bonus
        roll_total = sum(rng.get_int(1, sides) for _ in range(num_dice))
        return roll_total + bonus
    else:
        try:
            return int(dice_str)
        except ValueError:
            log.error("Invalid dice string format", dice_str=dice_str)
            return 0


# --- AOE Helper ---
def _get_entities_in_aoe(
    center_pos: Tuple[int, int], radius: int, gs: "GameState"
) -> List[int]:
    """Finds active entity IDs within a specified radius of a center point."""
    target_entities = []
    radius_sq = radius * radius
    cx, cy = center_pos

    active_entities_df = gs.entity_registry.get_active_entities()
    if active_entities_df.height == 0:
        return []

    # Filter entities within the bounding box first (minor optimization)
    potential_targets = active_entities_df.filter(
        (pl.col("x") >= cx - radius)
        & (pl.col("x") <= cx + radius)
        & (pl.col("y") >= cy - radius)
        & (pl.col("y") <= cy + radius)
    )

    # Precise distance check
    if potential_targets.height > 0:
        potential_targets = potential_targets.with_columns(
            dist_sq=((pl.col("x") - cx) ** 2 + (pl.col("y") - cy) ** 2)
        ).filter(pl.col("dist_sq") <= radius_sq)
        target_entities = potential_targets["entity_id"].to_list()

    # TODO: Optional LOS check from center_pos to each entity in target_entities
    # Requires game_map visibility logic

    log.debug(
        "AOE Query results",
        center=center_pos,
        radius=radius,
        count=len(target_entities),
        targets=target_entities,
    )
    return target_entities


# --- Handler Functions ---


def heal_target(context: Dict[str, Any], params: Dict[str, Any]):
    """Heals the target entity."""
    gs: "GameState" = context.get("game_state")
    rng: GameRNG | None = context.get("rng")
    target_id = context.get("target_entity_id", context.get("source_entity_id"))
    if not gs or target_id is None or not rng:
        log.warning(
            "Heal effect missing context", target_id=target_id, has_rng=bool(rng)
        )
        return

    base_heal = params.get("base_heal", 0)
    dice_str = params.get("dice")
    heal_amount = base_heal + _roll_dice(dice_str, rng)
    if heal_amount <= 0:
        return

    current_hp = gs.entity_registry.get_entity_component(target_id, "hp")
    max_hp = gs.entity_registry.get_entity_component(target_id, "max_hp")
    if current_hp is None or max_hp is None:
        log.warning("Heal target missing HP components", target_id=target_id)
        return

    new_hp = min(max_hp, current_hp + heal_amount)
    amount_healed = new_hp - current_hp
    if amount_healed > 0:
        success = gs.entity_registry.set_entity_component(target_id, "hp", new_hp)
        if success:
            log.debug(
                "Healed entity",
                target_id=target_id,
                amount=amount_healed,
                new_hp=new_hp,
            )
            target_name = (
                gs.entity_registry.get_entity_component(target_id, "name")
                or "Something"
            )
            if target_id == gs.player_id:
                gs.add_message(f"You heal for {amount_healed} HP.", (0, 255, 0))
            else:
                # TODO: Check visibility before showing message
                gs.add_message(
                    f"The {target_name} heals for {amount_healed} HP.", (0, 180, 0)
                )
        else:
            log.error("Failed to set new HP for heal target", target_id=target_id)


def modify_resource(context: Dict[str, Any], params: Dict[str, Any]):
    """Modifies a generic entity resource (e.g., fullness, mana). Requires component exists."""
    gs: "GameState" = context.get("game_state")
    target_id = context.get("target_entity_id", context.get("source_entity_id"))
    resource_name = params.get("resource")
    change_dice = params.get("dice")  # Allow dice roll for change
    base_change = params.get("base_change", 0)
    rng: GameRNG | None = context.get("rng")

    if not gs or target_id is None or not resource_name:
        log.warning(
            "Modify resource missing required info", target=target_id, res=resource_name
        )
        return

    change = base_change + _roll_dice(change_dice, rng)
    if change == 0:
        return  # No change

    # --- !!! IMPORTANT: Assumes components like 'mana', 'max_mana', 'fullness' exist !!! ---
    # --- !!! Need to add these to ENTITY_SCHEMA in registry.py                  !!! ---
    current_value = gs.entity_registry.get_entity_component(target_id, resource_name)
    max_value_component = f"max_{resource_name}"  # Convention: e.g., max_mana
    max_value = gs.entity_registry.get_entity_component(target_id, max_value_component)

    if current_value is None:
        log.warning(
            f"Target entity missing resource component '{resource_name}'",
            target_id=target_id,
        )
        return

    try:
        # Ensure types allow addition (e.g., handle None for max_value)
        numeric_current = float(current_value)  # Cast to float for flexibility
        new_value = numeric_current + change

        if max_value is not None:
            numeric_max = float(max_value)
            new_value = min(numeric_max, new_value)

        new_value = max(0.0, new_value)  # Assume resources don't go below 0

        # Cast back to the original type if needed, or keep as float? Assume float for now.
        # target_dtype = gs.entity_registry.entities_df.schema[resource_name]
        # final_value = target_dtype.cast(new_value) # Example casting

        success = gs.entity_registry.set_entity_component(
            target_id, resource_name, new_value
        )
        if success:
            log.debug(
                "Modified resource",
                target=target_id,
                resource=resource_name,
                change=change,
                new_value=new_value,
            )
            # Add message for player? (e.g., "You feel less hungry.", "Your mana regenerates.")
        else:
            log.error(
                "Failed to set new resource value",
                target=target_id,
                resource=resource_name,
            )
    except (TypeError, ValueError) as e:
        log.error(
            "Type/Value error during resource modification",
            target=target_id,
            resource=resource_name,
            current_val=current_value,
            change=change,
            error=str(e),
        )
    except Exception as e:
        log.error(
            "Error modifying resource",
            target=target_id,
            resource=resource_name,
            error=str(e),
            exc_info=True,
        )


def recall_ammo(context: Dict[str, Any], params: Dict[str, Any]):
    """Returns a projectile item to its owner's inventory."""
    gs: "GameState" = context.get("game_state")
    projectile_item_id = context.get("projectile_item_id")
    source_entity_id = context.get("source_entity_id")
    if not gs or projectile_item_id is None or source_entity_id is None:
        log.warning(
            "Recall ammo missing required context",
            item=projectile_item_id,
            owner=source_entity_id,
        )
        return

    item_active = gs.item_registry.get_item_component(projectile_item_id, "is_active")
    item_loc = gs.item_registry.get_item_component(projectile_item_id, "location_type")

    if not item_active or item_loc != "ground":
        log.debug(
            "Cannot recall ammo: not active or not on ground",
            item=projectile_item_id,
            loc=item_loc,
            active=item_active,
        )
        return

    success = gs.item_registry.move_item(
        item_id=projectile_item_id,
        new_location="inventory",
        owner_entity_id=source_entity_id,
    )
    if success:
        log.info(
            "Ammo recalled successfully",
            item=projectile_item_id,
            owner=source_entity_id,
        )
        if source_entity_id == gs.player_id:
            item_name = (
                gs.item_registry.get_item_component(projectile_item_id, "name")
                or "projectile"
            )
            gs.add_message(f"Your {item_name} mysteriously returns!", (150, 150, 255))
    else:
        log.error(
            "Failed to move recalled ammo to inventory",
            item=projectile_item_id,
            owner=source_entity_id,
        )


def apply_status(context: Dict[str, Any], params: Dict[str, Any]):
    """Applies a status effect to the target entity."""
    gs: "GameState" = context.get("game_state")
    target_id = context.get("target_entity_id", context.get("source_entity_id"))
    status_id = params.get("status")
    duration_dice = params.get("duration_dice")
    base_duration = params.get("base_duration", 1)
    intensity_dice = params.get("intensity_dice")
    base_intensity = params.get("base_intensity")  # Can be None
    rng: GameRNG | None = context.get("rng")

    if not gs or target_id is None or not status_id:
        log.warning(
            "ApplyStatus missing required info", target=target_id, status=status_id
        )
        return

    duration = base_duration + _roll_dice(duration_dice, rng)
    intensity = None
    if base_intensity is not None or intensity_dice:
        intensity_roll = _roll_dice(intensity_dice, rng)
        intensity = (base_intensity or 0) + intensity_roll
        # Ensure intensity is float if calculated
        intensity = float(intensity) if intensity is not None else None

    log.debug(
        "Applying status",
        target=target_id,
        status=status_id,
        dur=duration,
        intens=intensity,
    )

    current_statuses_list = gs.entity_registry.get_entity_component(
        target_id, "status_effects"
    )
    if current_statuses_list is None:
        log.error(
            "Target entity missing 'status_effects' component", target_id=target_id
        )
        return

    updated_statuses: List[Dict[str, Any]] = []
    found_existing = False

    for status_dict in current_statuses_list:
        if not isinstance(status_dict, dict):
            log.warning(
                "Skipping invalid status entry", entry=status_dict, target_id=target_id
            )
            continue

        if status_dict.get("id") == status_id:
            found_existing = True
            # Update logic: Max duration, replace intensity if new one provided & not None
            new_duration = max(status_dict.get("duration", 0), duration)
            new_intensity = (
                intensity if intensity is not None else status_dict.get("intensity")
            )

            updated_status = {"id": status_id, "duration": new_duration}
            if new_intensity is not None:
                updated_status["intensity"] = float(new_intensity)  # Ensure float

            updated_statuses.append(updated_status)
            log.debug(
                "Updated existing status",
                status_id=status_id,
                new_dur=new_duration,
                new_intens=new_intensity,
            )
        else:
            if "intensity" in status_dict and status_dict["intensity"] is not None:
                status_dict["intensity"] = float(status_dict["intensity"])
            updated_statuses.append(status_dict)

    if not found_existing:
        new_status = {"id": status_id, "duration": duration}
        if intensity is not None:
            new_status["intensity"] = float(intensity)
        updated_statuses.append(new_status)
        log.debug(
            "Added new status", status_id=status_id, dur=duration, intens=intensity
        )

    success = gs.entity_registry.set_entity_component(
        target_id, "status_effects", updated_statuses
    )
    if not success:
        log.error(
            "Failed to apply status effect component update",
            target_id=target_id,
            status_id=status_id,
        )
    else:
        # Add message? e.g., "The <target> starts burning!"
        target_name = (
            gs.entity_registry.get_entity_component(target_id, "name") or "Something"
        )
        # TODO: Check visibility
        if target_id == gs.player_id:
            gs.add_message(f"You feel {status_id}!", (255, 50, 50))  # Example color
        else:
            gs.add_message(
                f"The {target_name} is afflicted by {status_id}!", (200, 100, 100)
            )


# --- Implemented AOE ---
def apply_status_in_aoe(context: Dict[str, Any], params: Dict[str, Any]):
    """Applies a status effect to all valid targets within an AOE."""
    gs: "GameState" = context.get("game_state")
    center_pos = context.get("target_pos")
    radius = params.get("radius", 1)
    if not gs or center_pos is None or radius <= 0:
        log.warning(
            "ApplyStatusAOE missing context/params", center=center_pos, radius=radius
        )
        return

    log.debug("Applying status in AOE", center=center_pos, radius=radius, params=params)
    targets = _get_entities_in_aoe(center_pos, radius, gs)

    # Create a context copy for each target to avoid side-effects
    base_context = context.copy()
    for target_id in targets:
        target_context = base_context.copy()
        target_context["target_entity_id"] = target_id
        # Call the single-target apply_status handler
        apply_status(target_context, params)


# --- Implemented Damage ---
def deal_damage(context: Dict[str, Any], params: Dict[str, Any]):
    """Deals damage to a target entity."""
    gs: "GameState" = context.get("game_state")
    rng: GameRNG | None = context.get("rng")
    source_id = context.get("source_entity_id")  # Optional: for messages/XP
    target_id = context.get("target_entity_id")
    damage_type = params.get("damage_type", "physical")  # e.g., physical, fire, magic
    dice_str = params.get("dice")
    base_damage = params.get("base_damage", 0)

    if not gs or target_id is None or not rng:
        log.warning("DealDamage missing context", target=target_id, has_rng=bool(rng))
        return

    raw_damage = base_damage + _roll_dice(dice_str, rng)
    if raw_damage <= 0:
        log.debug("Damage calculated as zero or less", raw=raw_damage)
        return

    # TODO: Implement damage resistance/vulnerability checks based on damage_type
    # final_damage = calculate_final_damage(raw_damage, damage_type, target_id, gs)
    final_damage = raw_damage  # Placeholder

    current_hp = gs.entity_registry.get_entity_component(target_id, "hp")
    if current_hp is None:
        log.warning("DealDamage target missing HP component", target_id=target_id)
        return

    new_hp = max(0, current_hp - final_damage)  # Ensure HP doesn't go below 0
    amount_damaged = current_hp - new_hp

    if amount_damaged > 0:
        log.debug(
            "Applying damage",
            target=target_id,
            damage=amount_damaged,
            new_hp=new_hp,
            type=damage_type,
        )
        success = gs.entity_registry.set_entity_component(target_id, "hp", new_hp)
        if success:
            source_name = "Something"
            if source_id:
                source_name = (
                    gs.entity_registry.get_entity_component(source_id, "name")
                    or "Something"
                )
            target_name = (
                gs.entity_registry.get_entity_component(target_id, "name")
                or "Something"
            )
            # TODO: Check visibility
            if target_id == gs.player_id:
                gs.add_message(
                    f"The {source_name} hits you for {amount_damaged} damage!",
                    (255, 0, 0),
                )
            elif source_id == gs.player_id:
                gs.add_message(
                    f"You hit the {target_name} for {amount_damaged} damage!",
                    (0, 255, 0),
                )
            else:  # Mob vs Mob
                gs.add_message(
                    f"The {source_name} hits the {target_name} for {amount_damaged}.",
                    (200, 200, 0),
                )

            # --- Handle Death ---
            if new_hp <= 0:
                log.info(
                    "Entity died", target_id=target_id, name=target_name, hp=new_hp
                )
                # TODO: Check visibility
                gs.add_message(f"The {target_name} dies!", (255, 100, 100))
                # Handle death: drop items, remove from map, etc.
                # For now, just mark as inactive
                gs.entity_registry.delete_entity(target_id)
                # Maybe add 'target_is_living': False to context for trigger checks?
                context["target_is_living"] = (
                    False  # Update context for subsequent effects in chain
                )
        else:
            log.error("Failed to set new HP for damage target", target_id=target_id)


# --- Implemented AOE Damage ---
def deal_damage_in_aoe(context: Dict[str, Any], params: Dict[str, Any]):
    """Deals damage to all valid targets within an AOE."""
    gs: "GameState" = context.get("game_state")
    center_pos = context.get("target_pos")
    radius = params.get("radius", 1)
    source_id = context.get("source_entity_id")  # Pass source for damage messages

    if not gs or center_pos is None or radius <= 0:
        log.warning(
            "DealDamageAOE missing context/params", center=center_pos, radius=radius
        )
        return

    log.debug("Dealing damage in AOE", center=center_pos, radius=radius, params=params)
    targets = _get_entities_in_aoe(center_pos, radius, gs)

    # Create a context copy for each target
    base_context = context.copy()
    for target_id in targets:
        # Don't hit self unless explicitly allowed? (Assume no self-hit for now)
        if source_id is not None and target_id == source_id:
            continue

        target_context = base_context.copy()
        target_context["target_entity_id"] = target_id
        # Call the single-target deal_damage handler
        deal_damage(target_context, params)


# --- Implemented Dig Tunnel (minor refinement) ---
def dig_tunnel(context: Dict[str, Any], params: Dict[str, Any]):
    gs: "GameState" = context.get("game_state")
    source_entity_id = context.get("source_entity_id")
    direction = context.get("target_direction")
    if not gs or source_entity_id is None or direction is None:
        log.warning("DigTunnel missing context")
        return

    # Import locally only if needed? Or assume pre-imported TILE_IDs
    try:
        from ..game.world.game_map import TILE_ID_FLOOR, TILE_ID_WALL
    except ImportError:
        log.error("Could not import TILE_ID constants for digging.")
        return

    start_pos = gs.entity_registry.get_position(source_entity_id)
    if not start_pos:
        log.warning("Dig source entity has no position")
        return

    length = params.get("tunnel_length", 1)
    cx, cy = start_pos
    dx, dy = direction
    log.debug("Executing Dig Tunnel", start=start_pos, dir=direction, len=length)
    map_changed = False
    source_height_val = (
        gs.game_map.height_map[cy, cx] if gs.game_map.in_bounds(cx, cy) else 0
    )
    source_height = int(source_height_val)

    for i in range(1, length + 1):
        nx, ny = cx + dx * i, cy + dy * i
        if not gs.game_map.in_bounds(nx, ny):
            log.debug("Dig hit map boundary", pos=(nx, ny))
            break
        current_tile = gs.game_map.tiles[ny, nx]
        if current_tile == TILE_ID_WALL:
            gs.game_map.tiles[ny, nx] = TILE_ID_FLOOR
            # Set height/ceiling reasonably based on source
            gs.game_map.height_map[ny, nx] = source_height
            gs.game_map.ceiling_map[ny, nx] = source_height + 6  # Example ceiling
            log.debug("Dug wall", pos=(nx, ny))
            map_changed = True
        else:
            log.debug("Dig stopped by non-wall tile", pos=(nx, ny), tile=current_tile)
            break
    if map_changed:
        gs.game_map.update_tile_transparency()  # Crucial after changing tiles


# --- Implemented Spawning (Placeholders for templates) ---
def create_portal(context: Dict[str, Any], params: Dict[str, Any]):
    """Creates a portal entity at the target location."""
    gs: "GameState" = context.get("game_state")
    target_pos = context.get("target_pos")
    portal_template_id = params.get(
        "portal_template", "default_portal"
    )  # Needs definition
    linked_pos_param = params.get(
        "linked_position"
    )  # e.g., [10, 15] or target map name

    if not gs or target_pos is None:
        log.warning("CreatePortal missing context", pos=target_pos)
        return

    # --- Placeholder: Assume a simple portal entity ---
    portal_glyph = params.get("glyph", 62)  # '>'
    portal_color = params.get("color", (255, 0, 255))  # Magenta
    portal_name = params.get("name", "Portal")
    blocks = params.get("blocks_movement", False)
    # --- End Placeholder ---

    log.info(
        "Creating portal",
        template=portal_template_id,
        pos=target_pos,
        link=linked_pos_param,
    )
    # TODO: Add actual template lookup here
    # template_data = gs.entity_templates.get(portal_template_id)

    # Check if tile is blocked
    if not gs.game_map.is_walkable(target_pos[0], target_pos[1]):
        log.warning("Cannot create portal: location not walkable", pos=target_pos)
        return
    if gs.entity_registry.get_blocking_entity_at(target_pos[0], target_pos[1]):
        log.warning("Cannot create portal: location blocked by entity", pos=target_pos)
        return

    new_id = gs.entity_registry.create_entity(
        x=target_pos[0],
        y=target_pos[1],
        glyph=portal_glyph,
        color_fg=portal_color,
        name=portal_name,
        blocks_movement=blocks,
        hp=1,
        max_hp=1,  # Portals likely indestructible by HP
    )
    if new_id is not None:
        log.info("Portal entity created", entity_id=new_id, pos=target_pos)
        # TODO: Set portal-specific components (e.g., linked_pos, target_map) using set_entity_component
        # Requires adding these components to ENTITY_SCHEMA
        # gs.entity_registry.set_entity_component(new_id, "linked_position", linked_pos_param)
    else:
        log.error("Failed to create portal entity", pos=target_pos)


def attempt_spawn_entity(context: Dict[str, Any], params: Dict[str, Any]):
    """Attempts to spawn a specified entity at the target location based on chance."""
    gs: "GameState" = context.get("game_state")
    rng: GameRNG | None = context.get("rng")
    target_pos = context.get("target_pos")
    chance = params.get("chance", 100)
    entity_template_id = params.get("entity_template")  # ID string, e.g., "goblin"

    if not gs or target_pos is None or not entity_template_id or not rng:
        log.warning(
            "AttemptSpawn missing context",
            pos=target_pos,
            template=entity_template_id,
            has_rng=bool(rng),
        )
        return

    roll = rng.get_int(1, 100)
    if roll > chance:
        log.debug("AttemptSpawn failed chance roll", chance=chance, roll=roll)
        return

    # --- Placeholder: Assume simple templates ---
    # TODO: Replace with actual lookup from loaded entity templates (requires new config file/loader)
    templates = {
        "goblin": {"glyph": ord("g"), "color": (0, 128, 0), "hp": 10, "name": "Goblin"},
        "orc": {"glyph": ord("O"), "color": (0, 255, 0), "hp": 25, "name": "Orc"},
        "rat": {
            "glyph": ord("r"),
            "color": (128, 128, 128),
            "hp": 5,
            "name": "Giant Rat",
        },
    }
    template_data = templates.get(entity_template_id)
    if not template_data:
        log.error(
            "AttemptSpawn failed: Unknown entity template ID",
            template=entity_template_id,
        )
        return
    # --- End Placeholder ---

    log.info("Attempting to spawn entity", template=entity_template_id, pos=target_pos)

    # Check if tile is blocked
    if not gs.game_map.is_walkable(target_pos[0], target_pos[1]):
        log.debug("Cannot spawn entity: location not walkable", pos=target_pos)
        return
    if gs.entity_registry.get_blocking_entity_at(target_pos[0], target_pos[1]):
        log.debug("Cannot spawn entity: location blocked by entity", pos=target_pos)
        return

    # Create the entity using data from the (placeholder) template
    new_id = gs.entity_registry.create_entity(
        x=target_pos[0],
        y=target_pos[1],
        glyph=template_data["glyph"],
        color_fg=template_data["color"],
        name=template_data["name"],
        blocks_movement=True,  # Assume most spawned entities block
        hp=template_data["hp"],
        max_hp=template_data["hp"],
    )
    if new_id is not None:
        log.info(
            "Entity spawned successfully",
            entity_id=new_id,
            template=entity_template_id,
            pos=target_pos,
        )
        # Add message? "A goblin appears!"
    else:
        log.error("Failed to spawn entity", template=entity_template_id, pos=target_pos)


# --- Handler Registry (no changes needed here) ---
EFFECT_LOGIC_HANDLERS: Dict[str, callable] = {
    "heal_target": heal_target,
    "modify_resource": modify_resource,
    "recall_ammo": recall_ammo,
    "apply_status": apply_status,
    "apply_status_in_aoe": apply_status_in_aoe,
    "deal_damage": deal_damage,
    "deal_damage_in_aoe": deal_damage_in_aoe,
    "dig_tunnel": dig_tunnel,
    "create_portal": create_portal,
    "attempt_spawn_entity": attempt_spawn_entity,
}

```

`basicrl/game/entities/registry.py`:

```py
# game/entities/registry.py
from typing import Any, Dict, List, Self

import polars as pl
import structlog

try:
    from game.items.registry import BodySlotType, EquipSlot
except ImportError:
    log = structlog.get_logger()
    log.error(
        "CRITICAL: Could not import EquipSlot/BodySlotType from game.items.registry."
    )
    EquipSlot = Any
    BodySlotType = Any

log = structlog.get_logger()

# ENTITY_SCHEMA (Unchanged)
ENTITY_SCHEMA: dict[str, pl.DataType] = {
    "entity_id": pl.UInt32,
    "is_active": pl.Boolean,
    "x": pl.Int16,
    "y": pl.Int16,
    "glyph": pl.UInt16,
    "color_fg_r": pl.UInt8,
    "color_fg_g": pl.UInt8,
    "color_fg_b": pl.UInt8,
    "name": pl.Utf8,
    "blocks_movement": pl.Boolean,
    "hp": pl.Int16,
    "max_hp": pl.Int16,
    "inventory_capacity": pl.UInt16,
    "status_effects": pl.List(
        pl.Struct({"id": pl.Utf8, "duration": pl.Int16, "intensity": pl.Float32})
    ),
    "mana": pl.Float32,
    "max_mana": pl.Float32,
    "fullness": pl.Float32,
    "max_fullness": pl.Float32,
    "equipped_item_ids": pl.List(pl.UInt64),
    "body_plan": pl.Object,
}


class EntityRegistry:
    def __init__(self: Self):
        # (Initialization unchanged)
        log.info("Initializing EntityRegistry with body_plan schema")
        global ENTITY_SCHEMA
        if "equipped_item_ids" in ENTITY_SCHEMA and not isinstance(
            ENTITY_SCHEMA["equipped_item_ids"], pl.List
        ):
            log.warning("Correcting equipped_item_ids dtype in ENTITY_SCHEMA")
            ENTITY_SCHEMA["equipped_item_ids"] = pl.List(pl.UInt64)
        if "status_effects" in ENTITY_SCHEMA and not isinstance(
            ENTITY_SCHEMA["status_effects"], pl.List
        ):
            log.warning("Correcting status_effects dtype in ENTITY_SCHEMA")
            ENTITY_SCHEMA["status_effects"] = pl.List(
                pl.Struct(
                    {"id": pl.Utf8, "duration": pl.Int16, "intensity": pl.Float32}
                )
            )
        self.entities_df: pl.DataFrame = pl.DataFrame(schema=ENTITY_SCHEMA)
        self._next_entity_id: int = 0
        log.debug("EntityRegistry initialized", schema=list(ENTITY_SCHEMA.keys()))

    def _get_next_id(self: Self) -> int:
        # (Implementation unchanged)
        current_id = self._next_entity_id
        self._next_entity_id += 1
        if self._next_entity_id > 2**32 - 1:
            log.critical("Entity ID counter overflowed", next_id=self._next_entity_id)
            raise OverflowError("Entity ID counter overflowed (UInt32 limit reached).")
        return current_id

    def create_entity(
        self: Self,
        x: int,
        y: int,
        glyph: int,
        color_fg: tuple[int, int, int],
        name: str,
        blocks_movement: bool = True,
        hp: int = 1,
        max_hp: int = 1,
        inventory_capacity: int = 26,
        mana: float = 0.0,
        max_mana: float = 0.0,
        fullness: float = 100.0,
        max_fullness: float = 100.0,
        status_effects: list | None = None,
        initial_body_plan: Dict[str, int] | None = None,
    ) -> int:
        # (Implementation unchanged - uses direct schema on creation)
        new_id = self._get_next_id()
        log_context = {"name": name, "pos": (x, y), "glyph": glyph, "hp": hp}
        log.debug("Attempting to create entity", **log_context)
        default_body_plan = {
            "finger": 10,
            "hand": 2,
            "wrist": 2,
            "head": 1,
            "face": 1,
            "eyes": 1,
            "neck": 2,
            "upper_body_inner": 1,
            "upper_body_outer": 1,
            "lower_body_inner": 1,
            "lower_body_outer": 1,
            "feet": 2,
            "back": 1,
            "belt": 1,
        }
        body_plan = default_body_plan.copy()
        if initial_body_plan:
            if BodySlotType is Any:
                validated_initial = initial_body_plan
            else:
                try:
                    valid_keys = BodySlotType.__args__
                    validated_initial = {
                        k: v for k, v in initial_body_plan.items() if k in valid_keys
                    }
                    if len(validated_initial) != len(initial_body_plan):
                        log.warning(
                            "Invalid keys found in initial_body_plan, ignored.",
                            invalid_keys=set(initial_body_plan.keys())
                            - set(valid_keys),
                        )
                except AttributeError:
                    log.warning(
                        "BodySlotType definition not available, cannot validate initial_body_plan keys."
                    )
                    validated_initial = initial_body_plan
            body_plan.update(validated_initial)

        entity_data = {
            "entity_id": [new_id],
            "is_active": [True],
            "x": [x],
            "y": [y],
            "glyph": [glyph],
            "color_fg_r": [color_fg[0]],
            "color_fg_g": [color_fg[1]],
            "color_fg_b": [color_fg[2]],
            "name": [name],
            "blocks_movement": [blocks_movement],
            "hp": [hp],
            "max_hp": [max_hp],
            "inventory_capacity": [inventory_capacity],
            "status_effects": [status_effects if status_effects is not None else []],
            "mana": [mana],
            "max_mana": [max_mana],
            "fullness": [fullness],
            "max_fullness": [max_fullness],
            "equipped_item_ids": [[]],
            "body_plan": [body_plan],
        }
        try:
            new_entity_df = pl.DataFrame(entity_data, schema=ENTITY_SCHEMA)
            if self.entities_df.height == 0:
                self.entities_df = new_entity_df
            else:
                self.entities_df = pl.concat(
                    [self.entities_df, new_entity_df.select(self.entities_df.columns)],
                    how="vertical",
                )
            log.info("Entity created successfully", entity_id=new_id, **log_context)
            return new_id
        except Exception as e:
            log.error(
                "Failed to create entity DataFrame or append",
                error=str(e),
                exc_info=True,
                entity_data=entity_data,
            )
            raise

    def get_entity_component(
        self: Self, entity_id: int, component_name: str
    ) -> Any | None:
        """Retrieves the value of a specific component for a given *active* entity."""
        log_context = {"entity_id": entity_id, "component": component_name}
        if component_name not in self.entities_df.columns:
            log.warning("Component does not exist", **log_context)
            raise ValueError(
                f"Component '{component_name}' does not exist in ENTITY_SCHEMA."
            )

        try:
            # Filter first
            entity_df = self.entities_df.filter(
                (pl.col("entity_id") == entity_id) & pl.col("is_active")
            )

            if entity_df.height == 0:
                return None

            # Select the single column *after* filtering
            result_series = entity_df.select(component_name)[
                component_name
            ]  # Select column Series

            if (
                result_series.is_empty()
            ):  # Should not happen if height > 0, but safety check
                return None

            # --- MODIFICATION START ---
            # Check the target data type from the schema
            target_dtype = ENTITY_SCHEMA[component_name]

            # Extract value, handling List types specifically
            if isinstance(target_dtype, pl.List):
                # For list types, accessing the first element of the Series
                # and then converting to list should yield the Python list.
                # Polars Series.item() often returns the first element directly.
                list_value = result_series.item()  # Get the list element
                # Ensure it's actually a list (it should be if schema is correct)
                return (
                    list_value if isinstance(list_value, list) else []
                )  # Return empty list if type mismatch
            else:
                # For other types, .item() should return the scalar value
                return result_series.item()
            # --- MODIFICATION END ---

        except Exception as e:
            log.error(
                "Error getting entity component",
                error=str(e),
                exc_info=True,
                **log_context,
            )
            return None

    def set_entity_component(
        self: Self, entity_id: int, component_name: str, value: Any
    ) -> bool:
        # (Implementation unchanged)
        log_context = {
            "entity_id": entity_id,
            "component": component_name,
            "new_value": value,
        }
        if component_name not in self.entities_df.columns:
            log.warning("Component does not exist", **log_context)
            raise ValueError(
                f"Component '{component_name}' does not exist in ENTITY_SCHEMA."
            )
        if component_name in ("entity_id", "is_active"):
            log.warning("Attempted to set protected component", **log_context)
            raise ValueError(f"Cannot directly set '{component_name}' component.")
        try:
            target_dtype = ENTITY_SCHEMA[component_name]
            try:
                if target_dtype == pl.Object and not isinstance(
                    value, (dict, list, type(None))
                ):
                    log.warning(
                        f"Potentially incompatible type for Object column '{component_name}'",
                        type=type(value),
                        **log_context,
                    )
                lit_value = pl.lit(value).cast(target_dtype, strict=False)
            except Exception as cast_err:
                log.error(
                    f"Type error setting component '{component_name}'. Expected compatible with {target_dtype}.",
                    value_type=type(value),
                    error=cast_err,
                    **log_context,
                )
                return False
            entity_active = (
                self.entities_df.lazy()
                .filter((pl.col("entity_id") == entity_id) & pl.col("is_active"))
                .select(pl.lit(1))
                .head(1)
                .collect()
                .height
                > 0
            )
            if not entity_active:
                log.debug(
                    "Entity not found or inactive, cannot set component", **log_context
                )
                return False
            self.entities_df = self.entities_df.with_columns(
                pl.when((pl.col("entity_id") == entity_id) & pl.col("is_active"))
                .then(lit_value)
                .otherwise(pl.col(component_name))
                .alias(component_name)
                .cast(target_dtype, strict=False)
            )
            return True
        except Exception as e:
            log.error(
                "Error setting entity component",
                error=str(e),
                exc_info=True,
                **log_context,
            )
            return False

    def get_position(self: Self, entity_id: int) -> tuple[int, int] | None:
        # (Implementation unchanged)
        pos_x = self.get_entity_component(entity_id, "x")
        pos_y = self.get_entity_component(entity_id, "y")
        if pos_x is not None and pos_y is not None:
            return int(pos_x), int(pos_y)
        return None

    def set_position(self: Self, entity_id: int, x: int, y: int) -> bool:
        # (Implementation unchanged)
        success_x = self.set_entity_component(entity_id, "x", x)
        success_y = self.set_entity_component(entity_id, "y", y)
        return success_x and success_y

    def get_entities_at(self: Self, x: int, y: int) -> pl.DataFrame:
        # (Implementation unchanged)
        try:
            return (
                self.entities_df.lazy()
                .filter((pl.col("x") == x) & (pl.col("y") == y) & pl.col("is_active"))
                .collect()
            )
        except Exception as e:
            log.error(
                "Error getting entities at position",
                error=str(e),
                exc_info=True,
                pos=(x, y),
            )
            return pl.DataFrame(schema=ENTITY_SCHEMA)

    def get_blocking_entity_at(self: Self, x: int, y: int) -> int | None:
        # (Implementation unchanged)
        try:
            result = (
                self.entities_df.lazy()
                .filter(
                    (pl.col("x") == x)
                    & (pl.col("y") == y)
                    & pl.col("blocks_movement")
                    & pl.col("is_active")
                )
                .select("entity_id")
                .head(1)
                .collect()
            )
            if result.height > 0:
                return result.item()
            return None
        except Exception as e:
            log.error(
                "Error getting blocking entity", error=str(e), exc_info=True, pos=(x, y)
            )
            return None

    def delete_entity(self: Self, entity_id: int) -> bool:
        # (Implementation unchanged)
        log_context = {"entity_id": entity_id}
        log.debug("Deleting entity (marking inactive)", **log_context)
        try:
            entity_active_mask = (pl.col("entity_id") == entity_id) & pl.col(
                "is_active"
            )
            if self.entities_df.filter(entity_active_mask).height == 0:
                log.debug("Entity already inactive or does not exist", **log_context)
                return False
            self.entities_df = self.entities_df.with_columns(
                pl.when(entity_active_mask)
                .then(pl.lit(False))
                .otherwise(pl.col("is_active"))
                .alias("is_active")
            )
            log.info("Entity marked as inactive", **log_context)
            return True
        except Exception as e:
            log.error(
                "Error deleting entity (marking inactive)",
                error=str(e),
                exc_info=True,
                **log_context,
            )
            return False

    def compact_registry(self: Self) -> None:
        # (Implementation unchanged)
        log.info("Compacting entity registry...")
        try:
            initial_count = self.entities_df.height
            self.entities_df = self.entities_df.filter(pl.col("is_active"))
            final_count = self.entities_df.height
            removed_count = initial_count - final_count
            log.info(
                "Registry compacted",
                initial_count=initial_count,
                final_count=final_count,
                removed_count=removed_count,
            )
        except Exception as e:
            log.error("Error compacting registry", error=str(e), exc_info=True)

    def get_active_entities(self: Self) -> pl.DataFrame:
        # (Implementation unchanged)
        try:
            return self.entities_df.filter(pl.col("is_active"))
        except Exception as e:
            log.error("Error getting active entities", error=str(e), exc_info=True)
            return pl.DataFrame(schema=ENTITY_SCHEMA)

    def get_body_plan(self, entity_id: int) -> Dict[str, int] | None:
        # (Implementation unchanged)
        plan = self.get_entity_component(entity_id, "body_plan")
        return plan if isinstance(plan, dict) else None

    def set_body_plan(self, entity_id: int, body_plan: Dict[str, int]) -> bool:
        # (Implementation unchanged)
        if not isinstance(body_plan, dict):
            log.error(
                "Invalid body_plan type provided to set_body_plan",
                entity_id=entity_id,
                type=type(body_plan),
            )
            return False
        return self.set_entity_component(entity_id, "body_plan", body_plan)

    def get_equipped_ids(self, entity_id: int) -> List[int] | None:
        """Gets the list of directly equipped item IDs for an active entity."""
        ids = self.get_entity_component(entity_id, "equipped_item_ids")
        # --- REMOVED Series check ---
        # The get_entity_component method should now handle returning a list directly.
        # Ensure a list is returned (or None if component retrieval failed)
        return ids if isinstance(ids, list) else None  # Return None if not a list

    def set_equipped_ids(self, entity_id: int, equipped_ids: List[int]) -> bool:
        # (Implementation unchanged)
        if not isinstance(equipped_ids, list):
            log.error(
                "Invalid equipped_ids type provided to set_equipped_ids",
                entity_id=entity_id,
                type=type(equipped_ids),
            )
            return False
        return self.set_entity_component(entity_id, "equipped_item_ids", equipped_ids)

```

`basicrl/game/game_state.py`:

```py
# game/game_state.py
from typing import Any, Dict, Literal, Tuple, Union  # Added Literal

import structlog
from game_rng import GameRNG  # Assuming this path is correct

from game.entities.registry import EntityRegistry
from game.items.registry import ItemRegistry

# Assuming these imports are correct relative to game_state.py
from game.world.game_map import GameMap

log = structlog.get_logger()


class GameState:
    def __init__(
        self,
        existing_map: GameMap,
        player_start_pos: Tuple[int, int],
        # Config values passed directly
        player_glyph: int,
        player_start_hp: int,
        player_fov_radius: int,
        item_templates: Dict[str, Any],
        effect_definitions: Dict[str, Any],
        rng_seed: int | None,
    ):
        log.info("Initializing GameState...")

        if not isinstance(existing_map, GameMap):
            raise TypeError("GameState requires a valid GameMap instance.")
        if not player_start_pos or len(player_start_pos) != 2:
            raise ValueError(
                "GameState requires a valid player_start_pos tuple (x, y)."
            )

        self.game_map: GameMap = existing_map
        self._map_width: int = existing_map.width
        self._map_height: int = existing_map.height

        self.rng_instance: GameRNG = GameRNG(seed=rng_seed)
        log.debug("GameRNG initialized", seed=self.rng_instance.initial_seed)

        self.entity_registry: EntityRegistry = EntityRegistry()
        log.debug("EntityRegistry initialized")

        self.item_registry: ItemRegistry = ItemRegistry(item_templates)
        self.effect_definitions: Dict[str, Any] = effect_definitions
        log.debug("ItemRegistry initialized", templates=len(item_templates))
        log.debug("Effect definitions stored", effects=len(effect_definitions))

        player_start_x, player_start_y = player_start_pos
        # Ensure all necessary components are passed during creation if defaults changed
        self.player_id: int = self.entity_registry.create_entity(
            x=player_start_x,
            y=player_start_y,
            glyph=player_glyph,
            color_fg=(255, 255, 255),
            name="Player",
            blocks_movement=True,
            hp=player_start_hp,
            max_hp=player_start_hp,
            # Add defaults for mana/fullness etc. if needed by registry init
        )
        log.debug(
            "Player entity created",
            player_id=self.player_id,
            pos=(player_start_x, player_start_y),
            hp=player_start_hp,
            glyph=player_glyph,
        )

        self.fov_radius = player_fov_radius
        self.message_log: list[tuple[str, tuple[int, int, int]]] = []
        self.turn_count: int = 0

        # --- NEW: UI State ---
        self.ui_state: Literal["PLAYER_TURN", "INVENTORY_VIEW", "TARGETING"] = (
            "PLAYER_TURN"
        )
        # --- End NEW ---

        self.add_message("Welcome to BasicRL!", (0, 255, 0))

        log.info(
            "Game state initialized",
            map_size=f"{self._map_width}x{self._map_height}",
            player_id=self.player_id,
            item_templates_loaded=len(item_templates),
            effect_definitions_loaded=len(effect_definitions),
            rng_seed=self.rng_instance.initial_seed,
        )

        self.update_fov()  # Initial FOV calculation

    def update_fov(self) -> None:
        """Calculates Field of View based on player position."""
        player_pos = self.player_position
        if player_pos:
            px, py = player_pos
            if not self.game_map.in_bounds(px, py):
                log.warning("Player out of bounds, cannot compute FOV.", pos=(px, py))
                self.game_map.visible[:] = False  # Clear visibility if player is OOB
                return
            # Ensure origin height is passed correctly
            origin_height = int(self.game_map.height_map[py, px])
            self.game_map.compute_fov(
                px, py, self.fov_radius
            )  # compute_fov now handles explored
            # Post-check: Ensure origin is always visible if FOV somehow clears it
            if not self.game_map.visible[py, px]:
                log.warning(
                    "Origin tile became non-visible after FOV calculation, forcing visible.",
                    pos=(px, py),
                )
                self.game_map.visible[py, px] = True
                self.game_map.explored[py, px] = True  # Ensure explored too
        else:
            log.warning("Cannot update FOV: Player position not found.")
            self.game_map.visible[:] = False  # Clear visibility if no player

    @property
    def map_width(self) -> int:
        return self._map_width

    @property
    def map_height(self) -> int:
        return self._map_height

    @property
    def player_position(self) -> Union[Tuple[int, int], None]:
        """Gets the current player position from the EntityRegistry."""
        return self.entity_registry.get_position(self.player_id)

    def add_message(
        self, text: str, color: tuple[int, int, int] = (255, 255, 255)
    ) -> None:
        """Adds a message to the game log."""
        self.message_log.append((text, color))
        log.debug("Message added", message=text, color=color)
        # Optional: Trim log length if it gets too long
        # MAX_LOG_LENGTH = 100
        # if len(self.message_log) > MAX_LOG_LENGTH:
        #     self.message_log = self.message_log[-MAX_LOG_LENGTH:]

    def advance_turn(self) -> None:
        """Advances the game turn counter and performs turn-based updates."""
        self.turn_count += 1
        log.debug("Turn advanced", turn=self.turn_count)

        # --- TODO: Status Effect Duration Update ---
        # Iterate through active entities, get status_effects list, decrement durations,
        # filter expired effects, update component using set_entity_component.

        # --- TODO: AI processing call ---
        # e.g., process_all_mob_ai(self.entity_registry.entities_df, world_map_data, global_state)
        # This requires defining what constitutes world_map_data and global_state.

        # --- TODO: Other turn-based updates ---
        # (e.g., hunger increase, light source fuel consumption)

    # --- NEW: State transition helper ---
    def change_ui_state(
        self, new_state: Literal["PLAYER_TURN", "INVENTORY_VIEW", "TARGETING"]
    ):
        # Basic state change, could add validation or hooks later
        if self.ui_state != new_state:
            log.debug(f"Changing UI state from {self.ui_state} to {new_state}")
            self.ui_state = new_state
        else:
            log.debug(f"UI state already {new_state}, no change.")

    # --- End NEW ---

```

`basicrl/game/items/registry.py`:

```py
# game/items/registry.py
from typing import Any, Dict, Literal, Self, cast

import polars as pl
import structlog

log = structlog.get_logger()

# --- Expanded EquipSlot Definition ---
# Specific slots for ITEM definitions (where an item CAN go)
EquipSlot = Literal[
    "upper_body_inner",
    "upper_body_outer",
    "lower_body_inner",
    "lower_body_outer",
    "head",
    "face",
    "eyes",
    "feet",
    "wrists",
    "main_hand",
    "off_hand",
    "finger_0",
    "finger_1",
    "finger_2",
    "finger_3",
    "finger_4",
    "finger_5",
    "finger_6",
    "finger_7",
    "finger_8",
    "finger_9",
    "neck_1",
    "neck_2",
    "belt",
    "back",
    # "held_light", # REMOVED
    "generic_attachment_point",  # Example
]
# --- End Expanded Definition ---

# General types used in ENTITY body_plan
BodySlotType = Literal[
    "upper_body_inner",
    "upper_body_outer",
    "lower_body_inner",
    "lower_body_outer",
    "head",
    "face",
    "eyes",
    "feet",
    "wrist",
    "hand",
    "finger",
    "neck",
    "belt",
    "back",
]

ItemLocation = Literal[
    "ground", "inventory", "equipped", "attached"
]  # Added "attached"

# Define the schema for the item DataFrame
ITEM_SCHEMA: dict[str, pl.DataType] = {
    "item_id": pl.UInt64,
    "is_active": pl.Boolean,
    "template_id": pl.Enum([]),  # Categories added in __init__
    "name": pl.Utf8,
    "glyph": pl.UInt16,
    "color_fg_r": pl.UInt8,
    "color_fg_g": pl.UInt8,
    "color_fg_b": pl.UInt8,
    # --- Location and Ownership ---
    "location_type": pl.Enum(ItemLocation.__args__),
    "owner_entity_id": pl.UInt32,  # Nullable. ID of entity holding in inv/equipped DIRECTLY
    "x": pl.Int16,  # Nullable
    "y": pl.Int16,  # Nullable
    # --- Equip/Attach State ---
    "equipped_slot": pl.Enum(
        list(EquipSlot.__args__)
    ),  # Nullable. Stores the SPECIFIC slot used (e.g. finger_3, neck_1) when location="equipped"
    # -- Mount Points (on Host Item) --
    # List[Dict{'id': str, 'compatible_types': List[str], 'accepted_item_id': int | None, 'flags': List[str]}]
    "mount_points": pl.Object,  # Nullable
    # -- Attachable Info (on Attachable Item) --
    # Dict{'compatible_mount_types': List[str], 'flags_required': List[str]}
    "attachable_info": pl.Object,  # Nullable
    # -- Attachment Link (on Attached Item) --
    "parent_attachment_item_id": pl.UInt64,  # Nullable. ID of the item it's attached TO
    "parent_attachment_slot_id": pl.Utf8,  # Nullable. 'id' of the mount point used on parent
    # -- Other Components --
    "quantity": pl.UInt16,
    "current_charge": pl.Int16,  # Nullable
    "current_fuel": pl.Int16,  # Nullable. Example for lanterns
    "current_poison_doses": pl.UInt8,  # Nullable. Example
    "current_durability": pl.Float32,  # Nullable
    "is_identified": pl.Boolean,
    "is_cursed": pl.Boolean,
    "magic_detected": pl.Boolean,
}


class ItemRegistry:
    def __init__(self: Self, item_templates: Dict[str, dict]):
        log.info("Initializing ItemRegistry with expanded schema")
        self.item_templates: Dict[str, dict] = item_templates

        schema_copy = ITEM_SCHEMA.copy()
        known_template_ids = list(item_templates.keys())
        if known_template_ids:
            schema_copy["template_id"] = pl.Enum(known_template_ids)
            log.debug(
                "ItemRegistry schema updated: template_id Enum",
                count=len(known_template_ids),
            )
        else:
            log.warning("ItemRegistry: No item templates provided for Enum.")

        # Add Enum categories for location_type and equipped_slot based on Literals
        schema_copy["location_type"] = pl.Enum(ItemLocation.__args__)
        schema_copy["equipped_slot"] = pl.Enum(
            list(EquipSlot.__args__)
        )  # Use list() for Enum

        try:
            # Initialize with the corrected schema
            self.items_df: pl.DataFrame = pl.DataFrame(schema=schema_copy)
        except Exception as e:
            log.error(
                "Failed to initialize ItemRegistry DataFrame",
                error=str(e),
                exc_info=True,
            )
            self.items_df = pl.DataFrame()  # Fallback

        self._next_item_id: int = 0
        log.debug("ItemRegistry initialized", templates_loaded=len(item_templates))

    def _get_next_id(self: Self) -> int:
        """Generates the next available unique item ID."""
        current_id = self._next_item_id
        self._next_item_id += 1
        if self._next_item_id > 2**64 - 1:
            log.critical("Item ID counter overflowed (UInt64 limit reached).")
            raise OverflowError("Item ID counter overflowed.")
        return current_id

    def create_item(
        self: Self,
        template_id: str,
        location: ItemLocation = "ground",
        owner_entity_id: int | None = None,
        x: int | None = None,
        y: int | None = None,
        equipped_slot: EquipSlot | None = None,  # Specific slot for 'equipped'
        quantity: int = 1,
        parent_attachment_item_id: int | None = None,  # For 'attached'
        parent_attachment_slot_id: str | None = None,  # For 'attached'
    ) -> int | None:
        """Creates a new item instance from a template. Includes attachment info."""
        template = self.item_templates.get(template_id)
        if not template:
            log.warning("Unknown item template", template_id=template_id)
            return None

        new_id = self._get_next_id()
        log_context = {"template": template_id, "item_id": new_id, "location": location}

        # --- Validation Logic ---
        if location == "ground" and (x is None or y is None):
            log.error("Ground item created without coordinates", **log_context)
            return None
        if location in ("inventory", "equipped") and owner_entity_id is None:
            log.error(f"{location} item created without owner_entity_id", **log_context)
            return None
        if location == "equipped" and equipped_slot is None:
            log.error("Equipped item created without equipped_slot", **log_context)
            return None
        if location == "attached" and (
            parent_attachment_item_id is None or parent_attachment_slot_id is None
        ):
            log.error(
                "Attached item created without parent_item_id or parent_slot_id",
                **log_context,
            )
            return None
        # --- End Validation ---

        # --- Clear conflicting location info ---
        if location != "ground":
            x, y = None, None
        if location != "equipped":
            equipped_slot = None
        if location != "attached":
            parent_attachment_item_id, parent_attachment_slot_id = None, None
        if location == "attached":
            owner_entity_id, equipped_slot = None, None
        if location in ("inventory", "equipped"):
            parent_attachment_item_id, parent_attachment_slot_id = None, None
        # --- End Clear ---

        attributes = template.get("attributes", {})
        color = template.get("color_fg", [255, 0, 255])

        template_mount_points = attributes.get("mount_points")
        template_attachable_info = attributes.get("attachable_info")

        item_data = {
            "item_id": new_id,
            "is_active": True,
            "name": template.get("name", template_id),
            "glyph": template.get("glyph", 63),
            "color_fg_r": color[0],
            "color_fg_g": color[1],
            "color_fg_b": color[2],
            "location_type": location,
            "owner_entity_id": owner_entity_id,
            "x": x,
            "y": y,
            "equipped_slot": equipped_slot,
            "quantity": max(1, quantity),
            "current_charge": attributes.get("max_charge"),
            "current_fuel": attributes.get("max_fuel"),
            "current_poison_doses": attributes.get("max_poison_doses"),
            "current_durability": attributes.get("max_durability"),
            "is_identified": False,
            "is_cursed": False,
            "magic_detected": False,
            "mount_points": (
                [
                    {**mp, "accepted_item_id": None}
                    for mp in template_mount_points
                    if isinstance(mp, dict)
                ]
                if isinstance(template_mount_points, list)
                else None
            ),
            "attachable_info": (
                template_attachable_info
                if isinstance(template_attachable_info, dict)
                else None
            ),
            "parent_attachment_item_id": parent_attachment_item_id,
            "parent_attachment_slot_id": parent_attachment_slot_id,
        }
        item_data_list = {k: [v] for k, v in item_data.items()}
        item_data_list["template_id"] = [template_id]

        try:
            new_item_df = pl.DataFrame(item_data_list)
            # --- Casting and Column Handling ---
            cast_exprs = []
            current_schema = self.items_df.schema
            for col, target_dtype in current_schema.items():
                if col in new_item_df.columns:
                    cast_exprs.append(pl.col(col).cast(target_dtype, strict=False))
            new_item_df = new_item_df.with_columns(cast_exprs)
            for col, target_dtype in current_schema.items():
                if col not in new_item_df.columns:
                    log.warning(
                        f"Column '{col}' missing in create_item data, adding null."
                    )
                    new_item_df = new_item_df.with_columns(
                        pl.lit(None, dtype=target_dtype).alias(col)
                    )
            new_item_df = new_item_df.select(current_schema.keys())
            # --- End Casting ---

            if self.items_df.height == 0:
                self.items_df = new_item_df
            else:
                self.items_df = self.items_df.vstack(new_item_df)

            log.info("Item created successfully", **log_context)
            return new_id
        except Exception as e:
            log.error(
                "Failed to create item DataFrame or vstack",
                error=str(e),
                exc_info=True,
                item_data=item_data_list,
            )
            return None

    def get_items_at(self: Self, x: int, y: int) -> pl.DataFrame:
        """Returns active items on the ground at (x, y)."""
        try:
            return self.items_df.filter(
                (pl.col("x") == x)
                & (pl.col("y") == y)
                & (pl.col("location_type") == "ground")
                & pl.col("is_active")
            )
        except Exception as e:
            log.error(
                "Error getting items at position",
                pos=(x, y),
                error=str(e),
                exc_info=True,
            )
            return pl.DataFrame(schema=ITEM_SCHEMA)  # Return empty DF

    def get_entity_inventory(self: Self, owner_entity_id: int) -> pl.DataFrame:
        """Returns active items in an entity's inventory (not equipped/attached)."""
        try:
            return self.items_df.filter(
                (pl.col("owner_entity_id") == owner_entity_id)
                & (pl.col("location_type") == "inventory")
                & pl.col("is_active")
            )
        except Exception as e:
            log.error(
                "Error getting entity inventory",
                entity_id=owner_entity_id,
                error=str(e),
                exc_info=True,
            )
            return pl.DataFrame(schema=ITEM_SCHEMA)

    def get_entity_equipped(self: Self, owner_entity_id: int) -> pl.DataFrame:
        """Returns active items equipped directly to entity slots."""
        try:
            return self.items_df.filter(
                (pl.col("owner_entity_id") == owner_entity_id)
                & (pl.col("location_type") == "equipped")
                & pl.col("is_active")
            )
        except Exception as e:
            log.error(
                "Error getting entity equipped items",
                entity_id=owner_entity_id,
                error=str(e),
                exc_info=True,
            )
            return pl.DataFrame(schema=ITEM_SCHEMA)

    def get_attached_items(self, parent_item_id: int) -> pl.DataFrame:
        """Returns active items attached to a specific parent item."""
        try:
            return self.items_df.filter(
                (pl.col("parent_attachment_item_id") == parent_item_id)
                & (pl.col("location_type") == "attached")
                & pl.col("is_active")
            )
        except Exception as e:
            log.error(
                "Error getting attached items",
                parent_id=parent_item_id,
                error=str(e),
                exc_info=True,
            )
            return pl.DataFrame(schema=ITEM_SCHEMA)  # Return empty DF

    def get_item_component(self: Self, item_id: int, component_name: str) -> Any | None:
        """Retrieves a component value for a specific active item."""
        log_context = {"item_id": item_id, "component": component_name}
        current_schema = self.items_df.schema
        if component_name not in current_schema:
            log.warning("Component does not exist in ITEM_SCHEMA", **log_context)
            raise ValueError(
                f"Item component '{component_name}' not in instance schema."
            )

        try:
            result = (
                self.items_df.lazy()
                .filter((pl.col("item_id") == item_id) & pl.col("is_active"))
                .select(component_name)
                .collect()
            )
            if result.height == 0:
                return None
            return result.item()  # Extracts the single value
        except Exception as e:
            log.error(
                "Error getting item component",
                error=str(e),
                exc_info=True,
                **log_context,
            )
            return None

    def set_item_component(
        self: Self, item_id: int, component_name: str, value: Any
    ) -> bool:
        """Sets a component value for a specific active item instance."""
        log_context = {
            "item_id": item_id,
            "component": component_name,
            "new_value": value,
        }
        current_schema = self.items_df.schema
        protected_fields = {  # Fields managed by move_item or core logic
            "item_id",
            "is_active",
            "template_id",
            "location_type",
            "owner_entity_id",
            "x",
            "y",
            "equipped_slot",
            "parent_attachment_item_id",
            "parent_attachment_slot_id",
        }
        if component_name not in current_schema:
            log.warning("Component does not exist in ITEM_SCHEMA", **log_context)
            raise ValueError(
                f"Item component '{component_name}' not in instance schema."
            )
        if component_name in protected_fields:
            log.warning(
                "Attempted to set protected/location component directly", **log_context
            )
            raise ValueError(
                f"Cannot directly set '{component_name}'. Use move_item or specific actions."
            )

        target_dtype = current_schema[component_name]
        lit_value = pl.lit(value)

        try:
            item_mask = (pl.col("item_id") == item_id) & pl.col("is_active")
            if self.items_df.filter(item_mask).height == 0:
                log.debug(
                    "Item not found or inactive, cannot set component", **log_context
                )
                return False

            self.items_df = self.items_df.with_columns(
                pl.when(item_mask)
                .then(lit_value)
                .otherwise(pl.col(component_name))
                .cast(target_dtype, strict=False)
                .alias(component_name)
            )
            return True
        except Exception as e:
            log.error(
                "Error setting item component",
                error=str(e),
                exc_info=True,
                **log_context,
            )
            return False

    def move_item(
        self: Self,
        item_id: int,
        new_location: ItemLocation,
        owner_entity_id: int | None = None,
        x: int | None = None,
        y: int | None = None,
        equipped_slot: EquipSlot | None = None,
        parent_attachment_item_id: int | None = None,
        parent_attachment_slot_id: str | None = None,
    ) -> bool:
        """Moves an active item, performing validation and state clearing."""
        log_context = {"item_id": item_id, "new_loc": new_location}

        # --- Combined Validation ---
        if new_location == "ground" and (x is None or y is None):
            log.warning("Move failed: Ground requires coords", **log_context)
            return False
        if new_location in ("inventory", "equipped") and owner_entity_id is None:
            log.warning(f"Move failed: {new_location} requires owner", **log_context)
            return False
        if new_location == "equipped" and equipped_slot is None:
            log.warning("Move failed: Equipped requires slot", **log_context)
            return False
        if new_location == "attached" and (
            parent_attachment_item_id is None or parent_attachment_slot_id is None
        ):
            log.warning(
                "Move failed: Attached requires parent item/slot", **log_context
            )
            return False
        # --- End Validation ---

        item_mask = (pl.col("item_id") == item_id) & pl.col("is_active")
        if self.items_df.filter(item_mask).height == 0:
            log.warning("Move failed: Item not found or inactive", **log_context)
            return False

        # --- Prepare Updates and Clear Conflicting State ---
        final_x = x if new_location == "ground" else None
        final_y = y if new_location == "ground" else None
        final_owner = (
            owner_entity_id if new_location in ("inventory", "equipped") else None
        )
        final_equipped_slot = equipped_slot if new_location == "equipped" else None
        final_parent_item = (
            parent_attachment_item_id if new_location == "attached" else None
        )
        final_parent_slot = (
            parent_attachment_slot_id if new_location == "attached" else None
        )

        current_schema = self.items_df.schema
        updates: list[pl.Expr] = [
            pl.when(item_mask)
            .then(pl.lit(new_location))
            .otherwise(pl.col("location_type"))
            .cast(current_schema["location_type"], strict=False)
            .alias("location_type"),
            pl.when(item_mask)
            .then(pl.lit(final_owner))
            .otherwise(pl.col("owner_entity_id"))
            .cast(current_schema["owner_entity_id"], strict=False)
            .alias("owner_entity_id"),
            pl.when(item_mask)
            .then(pl.lit(final_x))
            .otherwise(pl.col("x"))
            .cast(current_schema["x"], strict=False)
            .alias("x"),
            pl.when(item_mask)
            .then(pl.lit(final_y))
            .otherwise(pl.col("y"))
            .cast(current_schema["y"], strict=False)
            .alias("y"),
            pl.when(item_mask)
            .then(pl.lit(final_equipped_slot))
            .otherwise(pl.col("equipped_slot"))
            .cast(current_schema["equipped_slot"], strict=False)
            .alias("equipped_slot"),
            pl.when(item_mask)
            .then(pl.lit(final_parent_item))
            .otherwise(pl.col("parent_attachment_item_id"))
            .cast(current_schema["parent_attachment_item_id"], strict=False)
            .alias("parent_attachment_item_id"),
            pl.when(item_mask)
            .then(pl.lit(final_parent_slot))
            .otherwise(pl.col("parent_attachment_slot_id"))
            .cast(current_schema["parent_attachment_slot_id"], strict=False)
            .alias("parent_attachment_slot_id"),
        ]

        try:
            self.items_df = self.items_df.with_columns(updates)
            log.info(
                "Item moved successfully",
                **log_context,
                owner=final_owner,
                pos=(final_x, final_y),
                slot=final_equipped_slot,
                parent=final_parent_item,
            )
            return True
        except Exception as e:
            log.error("Error moving item", error=str(e), exc_info=True, **log_context)
            return False

    def delete_item(self: Self, item_id: int) -> bool:
        """Marks an item as inactive (soft delete)."""
        log_context = {"item_id": item_id}
        try:
            item_mask = (pl.col("item_id") == item_id) & pl.col("is_active")
            was_active = self.items_df.filter(item_mask).height > 0

            if not was_active:
                log.debug("Item already inactive or does not exist", **log_context)
                return False

            self.items_df = self.items_df.with_columns(
                pl.when(item_mask)
                .then(pl.lit(False))
                .otherwise(pl.col("is_active"))
                .alias("is_active")
            )
            log.info("Item marked as inactive", **log_context)
            return True
        except Exception as e:
            log.error(
                "Error deleting item (marking inactive)",
                error=str(e),
                exc_info=True,
                **log_context,
            )
            return False

    def compact_registry(self: Self) -> None:
        """Permanently removes inactive items."""
        log.info("Compacting item registry...")
        try:
            initial_count = self.items_df.height
            self.items_df = self.items_df.filter(pl.col("is_active"))
            final_count = self.items_df.height
            removed_count = initial_count - final_count
            log.info(
                "Item registry compacted",
                initial=initial_count,
                final=final_count,
                removed=removed_count,
            )
        except Exception as e:
            log.error("Error compacting item registry", error=str(e), exc_info=True)

    # --- Utility Methods ---
    def get_template(self: Self, template_id: str) -> dict | None:
        """Safely retrieve an item template definition."""
        return self.item_templates.get(template_id)

    def get_item_template_id(self: Self, item_id: int) -> str | None:
        """Retrieve the template_id for a given item_id."""
        template_id_val = self.get_item_component(item_id, "template_id")
        return cast(str, template_id_val) if template_id_val else None

    def get_item_static_attribute(
        self: Self, item_id: int, attribute_name: str, default: Any = None
    ) -> Any:
        """Convenience method to get a static attribute from an item's template."""
        template_id = self.get_item_template_id(item_id)
        if template_id:
            template = self.get_template(template_id)
            if template:
                return template.get("attributes", {}).get(attribute_name, default)
        return default

```

`basicrl/game/systems/combat_system.py`:

```py
# game/systems/combat_system.py
"""
Handles combat calculations and actions between entities.
"""
from typing import TYPE_CHECKING

import structlog

# Import roll_dice from its new location
from utils.helpers import roll_dice

if TYPE_CHECKING:
    from game_rng import GameRNG  # Assuming this is importable for type hint

    from game.entities.registry import EntityRegistry
    from game.game_state import GameState
    from game.items.registry import ItemRegistry

log = structlog.get_logger(__name__)

DEFAULT_UNARMED_DAMAGE = "1d2"  # Damage if attacker has no weapon


def handle_melee_attack(attacker_id: int, defender_id: int, gs: "GameState"):
    """
    Processes a melee attack from attacker_id to defender_id.
    Calculates damage, applies it, handles messages, and checks for death.
    Currently assumes the action is valid and consumes a turn.
    """
    entity_reg: "EntityRegistry" = gs.entity_registry
    item_reg: "ItemRegistry" = gs.item_registry
    rng: "GameRNG" = gs.rng_instance  # Get RNG from GameState

    attacker_name = entity_reg.get_entity_component(attacker_id, "name") or "Attacker"
    defender_name = entity_reg.get_entity_component(defender_id, "name") or "Defender"
    log.debug(
        "Handling melee attack",
        attacker=attacker_name,
        defender=defender_name,
        attacker_id=attacker_id,
        defender_id=defender_id,
    )

    # --- Determine Attacker's Damage ---
    damage_dice = DEFAULT_UNARMED_DAMAGE
    weapon_name = "unarmed"

    # Find equipped weapon
    equipped_ids = entity_reg.get_equipped_ids(attacker_id)
    if equipped_ids:
        # Check main_hand first, then off_hand (simple priority for now)
        # TODO: Refine to handle two-handed weapons or dual wielding later
        main_hand_weapon_id = None
        # Query items registry for equipped items owned by attacker
        equipped_items = item_reg.get_entity_equipped(attacker_id).filter(
            pl.col("item_id").is_in(equipped_ids)
        )
        if equipped_items.height > 0:
            main_hand_item = equipped_items.filter(
                pl.col("equipped_slot") == "main_hand"
            ).row(0, named=True, default=None)
            if main_hand_item:
                main_hand_weapon_id = main_hand_item.get("item_id")

            # Simple fallback to any equipped weapon if main hand empty (could be off_hand weapon)
            if not main_hand_weapon_id:
                any_weapon = equipped_items.filter(pl.col("item_type") == "Weapon").row(
                    0, named=True, default=None
                )  # Assuming 'item_type' exists
                if any_weapon:
                    main_hand_weapon_id = any_weapon.get(
                        "item_id"
                    )  # Treat as primary weapon for now

        if main_hand_weapon_id:
            # Retrieve damage_dice attribute from the weapon's template
            weapon_damage_dice_attr = item_reg.get_item_static_attribute(
                main_hand_weapon_id, "damage_dice", default=None
            )
            if weapon_damage_dice_attr:
                damage_dice = weapon_damage_dice_attr
                weapon_name = (
                    item_reg.get_item_component(main_hand_weapon_id, "name") or "weapon"
                )
                log.debug("Attacker using weapon", weapon=weapon_name, dice=damage_dice)
            else:
                log.warning(
                    "Equipped weapon has no damage_dice attribute",
                    item_id=main_hand_weapon_id,
                )
    else:
        log.debug("Attacker is unarmed")

    # --- Calculate Damage ---
    # TODO: Factor in attacker stats (e.g., strength)
    # TODO: Factor in defender stats (e.g., defense, armor class)
    raw_damage = roll_dice(damage_dice, rng)
    final_damage = max(0, raw_damage)  # Ensure damage isn't negative

    # --- Apply Damage & Check Death ---
    defender_hp = entity_reg.get_entity_component(defender_id, "hp")
    if defender_hp is None:
        log.error("Defender missing HP component", defender_id=defender_id)
        return  # Cannot apply damage

    new_hp = max(0, defender_hp - final_damage)
    damage_dealt = defender_hp - new_hp

    log.debug(
        "Damage calculated",
        raw=raw_damage,
        final=final_damage,
        dealt=damage_dealt,
        defender_hp_old=defender_hp,
        defender_hp_new=new_hp,
    )

    # Add Combat Messages
    # TODO: Visibility checks
    attack_msg = ""
    damage_msg = ""
    hit_color = (200, 200, 200)  # Default color
    damage_color = (255, 255, 0)  # Yellow for damage

    if attacker_id == gs.player_id:
        attack_msg = f"You attack the {defender_name} with your {weapon_name}!"
        if damage_dealt > 0:
            damage_msg = f"You hit for {damage_dealt} damage!"
            damage_color = (0, 255, 0)  # Green for player dealing damage
        else:
            damage_msg = "You miss!"
            damage_color = (150, 150, 150)
    elif defender_id == gs.player_id:
        attack_msg = f"The {attacker_name} attacks you with its {weapon_name}!"
        if damage_dealt > 0:
            damage_msg = f"You are hit for {damage_dealt} damage!"
            damage_color = (255, 0, 0)  # Red for player taking damage
        else:
            damage_msg = f"The {attacker_name} misses!"
            damage_color = (150, 150, 150)
    else:  # Mob vs Mob
        attack_msg = f"The {attacker_name} attacks the {defender_name}!"
        if damage_dealt > 0:
            damage_msg = f"It hits for {damage_dealt} damage."
        else:
            damage_msg = "It misses."

    if attack_msg:
        gs.add_message(attack_msg, hit_color)
    if damage_msg:
        gs.add_message(damage_msg, damage_color)

    # Update Defender HP
    if damage_dealt > 0:
        update_success = entity_reg.set_entity_component(defender_id, "hp", new_hp)
        if not update_success:
            log.error("Failed to set defender HP after attack", defender_id=defender_id)
            # Continue to death check anyway, HP might conceptually be 0

    # Handle Death [Source [source 53]]
    if new_hp <= 0:
        log.info(f"{defender_name} died.", defender_id=defender_id)
        gs.add_message(f"The {defender_name} dies!", (255, 100, 100))  # Death color
        # TODO: Handle XP, item drops, remove body etc.
        entity_reg.delete_entity(defender_id)  # Mark inactive

```

`basicrl/game/systems/equipment_system.py`:

```py
# game/systems/equipment_system.py

"""
Handles the logic for equipping, unequipping, attaching, and detaching items,
considering entity body plans and item mount points.
"""
# Ensure Union is imported from typing
from typing import TYPE_CHECKING, Any, Dict, List, Tuple, Union, cast

import polars as pl
import structlog

# Import specific types needed from other modules
# Ensure these imports work correctly based on your project structure
try:
    from game.entities.registry import EntityRegistry
    from game.items.registry import BodySlotType, EquipSlot, ItemLocation, ItemRegistry
except ImportError as e:
    # Define logger early for import errors
    # Note: Basic config might be needed if structlog isn't fully configured yet
    import logging

    logging.basicConfig(level=logging.ERROR)
    log_fallback = logging.getLogger(__name__)
    log_fallback.error(
        f"CRITICAL: Failed to import registry types in equipment_system: {e}"
    )
    # Define dummy types to prevent NameErrors during parsing, but expect runtime failures
    EquipSlot = Any
    ItemLocation = Any
    BodySlotType = Any
    EntityRegistry = Any
    ItemRegistry = Any
    # Fallback logger if full structlog isn't ready
    log = log_fallback


if TYPE_CHECKING:
    from game.game_state import GameState

# Setup logger properly if structlog is available
try:
    log = structlog.get_logger(__name__)
except NameError:  # Handles case where log_fallback was used above
    pass


# --- Helper Functions ---


def get_item_template(item_id: int, gs: "GameState") -> Dict | None:
    """Helper: Safely get the template data for an item."""
    # Check if item_registry exists on gs
    if not hasattr(gs, "item_registry") or gs.item_registry is None:
        log.error("GameState missing item_registry", method="get_item_template")
        return None
    template_id = gs.item_registry.get_item_template_id(item_id)
    if template_id:
        return gs.item_registry.get_template(template_id)
    # Avoid logging warning if item_id itself was None or invalid
    if item_id is not None:
        log.debug(
            "Could not find template for item", item_id=item_id
        )  # Changed from warning
    return None


def get_item_attribute(
    item_id: int, attribute_name: str, gs: "GameState", default: Any = None
) -> Any:
    """Helper: Safely get an attribute from an item's template data."""
    template = get_item_template(item_id, gs)
    if template:
        return template.get("attributes", {}).get(attribute_name, default)
    return default


def get_general_slot_type(specific_slot: "EquipSlot") -> str | None:
    """Maps a specific EquipSlot (e.g., finger_3) to a general BodySlotType (e.g., finger)."""
    # Ensure specific_slot is a string before calling startswith
    if not isinstance(specific_slot, str):
        # Allow None gracefully
        if specific_slot is None:
            return None
        log.warning(
            "Invalid specific_slot type passed to get_general_slot_type",
            type=type(specific_slot),
        )
        return None

    if specific_slot.startswith("finger_"):
        return "finger"
    if specific_slot.startswith("neck_"):
        return "neck"
    if specific_slot in ["main_hand", "off_hand"]:
        return "hand"
    if specific_slot == "wrists":
        return "wrist"
    # Direct mappings based on BodySlotType keys - requires BodySlotType to be defined/imported
    try:
        if specific_slot in BodySlotType.__args__:
            return specific_slot
    except AttributeError:  # Handle if BodySlotType wasn't imported correctly
        log.error("BodySlotType type definition not available for validation")
        # Cannot safely map, return None
        return None

    log.warning(
        "Could not map specific slot to general type", specific_slot=specific_slot
    )
    return None


def get_slots_occupied_by_general_type(
    entity_id: int, general_slot_type: str, gs: "GameState"
) -> List["EquipSlot"]:
    """Helper: Gets a list of specific slots occupied by items of a general type."""
    occupied_slots = []
    # Ensure registries exist
    if (
        not hasattr(gs, "entity_registry")
        or gs.entity_registry is None
        or not hasattr(gs, "item_registry")
        or gs.item_registry is None
    ):
        log.error(
            "GameState missing entity_registry or item_registry",
            method="get_slots_occupied_by_general_type",
        )
        return []

    entity_reg = gs.entity_registry
    item_reg = gs.item_registry
    equipped_ids = entity_reg.get_equipped_ids(entity_id)
    if not equipped_ids:
        return []

    try:
        if equipped_ids:
            equipped_items_df = item_reg.items_df.filter(
                pl.col("item_id").is_in(equipped_ids)
                & (pl.col("location_type") == "equipped")
            )
            # Use select().to_series() for potentially faster extraction than iter_rows
            equipped_slots_series = (
                equipped_items_df.select("equipped_slot").to_series().drop_nulls()
            )

            for specific_slot in equipped_slots_series:
                if (
                    specific_slot
                ):  # Check if not None after drop_nulls (though redundant)
                    current_general_type = get_general_slot_type(
                        cast(str, specific_slot)
                    )  # Cast for safety
                    if current_general_type == general_slot_type:
                        # Ensure the slot is a valid EquipSlot before appending
                        try:
                            if (
                                "EquipSlot" in globals()
                                and EquipSlot is not Any
                                and specific_slot in EquipSlot.__args__
                            ):
                                occupied_slots.append(cast(EquipSlot, specific_slot))
                            # If EquipSlot wasn't loaded, we might have appended string earlier, allow it but log
                            elif "EquipSlot" not in globals() or EquipSlot is Any:
                                occupied_slots.append(
                                    specific_slot
                                )  # Assume it's valid if type unknown
                            else:
                                log.warning(
                                    "Occupied slot is not a valid EquipSlot literal",
                                    slot=specific_slot,
                                )
                        except AttributeError:
                            log.error(
                                "EquipSlot type definition not available for validation"
                            )
                            occupied_slots.append(specific_slot)  # Append anyway

        return occupied_slots
    except Exception as e:
        log.error(
            "Error fetching/processing equipped slots",
            entity_id=entity_id,
            error=str(e),
            exc_info=True,
        )
        return []


# --- CORRECTED TYPE HINT using Union ---
def find_first_available_slot(
    entity_id: int, item_id: int, gs: "GameState"
) -> Union[EquipSlot, None]:
    # --- End Correction ---
    """Helper: Find the first specific, unoccupied EquipSlot compatible with the item."""
    item_reg = gs.item_registry
    entity_reg = gs.entity_registry
    if not item_reg or not entity_reg:
        log.error("Registries unavailable", sys="equipment")
        return None

    template = get_item_template(item_id, gs)
    if not template:
        return None

    compatible_slots_specific = get_item_attribute(
        item_id, "compatible_equip_slots", gs
    )  # Option A
    primary_equip_slot = template.get("equip_slot")  # Option C (primary definition)
    general_slot_type = get_item_attribute(
        item_id, "general_equip_type", gs
    )  # Option B

    target_general_type = None
    possible_specific_slots: List[EquipSlot] = []

    # Determine valid EquipSlot literals dynamically if possible
    try:
        valid_equip_slots = (
            set(EquipSlot.__args__)
            if "EquipSlot" in globals() and EquipSlot is not Any
            else set()
        )
    except AttributeError:
        log.error("EquipSlot type definition not available for validation")
        valid_equip_slots = set()  # Cannot validate

    if isinstance(compatible_slots_specific, list) and compatible_slots_specific:
        possible_specific_slots = [
            s for s in compatible_slots_specific if s in valid_equip_slots
        ]
        if possible_specific_slots:
            target_general_type = get_general_slot_type(possible_specific_slots[0])
        else:
            log.warning(
                "Item compatible_equip_slots list contains no valid slots",
                item_id=item_id,
            )
            return None
    elif primary_equip_slot and primary_equip_slot in valid_equip_slots:
        target_general_type = get_general_slot_type(primary_equip_slot)
        possible_specific_slots = [
            s
            for s in valid_equip_slots
            if get_general_slot_type(s) == target_general_type
        ]
    elif general_slot_type:
        target_general_type = general_slot_type
        possible_specific_slots = [
            s
            for s in valid_equip_slots
            if get_general_slot_type(s) == target_general_type
        ]
    else:
        log.warning(
            "Item template lacks equip slot definition",
            item_id=item_id,
            template_id=template.get("name", "?"),
        )
        return None

    if not target_general_type or not possible_specific_slots:
        log.warning(
            "Could not determine target slot type or possible specific slots",
            item_id=item_id,
            general=target_general_type,
        )
        return None

    # Check body plan vs occupied count
    body_plan = entity_reg.get_body_plan(entity_id)
    if not body_plan:
        log.error("Entity has no body plan", entity_id=entity_id)
        return None
    available_count = body_plan.get(target_general_type, 0)
    occupied_slots = get_slots_occupied_by_general_type(
        entity_id, target_general_type, gs
    )
    current_count = len(occupied_slots)

    if current_count >= available_count:
        log.debug(
            "No free slots of general type",
            entity_id=entity_id,
            type=target_general_type,
            equipped=current_count,
            available=available_count,
        )
        return None

    # Find first free specific slot from the possible list
    occupied_set = set(occupied_slots)
    for slot in possible_specific_slots:
        if slot not in occupied_set:
            # Final check: ensure the found slot literal is valid
            if slot in valid_equip_slots:
                return slot
            else:  # Should not happen if possible_specific_slots was filtered correctly
                log.error(
                    "Internal Error: Found slot not in valid EquipSlot literals",
                    slot=slot,
                )
                return None

    log.debug(
        "Could not find specific unoccupied slot despite count mismatch",
        type=target_general_type,
        occupied=occupied_set,
        possible=possible_specific_slots,
    )
    return None


def get_item_mount_points(item_id: int, gs: "GameState") -> List[Dict] | None:
    """Helper: Get mount_points list for an item, ensuring validity."""
    if not hasattr(gs, "item_registry") or gs.item_registry is None:
        return None
    mounts = gs.item_registry.get_item_component(item_id, "mount_points")
    if isinstance(mounts, list) and all(isinstance(mp, dict) for mp in mounts):
        return mounts
    elif mounts is not None:
        log.warning(
            "mount_points component data is not list[dict]",
            item_id=item_id,
            data=mounts,
        )
    return None  # Return None if missing or invalid format


def get_attachable_info(item_id: int, gs: "GameState") -> Dict | None:
    """Helper: Get attachable_info dict for an item."""
    if not hasattr(gs, "item_registry") or gs.item_registry is None:
        return None
    info = gs.item_registry.get_item_component(item_id, "attachable_info")
    return info if isinstance(info, dict) else None


# --- Main Equipment Actions ---


def can_equip(
    entity_id: int, item_id: int, gs: "GameState"
) -> Tuple[bool, str, Union[EquipSlot, None]]:
    """Checks if entity can equip item directly. Returns (can_equip, reason, target_slot)."""
    log.debug("Checking can_equip", entity_id=entity_id, item_id=item_id)
    # Ensure registries are available
    if (
        not hasattr(gs, "item_registry")
        or gs.item_registry is None
        or not hasattr(gs, "entity_registry")
        or gs.entity_registry is None
    ):
        return False, "Internal Error: Registry missing", None
    item_reg = gs.item_registry

    # Check if item exists and is active
    item_state = (
        item_reg.items_df.filter(pl.col("item_id") == item_id)
        .select(["is_active", "location_type"])
        .row(0, named=True, default=None)
    )
    if not item_state or not item_state.get("is_active"):
        return False, "Item does not exist or is inactive", None

    # Check if item is equippable at all
    template = get_item_template(item_id, gs)
    if not template:
        return False, "Invalid item template", None
    flags = template.get("flags", [])
    is_defined_equippable = (
        template.get("equip_slot")
        or get_item_attribute(item_id, "compatible_equip_slots", gs)
        or get_item_attribute(item_id, "general_equip_type", gs)
    )
    if "EQUIPPABLE" not in flags and not is_defined_equippable:
        return False, "Item not equippable", None

    # Check if item is already equipped or attached elsewhere
    loc_type = item_state.get("location_type")
    if loc_type not in ["inventory", "ground"]:
        return False, f"Item is currently {loc_type}", None

    # Find available slot
    target_slot = find_first_available_slot(entity_id, item_id, gs)
    if target_slot:
        return True, "Slot available", target_slot
    else:
        # Check if the failure was due to lack of compatible slot type in body_plan
        general_type = get_item_attribute(item_id, "general_equip_type", gs) or (
            get_general_slot_type(template["equip_slot"])
            if template.get("equip_slot")
            else None
        )
        if (
            general_type
            and gs.entity_registry.get_body_plan(entity_id).get(general_type, 0) == 0
        ):
            return False, f"Body has no '{general_type}' slots", None
        return False, "No compatible/free slot", None


def equip_item(entity_id: int, item_id: int, gs: "GameState") -> bool:
    """Equips item to the first available valid slot on the entity."""
    if (
        not hasattr(gs, "entity_registry")
        or gs.entity_registry is None
        or not hasattr(gs, "item_registry")
        or gs.item_registry is None
    ):
        log.error("GameState missing registries", method="equip_item")
        return False
    entity_reg = gs.entity_registry
    item_reg = gs.item_registry

    can, reason, target_slot = can_equip(entity_id, item_id, gs)
    if not can or target_slot is None:
        log.debug(f"Cannot equip item {item_id} on entity {entity_id}: {reason}")
        if entity_id == gs.player_id:
            gs.add_message(f"Cannot equip that: {reason}")
        return False  # Turn not consumed

    log.info("Equipping item", entity_id=entity_id, item_id=item_id, slot=target_slot)

    current_ids = entity_reg.get_equipped_ids(entity_id)
    if current_ids is None:
        log.error("Failed to get equipped_ids list", entity_id=entity_id)
        return False
    if item_id in current_ids:
        log.warning(
            "Item already in equipped list? Aborting equip.",
            item_id=item_id,
            entity_id=entity_id,
        )
        # Maybe unequip first if logic requires it? For now, just prevent re-equip.
        gs.add_message("That item seems to already be equipped.", (255, 150, 0))
        return False  # Prevent duplicate equip
    new_ids = current_ids + [item_id]

    if not entity_reg.set_equipped_ids(entity_id, new_ids):
        log.error("Failed to set equipped_ids list", entity_id=entity_id)
        return False

    success = item_reg.move_item(
        item_id=item_id,
        new_location="equipped",
        owner_entity_id=entity_id,
        equipped_slot=target_slot,
    )

    if not success:
        log.error(
            "Failed to move item to equipped state in ItemRegistry", item_id=item_id
        )
        try:
            entity_reg.set_equipped_ids(entity_id, current_ids)  # Attempt rollback
        except Exception as rollback_err:
            log.critical(
                "Rollback equip failed!", entity_id=entity_id, error=rollback_err
            )
        return False

    item_name = item_reg.get_item_component(item_id, "name") or "item"
    if entity_id == gs.player_id:
        gs.add_message(f"You equip the {item_name} ({target_slot}).")
    # TODO: Apply passive effects

    return True


def can_unequip(entity_id: int, item_id: int, gs: "GameState") -> Tuple[bool, str]:
    """Checks if entity can unequip item. Checks for attached items and inventory space."""
    if (
        not hasattr(gs, "entity_registry")
        or gs.entity_registry is None
        or not hasattr(gs, "item_registry")
        or gs.item_registry is None
    ):
        log.error("GameState missing registries", method="can_unequip")
        return False, "Internal Error"
    item_reg = gs.item_registry
    entity_reg = gs.entity_registry

    # Check if item exists and is active first
    item_data = (
        item_reg.items_df.filter(pl.col("item_id") == item_id)
        .select(["is_active", "location_type"])
        .row(0, named=True, default=None)
    )
    if not item_data or not item_data.get("is_active"):
        return False, "Item does not exist"

    loc_type = item_data.get("location_type")
    if loc_type != "equipped":
        return False, "Item not equipped"

    # Check ownership via equipped_ids list (more robust than checking item.owner_entity_id)
    equipped_ids = entity_reg.get_equipped_ids(entity_id)
    if equipped_ids is None or item_id not in equipped_ids:
        log.warning(
            "Item location is 'equipped' but not in entity's equipped_ids list!",
            item_id=item_id,
            entity_id=entity_id,
        )
        return False, "Item not equipped by you"  # Or Internal Error?

    mount_points = get_item_mount_points(item_id, gs)
    if mount_points:
        for mp in mount_points:
            if mp.get("accepted_item_id") is not None:
                # Fetch name safely
                attached_item_name = "something"
                try:
                    attached_item_name = (
                        item_reg.get_item_component(mp["accepted_item_id"], "name")
                        or "something"
                    )
                except:
                    pass  # Ignore if attached item doesn't exist
                return False, f"'{attached_item_name}' attached"

    inv_capacity = entity_reg.get_entity_component(entity_id, "inventory_capacity")
    if inv_capacity is not None:
        current_inventory = item_reg.get_entity_inventory(entity_id)
        if current_inventory.height >= inv_capacity:
            return False, "Inventory full"

    return True, "Can unequip"


def unequip_item(entity_id: int, item_id: int, gs: "GameState") -> bool:
    """Unequips item from entity, moving to inventory."""
    if (
        not hasattr(gs, "entity_registry")
        or gs.entity_registry is None
        or not hasattr(gs, "item_registry")
        or gs.item_registry is None
    ):
        log.error("GameState missing registries", method="unequip_item")
        return False
    entity_reg = gs.entity_registry
    item_reg = gs.item_registry

    can, reason = can_unequip(entity_id, item_id, gs)
    if not can:
        log.debug(f"Cannot unequip item {item_id} from entity {entity_id}: {reason}")
        if entity_id == gs.player_id:
            gs.add_message(f"Cannot unequip: {reason}.")
        return False

    log.info("Unequipping item", entity_id=entity_id, item_id=item_id)

    current_ids = entity_reg.get_equipped_ids(entity_id)
    if current_ids is None:
        log.error("Failed to get equipped_ids list during unequip", entity_id=entity_id)
        return False
    try:
        new_ids = [i for i in current_ids if i != item_id]
    except TypeError:
        log.error(
            "equipped_item_ids was not a list during unequip", entity_id=entity_id
        )
        return False

    if not entity_reg.set_equipped_ids(entity_id, new_ids):
        log.error("Failed to set equipped_ids list during unequip", entity_id=entity_id)
        return False

    success = item_reg.move_item(
        item_id=item_id, new_location="inventory", owner_entity_id=entity_id
    )

    if not success:
        log.error(
            "Failed to move item to inventory state in ItemRegistry during unequip",
            item_id=item_id,
        )
        try:
            entity_reg.set_equipped_ids(entity_id, current_ids)  # Rollback attempt
        except Exception as rb_err:
            log.critical("Rollback unequip failed!", entity_id=entity_id, error=rb_err)
        return False

    item_name = item_reg.get_item_component(item_id, "name") or "item"
    if entity_id == gs.player_id:
        gs.add_message(f"You unequip the {item_name}.")
    # TODO: Remove passive effects

    return True


# --- Attachment Functions ---


def can_attach(
    entity_id: int, item_to_attach_id: int, target_host_item_id: int, gs: "GameState"
) -> Tuple[bool, str, str | None]:
    """Checks if item can be attached to host item. Returns (can_attach, reason, mount_slot_id)."""
    if (
        not hasattr(gs, "entity_registry")
        or gs.entity_registry is None
        or not hasattr(gs, "item_registry")
        or gs.item_registry is None
    ):
        log.error("GameState missing registries", method="can_attach")
        return False, "Internal Error", None
    item_reg = gs.item_registry
    entity_reg = gs.entity_registry

    # Check items exist and are active
    attach_item_data = (
        item_reg.items_df.filter(pl.col("item_id") == item_to_attach_id)
        .select(["is_active", "location_type", "owner_entity_id"])
        .row(0, named=True, default=None)
    )
    host_item_data = (
        item_reg.items_df.filter(pl.col("item_id") == target_host_item_id)
        .select(["is_active", "location_type", "owner_entity_id"])
        .row(0, named=True, default=None)
    )

    if not attach_item_data or not attach_item_data.get("is_active"):
        return False, "Item to attach does not exist", None
    if not host_item_data or not host_item_data.get("is_active"):
        return False, "Host item does not exist", None

    # 1. Check item_to_attach is in entity's inventory
    if (
        attach_item_data.get("location_type") != "inventory"
        or attach_item_data.get("owner_entity_id") != entity_id
    ):
        return False, "Item not in inventory", None

    # 2. Check target_host_item is equipped by the entity
    if (
        host_item_data.get("location_type") != "equipped"
        or host_item_data.get("owner_entity_id") != entity_id
    ):
        return False, "Host item not equipped", None

    # 3. Get attachable_info from item_to_attach
    attach_info = get_attachable_info(item_to_attach_id, gs)
    if not attach_info:
        return False, "Item not attachable", None
    compatible_mount_types = attach_info.get("compatible_mount_types")
    if not compatible_mount_types or not isinstance(compatible_mount_types, list):
        return False, "Item has no compatible mount types defined", None

    # 4. Get mount_points from target_host_item
    mount_points = get_item_mount_points(target_host_item_id, gs)
    if not mount_points:
        return False, "Host item has no mount points", None

    # 5. Iterate through mount_points on host and find compatible + free slot
    for mp in mount_points:
        mp_id = mp.get("id")
        is_free = mp.get("accepted_item_id") is None
        if mp_id and is_free and mp_id in compatible_mount_types:
            # TODO: Add flag checks if needed
            return True, "Compatible slot found", mp_id

    return False, "No compatible/free mount points", None


def attach_item(
    entity_id: int, item_to_attach_id: int, target_host_item_id: int, gs: "GameState"
) -> bool:
    """Attaches an item to a host item."""
    if not hasattr(gs, "item_registry") or gs.item_registry is None:
        log.error("GameState missing item_registry", method="attach_item")
        return False
    item_reg = gs.item_registry

    can, reason, mount_slot_id = can_attach(
        entity_id, item_to_attach_id, target_host_item_id, gs
    )
    if not can or mount_slot_id is None:
        log.debug(
            f"Cannot attach item {item_to_attach_id} to {target_host_item_id}: {reason}"
        )
        if entity_id == gs.player_id:
            gs.add_message(f"Cannot attach: {reason}.")
        return False

    log.info(
        "Attaching item",
        entity_id=entity_id,
        child_item=item_to_attach_id,
        parent_item=target_host_item_id,
        mount_id=mount_slot_id,
    )

    mount_points_list = get_item_mount_points(target_host_item_id, gs)
    if mount_points_list is None:
        log.error(
            "Host item mount points disappeared between check and action",
            host_item=target_host_item_id,
        )
        return False

    found_slot = False
    modified_mount_points = []
    for mp in mount_points_list:
        mp_copy = mp.copy()
        if (
            mp_copy.get("id") == mount_slot_id
            and mp_copy.get("accepted_item_id") is None
        ):
            mp_copy["accepted_item_id"] = item_to_attach_id
            found_slot = True
        modified_mount_points.append(mp_copy)

    if not found_slot:
        log.error(
            "Mount slot became occupied between check and action",
            host_item=target_host_item_id,
            slot_id=mount_slot_id,
        )
        return False

    if not item_reg.set_item_component(
        target_host_item_id, "mount_points", modified_mount_points
    ):
        log.error(
            "Failed to update host item mount points", host_item=target_host_item_id
        )
        return False

    success = item_reg.move_item(
        item_id=item_to_attach_id,
        new_location="attached",
        parent_attachment_item_id=target_host_item_id,
        parent_attachment_slot_id=mount_slot_id,
    )

    if not success:
        log.error("Failed to move attached item state", child_item=item_to_attach_id)
        log.critical(
            "CRITICAL: Failed to move attached item after host mount point update! State inconsistent.",
            child_item=item_to_attach_id,
            host_item=target_host_item_id,
        )
        # Rollback mount point change? Difficult.
        return False

    child_name = item_reg.get_item_component(item_to_attach_id, "name") or "item"
    host_name = item_reg.get_item_component(target_host_item_id, "name") or "item"
    if entity_id == gs.player_id:
        gs.add_message(f"You attach the {child_name} to the {host_name}.")
    # TODO: Apply effects

    return True


def can_detach(
    entity_id: int, item_to_detach_id: int, gs: "GameState"
) -> Tuple[bool, str]:
    """Checks if item can be detached by the entity."""
    if (
        not hasattr(gs, "entity_registry")
        or gs.entity_registry is None
        or not hasattr(gs, "item_registry")
        or gs.item_registry is None
    ):
        log.error("GameState missing registries", method="can_detach")
        return False, "Internal Error"
    item_reg = gs.item_registry
    entity_reg = gs.entity_registry

    item_info = (
        item_reg.items_df.filter(pl.col("item_id") == item_to_detach_id)
        .select(["is_active", "location_type", "parent_attachment_item_id"])
        .row(0, named=True, default=None)
    )

    if not item_info or not item_info.get("is_active"):
        return False, "Item does not exist"
    if item_info.get("location_type") != "attached":
        return False, "Item not attached"

    parent_item_id = item_info.get("parent_attachment_item_id")
    if parent_item_id is None:
        log.error("Attached item missing parent ID", item_id=item_to_detach_id)
        return False, "Internal error (missing parent)"

    # Check ownership chain
    parent_owner_id = item_reg.get_item_component(parent_item_id, "owner_entity_id")
    if parent_owner_id != entity_id:
        return False, "You don't own the item it's attached to"

    # Check inventory space
    inv_capacity = entity_reg.get_entity_component(entity_id, "inventory_capacity")
    if inv_capacity is not None:
        current_inventory = item_reg.get_entity_inventory(entity_id)
        if current_inventory.height >= inv_capacity:
            return False, "Inventory full"

    return True, "Can detach"


def detach_item(entity_id: int, item_to_detach_id: int, gs: "GameState") -> bool:
    """Detaches an item, moving it to entity's inventory."""
    if not hasattr(gs, "item_registry") or gs.item_registry is None:
        log.error("GameState missing item_registry", method="detach_item")
        return False
    item_reg = gs.item_registry

    can, reason = can_detach(entity_id, item_to_detach_id, gs)
    if not can:
        log.debug(f"Cannot detach item {item_to_detach_id}: {reason}")
        if entity_id == gs.player_id:
            gs.add_message(f"Cannot detach: {reason}.")
        return False

    log.info("Detaching item", entity_id=entity_id, item_id=item_to_detach_id)

    detach_info = (
        item_reg.items_df.filter(pl.col("item_id") == item_to_detach_id)
        .select(["parent_attachment_item_id", "parent_attachment_slot_id"])
        .row(0, named=True, default=None)
    )

    if not detach_info:
        log.error("Failed to get detach info", item_id=item_to_detach_id)
        return False
    parent_item_id = detach_info.get("parent_attachment_item_id")
    parent_slot_id = detach_info.get("parent_attachment_slot_id")
    if parent_item_id is None or parent_slot_id is None:
        log.error("Detach failed: Item missing parent info.", item_id=item_to_detach_id)
        return False

    mount_points_list = get_item_mount_points(parent_item_id, gs)
    if mount_points_list is None:
        log.error(
            "Detach failed: Parent item has no valid mount points.",
            parent_item_id=parent_item_id,
        )
        return False

    found_slot = False
    modified_mount_points = []
    for mp in mount_points_list:
        mp_copy = mp.copy()
        if (
            mp_copy.get("id") == parent_slot_id
            and mp_copy.get("accepted_item_id") == item_to_detach_id
        ):
            mp_copy["accepted_item_id"] = None
            found_slot = True
        modified_mount_points.append(mp_copy)

    if not found_slot:
        log.error(
            "Detach failed: Could not find item in parent's mount slot.",
            item_id=item_to_detach_id,
            parent_item_id=parent_item_id,
            slot_id=parent_slot_id,
        )
        return False

    if not item_reg.set_item_component(
        parent_item_id, "mount_points", modified_mount_points
    ):
        log.error(
            "Detach failed: Could not update parent item mount points",
            parent_item_id=parent_item_id,
        )
        return False

    success = item_reg.move_item(
        item_id=item_to_detach_id, new_location="inventory", owner_entity_id=entity_id
    )

    if not success:
        log.error(
            "Detach failed: Could not move item to inventory", item_id=item_to_detach_id
        )
        log.critical(
            "CRITICAL: Failed to move detached item after clearing parent mount point! State inconsistent.",
            item_id=item_to_detach_id,
            parent_item_id=parent_item_id,
        )
        # Rollback is hard here
        return False

    item_name = item_reg.get_item_component(item_to_detach_id, "name") or "item"
    parent_name = item_reg.get_item_component(parent_item_id, "name") or "item"
    if entity_id == gs.player_id:
        gs.add_message(f"You detach the {item_name} from the {parent_name}.")
    # TODO: Remove effects

    return True


def handle_limb_loss(entity_id: int, lost_slot_type: str, gs: "GameState"):
    """Handles unequipping items when a body slot type count decreases."""
    log.warning("handle_limb_loss needs implementation")
    # 1. Get body_plan, check new count for lost_slot_type.
    # 2. Get list of specific slots occupied by items of lost_slot_type.
    # 3. If len(occupied) > new_count:
    # 4.   Determine which specific slots/items are lost (e.g., highest index finger).
    # 5.   For each lost item: call unequip_item(entity_id, item_id_to_remove, gs).
    #      If unequip fails due to inventory full, attempt to drop instead?
    pass

```

`basicrl/game/systems/pathfinding/flowfield.py`:

```py
# game/systems/pathfinding/flowfield.py
from typing import Final, List, Optional, Tuple, Union

import heapq
import time

import numpy as np
import structlog # Added

# --- Numba Acceleration ---
try:
    from numba import njit
    from numba.typed import Dict as NumbaDict # For type hinting Numba dict if needed

    _NUMBA_AVAILABLE = True
except ImportError:
    _NUMBA_AVAILABLE = False
    NumbaDict = dict # Fallback type hint
    def njit(func=None, **options):
        if func:
            return func
        return lambda f: f

log = structlog.get_logger(__name__)

# --- Type Aliases ---
GridPosition = Tuple[int, int]  # (y, x) format

# --- Constants ---
DIRECTIONS_8: Final[np.ndarray] = np.array(
    [[-1, 0], [-1, 1], [0, 1], [1, 1], [1, 0], [1, -1], [0, -1], [-1, -1]],
    dtype=np.int8,
)
DIAGONAL_MOVE_COST: Final[float] = np.sqrt(2.0)
DEFAULT_HEIGHT_COST_FACTOR: Final[float] = 0.5  # Multiplier for height difference cost


# --- Numba Helper Functions ---
@njit(cache=True, fastmath=True)
def _calculate_light_intensity_scalar(
    dist_sq: np.float32,
    radius_sq: np.float32,
    falloff_power: np.float32,
    min_light_level: np.float32,
) -> np.float32:
    """Calculates light intensity based on distance squared."""
    if radius_sq < 0:
        return np.float32(1.0)
    if dist_sq > radius_sq:
        return np.float32(0.0)
    if dist_sq < 1e-6:
        return np.float32(1.0)
    if radius_sq <= 1e-6:
        return np.float32(0.0)

    dist = np.sqrt(dist_sq)
    radius = np.sqrt(radius_sq)
    falloff_ratio = dist / radius
    light_value = max(np.float32(0.0), np.float32(1.0 - falloff_ratio)) ** falloff_power
    intensity = max(light_value, min_light_level)
    return max(np.float32(0.0), min(np.float32(1.0), intensity))


# Use vectorize instead of relying on hasattr in Numba
_calculate_light_intensity_vectorized = np.vectorize(
    _calculate_light_intensity_scalar,
    otypes=[np.float32],
    excluded=["radius_sq", "falloff_power", "min_light_level"],
)


@njit(cache=True, fastmath=True)
def _calculate_flow_vectors_numba(
    integration_field: np.ndarray,
    passable_map: np.ndarray,  # Need this to avoid flowing into walls
    flow_x: np.ndarray,  # int8[:] - Modified in place
    flow_y: np.ndarray,  # int8[:] - Modified in place
):
    """
    Calculates the flow vectors based on the integration field.
    Points each cell towards the neighbour with the lowest integration cost.
    """
    height, width = integration_field.shape
    infinity = np.inf

    for y in range(height):
        for x in range(width):
            if not passable_map[y, x] or integration_field[y, x] == infinity:
                flow_x[y, x] = 0
                flow_y[y, x] = 0
                continue

            min_cost = integration_field[y, x]
            best_dx, best_dy = 0, 0

            for i in range(DIRECTIONS_8.shape[0]):
                dy, dx = DIRECTIONS_8[i]
                ny, nx = y + dy, x + dx

                if 0 <= ny < height and 0 <= nx < width:
                    neighbor_cost = integration_field[ny, nx]
                    if neighbor_cost < min_cost:
                        min_cost = neighbor_cost
                        best_dx, best_dy = dx, dy

            flow_x[y, x] = best_dx
            flow_y[y, x] = best_dy


class FlowFieldPathfinder:
    """
    Manages creation of Integration and Flow Fields using NumPy.
    Includes height difference cost calculation.
    """

    def __init__(
        self,
        passable_map: np.ndarray,
        terrain_cost_map: np.ndarray,
        height_map: np.ndarray,  # ADDED
        max_traversable_step: int,  # ADDED
        height_cost_factor: float = DEFAULT_HEIGHT_COST_FACTOR,  # ADDED
    ):
        # (Validation logic largely unchanged - Source [source 1551-1553])
        if passable_map.shape != terrain_cost_map.shape:
            raise ValueError(
                "Passable map and terrain cost map must have the same shape."
            )
        if passable_map.shape != height_map.shape:  # ADDED height map shape check
            raise ValueError("Passable map and height map must have the same shape.")
        if not np.issubdtype(passable_map.dtype, np.bool_):
            raise TypeError("passable_map must be a boolean NumPy array.")
        if not np.issubdtype(terrain_cost_map.dtype, np.floating):
            raise TypeError("terrain_cost_map must be a floating-point NumPy array.")
        if not np.issubdtype(
            height_map.dtype, np.integer
        ):  # ADDED height map type check
            raise TypeError("height_map must be an integer NumPy array.")

        self.passable: np.ndarray = passable_map.copy()
        self.terrain_cost: np.ndarray = terrain_cost_map.copy()
        self.height_map: np.ndarray = height_map.copy()  # ADDED: Store height map
        self.max_traversable_step: int = max_traversable_step  # ADDED
        self.height_cost_factor: float = height_cost_factor  # ADDED

        # Ensure costs are positive
        self.terrain_cost[self.terrain_cost <= 0] = 1.0

        self.height, self.width = self.passable.shape

        # (Field initializations unchanged - Source [source 1554])
        self.integration_field: np.ndarray = np.full(
            self.passable.shape, np.inf, dtype=np.float32
        )
        self.flow_x: np.ndarray = np.zeros(self.passable.shape, dtype=np.int8)
        self.flow_y: np.ndarray = np.zeros(self.passable.shape, dtype=np.int8)
        self._last_sources: Optional[List[GridPosition]] = None

    def compute_field(self, stimulus_sources: List[GridPosition]) -> bool:
        # (Initial checks and source validation unchanged - Source [source 1555-1559])
        if not stimulus_sources:
            log.warning("No stimulus sources provided.")
            self.integration_field.fill(np.inf)
            self.flow_x.fill(0)
            self.flow_y.fill(0)
            self._last_sources = None
            return False

        if self._last_sources and set(stimulus_sources) == set(self._last_sources):
            log.info("Skipping field computation: sources unchanged.")
            return True

        log.info(
            f"Computing flow field from {len(stimulus_sources)} sources (with height cost)..."
        )
        start_time = time.time()

        self.integration_field.fill(np.inf)
        valid_sources = [
            s
            for s in stimulus_sources
            if 0 <= s[0] < self.height and 0 <= s[1] < self.width
        ]
        if not valid_sources:
            log.warning("All provided stimulus sources are out of bounds.")
            self._last_sources = list(stimulus_sources)
            return False

        pq = []  # Min-heap: [(cost, y, x)]
        for y_s, x_s in valid_sources:
            if self.passable[y_s, x_s]:
                cost = 0.0
                self.integration_field[y_s, x_s] = cost
                heapq.heappush(pq, (cost, y_s, x_s))
            else:
                log.warning(f"Source at ({y_s}, {x_s}) is on impassable terrain.")
        if not pq:
            log.warning("No valid stimulus sources on passable terrain.")
            self._last_sources = list(stimulus_sources)
            return False

                # --- Dijkstra Loop ---
        processed_count = 0
        while pq:
            cost, y, x = heapq.heappop(pq)
            processed_count += 1

            if cost > self.integration_field[y, x]:
                continue

            current_h = self.height_map[y, x]  # Get height of current cell

            # Explore neighbors
            for i in range(DIRECTIONS_8.shape[0]):
                dy, dx = DIRECTIONS_8[i]
                ny, nx = y + dy, x + dx

                # Check bounds
                if not (0 <= ny < self.height and 0 <= nx < self.width):
                    continue

                # --- MODIFIED: Check Passability AND Height Difference ---
                neighbor_h = self.height_map[ny, nx]
                delta_h = abs(neighbor_h - current_h)

                if self.passable[ny, nx] and delta_h <= self.max_traversable_step:
                    # --- Calculate Move Cost with Height Penalty ---
                    base_move_cost = self.terrain_cost[ny, nx]  # Cost to enter neighbor
                    diagonal_penalty = 0.0
                    if dy != 0 and dx != 0:  # Diagonal move
                        # Apply diagonal cost multiplier to base cost
                        diagonal_penalty = base_move_cost * (DIAGONAL_MOVE_COST - 1.0)

                    # Calculate height penalty (simple linear penalty for change)
                    height_penalty = delta_h * self.height_cost_factor
                    # Optional: Penalize uphill movement more?
                    # height_penalty = max(0, neighbor_h - current_h) * self.height_cost_factor

                    move_cost = base_move_cost + diagonal_penalty + height_penalty
                    new_cost = cost + move_cost
                    # --- End Cost Calculation ---

                    if new_cost < self.integration_field[ny, nx]:
                        self.integration_field[ny, nx] = new_cost
                        heapq.heappush(pq, (new_cost, ny, nx))
                # --- END MODIFICATION ---

        integration_time = time.time()
        log.info(
            f"  Integration field computed ({processed_count} nodes processed) in {integration_time - start_time:.4f}s"
        )

        # Calculate Flow Vectors (unchanged Numba call)
        self.flow_x.fill(0)
        self.flow_y.fill(0)
        _calculate_flow_vectors_numba(
            self.integration_field, self.passable, self.flow_x, self.flow_y
        )

        flow_time = time.time()
        log.info(f"  Flow vectors calculated in {flow_time - integration_time:.4f}s")
        log.info(f"Total field computation time: {flow_time - start_time:.4f}s")

        self._last_sources = list(stimulus_sources)
        return True

    # (get_flow_vector, get_flow_field, get_integration_field methods unchanged - Source [source 1568-1570])
    def get_flow_vector(self, y: int, x: int) -> GridPosition:
        """Returns the optimal flow vector (dx, dy) for a given cell."""
        if 0 <= y < self.height and 0 <= x < self.width:
            return (int(self.flow_x[y, x]), int(self.flow_y[y, x]))
        else:
            return (0, 0)

    def get_flow_field(self) -> Tuple[np.ndarray, np.ndarray]:
        """Returns the complete flow field arrays (dx, dy components)."""
        return self.flow_x, self.flow_y

    def get_integration_field(self) -> np.ndarray:
        """Returns the computed integration field (cost to reach source)."""
        return self.integration_field


# --- Example Usage (Updated) ---
if __name__ == "__main__":

    # 1. Create Map Data (Includes height map now)
    map_h, map_w = 50, 70
    passable = np.ones((map_h, map_w), dtype=bool)
    costs = np.ones((map_h, map_w), dtype=np.float32)
    heights = np.zeros((map_h, map_w), dtype=np.int16)  # Base height 0

    # Add walls
    passable[map_h // 2, map_w // 4 : map_w * 3 // 4] = False
    passable[map_h // 4 : map_h * 3 // 4, map_w // 2] = False
    passable[10:15, 10:15] = False  # Box wall

    # Add varying heights
    heights[15:35, 15:35] = 2  # Plateau
    heights[20:30, 20:30] = 4  # Higher plateau
    heights[map_h // 2 + 5 : map_h // 2 + 15, map_w // 2 + 10 : map_w // 2 + 20] = (
        -2
    )  # Depression

    # Add high-cost terrain
    costs[40:48, 10:30] = 5.0  # Mud costs 5x

    # Set max step allowed (e.g., 1 meter = 2 height units)
    max_step = 2
    height_factor = 0.75  # Make height changes fairly costly

    log.info(f"Created map: {map_w}x{map_h} with height variations")
    log.info(f"Max traversable step: {max_step}, Height cost factor: {height_factor}")

    # 2. Initialize Pathfinder (Pass height map and max step)
    pathfinder = FlowFieldPathfinder(
        passable,
        costs,
        heights,  # Pass height map
        max_step,  # Pass step limit
        height_cost_factor=height_factor,
    )

    # 3. Define Stimulus Source(s)
    sources: List[GridPosition] = [(map_h - 5, map_w - 5)]  # Bottom-right corner

    # Check source validity
    if not pathfinder.passable[sources[0]]:
        log.warning(f"Source {sources[0]} is initially impassable!")

    # 4. Compute the field
    success = pathfinder.compute_field(sources)

    # 5. Get Flow Vector / Cost for an Agent
    if success:
        agent_pos_y, agent_pos_x = 5, 5  # Top-left corner agent
        if pathfinder.passable[agent_pos_y, agent_pos_x]:
            flow_dx, flow_dy = pathfinder.get_flow_vector(agent_pos_y, agent_pos_x)
            log.info(
                f"Agent at ({agent_pos_y}, {agent_pos_x}) should move by: ({flow_dx}, {flow_dy})"
            )

            cost_from_agent = pathfinder.get_integration_field()[
                agent_pos_y, agent_pos_x
            ]
            if cost_from_agent == np.inf:
                log.info("Cost from agent position to source: UNREACHABLE")
            else:
                log.info(f"Cost from agent position to source: {cost_from_agent:.2f}")
        else:
            log.warning(f"Agent at ({agent_pos_y}, {agent_pos_x}) is on impassable terrain.")

        # Test agent on plateau
        agent_on_plateau_y, agent_on_plateau_x = 25, 25
        if pathfinder.passable[agent_on_plateau_y, agent_on_plateau_x]:
            flow_dx_p, flow_dy_p = pathfinder.get_flow_vector(
                agent_on_plateau_y, agent_on_plateau_x
            )
            log.info(
                f"Agent at ({agent_on_plateau_y}, {agent_on_plateau_x}) [H={heights[agent_on_plateau_y, agent_on_plateau_x]}] should move by: ({flow_dx_p}, {flow_dy_p})"
            )
            cost_from_plateau = pathfinder.get_integration_field()[
                agent_on_plateau_y, agent_on_plateau_x
            ]
            log.info(f"Cost from plateau agent to source: {cost_from_plateau:.2f}")

        # (Visualization code unchanged - Source [source 1574-1578])
        print("\nVisualizing Flow Field (Sample):")
        flow_x_field, flow_y_field = pathfinder.get_flow_field()
        viz_step = 3
        dir_symbols = {
            (-1, 0): "^",
            (-1, 1): "/",
            (0, 1): ">",
            (1, 1): "\\",
            (1, 0): "v",
            (1, -1): "/",
            (0, -1): "<",
            (-1, -1): "\\",
            (0, 0): "·",
        }
        for y in range(0, map_h, viz_step):
            row_str = ""
            for x in range(0, map_w, viz_step):
                if not passable[y, x]:
                    row_str += "###"
                elif (y, x) in sources:
                    row_str += " S "
                else:
                    dy = int(flow_y_field[y, x])
                    dx = int(flow_x_field[y, x])
                    symbol = dir_symbols.get((dy, dx), "?")
                    # Add space for alignment
                    row_str += f" {symbol} "
            print(row_str)

```

`basicrl/game/world/fov.py`:

```py
# game/world/fov.py
"""
Field of View (FOV) and Line of Sight (LOS) calculations.
Uses Numba-accelerated Iterative Shadowcasting for FOV and Bresenham for LOS.
Includes height/ceiling checks and explored tile tracking.
"""

import time
import math
from collections import deque
from typing import TypeAlias, List, Optional

import numba
import numpy as np
import structlog
from numba.typed import List as NumbaList

# --- Type Aliases ---
Point: TypeAlias = tuple[int, int]
Slope: TypeAlias = tuple[int, int]  # (y, x) representation

# Numba type definitions
sector_type = numba.types.Tuple((
    numba.int64,  # octant
    numba.int64,  # x
    numba.types.Tuple((numba.int64, numba.int64)),  # top slope (y, x)
    numba.types.Tuple((numba.int64, numba.int64)),  # bottom slope (y, x)
))

# --- Logging Setup ---
log = structlog.get_logger(__name__)

# --- Configuration Constants ---
BASE_THRESHOLD: int = 1
CLOSE_RANGE_SQ_THRESHOLD: int = 16
CLOSE_RANGE_DIVISOR: int = 8
FAR_RANGE_DIVISOR: int = 16
_THRESHOLD_AT_CUTOFF: int = CLOSE_RANGE_SQ_THRESHOLD // CLOSE_RANGE_DIVISOR
MAX_SECTORS: int = 10000  # Safety limit for sector processing

# --- Numba Helper Functions ---
@numba.njit(cache=True, inline="always")
def slope_greater(slope1_yx: Slope, y: int, x: int) -> bool:
    """Check if slope1 is greater than the slope to point (y,x)."""
    slope_y, slope_x = slope1_yx
    if slope_x == 0 and x == 0: return slope_y > y
    if slope_x == 0: return True if x > 0 else False
    if x == 0: return False if slope_x > 0 else True
    return slope_y * x > slope_x * y

@numba.njit(cache=True, inline="always")
def slope_greater_or_equal(slope1_yx: Slope, y: int, x: int) -> bool:
    """Check if slope1 is greater than or equal to the slope to point (y,x)."""
    slope_y, slope_x = slope1_yx
    if slope_x == 0 and x == 0: return slope_y >= y
    if slope_x == 0: return True if x >= 0 else False
    if x == 0: return False if slope_x >= 0 else True
    return slope_y * x >= slope_x * y

@numba.njit(cache=True, inline="always")
def slope_less(slope1_yx: Slope, y: int, x: int) -> bool:
    """Check if slope1 is less than the slope to point (y,x)."""
    slope_y, slope_x = slope1_yx
    if slope_x == 0 and x == 0: return slope_y < y
    if slope_x == 0: return False if x > 0 else True
    if x == 0: return True if slope_x > 0 else False
    return slope_y * x < slope_x * y

@numba.njit(cache=True, inline="always")
def slope_less_or_equal(slope1_yx: Slope, y: int, x: int) -> bool:
    """Check if slope1 is less than or equal to the slope to point (y,x)."""
    slope_y, slope_x = slope1_yx
    if slope_x == 0 and x == 0: return slope_y <= y
    if slope_x == 0: return False if x > 0 else True
    if x == 0: return True if slope_x > 0 else False
    return slope_y * x <= slope_x * y

@numba.njit(cache=True)
def _transform_coords(octant_x: int, octant_y: int, octant: int, origin_xy: Point) -> Point:
    """Transform coordinates based on octant."""
    ox, oy = origin_xy
    nx, ny = ox, oy
    if octant == 0: nx += octant_x; ny -= octant_y
    elif octant == 1: nx += octant_y; ny -= octant_x
    elif octant == 2: nx -= octant_y; ny -= octant_x
    elif octant == 3: nx -= octant_x; ny -= octant_y
    elif octant == 4: nx -= octant_x; ny += octant_y
    elif octant == 5: nx -= octant_y; ny += octant_x
    elif octant == 6: nx += octant_y; ny += octant_x
    elif octant == 7: nx += octant_x; ny += octant_y
    return nx, ny

@numba.njit(cache=True)
def blocks_light_at(
    octant_x: int, octant_y: int, octant: int, origin_xy: Point,
    grid_shape: tuple[int, int], opaque_grid: np.ndarray,
    height_map: np.ndarray, ceiling_map: np.ndarray, origin_height: int
) -> bool:
    """Check if a tile blocks light, considering bounds, opacity, and height."""
    nx, ny = _transform_coords(octant_x, octant_y, octant, origin_xy)
    width, height = grid_shape
    
    if not (0 <= nx < width and 0 <= ny < height):
        return True
    
    if opaque_grid[ny, nx]:
        return True
    
    # Height and ceiling checks
    target_h = height_map[ny, nx]
    target_ceiling = ceiling_map[ny, nx]
    
    if target_ceiling <= origin_height:
        return True  # Ceiling too low
    
    # Calculate height difference threshold based on distance
    dist_sq = octant_x * octant_x + octant_y * octant_y
    threshold = BASE_THRESHOLD
    
    if dist_sq <= CLOSE_RANGE_SQ_THRESHOLD:
        threshold = dist_sq // CLOSE_RANGE_DIVISOR
    else:
        threshold = _THRESHOLD_AT_CUTOFF + (dist_sq - CLOSE_RANGE_SQ_THRESHOLD) // FAR_RANGE_DIVISOR
    
    return abs(target_h - origin_height) > threshold

@numba.njit(cache=True)
def set_visible_at(
    octant_x: int, octant_y: int, octant: int, origin_xy: Point,
    grid_shape: tuple[int, int], visible_grid: np.ndarray, explored_grid: np.ndarray
) -> None:
    """Mark a tile as visible and explored."""
    nx, ny = _transform_coords(octant_x, octant_y, octant, origin_xy)
    width, height = grid_shape
    if 0 <= nx < width and 0 <= ny < height:
        visible_grid[ny, nx] = True
        explored_grid[ny, nx] = True

@numba.njit(cache=True)
def is_in_range(octant_x: int, octant_y: int, range_limit_sq: int | float) -> bool:
    """Check if coordinates are within the range limit."""
    return (octant_x * octant_x + octant_y * octant_y) <= range_limit_sq


@numba.njit(cache=True)
def _compute_fov_numba_core(
    origin_xy: Point, range_limit: int, opaque_grid: np.ndarray,
    height_map: np.ndarray, ceiling_map: np.ndarray, origin_height: int,
    visible_grid: np.ndarray, explored_grid: np.ndarray
) -> None:
    """Numba-optimized FOV core computation."""
    range_limit_sq = range_limit * range_limit
    grid_shape = opaque_grid.shape
    
    # Initialize with Numba-compatible list
    sectors = NumbaList()
    for octant in range(8):
        sectors.append((octant, 1, (1, 1), (0, 1)))
    
    sector_count = 0
    while len(sectors) > 0 and sector_count < MAX_SECTORS:
        sector_count += 1
        
        # Pop first element (FIFO behavior)
        current = sectors.pop(0)
        octant, current_x = current[0], current[1]
        top_slope, bottom_slope = current[2], current[3]
        
        blocked = False
        for current_y in range(current_x, range_limit + 1):
            if not is_in_range(current_x, current_y, range_limit_sq):
                break

            cell_top_y = 2 * current_y + 1
            cell_bottom_y = 2 * current_y - 1
            cell_x = 2 * current_x
            center_y, center_x = current_y, current_x

            if slope_less(top_slope, center_y, center_x) or \
               slope_less_or_equal(bottom_slope, center_y, center_x):
                continue

            set_visible_at(current_x, current_y, octant, origin_xy, 
                         grid_shape, visible_grid, explored_grid)

            cell_blocks = blocks_light_at(
                current_x, current_y, octant, origin_xy, grid_shape,
                opaque_grid, height_map, ceiling_map, origin_height
            )

            if blocked:
                if cell_blocks:
                    continue
                else:
                    blocked = False
                    bottom_slope = (cell_top_y, cell_x)
            else:
                if cell_blocks:
                    blocked = True
                    if slope_greater(top_slope, cell_bottom_y, cell_x):
                        sectors.append((octant, current_x + 1, 
                                     top_slope, (cell_bottom_y, cell_x)))
                    top_slope = (cell_top_y, cell_x)

        if not blocked:
            sectors.append((octant, current_x + 1, top_slope, bottom_slope))

def _compute_fov_python_fallback(
    origin_xy: Point, range_limit: int, opaque_grid: np.ndarray,
    height_map: np.ndarray, ceiling_map: np.ndarray, origin_height: int,
    visible_grid: np.ndarray, explored_grid: np.ndarray
) -> None:
    """Python fallback implementation for debugging and fallback."""
    range_limit_sq = range_limit * range_limit
    grid_shape = opaque_grid.shape
    
    sectors: deque = deque()
    for octant in range(8):
        sectors.append((octant, 1, (1, 1), (0, 1)))
    
    sector_count = 0
    while sectors and sector_count < MAX_SECTORS:
        sector_count += 1
        
        octant, current_x, top_slope, bottom_slope = sectors.popleft()
        
        blocked = False
        for current_y in range(current_x, range_limit + 1):
            if not is_in_range(current_x, current_y, range_limit_sq):
                break

            cell_top_y = 2 * current_y + 1
            cell_bottom_y = 2 * current_y - 1
            cell_x = 2 * current_x
            center_y, center_x = current_y, current_x

            if slope_less(top_slope, center_y, center_x) or \
               slope_less_or_equal(bottom_slope, center_y, center_x):
                continue

            set_visible_at(current_x, current_y, octant, origin_xy,
                         grid_shape, visible_grid, explored_grid)

            cell_blocks = blocks_light_at(
                current_x, current_y, octant, origin_xy, grid_shape,
                opaque_grid, height_map, ceiling_map, origin_height
            )

            if blocked:
                if cell_blocks:
                    continue
                else:
                    blocked = False
                    bottom_slope = (cell_top_y, cell_x)
            else:
                if cell_blocks:
                    blocked = True
                    if slope_greater(top_slope, cell_bottom_y, cell_x):
                        sectors.append((octant, current_x + 1,
                                     top_slope, (cell_bottom_y, cell_x)))
                    top_slope = (cell_top_y, cell_x)

        if not blocked:
            sectors.append((octant, current_x + 1, top_slope, bottom_slope))


def compute_fov(
    origin_xy: Point, range_limit: int, opaque_grid: np.ndarray,
    height_map: np.ndarray, ceiling_map: np.ndarray, origin_height: int,
    visible_grid: np.ndarray, explored_grid: np.ndarray
) -> None:
    """
    Public interface for FOV computation.
    Attempts Numba-optimized version first, falls back to Python implementation.
    """
    func_log = log.bind(
        origin=origin_xy,
        range_limit=range_limit,
        grid_shape=opaque_grid.shape
    )
    func_log.info("Starting FOV computation")
    start_time = time.perf_counter()

    # Input validation
    if not isinstance(opaque_grid, np.ndarray) or opaque_grid.ndim != 2:
        raise TypeError("opaque_grid must be a 2D NumPy array")
    if opaque_grid.shape != height_map.shape or opaque_grid.shape != ceiling_map.shape:
        raise ValueError("Grid shapes must match")
    if not np.issubdtype(opaque_grid.dtype, np.bool_):
        opaque_grid = opaque_grid.astype(np.bool_)
    if not np.issubdtype(visible_grid.dtype, np.bool_) or \
       not np.issubdtype(explored_grid.dtype, np.bool_):
        raise TypeError("visible_grid and explored_grid must be boolean arrays")
    
    height, width = opaque_grid.shape
    ox, oy = origin_xy
    if not (0 <= ox < width and 0 <= oy < height):
        raise ValueError("Origin coordinates out of bounds")

    # Initialize visibility
    visible_grid.fill(False)
    visible_grid[oy, ox] = True
    explored_grid[oy, ox] = True

    try:
        # Try Numba-optimized version first
        _compute_fov_numba_core(
            origin_xy, range_limit, opaque_grid,
            height_map, ceiling_map, origin_height,
            visible_grid, explored_grid
        )
    except Exception as e:
        func_log.warning("Numba FOV failed, falling back to Python", error=str(e))
        try:
            # Fall back to Python version
            _compute_fov_python_fallback(
                origin_xy, range_limit, opaque_grid,
                height_map, ceiling_map, origin_height,
                visible_grid, explored_grid
            )
        except Exception as e:
            func_log.error("FOV calculation failed", error=str(e), exc_info=True)
            visible_grid.fill(False)
            visible_grid[oy, ox] = True

    end_time = time.perf_counter()
    duration_ms = (end_time - start_time) * 1000
    func_log.info(
        "FOV computation finished",
        duration_ms=f"{duration_ms:.2f}",
        visible_count=np.sum(visible_grid)
    )

@numba.njit(cache=True)
def line_of_sight(
    x0: int, y0: int, x1: int, y1: int, transparency_map: np.ndarray
) -> bool:
    """
    Bresenham line-of-sight implementation.
    Returns True if there's a clear line of sight between points.
    """
    height, width = transparency_map.shape
    if not (0 <= y0 < height and 0 <= x0 < width and \
           0 <= y1 < height and 0 <= x1 < width):
        return False

    dx = abs(x1 - x0)
    dy = -abs(y1 - y0)
    sx = 1 if x0 < x1 else -1
    sy = 1 if y0 < y1 else -1
    err = dx + dy
    
    xi, yi = x0, y0
    n_steps = max(dx, -dy)
    
    for _ in range(n_steps):
        e2 = 2 * err
        next_xi, next_yi = xi, yi
        step_x, step_y = False, False
        
        if e2 >= dy:
            if xi == x1:
                break
            err += dy
            next_xi += sx
            step_x = True
            
        if e2 <= dx:
            if yi == y1:
                break
            err += dx
            next_yi += sy
            step_y = True
            
        check_x, check_y = xi, yi
        if step_x:
            check_x += sx
        if step_y:
            check_y += sy
            
        if not transparency_map[check_y, check_x]:
            return False
            
        xi, yi = check_x, check_y
        if xi == x1 and yi == y1:
            break
            
    return True


```

`basicrl/game/world/game_map.py`:

```py
# game/world/game_map.py
from typing import Final, NamedTuple, Set, Tuple # Ensure Set, Tuple are imported

import numpy as np
import structlog

# Ensure correct import for the *new* FOV function
from game.world.fov import compute_fov

log = structlog.get_logger()

TILE_ID_FLOOR: Final[int] = 0
TILE_ID_WALL: Final[int] = 1


class TileType(NamedTuple):
    walkable: bool
    transparent: bool
    tile_index: int
    color_fg: tuple[int, int, int]
    color_bg: tuple[int, int, int]


TILE_TYPES: Final[dict[int, TileType]] = {
    TILE_ID_FLOOR: TileType(
        walkable=True,
        transparent=True,
        tile_index=2, # Example index for floor tile in tileset
        color_fg=(200, 200, 200),
        color_bg=(10, 10, 30),
    ),
    TILE_ID_WALL: TileType(
        walkable=False,
        transparent=False,
        tile_index=38, # Example index for wall tile in tileset
        color_fg=(180, 180, 180),
        color_bg=(30, 30, 50),
    ),
    # Add other tile types here...
}


def get_transparency_map(tiles: np.ndarray) -> np.ndarray:
    """Creates a boolean array indicating transparency based on TILE_TYPES."""
    # Initialize with False (opaque)
    transparency = np.zeros_like(tiles, dtype=bool)
    # Iterate through defined types and set transparency
    for tile_id, tile_type in TILE_TYPES.items():
        transparency[tiles == tile_id] = tile_type.transparent
    return transparency


class GameMap:
    def __init__(self, width: int, height: int):
        """
        Initializes the game map with dimensions and default tile arrays.
        """
        if width <= 0 or height <= 0:
            log.error("Invalid map dimensions", width=width, height=height)
            raise ValueError("Map width and height must be positive integers.")
        self._width = width
        self._height = height
        log.info("Initializing GameMap", width=self._width, height=self._height)

        # Core map data arrays - Use C order for compatibility with many libraries
        self.tiles: np.ndarray = np.full(
            (height, width), fill_value=TILE_ID_WALL, dtype=np.uint8, order="C"
        )
        # Visibility/Exploration state
        self.explored: np.ndarray = np.zeros((height, width), dtype=bool, order="C")
        self.visible: np.ndarray = np.zeros((height, width), dtype=bool, order="C")
        # Cached transparency map
        self.transparent: np.ndarray = get_transparency_map(self.tiles)
        # Height and Ceiling maps
        self.height_map: np.ndarray = np.zeros(
            (height, width), dtype=np.int16, order="C"
        )
        self.ceiling_map: np.ndarray = np.zeros(
            (height, width), dtype=np.int16, order="C"
        )
        log.debug("GameMap arrays initialized", shape=(height, width))

    def update_tile_transparency(self) -> None:
        """Recalculates the transparency map based on current self.tiles."""
        # This should be called whenever self.tiles is modified (e.g., after digging)
        self.transparent = np.zeros((self._height, self._width), dtype=bool)
        for tile_id, tile_type in TILE_TYPES.items():
            self.transparent[self.tiles == tile_id] = tile_type.transparent
        transparent_count = np.sum(self.transparent)
        log.info("Transparency map updated", transparent_count=transparent_count)

    @property
    def width(self) -> int:
        return self._width

    @property
    def height(self) -> int:
        return self._height

    def in_bounds(self, x: int, y: int) -> bool:
        """Checks if the given coordinates are within the map boundaries."""
        return 0 <= x < self._width and 0 <= y < self._height

    def is_walkable(self, x: int, y: int) -> bool:
        """Checks if the tile at (x, y) is walkable."""
        if not self.in_bounds(x, y):
            return False
        tile_id = self.tiles[y, x]
        tile_type = TILE_TYPES.get(tile_id)
        return tile_type.walkable if tile_type else False

    def is_transparent(self, x: int, y: int) -> bool:
        """Checks if the tile at (x, y) is transparent (for FOV)."""
        if not self.in_bounds(x, y):
            # Treat out of bounds as non-transparent for FOV calculations
            return False
        # Directly use the cached transparency map
        return self.transparent[y, x]

    # --- MODIFIED compute_fov method ---
    def compute_fov(self, x: int, y: int, radius: int) -> None:
        """
        Calculates FOV from (x, y) by calling the updated FOV function,
        passing all necessary map data correctly (including explored map).
        """
        log_context = {"origin": (x, y), "radius": radius}
        if not self.in_bounds(x, y):
            log.warning(
                "FOV origin out of bounds in GameMap.compute_fov", **log_context
            )
            self.visible.fill(False) # Clear visibility if origin invalid
            return

        # Prepare arguments for the imported compute_fov function
        origin_xy = (x, y)
        range_limit = radius
        opaque_grid = ~self.transparent # Invert transparency map
        height_map = self.height_map
        ceiling_map = self.ceiling_map
        visible_grid = self.visible # Pass visible grid to be modified
        explored_grid = self.explored # Pass explored grid to be modified

        try:
            # Ensure origin height is integer
            origin_height = int(height_map[y, x])

            # *** ADDED LOGGING ***
            log.debug(
                "Calling fov.compute_fov",
                **log_context,
                origin_h=origin_height,
                opaque_sum=np.sum(opaque_grid),
                visible_in_sum=np.sum(visible_grid),
                explored_in_sum=np.sum(explored_grid),
            )
            visible_grid.fill(False) # Clear visibility before calculation

            # Call the imported FOV function with all arguments
            compute_fov(
                origin_xy=origin_xy,
                range_limit=range_limit,
                opaque_grid=opaque_grid,
                height_map=height_map,
                ceiling_map=ceiling_map,
                origin_height=origin_height,
                visible_grid=visible_grid, # Pass visible grid
                explored_grid=explored_grid, # Pass explored grid
            )

            # Ensure origin is visible post-calculation
            if self.in_bounds(x,y) and not visible_grid[y, x]:
                 log.warning("Origin not visible after FOV, forcing.", **log_context)
                 visible_grid[y, x] = True
                 explored_grid[y, x] = True # Ensure explored too

            # *** ADDED LOGGING ***
            visible_count = np.sum(visible_grid)
            explored_count = np.sum(explored_grid)
            log.debug(
                "fov.compute_fov call finished",
                **log_context,
                visible_out_sum=visible_count,
                explored_out_sum=explored_count,
            )
            # Add a warning if FOV calculation results in nothing visible
            if visible_count == 0 and radius > 0:
                 log.warning("FOV calculation resulted in zero visible tiles (excluding origin forced visibility).", **log_context)

        except IndexError:
            log.error(
                "IndexError getting origin height in GameMap.compute_fov", **log_context
            )
            self.visible.fill(False)
            if self.in_bounds(x, y):
                self.visible[y, x] = True # Ensure player tile is visible on error
        except Exception as e:
            log.error(
                "Unexpected error during compute_fov call",
                error=str(e),
                exc_info=True,
                **log_context
            )
            # Fallback: Ensure at least the player's tile is visible
            self.visible.fill(False)
            if self.in_bounds(x, y):
                self.visible[y, x] = True

    # --- END MODIFIED compute_fov method ---

    def create_test_room(self) -> None:
        """Creates a simple rectangular room for testing."""
        room_x, room_y = self.width // 4, self.height // 4
        room_w, room_h = self.width // 2, self.height // 2

        # Ensure indices are within bounds for slicing
        x_start = max(0, room_x)
        y_start = max(0, room_y)
        x_end = min(self.width, room_x + room_w)
        y_end = min(self.height, room_y + room_h)

        # Assign FLOOR tile ID to the room area
        self.tiles[y_start:y_end, x_start:x_end] = TILE_ID_FLOOR

        # --- Assign default height/ceiling to test room ---
        test_floor_height = 0
        test_ceiling_height = 6 # e.g., 3 meters high
        self.height_map[y_start:y_end, x_start:x_end] = test_floor_height
        self.ceiling_map[y_start:y_end, x_start:x_end] = test_ceiling_height
        # --- End Assignment ---

        # Update transparency after changing tiles
        self.update_tile_transparency()
        log.info(
            "Created test room",
            x_start=x_start,
            y_start=y_start,
            x_end=x_end,
            y_end=y_end,
            floor_h=test_floor_height,
            ceil_h=test_ceiling_height,
        )
        transparent_count = np.sum(self.transparent)
        log.info("Map contains transparent tiles", count=transparent_count)

    def update_fov_with_tracking(
        self, x: int, y: int, radius: int
    ) -> Set[Tuple[int, int]]: # Use Tuple, Set imported
        """
        Updates FOV and returns a set of (x, y) coordinates where
        visibility changed (either became visible or hidden).
        """
        previous_visible = self.visible.copy()
        self.compute_fov(x, y, radius) # Calls the updated method
        changed_positions = set()

        # Optimization: Use np.where for potentially faster comparison on large maps
        diff_indices = np.argwhere(previous_visible != self.visible)
        for y_idx, x_idx in diff_indices:
            changed_positions.add((int(x_idx), int(y_idx))) # Store as (x, y)

        if changed_positions:
            log.debug("Visibility changed", changed_count=len(changed_positions))
        return changed_positions

```

`basicrl/game/world/procgen.py`:

```py
# basicrl/game/world/procgen.py
from typing import Iterator, List, NamedTuple, Tuple, Union

import structlog # Added

# Assuming GameRNG is importable
try:
    # If game_rng.py is in utils
    from utils.game_rng import GameRNG
except ImportError:
    # Fallback if it's directly importable (e.g., added to path)
    try:
        from game_rng import GameRNG
    except ImportError:
        # Define a dummy if not found - error will occur at runtime if used
        log_fallback = structlog.get_logger()
        log_fallback.error("CRITICAL: GameRNG class not found.")
        GameRNG = object # Dummy type


# Assuming GameMap is importable
try:
    from game.world.game_map import TILE_ID_FLOOR, GameMap
except ImportError:
    # Fallback import path if needed
    try:
         from basicrl.game.world.game_map import TILE_ID_FLOOR, GameMap
    except ImportError:
        log_fallback = structlog.get_logger()
        log_fallback.error("CRITICAL: GameMap class or TILE_ID_FLOOR not found.")
        # Define dummies
        GameMap = object
        TILE_ID_FLOOR = 0


log = structlog.get_logger() # Added

# --- Configuration ---
MIN_LEAF_SIZE = 6
ROOM_MAX_SIZE_RATIO = 0.8
ROOM_MIN_SIZE = 4
MAX_BSP_DEPTH = 10
DEFAULT_ROOM_CEILING_OFFSET = 6 # 3.0 meters
DEFAULT_CORRIDOR_CEILING_OFFSET = 4 # 2.0 meters


class Rect(NamedTuple):
    """A rectangle on the map."""
    x1: int
    y1: int
    x2: int
    y2: int

    @property
    def center(self) -> Tuple[int, int]:
        """Center coordinates of the rectangle."""
        center_x = (self.x1 + self.x2) // 2
        center_y = (self.y1 + self.y2) // 2
        return center_x, center_y

    @property
    def width(self) -> int:
        return self.x2 - self.x1 + 1

    @property
    def height(self) -> int:
        return self.y2 - self.y1 + 1

    def intersects(self, other: "Rect") -> bool:
        """Returns True if this rectangle intersects with another one."""
        return (
            self.x1 <= other.x2
            and self.x2 >= other.x1
            and self.y1 <= other.y2
            and self.y2 >= other.y1
        )

    def carve(self, game_map: GameMap, floor_height: int, ceiling_height: int) -> None:
        """Carves this rectangle as floor tiles onto the game map with specified heights."""
        # Ensure GameMap is the correct type before proceeding
        if not isinstance(game_map, GameMap) or GameMap is object:
             log.error("Carve called with invalid GameMap object")
             return

        y_start = max(0, self.y1)
        y_end = min(game_map.height, self.y2 + 1)
        x_start = max(0, self.x1)
        x_end = min(game_map.width, self.x2 + 1)

        log_context = {
            "rect": self,
            "floor_h": floor_height,
            "ceil_h": ceiling_height,
            "y_slice": f"{y_start}:{y_end}",
            "x_slice": f"{x_start}:{x_end}",
        }

        if y_start < y_end and x_start < x_end:
            try:
                # Set tile type
                game_map.tiles[y_start:y_end, x_start:x_end] = TILE_ID_FLOOR
                # Assign Height/Ceiling
                game_map.height_map[y_start:y_end, x_start:x_end] = floor_height
                game_map.ceiling_map[y_start:y_end, x_start:x_end] = ceiling_height
                log.debug("Carved rectangle area", **log_context)
            except IndexError:
                log.error("IndexError during carving", **log_context)
            except Exception as e:
                log.error(
                    "Error during carving", error=str(e), exc_info=True, **log_context
                )
        else:
            log.warning("Attempted to carve zero-size area", **log_context)


class BSPNode:
    """Represents a node in the BSP tree."""
    def __init__(
        self, rect: Rect, base_height: int = 0
    ): # base_height represents floor height
        self.rect: Rect = rect
        self.left: Union[BSPNode, None] = None
        self.right: Union[BSPNode, None] = None
        self.room: Union[Rect, None] = None
        self.corridors: List[Rect] = []
        self.base_height: int = base_height # Floor height for this node's region

    @property
    def is_leaf(self) -> bool:
        return self.left is None and self.right is None

    def get_leaves(self) -> Iterator["BSPNode"]:
        if self.is_leaf:
            yield self
        else:
            if self.left:
                yield from self.left.get_leaves()
            if self.right:
                yield from self.right.get_leaves()

    def get_room(self) -> Union[Rect, None]:
        if self.room:
            return self.room
        room = None
        if self.left:
            room = self.left.get_room()
        if not room and self.right:
            room = self.right.get_room()
        return room


def _split_node_recursive(node: BSPNode, rng: GameRNG, depth: int) -> bool:
    """Recursively splits a BSP node. Returns True if split occurred."""
    # Ensure GameRNG is the correct type before proceeding
    if not isinstance(rng, GameRNG) or GameRNG is object:
         log.error("Split called with invalid GameRNG object")
         return False

    log.debug(
        "Attempting BSP split",
        depth=depth,
        max_depth=MAX_BSP_DEPTH,
        is_leaf=node.is_leaf,
        rect=node.rect,
        base_h=node.base_height,
    )

    if depth >= MAX_BSP_DEPTH:
        log.debug("Split aborted: Max depth reached", depth=depth)
        return False

    # Decide split direction
    split_horizontally: bool
    if (
        node.rect.width > node.rect.height
        and node.rect.width / node.rect.height >= 1.25
    ):
        split_horizontally = False
    elif (
        node.rect.height > node.rect.width
        and node.rect.height / node.rect.width >= 1.25
    ):
        split_horizontally = True
    else:
        split_horizontally = rng.coin_flip()[0] == "heads"

    # Check if node is large enough
    max_size = node.rect.height if split_horizontally else node.rect.width
    min_req_size = MIN_LEAF_SIZE * 2
    if max_size <= min_req_size:
        log.debug(
            "Split aborted: Node too small",
            dimension_size=max_size,
            min_required=min_req_size,
            split_direction="horizontal" if split_horizontally else "vertical",
            rect=node.rect,
        )
        return False

    # Determine split position
    split_margin = MIN_LEAF_SIZE
    parent_height = node.base_height # Get parent floor height

    # Basic Height Inheritance (No variation yet)
    left_h, right_h = parent_height, parent_height

    if split_horizontally:
        split_y = rng.get_int(node.rect.y1 + split_margin, node.rect.y2 - split_margin)
        node.left = BSPNode(
            Rect(node.rect.x1, node.rect.y1, node.rect.x2, split_y - 1), left_h
        )
        node.right = BSPNode(
            Rect(node.rect.x1, split_y, node.rect.x2, node.rect.y2), right_h
        )
        log.debug(
            "Split node horizontally",
            depth=depth,
            y_split=split_y,
            left_rect=node.left.rect,
            left_h=left_h,
            right_rect=node.right.rect,
            right_h=right_h,
        )
    else: # Split vertically
        split_x = rng.get_int(node.rect.x1 + split_margin, node.rect.x2 - split_margin)
        node.left = BSPNode(
            Rect(node.rect.x1, node.rect.y1, split_x - 1, node.rect.y2), left_h
        )
        node.right = BSPNode(
            Rect(split_x, node.rect.y1, node.rect.x2, node.rect.y2), right_h
        )
        log.debug(
            "Split node vertically",
            depth=depth,
            x_split=split_x,
            left_rect=node.left.rect,
            left_h=left_h,
            right_rect=node.right.rect,
            right_h=right_h,
        )

    # Recursively split children
    _split_node_recursive(node.left, rng, depth + 1)
    _split_node_recursive(node.right, rng, depth + 1)

    return True # This node was split


def _create_rooms_in_leaves(root_node: BSPNode, rng: GameRNG):
    """Creates rooms within the leaf nodes of the BSP tree."""
    # Ensure GameRNG is the correct type before proceeding
    if not isinstance(rng, GameRNG) or GameRNG is object:
         log.error("Create rooms called with invalid GameRNG object")
         return

    log.debug("Creating rooms in leaves...")
    room_count = 0
    skipped_count = 0
    for leaf in root_node.get_leaves():
        # Room size calculation
        max_w = int(leaf.rect.width * ROOM_MAX_SIZE_RATIO)
        max_h = int(leaf.rect.height * ROOM_MAX_SIZE_RATIO)
        room_w = rng.get_int(ROOM_MIN_SIZE, max(ROOM_MIN_SIZE, max_w))
        room_h = rng.get_int(ROOM_MIN_SIZE, max(ROOM_MIN_SIZE, max_h))

        # Room position calculation
        room_x1 = rng.get_int(
            leaf.rect.x1, max(leaf.rect.x1, leaf.rect.x2 - room_w + 1)
        )
        room_y1 = rng.get_int(
            leaf.rect.y1, max(leaf.rect.y1, leaf.rect.y2 - room_h + 1)
        )
        room_x2 = room_x1 + room_w - 1
        room_y2 = room_y1 + room_h - 1

        # Clamp coordinates
        room_x1 = max(leaf.rect.x1, room_x1)
        room_y1 = max(leaf.rect.y1, room_y1)
        room_x2 = min(leaf.rect.x2, room_x2)
        room_y2 = min(leaf.rect.y2, room_y2)

        # Check final size and create room
        if (
            room_x2 >= room_x1 + ROOM_MIN_SIZE - 1
            and room_y2 >= room_y1 + ROOM_MIN_SIZE - 1
        ):
            leaf.room = Rect(room_x1, room_y1, room_x2, room_y2)
            room_count += 1
            log.debug(
                "Defined room",
                room_rect=leaf.room,
                leaf_rect=leaf.rect,
                base_floor_h=leaf.base_height,
            )
        else:
            skipped_count += 1
            log.debug(
                "Skipped room creation (too small)",
                leaf_rect=leaf.rect,
                final_w=(room_x2 - room_x1 + 1),
                final_h=(room_y2 - room_y1 + 1),
            )
    log.info("Room definition finished", created=room_count, skipped=skipped_count)


def _carve_tunnel(
    x1: int,
    y1: int,
    x2: int,
    y2: int,
    start_floor_h: int,
    end_floor_h: int, # Use floor heights
    game_map: GameMap,
    rng: GameRNG,
) -> List[Rect]:
    """
    Carves an L-shaped tunnel between two points, assigning simple heights.
    Returns list of Rects carved.
    """
    # Ensure GameMap and GameRNG are valid
    if not isinstance(game_map, GameMap) or GameMap is object:
         log.error("Carve tunnel called with invalid GameMap object")
         return []
    if not isinstance(rng, GameRNG) or GameRNG is object:
         log.error("Carve tunnel called with invalid GameRNG object")
         return []

    log_context = {
        "start_pos": (x1, y1),
        "end_pos": (x2, y2),
        "start_floor_h": start_floor_h,
        "end_floor_h": end_floor_h,
    }
    log.debug("Carving tunnel", **log_context)
    carved_rects = []

    # Simple height assignment: use start height for first segment, end height for second.
    # Define ceiling based on floor height.
    corridor_ceil_h1 = start_floor_h + DEFAULT_CORRIDOR_CEILING_OFFSET
    corridor_ceil_h2 = end_floor_h + DEFAULT_CORRIDOR_CEILING_OFFSET

    if rng.coin_flip()[0] == "heads": # Horizontal first, then vertical
        # Carve horizontal segment (use start_floor_h)
        cx1, cy1, cx2, cy2 = min(x1, x2), y1, max(x1, x2), y1
        h_tunnel = Rect(cx1, cy1, cx2, cy2)
        h_tunnel.carve(game_map, start_floor_h, corridor_ceil_h1)
        carved_rects.append(h_tunnel)
        log.debug(
            "Carved horizontal tunnel segment",
            rect=h_tunnel,
            floor_h=start_floor_h,
            ceil_h=corridor_ceil_h1,
        )

        # Carve vertical segment (use end_floor_h)
        vx1, vy1, vx2, vy2 = x2, min(y1, y2), x2, max(y1, y2)
        # Ensure correct range for vertical segment (don't overlap corners)
        if y1 < y2:
            vy1 = y1 + 1 # Start one step down if moving down
        if y1 > y2:
            vy2 = y1 - 1 # Start one step up if moving up
        if vy1 <= vy2: # Only carve if valid range
            v_tunnel = Rect(vx1, vy1, vx2, vy2)
            v_tunnel.carve(game_map, end_floor_h, corridor_ceil_h2)
            carved_rects.append(v_tunnel)
            log.debug(
                "Carved vertical tunnel segment",
                rect=v_tunnel,
                floor_h=end_floor_h,
                ceil_h=corridor_ceil_h2,
            )

    else: # Vertical first, then horizontal
        # Carve vertical segment (use start_floor_h)
        vx1, vy1, vx2, vy2 = x1, min(y1, y2), x1, max(y1, y2)
        v_tunnel = Rect(vx1, vy1, vx2, vy2)
        v_tunnel.carve(game_map, start_floor_h, corridor_ceil_h1)
        carved_rects.append(v_tunnel)
        log.debug(
            "Carved vertical tunnel segment",
            rect=v_tunnel,
            floor_h=start_floor_h,
            ceil_h=corridor_ceil_h1,
        )

        # Carve horizontal segment (use end_floor_h)
        cx1, cy1, cx2, cy2 = min(x1, x2), y2, max(x1, x2), y2
        # Ensure correct range for horizontal segment
        if x1 < x2:
            cx1 = x1 + 1
        if x1 > x2:
            cx2 = x1 - 1
        if cx1 <= cx2: # Only carve if valid range
            h_tunnel = Rect(cx1, cy1, cx2, cy2)
            h_tunnel.carve(game_map, end_floor_h, corridor_ceil_h2)
            carved_rects.append(h_tunnel)
            log.debug(
                "Carved horizontal tunnel segment",
                rect=h_tunnel,
                floor_h=end_floor_h,
                ceil_h=corridor_ceil_h2,
            )

    return carved_rects


def _connect_rooms(node: BSPNode, game_map: GameMap, rng: GameRNG):
    """Recursively connects rooms in sibling nodes."""
     # Ensure GameMap and GameRNG are valid
    if not isinstance(game_map, GameMap) or GameMap is object:
         log.error("Connect rooms called with invalid GameMap object")
         return
    if not isinstance(rng, GameRNG) or GameRNG is object:
         log.error("Connect rooms called with invalid GameRNG object")
         return

    log.debug("Connecting rooms for node", rect=node.rect, is_leaf=node.is_leaf)
    if node.is_leaf:
        return

    # Recursively connect children first
    if node.left:
        _connect_rooms(node.left, game_map, rng)
    if node.right:
        _connect_rooms(node.right, game_map, rng)

    # Connect the rooms in the direct children (if they exist)
    left_room = node.left.get_room() if node.left else None
    right_room = node.right.get_room() if node.right else None

    if left_room and right_room:
        # Pick random points within each room to connect
        lx, ly = rng.get_int(left_room.x1, left_room.x2), rng.get_int(
            left_room.y1, left_room.y2
        )
        rx, ry = rng.get_int(right_room.x1, right_room.x2), rng.get_int(
            right_room.y1, right_room.y2
        )

        # Get Base Floor Heights
        start_h = (
            node.left.base_height if node.left else 0
        ) # Default if something went wrong
        end_h = node.right.base_height if node.right else 0

        log_context = {
            "left_center": left_room.center,
            "right_center": right_room.center,
            "connect_left": (lx, ly),
            "connect_right": (rx, ry),
            "start_floor_h": start_h,
            "end_floor_h": end_h,
        }
        log.debug("Connecting sibling rooms", **log_context)

        # Pass floor heights to carve_tunnel
        node.corridors = _carve_tunnel(lx, ly, rx, ry, start_h, end_h, game_map, rng)
    elif left_room and not right_room:
         log.debug("Skipping connection: Right child has no room", left_center=left_room.center)
    elif not left_room and right_room:
         log.debug("Skipping connection: Left child has no room", right_center=right_room.center)
    else:
         log.debug("Skipping connection: Neither child has a room.")


def generate_dungeon(
    game_map: GameMap, map_width: int, map_height: int, seed: Union[int, None] = None
) -> Tuple[int, int]:
    """
    Generates a dungeon layout using BSP trees, populating height maps.
    """
    # Ensure GameMap is valid
    if not isinstance(game_map, GameMap) or GameMap is object:
         log.error("Generate dungeon called with invalid GameMap object")
         raise TypeError("Invalid GameMap object passed to generate_dungeon")

    log.info(
        "Starting dungeon generation", width=map_width, height=map_height, seed=seed
    )
    try:
        rng = GameRNG(seed=seed)
    except NameError:
        log.critical("GameRNG class not available for dungeon generation.")
        raise RuntimeError("GameRNG unavailable.")


    # 1. Initialize map (done by GameMap constructor)

    # 2. Create root BSP node with initial height 0
    initial_base_height = 0
    root_node = BSPNode(Rect(1, 1, map_width - 2, map_height - 2), initial_base_height)
    log.debug(
        "Created root BSP node", rect=root_node.rect, base_height=initial_base_height
    )

    # 3. Recursively split the map
    log.info("Splitting BSP tree...")
    _split_node_recursive(root_node, rng, 0) # Populates base_height in children

    # 4. Create rooms in the leaf nodes (defines leaf.room Rects)
    log.info("Defining rooms...")
    _create_rooms_in_leaves(root_node, rng)

    # 5. Carve rooms onto the map (uses leaf.base_height and default ceiling offset)
    all_rooms: List[Rect] = []
    log.info("Carving rooms onto map...")
    for leaf in root_node.get_leaves():
        if leaf.room:
            room_floor_h = leaf.base_height
            room_ceil_h = room_floor_h + DEFAULT_ROOM_CEILING_OFFSET
            leaf.room.carve(game_map, room_floor_h, room_ceil_h)
            all_rooms.append(leaf.room)
    log.info("Rooms carved", count=len(all_rooms))

    if not all_rooms:
        log.error("BSP generation failed to create any rooms!")
        raise RuntimeError("BSP generation failed to create any rooms!")

    # 6. Connect rooms (passes node base_heights to _carve_tunnel)
    log.info("Connecting rooms...")
    _connect_rooms(root_node, game_map, rng)

    # 7. Determine player start position
    first_room = all_rooms[0]
    player_start_x, player_start_y = first_room.center

    # *** ADDED LOGGING ***
    log.info(
        "Determined player start position",
        pos=(player_start_x, player_start_y),
        first_room_rect=first_room, # Log the room rect too
        room_center=first_room.center,
    )
    # *** END LOGGING ***


    # 8. Update map transparency
    log.info("Updating transparency map...")
    game_map.update_tile_transparency()

    log.info(
        "Dungeon generation complete", player_start=(player_start_x, player_start_y)
    )
    return player_start_x, player_start_y

```

`basicrl/main.py`:

```py
# main.py
import logging
import sys
import time
import tomllib # Standard in Python 3.11+
from pathlib import Path
from typing import Any
from typing import Dict as PyDict # Use PyDict for Dict type alias

import numpy as np # Added for map printing
import structlog
import yaml
from PySide6.QtWidgets import QApplication
from structlog.stdlib import add_log_level, add_logger_name # Ensure these are imported

# Use absolute imports relative to project root (basicrl)
from engine.main_loop import MainLoop
from engine.window_manager import WindowManager
from game.game_state import GameState
# Ensure GameMap and TILE IDs are importable
try:
    from game.world.game_map import TILE_ID_FLOOR, TILE_ID_WALL, GameMap
except ImportError:
    try:
         from basicrl.game.world.game_map import TILE_ID_FLOOR, TILE_ID_WALL, GameMap
    except ImportError:
        structlog.get_logger().error("CRITICAL: Failed to import GameMap and TILE IDs.")
        GameMap = object # Dummy
        TILE_ID_FLOOR, TILE_ID_WALL = 0, 1 # Dummies

# Ensure procgen is importable
try:
    from game.world.procgen import generate_dungeon
except ImportError:
    try:
        from basicrl.game.world.procgen import generate_dungeon
    except ImportError:
         structlog.get_logger().error("CRITICAL: Failed to import generate_dungeon.")
         def generate_dungeon(*args, **kwargs): raise NotImplementedError("generate_dungeon not imported")


# --- Paths relative to this script's location ---
SCRIPT_DIR = Path(__file__).parent.resolve()
CONFIG_DIR = SCRIPT_DIR / "config"
FONTS_DIR = SCRIPT_DIR / "fonts"

CONFIG_FILE = CONFIG_DIR / "config.yaml"
ITEMS_CONFIG_FILE = CONFIG_DIR / "items.yaml"
EFFECTS_CONFIG_FILE = CONFIG_DIR / "effects.yaml"
KEYBINDINGS_FILE = CONFIG_DIR / "keybindings.toml"
SETTINGS_FILE = CONFIG_DIR / "settings.toml"
# --- End Paths ---


# --- Structlog Setup ---
def setup_logging():
    """Configures structlog for console output."""
    # Ensure standard logging is configured first if not done elsewhere
    logging.basicConfig(level=logging.DEBUG, format="%(message)s") # Set base level for stdlib

    structlog.configure(
        processors=[
            structlog.contextvars.merge_contextvars,
            add_logger_name,
            add_log_level,
            structlog.processors.TimeStamper(fmt="iso", utc=False),
            structlog.dev.ConsoleRenderer(colors=True),
        ],
        # *** MODIFIED: Changed level to DEBUG ***
        wrapper_class=structlog.make_filtering_bound_logger(logging.DEBUG),
        # *** END MODIFICATION ***
        context_class=dict,
        logger_factory=structlog.stdlib.LoggerFactory(),
        cache_logger_on_first_use=True,
    )

log = structlog.get_logger() # module-level logger
# --- End Structlog Setup ---


# --- Config Loading Helpers ---
def load_toml_config(config_path: Path, config_name: str) -> PyDict[str, Any]:
    """Loads a TOML configuration file."""
    # (Implementation unchanged)
    if not config_path.is_file():
        log.error(f"{config_name} config file not found", path=str(config_path))
        return {}
    try:
        with config_path.open("rb") as f: # tomllib requires bytes mode
            config_data = tomllib.load(f)
        log.info(f"{config_name} config loaded", path=str(config_path))
        return config_data
    except tomllib.TOMLDecodeError as e:
        log.error( f"Error parsing TOML for {config_name}", path=str(config_path), error=str(e), exc_info=True, )
        return {}
    except Exception as e:
        log.error( f"Failed to load {config_name} config", path=str(config_path), error=str(e), exc_info=True, )
        return {}

def load_yaml_config(config_path: Path, config_name: str) -> PyDict[str, Any]:
    """Loads a generic YAML configuration file."""
    # (Implementation unchanged)
    if not config_path.is_file():
        log.error(f"{config_name} config file not found", path=str(config_path))
        raise FileNotFoundError( f"{config_name} configuration file not found: {config_path}" )
    try:
        with config_path.open("r") as f:
            config_data = yaml.safe_load(f)
        if config_data is None:
            log.warning(f"{config_name} config file is empty.", path=str(config_path))
            return {}
        log.info(f"{config_name} config loaded", path=str(config_path))
        return config_data
    except yaml.YAMLError as e:
        log.error( f"Error parsing YAML for {config_name}", path=str(config_path), error=str(e), exc_info=True, )
        raise # Re-raise parsing errors
    except Exception as e:
        log.error( f"Failed to load {config_name} config", path=str(config_path), error=str(e), exc_info=True, )
        raise # Re-raise other load errors

# --- End Config Loading ---


# --- Debug Map Printing Function ---
def print_map_section(game_map: GameMap, center_x: int, center_y: int, radius: int = 5):
    """Prints a section of the map centered around (x, y) to the console."""
    # (Implementation unchanged)
    if not isinstance(game_map, GameMap): log.warning("Cannot print map section: Invalid GameMap object."); return
    y_min = max(0, center_y - radius); y_max = min(game_map.height, center_y + radius + 1)
    x_min = max(0, center_x - radius); x_max = min(game_map.width, center_x + radius + 1)
    print(f"\n--- Map Section around ({center_x},{center_y}) ---")
    header = "   " + "".join([f"{x:<3}" for x in range(x_min, x_max)])
    print(header); print("  " + "-" * (len(header)-2))
    for y in range(y_min, y_max):
        row_str = f"{y:<2}|"
        for x in range(x_min, x_max):
            char = "?"; tile_id = game_map.tiles[y, x]
            if tile_id == TILE_ID_FLOOR: char = "."
            elif tile_id == TILE_ID_WALL: char = "#"
            else: char = str(tile_id)
            if x == center_x and y == center_y: row_str += f"[{char}]"
            else: row_str += f" {char} "
        print(row_str)
    print("------------------------------------\n")
# --- End Debug Map Printing ---


def main() -> None:
    """Main entry point for the application."""
    setup_logging()
    log.info("Application starting...")
    log.info(f"Script directory: {SCRIPT_DIR}")
    log.info(f"Config directory: {CONFIG_DIR}")

    app = QApplication(sys.argv)

    try:
        # --- Load Configurations ---
        config = load_yaml_config(CONFIG_FILE, "Main")
        item_templates = load_yaml_config(ITEMS_CONFIG_FILE, "Items").get( "templates", {} )
        effect_definitions = load_yaml_config(EFFECTS_CONFIG_FILE, "Effects").get( "effects", {} )
        keybindings_config = load_toml_config(KEYBINDINGS_FILE, "Keybindings")
        settings_config = load_toml_config(SETTINGS_FILE, "Settings")
        log.info( "Configurations loaded", items=len(item_templates), effects=len(effect_definitions),
                  keybindings=len(keybindings_config.get("bindings", {})), settings=len(settings_config) )

        # --- Extract Config Values ---
        # (Extraction logic unchanged)
        initial_tileset_folder_rel: str = config.get( "initial_tileset_folder", "fonts/classic_roguelike_sliced_svgs" )
        initial_tileset_folder_abs = SCRIPT_DIR / initial_tileset_folder_rel
        log.debug( "Resolved initial tileset path", relative=initial_tileset_folder_rel, absolute=str(initial_tileset_folder_abs), )
        initial_tile_width: int = config.get("initial_tile_width", 16)
        initial_tile_height: int = config.get("initial_tile_height", 16)
        min_tile_size: int = config.get("minimum_tile_size", 4)
        scroll_debounce_ms: int = config.get("scroll_scale_debounce_ms", 200)
        resize_debounce_ms: int = config.get("resize_debounce_ms", 100)
        map_width: int = config.get("map_width", 80)
        map_height: int = config.get("map_height", 50)
        dungeon_seed_cfg = config.get("dungeon_seed")
        player_glyph: int = config.get("player_glyph", 113)
        player_start_hp: int = config.get("player_start_hp", 30)
        player_fov_radius: int = config.get("player_fov_radius", 8)
        lighting_config = config.get("lighting", {})
        lighting_ambient: float = lighting_config.get("ambient_level", 0.15)
        lighting_min_fov: float = lighting_config.get("min_fov_level", 0.25)
        lighting_falloff: float = lighting_config.get("falloff_power", 1.5)
        hv_config = config.get("height_visualization", {})
        vis_enabled_default: bool = hv_config.get("enabled_by_default", False)
        vis_max_diff: int = hv_config.get("max_relative_difference", 10)
        vis_color_high: list = hv_config.get("color_high", [255, 255, 0])
        vis_color_mid: list = hv_config.get("color_mid", [0, 255, 0])
        vis_color_low: list = hv_config.get("color_low", [0, 128, 255])
        vis_blend_factor: float = hv_config.get("blend_factor", 0.3)
        gameplay_rules = config.get("gameplay_rules", {})
        max_traversable_step: int = gameplay_rules.get("max_traversable_step", 2)
        log.info("Main configuration values extracted.")

        # --- Game Initialization ---
        log.info("Creating game map", width=map_width, height=map_height)
        game_map = GameMap(width=map_width, height=map_height)

        log.info("Generating dungeon layout...")
        dungeon_seed = ( int(time.time() * 1000) if dungeon_seed_cfg is None else int(dungeon_seed_cfg) )
        rng_seed_to_pass = dungeon_seed
        log.info("Using dungeon seed", seed=dungeon_seed)
        player_start_pos = generate_dungeon( game_map, map_width, map_height, seed=dungeon_seed )
        log.info("Dungeon generated", player_start=player_start_pos)

        # Print map section after generation
        print_map_section(game_map, player_start_pos[0], player_start_pos[1], radius=10)

        log.info("Initializing game state...")
        game_state = GameState(
            existing_map=game_map, player_start_pos=player_start_pos,
            player_glyph=player_glyph, player_start_hp=player_start_hp,
            player_fov_radius=player_fov_radius, item_templates=item_templates,
            effect_definitions=effect_definitions, rng_seed=rng_seed_to_pass,
        )

        # Spawn initial items
        if player_start_pos:
            spawn_x, spawn_y = player_start_pos
            if hasattr(game_state, "item_registry") and game_state.item_registry:
                log.info("Spawning initial items near player", pos=(spawn_x, spawn_y))
                game_state.item_registry.create_item( "simple_dagger", "ground", x=spawn_x + 1, y=spawn_y )
                game_state.item_registry.create_item( "cookies", "ground", x=spawn_x, y=spawn_y + 1 )
                game_state.item_registry.create_item( "torch", "ground", x=spawn_x - 1, y=spawn_y )
            else: log.warning( "ItemRegistry not found in GameState, skipping initial item spawn." )

        log.info("Creating main window...")
        # WindowManager Instantiation
        window = WindowManager(
            app_config=config, keybindings_config=keybindings_config,
            initial_tileset_path=str(initial_tileset_folder_abs),
            initial_tile_width=initial_tile_width, initial_tile_height=initial_tile_height,
            map_width=game_state.map_width, map_height=game_state.map_height,
            min_tile_size_cfg=min_tile_size, scroll_debounce_cfg=scroll_debounce_ms,
            resize_debounce_cfg=resize_debounce_ms,
        )

        log.info("Initializing main loop...")
        main_loop = MainLoop(
            game_state=game_state, window=window,
            vis_enabled_default=vis_enabled_default, vis_max_diff=vis_max_diff,
            vis_color_high=vis_color_high, vis_color_mid=vis_color_mid,
            vis_color_low=vis_color_low, vis_blend_factor=vis_blend_factor,
            max_traversable_step=max_traversable_step, lighting_ambient=lighting_ambient,
            lighting_min_fov=lighting_min_fov, lighting_falloff=lighting_falloff,
        )
        window.set_main_loop(main_loop)

    # --- Exception Handling ---
    except FileNotFoundError as e:
        log.critical("Required file not found during init", error=str(e), exc_info=True)
        sys.exit(f"Initialization failed: File not found - {e}")
    except KeyError as e:
        log.critical( "Missing required key, possibly in config", key=str(e), exc_info=True )
        sys.exit(f"Configuration failed: Missing key {e}")
    except TypeError as e:
        log.critical("Fatal Type Error during init", error=str(e), exc_info=True)
        sys.exit(f"Initialization failed (TypeError): {e}")
    except Exception as e:
        log.critical("Fatal initialization error", error=str(e), exc_info=True)
        sys.exit(f"Initialization failed: {e}")
    # --- End Exception Handling ---

    log.info("Showing window and starting application loop...")
    window.show()
    sys.exit(app.exec()) # Start the Qt event loop


if __name__ == "__main__":
    main()

```

`basicrl/output.log`:

```log
Running: python -m basicrl.main 
[2m2025-05-14T23:07:35.562461[0m [[32m[1minfo     [0m] [1mApplication starting...       [0m [[0m[1m[34m__main__[0m][0m
[2m2025-05-14T23:07:35.562539[0m [[32m[1minfo     [0m] [1mScript directory: /home/earnest/code_projects/basicrl[0m [[0m[1m[34m__main__[0m][0m
[2m2025-05-14T23:07:35.562607[0m [[32m[1minfo     [0m] [1mConfig directory: /home/earnest/code_projects/basicrl/config[0m [[0m[1m[34m__main__[0m][0m
[2m2025-05-14T23:07:35.619250[0m [[32m[1minfo     [0m] [1mMain config loaded            [0m [[0m[1m[34m__main__[0m][0m [36mpath[0m=[35m/home/earnest/code_projects/basicrl/config/config.yaml[0m
[2m2025-05-14T23:07:35.629415[0m [[32m[1minfo     [0m] [1mItems config loaded           [0m [[0m[1m[34m__main__[0m][0m [36mpath[0m=[35m/home/earnest/code_projects/basicrl/config/items.yaml[0m
[2m2025-05-14T23:07:35.631010[0m [[32m[1minfo     [0m] [1mEffects config loaded         [0m [[0m[1m[34m__main__[0m][0m [36mpath[0m=[35m/home/earnest/code_projects/basicrl/config/effects.yaml[0m
[2m2025-05-14T23:07:35.631936[0m [[32m[1minfo     [0m] [1mKeybindings config loaded     [0m [[0m[1m[34m__main__[0m][0m [36mpath[0m=[35m/home/earnest/code_projects/basicrl/config/keybindings.toml[0m
[2m2025-05-14T23:07:35.632022[0m [[32m[1minfo     [0m] [1mSettings config loaded        [0m [[0m[1m[34m__main__[0m][0m [36mpath[0m=[35m/home/earnest/code_projects/basicrl/config/settings.toml[0m
[2m2025-05-14T23:07:35.632071[0m [[32m[1minfo     [0m] [1mConfigurations loaded         [0m [[0m[1m[34m__main__[0m][0m [36meffects[0m=[35m4[0m [36mitems[0m=[35m15[0m [36mkeybindings[0m=[35m5[0m [36msettings[0m=[35m0[0m
[2m2025-05-14T23:07:35.632120[0m [[32m[1mdebug    [0m] [1mResolved initial tileset path [0m [[0m[1m[34m__main__[0m][0m [36mabsolute[0m=[35m/home/earnest/code_projects/basicrl/fonts/classic_roguelike_sliced_svgs[0m [36mrelative[0m=[35mfonts/classic_roguelike_sliced_svgs[0m
[2m2025-05-14T23:07:35.632161[0m [[32m[1minfo     [0m] [1mMain configuration values extracted.[0m [[0m[1m[34m__main__[0m][0m
[2m2025-05-14T23:07:35.632187[0m [[32m[1minfo     [0m] [1mCreating game map             [0m [[0m[1m[34m__main__[0m][0m [36mheight[0m=[35m50[0m [36mwidth[0m=[35m80[0m
[2m2025-05-14T23:07:35.632234[0m [[32m[1minfo     [0m] [1mInitializing GameMap          [0m [[0m[1m[34mgame.world.game_map[0m][0m [36mheight[0m=[35m50[0m [36mwidth[0m=[35m80[0m
[2m2025-05-14T23:07:35.632332[0m [[32m[1mdebug    [0m] [1mGameMap arrays initialized    [0m [[0m[1m[34mgame.world.game_map[0m][0m [36mshape[0m=[35m(50, 80)[0m
[2m2025-05-14T23:07:35.632369[0m [[32m[1minfo     [0m] [1mGenerating dungeon layout...  [0m [[0m[1m[34m__main__[0m][0m
[2m2025-05-14T23:07:35.632394[0m [[32m[1minfo     [0m] [1mUsing dungeon seed            [0m [[0m[1m[34m__main__[0m][0m [36mseed[0m=[35m1747260455632[0m
[2m2025-05-14T23:07:35.632431[0m [[32m[1minfo     [0m] [1mStarting dungeon generation   [0m [[0m[1m[34mgame.world.procgen[0m][0m [36mheight[0m=[35m50[0m [36mseed[0m=[35m1747260455632[0m [36mwidth[0m=[35m80[0m
[2m2025-05-14T23:07:35.634948[0m [[32m[1mdebug    [0m] [1mCreated root BSP node         [0m [[0m[1m[34mgame.world.procgen[0m][0m [36mbase_height[0m=[35m0[0m [36mrect[0m=[35mRect(x1=1, y1=1, x2=78, y2=48)[0m
[2m2025-05-14T23:07:35.634998[0m [[32m[1minfo     [0m] [1mSplitting BSP tree...         [0m [[0m[1m[34mgame.world.procgen[0m][0m
[2m2025-05-14T23:07:35.635030[0m [[32m[1mdebug    [0m] [1mAttempting BSP split          [0m [[0m[1m[34mgame.world.procgen[0m][0m [36mbase_h[0m=[35m0[0m [36mdepth[0m=[35m0[0m [36mis_leaf[0m=[35mTrue[0m [36mmax_depth[0m=[35m10[0m [36mrect[0m=[35mRect(x1=1, y1=1, x2=78, y2=48)[0m
[2m2025-05-14T23:07:35.635091[0m [[32m[1mdebug    [0m] [1mSplit node vertically         [0m [[0m[1m[34mgame.world.procgen[0m][0m [36mdepth[0m=[35m0[0m [36mleft_h[0m=[35m0[0m [36mleft_rect[0m=[35mRect(x1=1, y1=1, x2=34, y2=48)[0m [36mright_h[0m=[35m0[0m [36mright_rect[0m=[35mRect(x1=35, y1=1, x2=78, y2=48)[0m [36mx_split[0m=[35m35[0m
[2m2025-05-14T23:07:35.635136[0m [[32m[1mdebug    [0m] [1mAttempting BSP split          [0m [[0m[1m[34mgame.world.procgen[0m][0m [36mbase_h[0m=[35m0[0m [36mdepth[0m=[35m1[0m [36mis_leaf[0m=[35mTrue[0m [36mmax_depth[0m=[35m10[0m [36mrect[0m=[35mRect(x1=1, y1=1, x2=34, y2=48)[0m
[2m2025-05-14T23:07:35.635182[0m [[32m[1mdebug    [0m] [1mSplit node horizontally       [0m [[0m[1m[34mgame.world.procgen[0m][0m [36mdepth[0m=[35m1[0m [36mleft_h[0m=[35m0[0m [36mleft_rect[0m=[35mRect(x1=1, y1=1, x2=34, y2=6)[0m [36mright_h[0m=[35m0[0m [36mright_rect[0m=[35mRect(x1=1, y1=7, x2=34, y2=48)[0m [36my_split[0m=[35m7[0m
[2m2025-05-14T23:07:35.635215[0m [[32m[1mdebug    [0m] [1mAttempting BSP split          [0m [[0m[1m[34mgame.world.procgen[0m][0m [36mbase_h[0m=[35m0[0m [36mdepth[0m=[35m2[0m [36mis_leaf[0m=[35mTrue[0m [36mmax_depth[0m=[35m10[0m [36mrect[0m=[35mRect(x1=1, y1=1, x2=34, y2=6)[0m
[2m2025-05-14T23:07:35.635263[0m [[32m[1mdebug    [0m] [1mSplit node vertically         [0m [[0m[1m[34mgame.world.procgen[0m][0m [36mdepth[0m=[35m2[0m [36mleft_h[0m=[35m0[0m [36mleft_rect[0m=[35mRect(x1=1, y1=1, x2=16, y2=6)[0m [36mright_h[0m=[35m0[0m [36mright_rect[0m=[35mRect(x1=17, y1=1, x2=34, y2=6)[0m [36mx_split[0m=[35m17[0m
[2m2025-05-14T23:07:35.635297[0m [[32m[1mdebug    [0m] [1mAttempting BSP split          [0m [[0m[1m[34mgame.world.procgen[0m][0m [36mbase_h[0m=[35m0[0m [36mdepth[0m=[35m3[0m [36mis_leaf[0m=[35mTrue[0m [36mmax_depth[0m=[35m10[0m [36mrect[0m=[35mRect(x1=1, y1=1, x2=16, y2=6)[0m
[2m2025-05-14T23:07:35.635338[0m [[32m[1mdebug    [0m] [1mSplit node vertically         [0m [[0m[1m[34mgame.world.procgen[0m][0m [36mdepth[0m=[35m3[0m [36mleft_h[0m=[35m0[0m [36mleft_rect[0m=[35mRect(x1=1, y1=1, x2=7, y2=6)[0m [36mright_h[0m=[35m0[0m [36mright_rect[0m=[35mRect(x1=8, y1=1, x2=16, y2=6)[0m [36mx_split[0m=[35m8[0m
[2m2025-05-14T23:07:35.635371[0m [[32m[1mdebug    [0m] [1mAttempting BSP split          [0m [[0m[1m[34mgame.world.procgen[0m][0m [36mbase_h[0m=[35m0[0m [36mdepth[0m=[35m4[0m [36mis_leaf[0m=[35mTrue[0m [36mmax_depth[0m=[35m10[0m [36mrect[0m=[35mRect(x1=1, y1=1, x2=7, y2=6)[0m
[2m2025-05-14T23:07:35.635410[0m [[32m[1mdebug    [0m] [1mSplit aborted: Node too small [0m [[0m[1m[34mgame.world.procgen[0m][0m [36mdimension_size[0m=[35m7[0m [36mmin_required[0m=[35m12[0m [36mrect[0m=[35mRect(x1=1, y1=1, x2=7, y2=6)[0m [36msplit_direction[0m=[35mvertical[0m
[2m2025-05-14T23:07:35.635442[0m [[32m[1mdebug    [0m] [1mAttempting BSP split          [0m [[0m[1m[34mgame.world.procgen[0m][0m [36mbase_h[0m=[35m0[0m [36mdepth[0m=[35m4[0m [36mis_leaf[0m=[35mTrue[0m [36mmax_depth[0m=[35m10[0m [36mrect[0m=[35mRect(x1=8, y1=1, x2=16, y2=6)[0m
[2m2025-05-14T23:07:35.635471[0m [[32m[1mdebug    [0m] [1mSplit aborted: Node too small [0m [[0m[1m[34mgame.world.procgen[0m][0m [36mdimension_size[0m=[35m9[0m [36mmin_required[0m=[35m12[0m [36mrect[0m=[35mRect(x1=8, y1=1, x2=16, y2=6)[0m [36msplit_direction[0m=[35mvertical[0m
[2m2025-05-14T23:07:35.635500[0m [[32m[1mdebug    [0m] [1mAttempting BSP split          [0m [[0m[1m[34mgame.world.procgen[0m][0m [36mbase_h[0m=[35m0[0m [36mdepth[0m=[35m3[0m [36mis_leaf[0m=[35mTrue[0m [36mmax_depth[0m=[35m10[0m [36mrect[0m=[35mRect(x1=17, y1=1, x2=34, y2=6)[0m
[2m2025-05-14T23:07:35.635541[0m [[32m[1mdebug    [0m] [1mSplit node vertically         [0m [[0m[1m[34mgame.world.procgen[0m][0m [36mdepth[0m=[35m3[0m [36mleft_h[0m=[35m0[0m [36mleft_rect[0m=[35mRect(x1=17, y1=1, x2=23, y2=6)[0m [36mright_h[0m=[35m0[0m [36mright_rect[0m=[35mRect(x1=24, y1=1, x2=34, y2=6)[0m [36mx_split[0m=[35m24[0m
[2m2025-05-14T23:07:35.635587[0m [[32m[1mdebug    [0m] [1mAttempting BSP split          [0m [[0m[1m[34mgame.world.procgen[0m][0m [36mbase_h[0m=[35m0[0m [36mdepth[0m=[35m4[0m [36mis_leaf[0m=[35mTrue[0m [36mmax_depth[0m=[35m10[0m [36mrect[0m=[35mRect(x1=17, y1=1, x2=23, y2=6)[0m
[2m2025-05-14T23:07:35.635631[0m [[32m[1mdebug    [0m] [1mSplit aborted: Node too small [0m [[0m[1m[34mgame.world.procgen[0m][0m [36mdimension_size[0m=[35m7[0m [36mmin_required[0m=[35m12[0m [36mrect[0m=[35mRect(x1=17, y1=1, x2=23, y2=6)[0m [36msplit_direction[0m=[35mvertical[0m
[2m2025-05-14T23:07:35.635664[0m [[32m[1mdebug    [0m] [1mAttempting BSP split          [0m [[0m[1m[34mgame.world.procgen[0m][0m [36mbase_h[0m=[35m0[0m [36mdepth[0m=[35m4[0m [36mis_leaf[0m=[35mTrue[0m [36mmax_depth[0m=[35m10[0m [36mrect[0m=[35mRect(x1=24, y1=1, x2=34, y2=6)[0m
[2m2025-05-14T23:07:35.635693[0m [[32m[1mdebug    [0m] [1mSplit aborted: Node too small [0m [[0m[1m[34mgame.world.procgen[0m][0m [36mdimension_size[0m=[35m11[0m [36mmin_required[0m=[35m12[0m [36mrect[0m=[35mRect(x1=24, y1=1, x2=34, y2=6)[0m [36msplit_direction[0m=[35mvertical[0m
[2m2025-05-14T23:07:35.635722[0m [[32m[1mdebug    [0m] [1mAttempting BSP split          [0m [[0m[1m[34mgame.world.procgen[0m][0m [36mbase_h[0m=[35m0[0m [36mdepth[0m=[35m2[0m [36mis_leaf[0m=[35mTrue[0m [36mmax_depth[0m=[35m10[0m [36mrect[0m=[35mRect(x1=1, y1=7, x2=34, y2=48)[0m
[2m2025-05-14T23:07:35.635770[0m [[32m[1mdebug    [0m] [1mSplit node vertically         [0m [[0m[1m[34mgame.world.procgen[0m][0m [36mdepth[0m=[35m2[0m [36mleft_h[0m=[35m0[0m [36mleft_rect[0m=[35mRect(x1=1, y1=7, x2=14, y2=48)[0m [36mright_h[0m=[35m0[0m [36mright_rect[0m=[35mRect(x1=15, y1=7, x2=34, y2=48)[0m [36mx_split[0m=[35m15[0m
[2m2025-05-14T23:07:35.635805[0m [[32m[1mdebug    [0m] [1mAttempting BSP split          [0m [[0m[1m[34mgame.world.procgen[0m][0m [36mbase_h[0m=[35m0[0m [36mdepth[0m=[35m3[0m [36mis_leaf[0m=[35mTrue[0m [36mmax_depth[0m=[35m10[0m [36mrect[0m=[35mRect(x1=1, y1=7, x2=14, y2=48)[0m
[2m2025-05-14T23:07:35.635842[0m [[32m[1mdebug    [0m] [1mSplit node horizontally       [0m [[0m[1m[34mgame.world.procgen[0m][0m [36mdepth[0m=[35m3[0m [36mleft_h[0m=[35m0[0m [36mleft_rect[0m=[35mRect(x1=1, y1=7, x2=14, y2=41)[0m [36mright_h[0m=[35m0[0m [36mright_rect[0m=[35mRect(x1=1, y1=42, x2=14, y2=48)[0m [36my_split[0m=[35m42[0m
[2m2025-05-14T23:07:35.635873[0m [[32m[1mdebug    [0m] [1mAttempting BSP split          [0m [[0m[1m[34mgame.world.procgen[0m][0m [36mbase_h[0m=[35m0[0m [36mdepth[0m=[35m4[0m [36mis_leaf[0m=[35mTrue[0m [36mmax_depth[0m=[35m10[0m [36mrect[0m=[35mRect(x1=1, y1=7, x2=14, y2=41)[0m
[2m2025-05-14T23:07:35.635910[0m [[32m[1mdebug    [0m] [1mSplit node horizontally       [0m [[0m[1m[34mgame.world.procgen[0m][0m [36mdepth[0m=[35m4[0m [36mleft_h[0m=[35m0[0m [36mleft_rect[0m=[35mRect(x1=1, y1=7, x2=14, y2=12)[0m [36mright_h[0m=[35m0[0m [36mright_rect[0m=[35mRect(x1=1, y1=13, x2=14, y2=41)[0m [36my_split[0m=[35m13[0m
[2m2025-05-14T23:07:35.635942[0m [[32m[1mdebug    [0m] [1mAttempting BSP split          [0m [[0m[1m[34mgame.world.procgen[0m][0m [36mbase_h[0m=[35m0[0m [36mdepth[0m=[35m5[0m [36mis_leaf[0m=[35mTrue[0m [36mmax_depth[0m=[35m10[0m [36mrect[0m=[35mRect(x1=1, y1=7, x2=14, y2=12)[0m
[2m2025-05-14T23:07:35.635981[0m [[32m[1mdebug    [0m] [1mSplit node vertically         [0m [[0m[1m[34mgame.world.procgen[0m][0m [36mdepth[0m=[35m5[0m [36mleft_h[0m=[35m0[0m [36mleft_rect[0m=[35mRect(x1=1, y1=7, x2=7, y2=12)[0m [36mright_h[0m=[35m0[0m [36mright_rect[0m=[35mRect(x1=8, y1=7, x2=14, y2=12)[0m [36mx_split[0m=[35m8[0m
[2m2025-05-14T23:07:35.636012[0m [[32m[1mdebug    [0m] [1mAttempting BSP split          [0m [[0m[1m[34mgame.world.procgen[0m][0m [36mbase_h[0m=[35m0[0m [36mdepth[0m=[35m6[0m [36mis_leaf[0m=[35mTrue[0m [36mmax_depth[0m=[35m10[0m [36mrect[0m=[35mRect(x1=1, y1=7, x2=7, y2=12)[0m
[2m2025-05-14T23:07:35.636052[0m [[32m[1mdebug    [0m] [1mSplit aborted: Node too small [0m [[0m[1m[34mgame.world.procgen[0m][0m [36mdimension_size[0m=[35m7[0m [36mmin_required[0m=[35m12[0m [36mrect[0m=[35mRect(x1=1, y1=7, x2=7, y2=12)[0m [36msplit_direction[0m=[35mvertical[0m
[2m2025-05-14T23:07:35.636083[0m [[32m[1mdebug    [0m] [1mAttempting BSP split          [0m [[0m[1m[34mgame.world.procgen[0m][0m [36mbase_h[0m=[35m0[0m [36mdepth[0m=[35m6[0m [36mis_leaf[0m=[35mTrue[0m [36mmax_depth[0m=[35m10[0m [36mrect[0m=[35mRect(x1=8, y1=7, x2=14, y2=12)[0m
[2m2025-05-14T23:07:35.636117[0m [[32m[1mdebug    [0m] [1mSplit aborted: Node too small [0m [[0m[1m[34mgame.world.procgen[0m][0m [36mdimension_size[0m=[35m7[0m [36mmin_required[0m=[35m12[0m [36mrect[0m=[35mRect(x1=8, y1=7, x2=14, y2=12)[0m [36msplit_direction[0m=[35mvertical[0m
[2m2025-05-14T23:07:35.636146[0m [[32m[1mdebug    [0m] [1mAttempting BSP split          [0m [[0m[1m[34mgame.world.procgen[0m][0m [36mbase_h[0m=[35m0[0m [36mdepth[0m=[35m5[0m [36mis_leaf[0m=[35mTrue[0m [36mmax_depth[0m=[35m10[0m [36mrect[0m=[35mRect(x1=1, y1=13, x2=14, y2=41)[0m
[2m2025-05-14T23:07:35.636190[0m [[32m[1mdebug    [0m] [1mSplit node horizontally       [0m [[0m[1m[34mgame.world.procgen[0m][0m [36mdepth[0m=[35m5[0m [36mleft_h[0m=[35m0[0m [36mleft_rect[0m=[35mRect(x1=1, y1=13, x2=14, y2=22)[0m [36mright_h[0m=[35m0[0m [36mright_rect[0m=[35mRect(x1=1, y1=23, x2=14, y2=41)[0m [36my_split[0m=[35m23[0m
[2m2025-05-14T23:07:35.636221[0m [[32m[1mdebug    [0m] [1mAttempting BSP split          [0m [[0m[1m[34mgame.world.procgen[0m][0m [36mbase_h[0m=[35m0[0m [36mdepth[0m=[35m6[0m [36mis_leaf[0m=[35mTrue[0m [36mmax_depth[0m=[35m10[0m [36mrect[0m=[35mRect(x1=1, y1=13, x2=14, y2=22)[0m
[2m2025-05-14T23:07:35.636260[0m [[32m[1mdebug    [0m] [1mSplit node vertically         [0m [[0m[1m[34mgame.world.procgen[0m][0m [36mdepth[0m=[35m6[0m [36mleft_h[0m=[35m0[0m [36mleft_rect[0m=[35mRect(x1=1, y1=13, x2=6, y2=22)[0m [36mright_h[0m=[35m0[0m [36mright_rect[0m=[35mRect(x1=7, y1=13, x2=14, y2=22)[0m [36mx_split[0m=[35m7[0m
[2m2025-05-14T23:07:35.636290[0m [[32m[1mdebug    [0m] [1mAttempting BSP split          [0m [[0m[1m[34mgame.world.procgen[0m][0m [36mbase_h[0m=[35m0[0m [36mdepth[0m=[35m7[0m [36mis_leaf[0m=[35mTrue[0m [36mmax_depth[0m=[35m10[0m [36mrect[0m=[35mRect(x1=1, y1=13, x2=6, y2=22)[0m
[2m2025-05-14T23:07:35.636319[0m [[32m[1mdebug    [0m] [1mSplit aborted: Node too small [0m [[0m[1m[34mgame.world.procgen[0m][0m [36mdimension_size[0m=[35m10[0m [36mmin_required[0m=[35m12[0m [36mrect[0m=[35mRect(x1=1, y1=13, x2=6, y2=22)[0m [36msplit_direction[0m=[35mhorizontal[0m
[2m2025-05-14T23:07:35.636346[0m [[32m[1mdebug    [0m] [1mAttempting BSP split          [0m [[0m[1m[34mgame.world.procgen[0m][0m [36mbase_h[0m=[35m0[0m [36mdepth[0m=[35m7[0m [36mis_leaf[0m=[35mTrue[0m [36mmax_depth[0m=[35m10[0m [36mrect[0m=[35mRect(x1=7, y1=13, x2=14, y2=22)[0m
[2m2025-05-14T23:07:35.636373[0m [[32m[1mdebug    [0m] [1mSplit aborted: Node too small [0m [[0m[1m[34mgame.world.procgen[0m][0m [36mdimension_size[0m=[35m10[0m [36mmin_required[0m=[35m12[0m [36mrect[0m=[35mRect(x1=7, y1=13, x2=14, y2=22)[0m [36msplit_direction[0m=[35mhorizontal[0m
[2m2025-05-14T23:07:35.636400[0m [[32m[1mdebug    [0m] [1mAttempting BSP split          [0m [[0m[1m[34mgame.world.procgen[0m][0m [36mbase_h[0m=[35m0[0m [36mdepth[0m=[35m6[0m [36mis_leaf[0m=[35mTrue[0m [36mmax_depth[0m=[35m10[0m [36mrect[0m=[35mRect(x1=1, y1=23, x2=14, y2=41)[0m
[2m2025-05-14T23:07:35.636447[0m [[32m[1mdebug    [0m] [1mSplit node horizontally       [0m [[0m[1m[34mgame.world.procgen[0m][0m [36mdepth[0m=[35m6[0m [36mleft_h[0m=[35m0[0m [36mleft_rect[0m=[35mRect(x1=1, y1=23, x2=14, y2=32)[0m [36mright_h[0m=[35m0[0m [36mright_rect[0m=[35mRect(x1=1, y1=33, x2=14, y2=41)[0m [36my_split[0m=[35m33[0m
[2m2025-05-14T23:07:35.636479[0m [[32m[1mdebug    [0m] [1mAttempting BSP split          [0m [[0m[1m[34mgame.world.procgen[0m][0m [36mbase_h[0m=[35m0[0m [36mdepth[0m=[35m7[0m [36mis_leaf[0m=[35mTrue[0m [36mmax_depth[0m=[35m10[0m [36mrect[0m=[35mRect(x1=1, y1=23, x2=14, y2=32)[0m
[2m2025-05-14T23:07:35.636518[0m [[32m[1mdebug    [0m] [1mSplit node vertically         [0m [[0m[1m[34mgame.world.procgen[0m][0m [36mdepth[0m=[35m7[0m [36mleft_h[0m=[35m0[0m [36mleft_rect[0m=[35mRect(x1=1, y1=23, x2=7, y2=32)[0m [36mright_h[0m=[35m0[0m [36mright_rect[0m=[35mRect(x1=8, y1=23, x2=14, y2=32)[0m [36mx_split[0m=[35m8[0m
[2m2025-05-14T23:07:35.636550[0m [[32m[1mdebug    [0m] [1mAttempting BSP split          [0m [[0m[1m[34mgame.world.procgen[0m][0m [36mbase_h[0m=[35m0[0m [36mdepth[0m=[35m8[0m [36mis_leaf[0m=[35mTrue[0m [36mmax_depth[0m=[35m10[0m [36mrect[0m=[35mRect(x1=1, y1=23, x2=7, y2=32)[0m
[2m2025-05-14T23:07:35.636588[0m [[32m[1mdebug    [0m] [1mSplit aborted: Node too small [0m [[0m[1m[34mgame.world.procgen[0m][0m [36mdimension_size[0m=[35m10[0m [36mmin_required[0m=[35m12[0m [36mrect[0m=[35mRect(x1=1, y1=23, x2=7, y2=32)[0m [36msplit_direction[0m=[35mhorizontal[0m
[2m2025-05-14T23:07:35.636617[0m [[32m[1mdebug    [0m] [1mAttempting BSP split          [0m [[0m[1m[34mgame.world.procgen[0m][0m [36mbase_h[0m=[35m0[0m [36mdepth[0m=[35m8[0m [36mis_leaf[0m=[35mTrue[0m [36mmax_depth[0m=[35m10[0m [36mrect[0m=[35mRect(x1=8, y1=23, x2=14, y2=32)[0m
[2m2025-05-14T23:07:35.636646[0m [[32m[1mdebug    [0m] [1mSplit aborted: Node too small [0m [[0m[1m[34mgame.world.procgen[0m][0m [36mdimension_size[0m=[35m10[0m [36mmin_required[0m=[35m12[0m [36mrect[0m=[35mRect(x1=8, y1=23, x2=14, y2=32)[0m [36msplit_direction[0m=[35mhorizontal[0m
[2m2025-05-14T23:07:35.636674[0m [[32m[1mdebug    [0m] [1mAttempting BSP split          [0m [[0m[1m[34mgame.world.procgen[0m][0m [36mbase_h[0m=[35m0[0m [36mdepth[0m=[35m7[0m [36mis_leaf[0m=[35mTrue[0m [36mmax_depth[0m=[35m10[0m [36mrect[0m=[35mRect(x1=1, y1=33, x2=14, y2=41)[0m
[2m2025-05-14T23:07:35.636716[0m [[32m[1mdebug    [0m] [1mSplit node vertically         [0m [[0m[1m[34mgame.world.procgen[0m][0m [36mdepth[0m=[35m7[0m [36mleft_h[0m=[35m0[0m [36mleft_rect[0m=[35mRect(x1=1, y1=33, x2=6, y2=41)[0m [36mright_h[0m=[35m0[0m [36mright_rect[0m=[35mRect(x1=7, y1=33, x2=14, y2=41)[0m [36mx_split[0m=[35m7[0m
[2m2025-05-14T23:07:35.636748[0m [[32m[1mdebug    [0m] [1mAttempting BSP split          [0m [[0m[1m[34mgame.world.procgen[0m][0m [36mbase_h[0m=[35m0[0m [36mdepth[0m=[35m8[0m [36mis_leaf[0m=[35mTrue[0m [36mmax_depth[0m=[35m10[0m [36mrect[0m=[35mRect(x1=1, y1=33, x2=6, y2=41)[0m
[2m2025-05-14T23:07:35.636775[0m [[32m[1mdebug    [0m] [1mSplit aborted: Node too small [0m [[0m[1m[34mgame.world.procgen[0m][0m [36mdimension_size[0m=[35m9[0m [36mmin_required[0m=[35m12[0m [36mrect[0m=[35mRect(x1=1, y1=33, x2=6, y2=41)[0m [36msplit_direction[0m=[35mhorizontal[0m
[2m2025-05-14T23:07:35.636802[0m [[32m[1mdebug    [0m] [1mAttempting BSP split          [0m [[0m[1m[34mgame.world.procgen[0m][0m [36mbase_h[0m=[35m0[0m [36mdepth[0m=[35m8[0m [36mis_leaf[0m=[35mTrue[0m [36mmax_depth[0m=[35m10[0m [36mrect[0m=[35mRect(x1=7, y1=33, x2=14, y2=41)[0m
[2m2025-05-14T23:07:35.636834[0m [[32m[1mdebug    [0m] [1mSplit aborted: Node too small [0m [[0m[1m[34mgame.world.procgen[0m][0m [36mdimension_size[0m=[35m8[0m [36mmin_required[0m=[35m12[0m [36mrect[0m=[35mRect(x1=7, y1=33, x2=14, y2=41)[0m [36msplit_direction[0m=[35mvertical[0m
[2m2025-05-14T23:07:35.636865[0m [[32m[1mdebug    [0m] [1mAttempting BSP split          [0m [[0m[1m[34mgame.world.procgen[0m][0m [36mbase_h[0m=[35m0[0m [36mdepth[0m=[35m4[0m [36mis_leaf[0m=[35mTrue[0m [36mmax_depth[0m=[35m10[0m [36mrect[0m=[35mRect(x1=1, y1=42, x2=14, y2=48)[0m
[2m2025-05-14T23:07:35.636905[0m [[32m[1mdebug    [0m] [1mSplit node vertically         [0m [[0m[1m[34mgame.world.procgen[0m][0m [36mdepth[0m=[35m4[0m [36mleft_h[0m=[35m0[0m [36mleft_rect[0m=[35mRect(x1=1, y1=42, x2=6, y2=48)[0m [36mright_h[0m=[35m0[0m [36mright_rect[0m=[35mRect(x1=7, y1=42, x2=14, y2=48)[0m [36mx_split[0m=[35m7[0m
[2m2025-05-14T23:07:35.636937[0m [[32m[1mdebug    [0m] [1mAttempting BSP split          [0m [[0m[1m[34mgame.world.procgen[0m][0m [36mbase_h[0m=[35m0[0m [36mdepth[0m=[35m5[0m [36mis_leaf[0m=[35mTrue[0m [36mmax_depth[0m=[35m10[0m [36mrect[0m=[35mRect(x1=1, y1=42, x2=6, y2=48)[0m
[2m2025-05-14T23:07:35.636969[0m [[32m[1mdebug    [0m] [1mSplit aborted: Node too small [0m [[0m[1m[34mgame.world.procgen[0m][0m [36mdimension_size[0m=[35m6[0m [36mmin_required[0m=[35m12[0m [36mrect[0m=[35mRect(x1=1, y1=42, x2=6, y2=48)[0m [36msplit_direction[0m=[35mvertical[0m
[2m2025-05-14T23:07:35.636997[0m [[32m[1mdebug    [0m] [1mAttempting BSP split          [0m [[0m[1m[34mgame.world.procgen[0m][0m [36mbase_h[0m=[35m0[0m [36mdepth[0m=[35m5[0m [36mis_leaf[0m=[35mTrue[0m [36mmax_depth[0m=[35m10[0m [36mrect[0m=[35mRect(x1=7, y1=42, x2=14, y2=48)[0m
[2m2025-05-14T23:07:35.637030[0m [[32m[1mdebug    [0m] [1mSplit aborted: Node too small [0m [[0m[1m[34mgame.world.procgen[0m][0m [36mdimension_size[0m=[35m8[0m [36mmin_required[0m=[35m12[0m [36mrect[0m=[35mRect(x1=7, y1=42, x2=14, y2=48)[0m [36msplit_direction[0m=[35mvertical[0m
[2m2025-05-14T23:07:35.637058[0m [[32m[1mdebug    [0m] [1mAttempting BSP split          [0m [[0m[1m[34mgame.world.procgen[0m][0m [36mbase_h[0m=[35m0[0m [36mdepth[0m=[35m3[0m [36mis_leaf[0m=[35mTrue[0m [36mmax_depth[0m=[35m10[0m [36mrect[0m=[35mRect(x1=15, y1=7, x2=34, y2=48)[0m
[2m2025-05-14T23:07:35.637094[0m [[32m[1mdebug    [0m] [1mSplit node horizontally       [0m [[0m[1m[34mgame.world.procgen[0m][0m [36mdepth[0m=[35m3[0m [36mleft_h[0m=[35m0[0m [36mleft_rect[0m=[35mRect(x1=15, y1=7, x2=34, y2=16)[0m [36mright_h[0m=[35m0[0m [36mright_rect[0m=[35mRect(x1=15, y1=17, x2=34, y2=48)[0m [36my_split[0m=[35m17[0m
[2m2025-05-14T23:07:35.637124[0m [[32m[1mdebug    [0m] [1mAttempting BSP split          [0m [[0m[1m[34mgame.world.procgen[0m][0m [36mbase_h[0m=[35m0[0m [36mdepth[0m=[35m4[0m [36mis_leaf[0m=[35mTrue[0m [36mmax_depth[0m=[35m10[0m [36mrect[0m=[35mRect(x1=15, y1=7, x2=34, y2=16)[0m
[2m2025-05-14T23:07:35.637162[0m [[32m[1mdebug    [0m] [1mSplit node vertically         [0m [[0m[1m[34mgame.world.procgen[0m][0m [36mdepth[0m=[35m4[0m [36mleft_h[0m=[35m0[0m [36mleft_rect[0m=[35mRect(x1=15, y1=7, x2=25, y2=16)[0m [36mright_h[0m=[35m0[0m [36mright_rect[0m=[35mRect(x1=26, y1=7, x2=34, y2=16)[0m [36mx_split[0m=[35m26[0m
[2m2025-05-14T23:07:35.637193[0m [[32m[1mdebug    [0m] [1mAttempting BSP split          [0m [[0m[1m[34mgame.world.procgen[0m][0m [36mbase_h[0m=[35m0[0m [36mdepth[0m=[35m5[0m [36mis_leaf[0m=[35mTrue[0m [36mmax_depth[0m=[35m10[0m [36mrect[0m=[35mRect(x1=15, y1=7, x2=25, y2=16)[0m
[2m2025-05-14T23:07:35.637225[0m [[32m[1mdebug    [0m] [1mSplit aborted: Node too small [0m [[0m[1m[34mgame.world.procgen[0m][0m [36mdimension_size[0m=[35m11[0m [36mmin_required[0m=[35m12[0m [36mrect[0m=[35mRect(x1=15, y1=7, x2=25, y2=16)[0m [36msplit_direction[0m=[35mvertical[0m
[2m2025-05-14T23:07:35.637253[0m [[32m[1mdebug    [0m] [1mAttempting BSP split          [0m [[0m[1m[34mgame.world.procgen[0m][0m [36mbase_h[0m=[35m0[0m [36mdepth[0m=[35m5[0m [36mis_leaf[0m=[35mTrue[0m [36mmax_depth[0m=[35m10[0m [36mrect[0m=[35mRect(x1=26, y1=7, x2=34, y2=16)[0m
[2m2025-05-14T23:07:35.637288[0m [[32m[1mdebug    [0m] [1mSplit aborted: Node too small [0m [[0m[1m[34mgame.world.procgen[0m][0m [36mdimension_size[0m=[35m9[0m [36mmin_required[0m=[35m12[0m [36mrect[0m=[35mRect(x1=26, y1=7, x2=34, y2=16)[0m [36msplit_direction[0m=[35mvertical[0m
[2m2025-05-14T23:07:35.637317[0m [[32m[1mdebug    [0m] [1mAttempting BSP split          [0m [[0m[1m[34mgame.world.procgen[0m][0m [36mbase_h[0m=[35m0[0m [36mdepth[0m=[35m4[0m [36mis_leaf[0m=[35mTrue[0m [36mmax_depth[0m=[35m10[0m [36mrect[0m=[35mRect(x1=15, y1=17, x2=34, y2=48)[0m
[2m2025-05-14T23:07:35.637355[0m [[32m[1mdebug    [0m] [1mSplit node horizontally       [0m [[0m[1m[34mgame.world.procgen[0m][0m [36mdepth[0m=[35m4[0m [36mleft_h[0m=[35m0[0m [36mleft_rect[0m=[35mRect(x1=15, y1=17, x2=34, y2=27)[0m [36mright_h[0m=[35m0[0m [36mright_rect[0m=[35mRect(x1=15, y1=28, x2=34, y2=48)[0m [36my_split[0m=[35m28[0m
[2m2025-05-14T23:07:35.637385[0m [[32m[1mdebug    [0m] [1mAttempting BSP split          [0m [[0m[1m[34mgame.world.procgen[0m][0m [36mbase_h[0m=[35m0[0m [36mdepth[0m=[35m5[0m [36mis_leaf[0m=[35mTrue[0m [36mmax_depth[0m=[35m10[0m [36mrect[0m=[35mRect(x1=15, y1=17, x2=34, y2=27)[0m
[2m2025-05-14T23:07:35.637424[0m [[32m[1mdebug    [0m] [1mSplit node vertically         [0m [[0m[1m[34mgame.world.procgen[0m][0m [36mdepth[0m=[35m5[0m [36mleft_h[0m=[35m0[0m [36mleft_rect[0m=[35mRect(x1=15, y1=17, x2=21, y2=27)[0m [36mright_h[0m=[35m0[0m [36mright_rect[0m=[35mRect(x1=22, y1=17, x2=34, y2=27)[0m [36mx_split[0m=[35m22[0m
[2m2025-05-14T23:07:35.637454[0m [[32m[1mdebug    [0m] [1mAttempting BSP split          [0m [[0m[1m[34mgame.world.procgen[0m][0m [36mbase_h[0m=[35m0[0m [36mdepth[0m=[35m6[0m [36mis_leaf[0m=[35mTrue[0m [36mmax_depth[0m=[35m10[0m [36mrect[0m=[35mRect(x1=15, y1=17, x2=21, y2=27)[0m
[2m2025-05-14T23:07:35.637482[0m [[32m[1mdebug    [0m] [1mSplit aborted: Node too small [0m [[0m[1m[34mgame.world.procgen[0m][0m [36mdimension_size[0m=[35m11[0m [36mmin_required[0m=[35m12[0m [36mrect[0m=[35mRect(x1=15, y1=17, x2=21, y2=27)[0m [36msplit_direction[0m=[35mhorizontal[0m
[2m2025-05-14T23:07:35.637514[0m [[32m[1mdebug    [0m] [1mAttempting BSP split          [0m [[0m[1m[34mgame.world.procgen[0m][0m [36mbase_h[0m=[35m0[0m [36mdepth[0m=[35m6[0m [36mis_leaf[0m=[35mTrue[0m [36mmax_depth[0m=[35m10[0m [36mrect[0m=[35mRect(x1=22, y1=17, x2=34, y2=27)[0m
[2m2025-05-14T23:07:35.637548[0m [[32m[1mdebug    [0m] [1mSplit node vertically         [0m [[0m[1m[34mgame.world.procgen[0m][0m [36mdepth[0m=[35m6[0m [36mleft_h[0m=[35m0[0m [36mleft_rect[0m=[35mRect(x1=22, y1=17, x2=27, y2=27)[0m [36mright_h[0m=[35m0[0m [36mright_rect[0m=[35mRect(x1=28, y1=17, x2=34, y2=27)[0m [36mx_split[0m=[35m28[0m
[2m2025-05-14T23:07:35.637587[0m [[32m[1mdebug    [0m] [1mAttempting BSP split          [0m [[0m[1m[34mgame.world.procgen[0m][0m [36mbase_h[0m=[35m0[0m [36mdepth[0m=[35m7[0m [36mis_leaf[0m=[35mTrue[0m [36mmax_depth[0m=[35m10[0m [36mrect[0m=[35mRect(x1=22, y1=17, x2=27, y2=27)[0m
[2m2025-05-14T23:07:35.637617[0m [[32m[1mdebug    [0m] [1mSplit aborted: Node too small [0m [[0m[1m[34mgame.world.procgen[0m][0m [36mdimension_size[0m=[35m11[0m [36mmin_required[0m=[35m12[0m [36mrect[0m=[35mRect(x1=22, y1=17, x2=27, y2=27)[0m [36msplit_direction[0m=[35mhorizontal[0m
[2m2025-05-14T23:07:35.637646[0m [[32m[1mdebug    [0m] [1mAttempting BSP split          [0m [[0m[1m[34mgame.world.procgen[0m][0m [36mbase_h[0m=[35m0[0m [36mdepth[0m=[35m7[0m [36mis_leaf[0m=[35mTrue[0m [36mmax_depth[0m=[35m10[0m [36mrect[0m=[35mRect(x1=28, y1=17, x2=34, y2=27)[0m
[2m2025-05-14T23:07:35.637677[0m [[32m[1mdebug    [0m] [1mSplit aborted: Node too small [0m [[0m[1m[34mgame.world.procgen[0m][0m [36mdimension_size[0m=[35m11[0m [36mmin_required[0m=[35m12[0m [36mrect[0m=[35mRect(x1=28, y1=17, x2=34, y2=27)[0m [36msplit_direction[0m=[35mhorizontal[0m
[2m2025-05-14T23:07:35.637706[0m [[32m[1mdebug    [0m] [1mAttempting BSP split          [0m [[0m[1m[34mgame.world.procgen[0m][0m [36mbase_h[0m=[35m0[0m [36mdepth[0m=[35m5[0m [36mis_leaf[0m=[35mTrue[0m [36mmax_depth[0m=[35m10[0m [36mrect[0m=[35mRect(x1=15, y1=28, x2=34, y2=48)[0m
[2m2025-05-14T23:07:35.637747[0m [[32m[1mdebug    [0m] [1mSplit node vertically         [0m [[0m[1m[34mgame.world.procgen[0m][0m [36mdepth[0m=[35m5[0m [36mleft_h[0m=[35m0[0m [36mleft_rect[0m=[35mRect(x1=15, y1=28, x2=25, y2=48)[0m [36mright_h[0m=[35m0[0m [36mright_rect[0m=[35mRect(x1=26, y1=28, x2=34, y2=48)[0m [36mx_split[0m=[35m26[0m
[2m2025-05-14T23:07:35.637779[0m [[32m[1mdebug    [0m] [1mAttempting BSP split          [0m [[0m[1m[34mgame.world.procgen[0m][0m [36mbase_h[0m=[35m0[0m [36mdepth[0m=[35m6[0m [36mis_leaf[0m=[35mTrue[0m [36mmax_depth[0m=[35m10[0m [36mrect[0m=[35mRect(x1=15, y1=28, x2=25, y2=48)[0m
[2m2025-05-14T23:07:35.637815[0m [[32m[1mdebug    [0m] [1mSplit node horizontally       [0m [[0m[1m[34mgame.world.procgen[0m][0m [36mdepth[0m=[35m6[0m [36mleft_h[0m=[35m0[0m [36mleft_rect[0m=[35mRect(x1=15, y1=28, x2=25, y2=37)[0m [36mright_h[0m=[35m0[0m [36mright_rect[0m=[35mRect(x1=15, y1=38, x2=25, y2=48)[0m [36my_split[0m=[35m38[0m
[2m2025-05-14T23:07:35.637844[0m [[32m[1mdebug    [0m] [1mAttempting BSP split          [0m [[0m[1m[34mgame.world.procgen[0m][0m [36mbase_h[0m=[35m0[0m [36mdepth[0m=[35m7[0m [36mis_leaf[0m=[35mTrue[0m [36mmax_depth[0m=[35m10[0m [36mrect[0m=[35mRect(x1=15, y1=28, x2=25, y2=37)[0m
[2m2025-05-14T23:07:35.637877[0m [[32m[1mdebug    [0m] [1mSplit aborted: Node too small [0m [[0m[1m[34mgame.world.procgen[0m][0m [36mdimension_size[0m=[35m11[0m [36mmin_required[0m=[35m12[0m [36mrect[0m=[35mRect(x1=15, y1=28, x2=25, y2=37)[0m [36msplit_direction[0m=[35mvertical[0m
[2m2025-05-14T23:07:35.637909[0m [[32m[1mdebug    [0m] [1mAttempting BSP split          [0m [[0m[1m[34mgame.world.procgen[0m][0m [36mbase_h[0m=[35m0[0m [36mdepth[0m=[35m7[0m [36mis_leaf[0m=[35mTrue[0m [36mmax_depth[0m=[35m10[0m [36mrect[0m=[35mRect(x1=15, y1=38, x2=25, y2=48)[0m
[2m2025-05-14T23:07:35.637941[0m [[32m[1mdebug    [0m] [1mSplit aborted: Node too small [0m [[0m[1m[34mgame.world.procgen[0m][0m [36mdimension_size[0m=[35m11[0m [36mmin_required[0m=[35m12[0m [36mrect[0m=[35mRect(x1=15, y1=38, x2=25, y2=48)[0m [36msplit_direction[0m=[35mvertical[0m
[2m2025-05-14T23:07:35.637969[0m [[32m[1mdebug    [0m] [1mAttempting BSP split          [0m [[0m[1m[34mgame.world.procgen[0m][0m [36mbase_h[0m=[35m0[0m [36mdepth[0m=[35m6[0m [36mis_leaf[0m=[35mTrue[0m [36mmax_depth[0m=[35m10[0m [36mrect[0m=[35mRect(x1=26, y1=28, x2=34, y2=48)[0m
[2m2025-05-14T23:07:35.638005[0m [[32m[1mdebug    [0m] [1mSplit node horizontally       [0m [[0m[1m[34mgame.world.procgen[0m][0m [36mdepth[0m=[35m6[0m [36mleft_h[0m=[35m0[0m [36mleft_rect[0m=[35mRect(x1=26, y1=28, x2=34, y2=33)[0m [36mright_h[0m=[35m0[0m [36mright_rect[0m=[35mRect(x1=26, y1=34, x2=34, y2=48)[0m [36my_split[0m=[35m34[0m
[2m2025-05-14T23:07:35.638035[0m [[32m[1mdebug    [0m] [1mAttempting BSP split          [0m [[0m[1m[34mgame.world.procgen[0m][0m [36mbase_h[0m=[35m0[0m [36mdepth[0m=[35m7[0m [36mis_leaf[0m=[35mTrue[0m [36mmax_depth[0m=[35m10[0m [36mrect[0m=[35mRect(x1=26, y1=28, x2=34, y2=33)[0m
[2m2025-05-14T23:07:35.638062[0m [[32m[1mdebug    [0m] [1mSplit aborted: Node too small [0m [[0m[1m[34mgame.world.procgen[0m][0m [36mdimension_size[0m=[35m9[0m [36mmin_required[0m=[35m12[0m [36mrect[0m=[35mRect(x1=26, y1=28, x2=34, y2=33)[0m [36msplit_direction[0m=[35mvertical[0m
[2m2025-05-14T23:07:35.638106[0m [[32m[1mdebug    [0m] [1mAttempting BSP split          [0m [[0m[1m[34mgame.world.procgen[0m][0m [36mbase_h[0m=[35m0[0m [36mdepth[0m=[35m7[0m [36mis_leaf[0m=[35mTrue[0m [36mmax_depth[0m=[35m10[0m [36mrect[0m=[35mRect(x1=26, y1=34, x2=34, y2=48)[0m
[2m2025-05-14T23:07:35.638165[0m [[32m[1mdebug    [0m] [1mSplit node horizontally       [0m [[0m[1m[34mgame.world.procgen[0m][0m [36mdepth[0m=[35m7[0m [36mleft_h[0m=[35m0[0m [36mleft_rect[0m=[35mRect(x1=26, y1=34, x2=34, y2=39)[0m [36mright_h[0m=[35m0[0m [36mright_rect[0m=[35mRect(x1=26, y1=40, x2=34, y2=48)[0m [36my_split[0m=[35m40[0m
[2m2025-05-14T23:07:35.638203[0m [[32m[1mdebug    [0m] [1mAttempting BSP split          [0m [[0m[1m[34mgame.world.procgen[0m][0m [36mbase_h[0m=[35m0[0m [36mdepth[0m=[35m8[0m [36mis_leaf[0m=[35mTrue[0m [36mmax_depth[0m=[35m10[0m [36mrect[0m=[35mRect(x1=26, y1=34, x2=34, y2=39)[0m
[2m2025-05-14T23:07:35.638235[0m [[32m[1mdebug    [0m] [1mSplit aborted: Node too small [0m [[0m[1m[34mgame.world.procgen[0m][0m [36mdimension_size[0m=[35m9[0m [36mmin_required[0m=[35m12[0m [36mrect[0m=[35mRect(x1=26, y1=34, x2=34, y2=39)[0m [36msplit_direction[0m=[35mvertical[0m
[2m2025-05-14T23:07:35.638266[0m [[32m[1mdebug    [0m] [1mAttempting BSP split          [0m [[0m[1m[34mgame.world.procgen[0m][0m [36mbase_h[0m=[35m0[0m [36mdepth[0m=[35m8[0m [36mis_leaf[0m=[35mTrue[0m [36mmax_depth[0m=[35m10[0m [36mrect[0m=[35mRect(x1=26, y1=40, x2=34, y2=48)[0m
[2m2025-05-14T23:07:35.638304[0m [[32m[1mdebug    [0m] [1mSplit aborted: Node too small [0m [[0m[1m[34mgame.world.procgen[0m][0m [36mdimension_size[0m=[35m9[0m [36mmin_required[0m=[35m12[0m [36mrect[0m=[35mRect(x1=26, y1=40, x2=34, y2=48)[0m [36msplit_direction[0m=[35mvertical[0m
[2m2025-05-14T23:07:35.638335[0m [[32m[1mdebug    [0m] [1mAttempting BSP split          [0m [[0m[1m[34mgame.world.procgen[0m][0m [36mbase_h[0m=[35m0[0m [36mdepth[0m=[35m1[0m [36mis_leaf[0m=[35mTrue[0m [36mmax_depth[0m=[35m10[0m [36mrect[0m=[35mRect(x1=35, y1=1, x2=78, y2=48)[0m
[2m2025-05-14T23:07:35.638382[0m [[32m[1mdebug    [0m] [1mSplit node vertically         [0m [[0m[1m[34mgame.world.procgen[0m][0m [36mdepth[0m=[35m1[0m [36mleft_h[0m=[35m0[0m [36mleft_rect[0m=[35mRect(x1=35, y1=1, x2=46, y2=48)[0m [36mright_h[0m=[35m0[0m [36mright_rect[0m=[35mRect(x1=47, y1=1, x2=78, y2=48)[0m [36mx_split[0m=[35m47[0m
[2m2025-05-14T23:07:35.638416[0m [[32m[1mdebug    [0m] [1mAttempting BSP split          [0m [[0m[1m[34mgame.world.procgen[0m][0m [36mbase_h[0m=[35m0[0m [36mdepth[0m=[35m2[0m [36mis_leaf[0m=[35mTrue[0m [36mmax_depth[0m=[35m10[0m [36mrect[0m=[35mRect(x1=35, y1=1, x2=46, y2=48)[0m
[2m2025-05-14T23:07:35.638458[0m [[32m[1mdebug    [0m] [1mSplit node horizontally       [0m [[0m[1m[34mgame.world.procgen[0m][0m [36mdepth[0m=[35m2[0m [36mleft_h[0m=[35m0[0m [36mleft_rect[0m=[35mRect(x1=35, y1=1, x2=46, y2=9)[0m [36mright_h[0m=[35m0[0m [36mright_rect[0m=[35mRect(x1=35, y1=10, x2=46, y2=48)[0m [36my_split[0m=[35m10[0m
[2m2025-05-14T23:07:35.638489[0m [[32m[1mdebug    [0m] [1mAttempting BSP split          [0m [[0m[1m[34mgame.world.procgen[0m][0m [36mbase_h[0m=[35m0[0m [36mdepth[0m=[35m3[0m [36mis_leaf[0m=[35mTrue[0m [36mmax_depth[0m=[35m10[0m [36mrect[0m=[35mRect(x1=35, y1=1, x2=46, y2=9)[0m
[2m2025-05-14T23:07:35.638517[0m [[32m[1mdebug    [0m] [1mSplit aborted: Node too small [0m [[0m[1m[34mgame.world.procgen[0m][0m [36mdimension_size[0m=[35m12[0m [36mmin_required[0m=[35m12[0m [36mrect[0m=[35mRect(x1=35, y1=1, x2=46, y2=9)[0m [36msplit_direction[0m=[35mvertical[0m
[2m2025-05-14T23:07:35.638550[0m [[32m[1mdebug    [0m] [1mAttempting BSP split          [0m [[0m[1m[34mgame.world.procgen[0m][0m [36mbase_h[0m=[35m0[0m [36mdepth[0m=[35m3[0m [36mis_leaf[0m=[35mTrue[0m [36mmax_depth[0m=[35m10[0m [36mrect[0m=[35mRect(x1=35, y1=10, x2=46, y2=48)[0m
[2m2025-05-14T23:07:35.638607[0m [[32m[1mdebug    [0m] [1mSplit node horizontally       [0m [[0m[1m[34mgame.world.procgen[0m][0m [36mdepth[0m=[35m3[0m [36mleft_h[0m=[35m0[0m [36mleft_rect[0m=[35mRect(x1=35, y1=10, x2=46, y2=28)[0m [36mright_h[0m=[35m0[0m [36mright_rect[0m=[35mRect(x1=35, y1=29, x2=46, y2=48)[0m [36my_split[0m=[35m29[0m
[2m2025-05-14T23:07:35.638643[0m [[32m[1mdebug    [0m] [1mAttempting BSP split          [0m [[0m[1m[34mgame.world.procgen[0m][0m [36mbase_h[0m=[35m0[0m [36mdepth[0m=[35m4[0m [36mis_leaf[0m=[35mTrue[0m [36mmax_depth[0m=[35m10[0m [36mrect[0m=[35mRect(x1=35, y1=10, x2=46, y2=28)[0m
[2m2025-05-14T23:07:35.638681[0m [[32m[1mdebug    [0m] [1mSplit node horizontally       [0m [[0m[1m[34mgame.world.procgen[0m][0m [36mdepth[0m=[35m4[0m [36mleft_h[0m=[35m0[0m [36mleft_rect[0m=[35mRect(x1=35, y1=10, x2=46, y2=20)[0m [36mright_h[0m=[35m0[0m [36mright_rect[0m=[35mRect(x1=35, y1=21, x2=46, y2=28)[0m [36my_split[0m=[35m21[0m
[2m2025-05-14T23:07:35.638713[0m [[32m[1mdebug    [0m] [1mAttempting BSP split          [0m [[0m[1m[34mgame.world.procgen[0m][0m [36mbase_h[0m=[35m0[0m [36mdepth[0m=[35m5[0m [36mis_leaf[0m=[35mTrue[0m [36mmax_depth[0m=[35m10[0m [36mrect[0m=[35mRect(x1=35, y1=10, x2=46, y2=20)[0m
[2m2025-05-14T23:07:35.638750[0m [[32m[1mdebug    [0m] [1mSplit aborted: Node too small [0m [[0m[1m[34mgame.world.procgen[0m][0m [36mdimension_size[0m=[35m12[0m [36mmin_required[0m=[35m12[0m [36mrect[0m=[35mRect(x1=35, y1=10, x2=46, y2=20)[0m [36msplit_direction[0m=[35mvertical[0m
[2m2025-05-14T23:07:35.638795[0m [[32m[1mdebug    [0m] [1mAttempting BSP split          [0m [[0m[1m[34mgame.world.procgen[0m][0m [36mbase_h[0m=[35m0[0m [36mdepth[0m=[35m5[0m [36mis_leaf[0m=[35mTrue[0m [36mmax_depth[0m=[35m10[0m [36mrect[0m=[35mRect(x1=35, y1=21, x2=46, y2=28)[0m
[2m2025-05-14T23:07:35.638840[0m [[32m[1mdebug    [0m] [1mSplit aborted: Node too small [0m [[0m[1m[34mgame.world.procgen[0m][0m [36mdimension_size[0m=[35m12[0m [36mmin_required[0m=[35m12[0m [36mrect[0m=[35mRect(x1=35, y1=21, x2=46, y2=28)[0m [36msplit_direction[0m=[35mvertical[0m
[2m2025-05-14T23:07:35.638879[0m [[32m[1mdebug    [0m] [1mAttempting BSP split          [0m [[0m[1m[34mgame.world.procgen[0m][0m [36mbase_h[0m=[35m0[0m [36mdepth[0m=[35m4[0m [36mis_leaf[0m=[35mTrue[0m [36mmax_depth[0m=[35m10[0m [36mrect[0m=[35mRect(x1=35, y1=29, x2=46, y2=48)[0m
[2m2025-05-14T23:07:35.638919[0m [[32m[1mdebug    [0m] [1mSplit node horizontally       [0m [[0m[1m[34mgame.world.procgen[0m][0m [36mdepth[0m=[35m4[0m [36mleft_h[0m=[35m0[0m [36mleft_rect[0m=[35mRect(x1=35, y1=29, x2=46, y2=40)[0m [36mright_h[0m=[35m0[0m [36mright_rect[0m=[35mRect(x1=35, y1=41, x2=46, y2=48)[0m [36my_split[0m=[35m41[0m
[2m2025-05-14T23:07:35.638951[0m [[32m[1mdebug    [0m] [1mAttempting BSP split          [0m [[0m[1m[34mgame.world.procgen[0m][0m [36mbase_h[0m=[35m0[0m [36mdepth[0m=[35m5[0m [36mis_leaf[0m=[35mTrue[0m [36mmax_depth[0m=[35m10[0m [36mrect[0m=[35mRect(x1=35, y1=29, x2=46, y2=40)[0m
[2m2025-05-14T23:07:35.638985[0m [[32m[1mdebug    [0m] [1mSplit aborted: Node too small [0m [[0m[1m[34mgame.world.procgen[0m][0m [36mdimension_size[0m=[35m12[0m [36mmin_required[0m=[35m12[0m [36mrect[0m=[35mRect(x1=35, y1=29, x2=46, y2=40)[0m [36msplit_direction[0m=[35mvertical[0m
[2m2025-05-14T23:07:35.639014[0m [[32m[1mdebug    [0m] [1mAttempting BSP split          [0m [[0m[1m[34mgame.world.procgen[0m][0m [36mbase_h[0m=[35m0[0m [36mdepth[0m=[35m5[0m [36mis_leaf[0m=[35mTrue[0m [36mmax_depth[0m=[35m10[0m [36mrect[0m=[35mRect(x1=35, y1=41, x2=46, y2=48)[0m
[2m2025-05-14T23:07:35.639048[0m [[32m[1mdebug    [0m] [1mSplit aborted: Node too small [0m [[0m[1m[34mgame.world.procgen[0m][0m [36mdimension_size[0m=[35m12[0m [36mmin_required[0m=[35m12[0m [36mrect[0m=[35mRect(x1=35, y1=41, x2=46, y2=48)[0m [36msplit_direction[0m=[35mvertical[0m
[2m2025-05-14T23:07:35.639077[0m [[32m[1mdebug    [0m] [1mAttempting BSP split          [0m [[0m[1m[34mgame.world.procgen[0m][0m [36mbase_h[0m=[35m0[0m [36mdepth[0m=[35m2[0m [36mis_leaf[0m=[35mTrue[0m [36mmax_depth[0m=[35m10[0m [36mrect[0m=[35mRect(x1=47, y1=1, x2=78, y2=48)[0m
[2m2025-05-14T23:07:35.639116[0m [[32m[1mdebug    [0m] [1mSplit node horizontally       [0m [[0m[1m[34mgame.world.procgen[0m][0m [36mdepth[0m=[35m2[0m [36mleft_h[0m=[35m0[0m [36mleft_rect[0m=[35mRect(x1=47, y1=1, x2=78, y2=27)[0m [36mright_h[0m=[35m0[0m [36mright_rect[0m=[35mRect(x1=47, y1=28, x2=78, y2=48)[0m [36my_split[0m=[35m28[0m
[2m2025-05-14T23:07:35.639147[0m [[32m[1mdebug    [0m] [1mAttempting BSP split          [0m [[0m[1m[34mgame.world.procgen[0m][0m [36mbase_h[0m=[35m0[0m [36mdepth[0m=[35m3[0m [36mis_leaf[0m=[35mTrue[0m [36mmax_depth[0m=[35m10[0m [36mrect[0m=[35mRect(x1=47, y1=1, x2=78, y2=27)[0m
[2m2025-05-14T23:07:35.639190[0m [[32m[1mdebug    [0m] [1mSplit node vertically         [0m [[0m[1m[34mgame.world.procgen[0m][0m [36mdepth[0m=[35m3[0m [36mleft_h[0m=[35m0[0m [36mleft_rect[0m=[35mRect(x1=47, y1=1, x2=70, y2=27)[0m [36mright_h[0m=[35m0[0m [36mright_rect[0m=[35mRect(x1=71, y1=1, x2=78, y2=27)[0m [36mx_split[0m=[35m71[0m
[2m2025-05-14T23:07:35.639222[0m [[32m[1mdebug    [0m] [1mAttempting BSP split          [0m [[0m[1m[34mgame.world.procgen[0m][0m [36mbase_h[0m=[35m0[0m [36mdepth[0m=[35m4[0m [36mis_leaf[0m=[35mTrue[0m [36mmax_depth[0m=[35m10[0m [36mrect[0m=[35mRect(x1=47, y1=1, x2=70, y2=27)[0m
[2m2025-05-14T23:07:35.639265[0m [[32m[1mdebug    [0m] [1mSplit node vertically         [0m [[0m[1m[34mgame.world.procgen[0m][0m [36mdepth[0m=[35m4[0m [36mleft_h[0m=[35m0[0m [36mleft_rect[0m=[35mRect(x1=47, y1=1, x2=63, y2=27)[0m [36mright_h[0m=[35m0[0m [36mright_rect[0m=[35mRect(x1=64, y1=1, x2=70, y2=27)[0m [36mx_split[0m=[35m64[0m
[2m2025-05-14T23:07:35.639296[0m [[32m[1mdebug    [0m] [1mAttempting BSP split          [0m [[0m[1m[34mgame.world.procgen[0m][0m [36mbase_h[0m=[35m0[0m [36mdepth[0m=[35m5[0m [36mis_leaf[0m=[35mTrue[0m [36mmax_depth[0m=[35m10[0m [36mrect[0m=[35mRect(x1=47, y1=1, x2=63, y2=27)[0m
[2m2025-05-14T23:07:35.639332[0m [[32m[1mdebug    [0m] [1mSplit node horizontally       [0m [[0m[1m[34mgame.world.procgen[0m][0m [36mdepth[0m=[35m5[0m [36mleft_h[0m=[35m0[0m [36mleft_rect[0m=[35mRect(x1=47, y1=1, x2=63, y2=20)[0m [36mright_h[0m=[35m0[0m [36mright_rect[0m=[35mRect(x1=47, y1=21, x2=63, y2=27)[0m [36my_split[0m=[35m21[0m
[2m2025-05-14T23:07:35.639361[0m [[32m[1mdebug    [0m] [1mAttempting BSP split          [0m [[0m[1m[34mgame.world.procgen[0m][0m [36mbase_h[0m=[35m0[0m [36mdepth[0m=[35m6[0m [36mis_leaf[0m=[35mTrue[0m [36mmax_depth[0m=[35m10[0m [36mrect[0m=[35mRect(x1=47, y1=1, x2=63, y2=20)[0m
[2m2025-05-14T23:07:35.639409[0m [[32m[1mdebug    [0m] [1mSplit node vertically         [0m [[0m[1m[34mgame.world.procgen[0m][0m [36mdepth[0m=[35m6[0m [36mleft_h[0m=[35m0[0m [36mleft_rect[0m=[35mRect(x1=47, y1=1, x2=54, y2=20)[0m [36mright_h[0m=[35m0[0m [36mright_rect[0m=[35mRect(x1=55, y1=1, x2=63, y2=20)[0m [36mx_split[0m=[35m55[0m
[2m2025-05-14T23:07:35.639439[0m [[32m[1mdebug    [0m] [1mAttempting BSP split          [0m [[0m[1m[34mgame.world.procgen[0m][0m [36mbase_h[0m=[35m0[0m [36mdepth[0m=[35m7[0m [36mis_leaf[0m=[35mTrue[0m [36mmax_depth[0m=[35m10[0m [36mrect[0m=[35mRect(x1=47, y1=1, x2=54, y2=20)[0m
[2m2025-05-14T23:07:35.639479[0m [[32m[1mdebug    [0m] [1mSplit node horizontally       [0m [[0m[1m[34mgame.world.procgen[0m][0m [36mdepth[0m=[35m7[0m [36mleft_h[0m=[35m0[0m [36mleft_rect[0m=[35mRect(x1=47, y1=1, x2=54, y2=7)[0m [36mright_h[0m=[35m0[0m [36mright_rect[0m=[35mRect(x1=47, y1=8, x2=54, y2=20)[0m [36my_split[0m=[35m8[0m
[2m2025-05-14T23:07:35.639510[0m [[32m[1mdebug    [0m] [1mAttempting BSP split          [0m [[0m[1m[34mgame.world.procgen[0m][0m [36mbase_h[0m=[35m0[0m [36mdepth[0m=[35m8[0m [36mis_leaf[0m=[35mTrue[0m [36mmax_depth[0m=[35m10[0m [36mrect[0m=[35mRect(x1=47, y1=1, x2=54, y2=7)[0m
[2m2025-05-14T23:07:35.639542[0m [[32m[1mdebug    [0m] [1mSplit aborted: Node too small [0m [[0m[1m[34mgame.world.procgen[0m][0m [36mdimension_size[0m=[35m8[0m [36mmin_required[0m=[35m12[0m [36mrect[0m=[35mRect(x1=47, y1=1, x2=54, y2=7)[0m [36msplit_direction[0m=[35mvertical[0m
[2m2025-05-14T23:07:35.639582[0m [[32m[1mdebug    [0m] [1mAttempting BSP split          [0m [[0m[1m[34mgame.world.procgen[0m][0m [36mbase_h[0m=[35m0[0m [36mdepth[0m=[35m8[0m [36mis_leaf[0m=[35mTrue[0m [36mmax_depth[0m=[35m10[0m [36mrect[0m=[35mRect(x1=47, y1=8, x2=54, y2=20)[0m
[2m2025-05-14T23:07:35.639639[0m [[32m[1mdebug    [0m] [1mSplit node horizontally       [0m [[0m[1m[34mgame.world.procgen[0m][0m [36mdepth[0m=[35m8[0m [36mleft_h[0m=[35m0[0m [36mleft_rect[0m=[35mRect(x1=47, y1=8, x2=54, y2=13)[0m [36mright_h[0m=[35m0[0m [36mright_rect[0m=[35mRect(x1=47, y1=14, x2=54, y2=20)[0m [36my_split[0m=[35m14[0m
[2m2025-05-14T23:07:35.639676[0m [[32m[1mdebug    [0m] [1mAttempting BSP split          [0m [[0m[1m[34mgame.world.procgen[0m][0m [36mbase_h[0m=[35m0[0m [36mdepth[0m=[35m9[0m [36mis_leaf[0m=[35mTrue[0m [36mmax_depth[0m=[35m10[0m [36mrect[0m=[35mRect(x1=47, y1=8, x2=54, y2=13)[0m
[2m2025-05-14T23:07:35.639707[0m [[32m[1mdebug    [0m] [1mSplit aborted: Node too small [0m [[0m[1m[34mgame.world.procgen[0m][0m [36mdimension_size[0m=[35m8[0m [36mmin_required[0m=[35m12[0m [36mrect[0m=[35mRect(x1=47, y1=8, x2=54, y2=13)[0m [36msplit_direction[0m=[35mvertical[0m
[2m2025-05-14T23:07:35.639738[0m [[32m[1mdebug    [0m] [1mAttempting BSP split          [0m [[0m[1m[34mgame.world.procgen[0m][0m [36mbase_h[0m=[35m0[0m [36mdepth[0m=[35m9[0m [36mis_leaf[0m=[35mTrue[0m [36mmax_depth[0m=[35m10[0m [36mrect[0m=[35mRect(x1=47, y1=14, x2=54, y2=20)[0m
[2m2025-05-14T23:07:35.639773[0m [[32m[1mdebug    [0m] [1mSplit aborted: Node too small [0m [[0m[1m[34mgame.world.procgen[0m][0m [36mdimension_size[0m=[35m8[0m [36mmin_required[0m=[35m12[0m [36mrect[0m=[35mRect(x1=47, y1=14, x2=54, y2=20)[0m [36msplit_direction[0m=[35mvertical[0m
[2m2025-05-14T23:07:35.639803[0m [[32m[1mdebug    [0m] [1mAttempting BSP split          [0m [[0m[1m[34mgame.world.procgen[0m][0m [36mbase_h[0m=[35m0[0m [36mdepth[0m=[35m7[0m [36mis_leaf[0m=[35mTrue[0m [36mmax_depth[0m=[35m10[0m [36mrect[0m=[35mRect(x1=55, y1=1, x2=63, y2=20)[0m
[2m2025-05-14T23:07:35.639845[0m [[32m[1mdebug    [0m] [1mSplit node horizontally       [0m [[0m[1m[34mgame.world.procgen[0m][0m [36mdepth[0m=[35m7[0m [36mleft_h[0m=[35m0[0m [36mleft_rect[0m=[35mRect(x1=55, y1=1, x2=63, y2=7)[0m [36mright_h[0m=[35m0[0m [36mright_rect[0m=[35mRect(x1=55, y1=8, x2=63, y2=20)[0m [36my_split[0m=[35m8[0m
[2m2025-05-14T23:07:35.639877[0m [[32m[1mdebug    [0m] [1mAttempting BSP split          [0m [[0m[1m[34mgame.world.procgen[0m][0m [36mbase_h[0m=[35m0[0m [36mdepth[0m=[35m8[0m [36mis_leaf[0m=[35mTrue[0m [36mmax_depth[0m=[35m10[0m [36mrect[0m=[35mRect(x1=55, y1=1, x2=63, y2=7)[0m
[2m2025-05-14T23:07:35.639905[0m [[32m[1mdebug    [0m] [1mSplit aborted: Node too small [0m [[0m[1m[34mgame.world.procgen[0m][0m [36mdimension_size[0m=[35m9[0m [36mmin_required[0m=[35m12[0m [36mrect[0m=[35mRect(x1=55, y1=1, x2=63, y2=7)[0m [36msplit_direction[0m=[35mvertical[0m
[2m2025-05-14T23:07:35.639938[0m [[32m[1mdebug    [0m] [1mAttempting BSP split          [0m [[0m[1m[34mgame.world.procgen[0m][0m [36mbase_h[0m=[35m0[0m [36mdepth[0m=[35m8[0m [36mis_leaf[0m=[35mTrue[0m [36mmax_depth[0m=[35m10[0m [36mrect[0m=[35mRect(x1=55, y1=8, x2=63, y2=20)[0m
[2m2025-05-14T23:07:35.639969[0m [[32m[1mdebug    [0m] [1mSplit node horizontally       [0m [[0m[1m[34mgame.world.procgen[0m][0m [36mdepth[0m=[35m8[0m [36mleft_h[0m=[35m0[0m [36mleft_rect[0m=[35mRect(x1=55, y1=8, x2=63, y2=13)[0m [36mright_h[0m=[35m0[0m [36mright_rect[0m=[35mRect(x1=55, y1=14, x2=63, y2=20)[0m [36my_split[0m=[35m14[0m
[2m2025-05-14T23:07:35.639999[0m [[32m[1mdebug    [0m] [1mAttempting BSP split          [0m [[0m[1m[34mgame.world.procgen[0m][0m [36mbase_h[0m=[35m0[0m [36mdepth[0m=[35m9[0m [36mis_leaf[0m=[35mTrue[0m [36mmax_depth[0m=[35m10[0m [36mrect[0m=[35mRect(x1=55, y1=8, x2=63, y2=13)[0m
[2m2025-05-14T23:07:35.640027[0m [[32m[1mdebug    [0m] [1mSplit aborted: Node too small [0m [[0m[1m[34mgame.world.procgen[0m][0m [36mdimension_size[0m=[35m9[0m [36mmin_required[0m=[35m12[0m [36mrect[0m=[35mRect(x1=55, y1=8, x2=63, y2=13)[0m [36msplit_direction[0m=[35mvertical[0m
[2m2025-05-14T23:07:35.640054[0m [[32m[1mdebug    [0m] [1mAttempting BSP split          [0m [[0m[1m[34mgame.world.procgen[0m][0m [36mbase_h[0m=[35m0[0m [36mdepth[0m=[35m9[0m [36mis_leaf[0m=[35mTrue[0m [36mmax_depth[0m=[35m10[0m [36mrect[0m=[35mRect(x1=55, y1=14, x2=63, y2=20)[0m
[2m2025-05-14T23:07:35.640082[0m [[32m[1mdebug    [0m] [1mSplit aborted: Node too small [0m [[0m[1m[34mgame.world.procgen[0m][0m [36mdimension_size[0m=[35m9[0m [36mmin_required[0m=[35m12[0m [36mrect[0m=[35mRect(x1=55, y1=14, x2=63, y2=20)[0m [36msplit_direction[0m=[35mvertical[0m
[2m2025-05-14T23:07:35.640109[0m [[32m[1mdebug    [0m] [1mAttempting BSP split          [0m [[0m[1m[34mgame.world.procgen[0m][0m [36mbase_h[0m=[35m0[0m [36mdepth[0m=[35m6[0m [36mis_leaf[0m=[35mTrue[0m [36mmax_depth[0m=[35m10[0m [36mrect[0m=[35mRect(x1=47, y1=21, x2=63, y2=27)[0m
[2m2025-05-14T23:07:35.640154[0m [[32m[1mdebug    [0m] [1mSplit node vertically         [0m [[0m[1m[34mgame.world.procgen[0m][0m [36mdepth[0m=[35m6[0m [36mleft_h[0m=[35m0[0m [36mleft_rect[0m=[35mRect(x1=47, y1=21, x2=55, y2=27)[0m [36mright_h[0m=[35m0[0m [36mright_rect[0m=[35mRect(x1=56, y1=21, x2=63, y2=27)[0m [36mx_split[0m=[35m56[0m
[2m2025-05-14T23:07:35.640186[0m [[32m[1mdebug    [0m] [1mAttempting BSP split          [0m [[0m[1m[34mgame.world.procgen[0m][0m [36mbase_h[0m=[35m0[0m [36mdepth[0m=[35m7[0m [36mis_leaf[0m=[35mTrue[0m [36mmax_depth[0m=[35m10[0m [36mrect[0m=[35mRect(x1=47, y1=21, x2=55, y2=27)[0m
[2m2025-05-14T23:07:35.640215[0m [[32m[1mdebug    [0m] [1mSplit aborted: Node too small [0m [[0m[1m[34mgame.world.procgen[0m][0m [36mdimension_size[0m=[35m9[0m [36mmin_required[0m=[35m12[0m [36mrect[0m=[35mRect(x1=47, y1=21, x2=55, y2=27)[0m [36msplit_direction[0m=[35mvertical[0m
[2m2025-05-14T23:07:35.640242[0m [[32m[1mdebug    [0m] [1mAttempting BSP split          [0m [[0m[1m[34mgame.world.procgen[0m][0m [36mbase_h[0m=[35m0[0m [36mdepth[0m=[35m7[0m [36mis_leaf[0m=[35mTrue[0m [36mmax_depth[0m=[35m10[0m [36mrect[0m=[35mRect(x1=56, y1=21, x2=63, y2=27)[0m
[2m2025-05-14T23:07:35.640275[0m [[32m[1mdebug    [0m] [1mSplit aborted: Node too small [0m [[0m[1m[34mgame.world.procgen[0m][0m [36mdimension_size[0m=[35m8[0m [36mmin_required[0m=[35m12[0m [36mrect[0m=[35mRect(x1=56, y1=21, x2=63, y2=27)[0m [36msplit_direction[0m=[35mvertical[0m
[2m2025-05-14T23:07:35.640303[0m [[32m[1mdebug    [0m] [1mAttempting BSP split          [0m [[0m[1m[34mgame.world.procgen[0m][0m [36mbase_h[0m=[35m0[0m [36mdepth[0m=[35m5[0m [36mis_leaf[0m=[35mTrue[0m [36mmax_depth[0m=[35m10[0m [36mrect[0m=[35mRect(x1=64, y1=1, x2=70, y2=27)[0m
[2m2025-05-14T23:07:35.640345[0m [[32m[1mdebug    [0m] [1mSplit node horizontally       [0m [[0m[1m[34mgame.world.procgen[0m][0m [36mdepth[0m=[35m5[0m [36mleft_h[0m=[35m0[0m [36mleft_rect[0m=[35mRect(x1=64, y1=1, x2=70, y2=13)[0m [36mright_h[0m=[35m0[0m [36mright_rect[0m=[35mRect(x1=64, y1=14, x2=70, y2=27)[0m [36my_split[0m=[35m14[0m
[2m2025-05-14T23:07:35.640378[0m [[32m[1mdebug    [0m] [1mAttempting BSP split          [0m [[0m[1m[34mgame.world.procgen[0m][0m [36mbase_h[0m=[35m0[0m [36mdepth[0m=[35m6[0m [36mis_leaf[0m=[35mTrue[0m [36mmax_depth[0m=[35m10[0m [36mrect[0m=[35mRect(x1=64, y1=1, x2=70, y2=13)[0m
[2m2025-05-14T23:07:35.640410[0m [[32m[1mdebug    [0m] [1mSplit node horizontally       [0m [[0m[1m[34mgame.world.procgen[0m][0m [36mdepth[0m=[35m6[0m [36mleft_h[0m=[35m0[0m [36mleft_rect[0m=[35mRect(x1=64, y1=1, x2=70, y2=6)[0m [36mright_h[0m=[35m0[0m [36mright_rect[0m=[35mRect(x1=64, y1=7, x2=70, y2=13)[0m [36my_split[0m=[35m7[0m
[2m2025-05-14T23:07:35.640439[0m [[32m[1mdebug    [0m] [1mAttempting BSP split          [0m [[0m[1m[34mgame.world.procgen[0m][0m [36mbase_h[0m=[35m0[0m [36mdepth[0m=[35m7[0m [36mis_leaf[0m=[35mTrue[0m [36mmax_depth[0m=[35m10[0m [36mrect[0m=[35mRect(x1=64, y1=1, x2=70, y2=6)[0m
[2m2025-05-14T23:07:35.640471[0m [[32m[1mdebug    [0m] [1mSplit aborted: Node too small [0m [[0m[1m[34mgame.world.procgen[0m][0m [36mdimension_size[0m=[35m7[0m [36mmin_required[0m=[35m12[0m [36mrect[0m=[35mRect(x1=64, y1=1, x2=70, y2=6)[0m [36msplit_direction[0m=[35mvertical[0m
[2m2025-05-14T23:07:35.640500[0m [[32m[1mdebug    [0m] [1mAttempting BSP split          [0m [[0m[1m[34mgame.world.procgen[0m][0m [36mbase_h[0m=[35m0[0m [36mdepth[0m=[35m7[0m [36mis_leaf[0m=[35mTrue[0m [36mmax_depth[0m=[35m10[0m [36mrect[0m=[35mRect(x1=64, y1=7, x2=70, y2=13)[0m
[2m2025-05-14T23:07:35.640532[0m [[32m[1mdebug    [0m] [1mSplit aborted: Node too small [0m [[0m[1m[34mgame.world.procgen[0m][0m [36mdimension_size[0m=[35m7[0m [36mmin_required[0m=[35m12[0m [36mrect[0m=[35mRect(x1=64, y1=7, x2=70, y2=13)[0m [36msplit_direction[0m=[35mvertical[0m
[2m2025-05-14T23:07:35.640559[0m [[32m[1mdebug    [0m] [1mAttempting BSP split          [0m [[0m[1m[34mgame.world.procgen[0m][0m [36mbase_h[0m=[35m0[0m [36mdepth[0m=[35m6[0m [36mis_leaf[0m=[35mTrue[0m [36mmax_depth[0m=[35m10[0m [36mrect[0m=[35mRect(x1=64, y1=14, x2=70, y2=27)[0m
[2m2025-05-14T23:07:35.640613[0m [[32m[1mdebug    [0m] [1mSplit node horizontally       [0m [[0m[1m[34mgame.world.procgen[0m][0m [36mdepth[0m=[35m6[0m [36mleft_h[0m=[35m0[0m [36mleft_rect[0m=[35mRect(x1=64, y1=14, x2=70, y2=20)[0m [36mright_h[0m=[35m0[0m [36mright_rect[0m=[35mRect(x1=64, y1=21, x2=70, y2=27)[0m [36my_split[0m=[35m21[0m
[2m2025-05-14T23:07:35.640645[0m [[32m[1mdebug    [0m] [1mAttempting BSP split          [0m [[0m[1m[34mgame.world.procgen[0m][0m [36mbase_h[0m=[35m0[0m [36mdepth[0m=[35m7[0m [36mis_leaf[0m=[35mTrue[0m [36mmax_depth[0m=[35m10[0m [36mrect[0m=[35mRect(x1=64, y1=14, x2=70, y2=20)[0m
[2m2025-05-14T23:07:35.640678[0m [[32m[1mdebug    [0m] [1mSplit aborted: Node too small [0m [[0m[1m[34mgame.world.procgen[0m][0m [36mdimension_size[0m=[35m7[0m [36mmin_required[0m=[35m12[0m [36mrect[0m=[35mRect(x1=64, y1=14, x2=70, y2=20)[0m [36msplit_direction[0m=[35mvertical[0m
[2m2025-05-14T23:07:35.640706[0m [[32m[1mdebug    [0m] [1mAttempting BSP split          [0m [[0m[1m[34mgame.world.procgen[0m][0m [36mbase_h[0m=[35m0[0m [36mdepth[0m=[35m7[0m [36mis_leaf[0m=[35mTrue[0m [36mmax_depth[0m=[35m10[0m [36mrect[0m=[35mRect(x1=64, y1=21, x2=70, y2=27)[0m
[2m2025-05-14T23:07:35.640741[0m [[32m[1mdebug    [0m] [1mSplit aborted: Node too small [0m [[0m[1m[34mgame.world.procgen[0m][0m [36mdimension_size[0m=[35m7[0m [36mmin_required[0m=[35m12[0m [36mrect[0m=[35mRect(x1=64, y1=21, x2=70, y2=27)[0m [36msplit_direction[0m=[35mvertical[0m
[2m2025-05-14T23:07:35.640771[0m [[32m[1mdebug    [0m] [1mAttempting BSP split          [0m [[0m[1m[34mgame.world.procgen[0m][0m [36mbase_h[0m=[35m0[0m [36mdepth[0m=[35m4[0m [36mis_leaf[0m=[35mTrue[0m [36mmax_depth[0m=[35m10[0m [36mrect[0m=[35mRect(x1=71, y1=1, x2=78, y2=27)[0m
[2m2025-05-14T23:07:35.640806[0m [[32m[1mdebug    [0m] [1mSplit node horizontally       [0m [[0m[1m[34mgame.world.procgen[0m][0m [36mdepth[0m=[35m4[0m [36mleft_h[0m=[35m0[0m [36mleft_rect[0m=[35mRect(x1=71, y1=1, x2=78, y2=9)[0m [36mright_h[0m=[35m0[0m [36mright_rect[0m=[35mRect(x1=71, y1=10, x2=78, y2=27)[0m [36my_split[0m=[35m10[0m
[2m2025-05-14T23:07:35.640836[0m [[32m[1mdebug    [0m] [1mAttempting BSP split          [0m [[0m[1m[34mgame.world.procgen[0m][0m [36mbase_h[0m=[35m0[0m [36mdepth[0m=[35m5[0m [36mis_leaf[0m=[35mTrue[0m [36mmax_depth[0m=[35m10[0m [36mrect[0m=[35mRect(x1=71, y1=1, x2=78, y2=9)[0m
[2m2025-05-14T23:07:35.640868[0m [[32m[1mdebug    [0m] [1mSplit aborted: Node too small [0m [[0m[1m[34mgame.world.procgen[0m][0m [36mdimension_size[0m=[35m8[0m [36mmin_required[0m=[35m12[0m [36mrect[0m=[35mRect(x1=71, y1=1, x2=78, y2=9)[0m [36msplit_direction[0m=[35mvertical[0m
[2m2025-05-14T23:07:35.640897[0m [[32m[1mdebug    [0m] [1mAttempting BSP split          [0m [[0m[1m[34mgame.world.procgen[0m][0m [36mbase_h[0m=[35m0[0m [36mdepth[0m=[35m5[0m [36mis_leaf[0m=[35mTrue[0m [36mmax_depth[0m=[35m10[0m [36mrect[0m=[35mRect(x1=71, y1=10, x2=78, y2=27)[0m
[2m2025-05-14T23:07:35.640936[0m [[32m[1mdebug    [0m] [1mSplit node horizontally       [0m [[0m[1m[34mgame.world.procgen[0m][0m [36mdepth[0m=[35m5[0m [36mleft_h[0m=[35m0[0m [36mleft_rect[0m=[35mRect(x1=71, y1=10, x2=78, y2=19)[0m [36mright_h[0m=[35m0[0m [36mright_rect[0m=[35mRect(x1=71, y1=20, x2=78, y2=27)[0m [36my_split[0m=[35m20[0m
[2m2025-05-14T23:07:35.640966[0m [[32m[1mdebug    [0m] [1mAttempting BSP split          [0m [[0m[1m[34mgame.world.procgen[0m][0m [36mbase_h[0m=[35m0[0m [36mdepth[0m=[35m6[0m [36mis_leaf[0m=[35mTrue[0m [36mmax_depth[0m=[35m10[0m [36mrect[0m=[35mRect(x1=71, y1=10, x2=78, y2=19)[0m
[2m2025-05-14T23:07:35.640994[0m [[32m[1mdebug    [0m] [1mSplit aborted: Node too small [0m [[0m[1m[34mgame.world.procgen[0m][0m [36mdimension_size[0m=[35m10[0m [36mmin_required[0m=[35m12[0m [36mrect[0m=[35mRect(x1=71, y1=10, x2=78, y2=19)[0m [36msplit_direction[0m=[35mhorizontal[0m
[2m2025-05-14T23:07:35.641021[0m [[32m[1mdebug    [0m] [1mAttempting BSP split          [0m [[0m[1m[34mgame.world.procgen[0m][0m [36mbase_h[0m=[35m0[0m [36mdepth[0m=[35m6[0m [36mis_leaf[0m=[35mTrue[0m [36mmax_depth[0m=[35m10[0m [36mrect[0m=[35mRect(x1=71, y1=20, x2=78, y2=27)[0m
[2m2025-05-14T23:07:35.641057[0m [[32m[1mdebug    [0m] [1mSplit aborted: Node too small [0m [[0m[1m[34mgame.world.procgen[0m][0m [36mdimension_size[0m=[35m8[0m [36mmin_required[0m=[35m12[0m [36mrect[0m=[35mRect(x1=71, y1=20, x2=78, y2=27)[0m [36msplit_direction[0m=[35mvertical[0m
[2m2025-05-14T23:07:35.641095[0m [[32m[1mdebug    [0m] [1mAttempting BSP split          [0m [[0m[1m[34mgame.world.procgen[0m][0m [36mbase_h[0m=[35m0[0m [36mdepth[0m=[35m3[0m [36mis_leaf[0m=[35mTrue[0m [36mmax_depth[0m=[35m10[0m [36mrect[0m=[35mRect(x1=47, y1=28, x2=78, y2=48)[0m
[2m2025-05-14T23:07:35.641137[0m [[32m[1mdebug    [0m] [1mSplit node vertically         [0m [[0m[1m[34mgame.world.procgen[0m][0m [36mdepth[0m=[35m3[0m [36mleft_h[0m=[35m0[0m [36mleft_rect[0m=[35mRect(x1=47, y1=28, x2=67, y2=48)[0m [36mright_h[0m=[35m0[0m [36mright_rect[0m=[35mRect(x1=68, y1=28, x2=78, y2=48)[0m [36mx_split[0m=[35m68[0m
[2m2025-05-14T23:07:35.641172[0m [[32m[1mdebug    [0m] [1mAttempting BSP split          [0m [[0m[1m[34mgame.world.procgen[0m][0m [36mbase_h[0m=[35m0[0m [36mdepth[0m=[35m4[0m [36mis_leaf[0m=[35mTrue[0m [36mmax_depth[0m=[35m10[0m [36mrect[0m=[35mRect(x1=47, y1=28, x2=67, y2=48)[0m
[2m2025-05-14T23:07:35.641223[0m [[32m[1mdebug    [0m] [1mSplit node vertically         [0m [[0m[1m[34mgame.world.procgen[0m][0m [36mdepth[0m=[35m4[0m [36mleft_h[0m=[35m0[0m [36mleft_rect[0m=[35mRect(x1=47, y1=28, x2=58, y2=48)[0m [36mright_h[0m=[35m0[0m [36mright_rect[0m=[35mRect(x1=59, y1=28, x2=67, y2=48)[0m [36mx_split[0m=[35m59[0m
[2m2025-05-14T23:07:35.641255[0m [[32m[1mdebug    [0m] [1mAttempting BSP split          [0m [[0m[1m[34mgame.world.procgen[0m][0m [36mbase_h[0m=[35m0[0m [36mdepth[0m=[35m5[0m [36mis_leaf[0m=[35mTrue[0m [36mmax_depth[0m=[35m10[0m [36mrect[0m=[35mRect(x1=47, y1=28, x2=58, y2=48)[0m
[2m2025-05-14T23:07:35.641291[0m [[32m[1mdebug    [0m] [1mSplit node horizontally       [0m [[0m[1m[34mgame.world.procgen[0m][0m [36mdepth[0m=[35m5[0m [36mleft_h[0m=[35m0[0m [36mleft_rect[0m=[35mRect(x1=47, y1=28, x2=58, y2=39)[0m [36mright_h[0m=[35m0[0m [36mright_rect[0m=[35mRect(x1=47, y1=40, x2=58, y2=48)[0m [36my_split[0m=[35m40[0m
[2m2025-05-14T23:07:35.641322[0m [[32m[1mdebug    [0m] [1mAttempting BSP split          [0m [[0m[1m[34mgame.world.procgen[0m][0m [36mbase_h[0m=[35m0[0m [36mdepth[0m=[35m6[0m [36mis_leaf[0m=[35mTrue[0m [36mmax_depth[0m=[35m10[0m [36mrect[0m=[35mRect(x1=47, y1=28, x2=58, y2=39)[0m
[2m2025-05-14T23:07:35.641353[0m [[32m[1mdebug    [0m] [1mSplit aborted: Node too small [0m [[0m[1m[34mgame.world.procgen[0m][0m [36mdimension_size[0m=[35m12[0m [36mmin_required[0m=[35m12[0m [36mrect[0m=[35mRect(x1=47, y1=28, x2=58, y2=39)[0m [36msplit_direction[0m=[35mvertical[0m
[2m2025-05-14T23:07:35.641381[0m [[32m[1mdebug    [0m] [1mAttempting BSP split          [0m [[0m[1m[34mgame.world.procgen[0m][0m [36mbase_h[0m=[35m0[0m [36mdepth[0m=[35m6[0m [36mis_leaf[0m=[35mTrue[0m [36mmax_depth[0m=[35m10[0m [36mrect[0m=[35mRect(x1=47, y1=40, x2=58, y2=48)[0m
[2m2025-05-14T23:07:35.641408[0m [[32m[1mdebug    [0m] [1mSplit aborted: Node too small [0m [[0m[1m[34mgame.world.procgen[0m][0m [36mdimension_size[0m=[35m12[0m [36mmin_required[0m=[35m12[0m [36mrect[0m=[35mRect(x1=47, y1=40, x2=58, y2=48)[0m [36msplit_direction[0m=[35mvertical[0m
[2m2025-05-14T23:07:35.641435[0m [[32m[1mdebug    [0m] [1mAttempting BSP split          [0m [[0m[1m[34mgame.world.procgen[0m][0m [36mbase_h[0m=[35m0[0m [36mdepth[0m=[35m5[0m [36mis_leaf[0m=[35mTrue[0m [36mmax_depth[0m=[35m10[0m [36mrect[0m=[35mRect(x1=59, y1=28, x2=67, y2=48)[0m
[2m2025-05-14T23:07:35.641469[0m [[32m[1mdebug    [0m] [1mSplit node horizontally       [0m [[0m[1m[34mgame.world.procgen[0m][0m [36mdepth[0m=[35m5[0m [36mleft_h[0m=[35m0[0m [36mleft_rect[0m=[35mRect(x1=59, y1=28, x2=67, y2=39)[0m [36mright_h[0m=[35m0[0m [36mright_rect[0m=[35mRect(x1=59, y1=40, x2=67, y2=48)[0m [36my_split[0m=[35m40[0m
[2m2025-05-14T23:07:35.641499[0m [[32m[1mdebug    [0m] [1mAttempting BSP split          [0m [[0m[1m[34mgame.world.procgen[0m][0m [36mbase_h[0m=[35m0[0m [36mdepth[0m=[35m6[0m [36mis_leaf[0m=[35mTrue[0m [36mmax_depth[0m=[35m10[0m [36mrect[0m=[35mRect(x1=59, y1=28, x2=67, y2=39)[0m
[2m2025-05-14T23:07:35.641525[0m [[32m[1mdebug    [0m] [1mSplit aborted: Node too small [0m [[0m[1m[34mgame.world.procgen[0m][0m [36mdimension_size[0m=[35m12[0m [36mmin_required[0m=[35m12[0m [36mrect[0m=[35mRect(x1=59, y1=28, x2=67, y2=39)[0m [36msplit_direction[0m=[35mhorizontal[0m
[2m2025-05-14T23:07:35.641556[0m [[32m[1mdebug    [0m] [1mAttempting BSP split          [0m [[0m[1m[34mgame.world.procgen[0m][0m [36mbase_h[0m=[35m0[0m [36mdepth[0m=[35m6[0m [36mis_leaf[0m=[35mTrue[0m [36mmax_depth[0m=[35m10[0m [36mrect[0m=[35mRect(x1=59, y1=40, x2=67, y2=48)[0m
[2m2025-05-14T23:07:35.641599[0m [[32m[1mdebug    [0m] [1mSplit aborted: Node too small [0m [[0m[1m[34mgame.world.procgen[0m][0m [36mdimension_size[0m=[35m9[0m [36mmin_required[0m=[35m12[0m [36mrect[0m=[35mRect(x1=59, y1=40, x2=67, y2=48)[0m [36msplit_direction[0m=[35mvertical[0m
[2m2025-05-14T23:07:35.641629[0m [[32m[1mdebug    [0m] [1mAttempting BSP split          [0m [[0m[1m[34mgame.world.procgen[0m][0m [36mbase_h[0m=[35m0[0m [36mdepth[0m=[35m4[0m [36mis_leaf[0m=[35mTrue[0m [36mmax_depth[0m=[35m10[0m [36mrect[0m=[35mRect(x1=68, y1=28, x2=78, y2=48)[0m
[2m2025-05-14T23:07:35.641665[0m [[32m[1mdebug    [0m] [1mSplit node horizontally       [0m [[0m[1m[34mgame.world.procgen[0m][0m [36mdepth[0m=[35m4[0m [36mleft_h[0m=[35m0[0m [36mleft_rect[0m=[35mRect(x1=68, y1=28, x2=78, y2=40)[0m [36mright_h[0m=[35m0[0m [36mright_rect[0m=[35mRect(x1=68, y1=41, x2=78, y2=48)[0m [36my_split[0m=[35m41[0m
[2m2025-05-14T23:07:35.641695[0m [[32m[1mdebug    [0m] [1mAttempting BSP split          [0m [[0m[1m[34mgame.world.procgen[0m][0m [36mbase_h[0m=[35m0[0m [36mdepth[0m=[35m5[0m [36mis_leaf[0m=[35mTrue[0m [36mmax_depth[0m=[35m10[0m [36mrect[0m=[35mRect(x1=68, y1=28, x2=78, y2=40)[0m
[2m2025-05-14T23:07:35.641727[0m [[32m[1mdebug    [0m] [1mSplit aborted: Node too small [0m [[0m[1m[34mgame.world.procgen[0m][0m [36mdimension_size[0m=[35m11[0m [36mmin_required[0m=[35m12[0m [36mrect[0m=[35mRect(x1=68, y1=28, x2=78, y2=40)[0m [36msplit_direction[0m=[35mvertical[0m
[2m2025-05-14T23:07:35.641754[0m [[32m[1mdebug    [0m] [1mAttempting BSP split          [0m [[0m[1m[34mgame.world.procgen[0m][0m [36mbase_h[0m=[35m0[0m [36mdepth[0m=[35m5[0m [36mis_leaf[0m=[35mTrue[0m [36mmax_depth[0m=[35m10[0m [36mrect[0m=[35mRect(x1=68, y1=41, x2=78, y2=48)[0m
[2m2025-05-14T23:07:35.641781[0m [[32m[1mdebug    [0m] [1mSplit aborted: Node too small [0m [[0m[1m[34mgame.world.procgen[0m][0m [36mdimension_size[0m=[35m11[0m [36mmin_required[0m=[35m12[0m [36mrect[0m=[35mRect(x1=68, y1=41, x2=78, y2=48)[0m [36msplit_direction[0m=[35mvertical[0m
[2m2025-05-14T23:07:35.641807[0m [[32m[1minfo     [0m] [1mDefining rooms...             [0m [[0m[1m[34mgame.world.procgen[0m][0m
[2m2025-05-14T23:07:35.641829[0m [[32m[1mdebug    [0m] [1mCreating rooms in leaves...   [0m [[0m[1m[34mgame.world.procgen[0m][0m
[2m2025-05-14T23:07:35.641875[0m [[32m[1mdebug    [0m] [1mDefined room                  [0m [[0m[1m[34mgame.world.procgen[0m][0m [36mbase_floor_h[0m=[35m0[0m [36mleaf_rect[0m=[35mRect(x1=1, y1=1, x2=7, y2=6)[0m [36mroom_rect[0m=[35mRect(x1=2, y1=2, x2=6, y2=5)[0m
[2m2025-05-14T23:07:35.641923[0m [[32m[1mdebug    [0m] [1mDefined room                  [0m [[0m[1m[34mgame.world.procgen[0m][0m [36mbase_floor_h[0m=[35m0[0m [36mleaf_rect[0m=[35mRect(x1=8, y1=1, x2=16, y2=6)[0m [36mroom_rect[0m=[35mRect(x1=10, y1=1, x2=15, y2=4)[0m
[2m2025-05-14T23:07:35.641970[0m [[32m[1mdebug    [0m] [1mDefined room                  [0m [[0m[1m[34mgame.world.procgen[0m][0m [36mbase_floor_h[0m=[35m0[0m [36mleaf_rect[0m=[35mRect(x1=17, y1=1, x2=23, y2=6)[0m [36mroom_rect[0m=[35mRect(x1=18, y1=2, x2=22, y2=5)[0m
[2m2025-05-14T23:07:35.642029[0m [[32m[1mdebug    [0m] [1mDefined room                  [0m [[0m[1m[34mgame.world.procgen[0m][0m [36mbase_floor_h[0m=[35m0[0m [36mleaf_rect[0m=[35mRect(x1=24, y1=1, x2=34, y2=6)[0m [36mroom_rect[0m=[35mRect(x1=25, y1=2, x2=32, y2=5)[0m
[2m2025-05-14T23:07:35.642080[0m [[32m[1mdebug    [0m] [1mDefined room                  [0m [[0m[1m[34mgame.world.procgen[0m][0m [36mbase_floor_h[0m=[35m0[0m [36mleaf_rect[0m=[35mRect(x1=1, y1=7, x2=7, y2=12)[0m [36mroom_rect[0m=[35mRect(x1=2, y1=9, x2=6, y2=12)[0m
[2m2025-05-14T23:07:35.642132[0m [[32m[1mdebug    [0m] [1mDefined room                  [0m [[0m[1m[34mgame.world.procgen[0m][0m [36mbase_floor_h[0m=[35m0[0m [36mleaf_rect[0m=[35mRect(x1=8, y1=7, x2=14, y2=12)[0m [36mroom_rect[0m=[35mRect(x1=10, y1=7, x2=13, y2=10)[0m
[2m2025-05-14T23:07:35.642183[0m [[32m[1mdebug    [0m] [1mDefined room                  [0m [[0m[1m[34mgame.world.procgen[0m][0m [36mbase_floor_h[0m=[35m0[0m [36mleaf_rect[0m=[35mRect(x1=1, y1=13, x2=6, y2=22)[0m [36mroom_rect[0m=[35mRect(x1=3, y1=15, x2=6, y2=18)[0m
[2m2025-05-14T23:07:35.642237[0m [[32m[1mdebug    [0m] [1mDefined room                  [0m [[0m[1m[34mgame.world.procgen[0m][0m [36mbase_floor_h[0m=[35m0[0m [36mleaf_rect[0m=[35mRect(x1=7, y1=13, x2=14, y2=22)[0m [36mroom_rect[0m=[35mRect(x1=9, y1=18, x2=14, y2=21)[0m
[2m2025-05-14T23:07:35.642289[0m [[32m[1mdebug    [0m] [1mDefined room                  [0m [[0m[1m[34mgame.world.procgen[0m][0m [36mbase_floor_h[0m=[35m0[0m [36mleaf_rect[0m=[35mRect(x1=1, y1=23, x2=7, y2=32)[0m [36mroom_rect[0m=[35mRect(x1=4, y1=24, x2=7, y2=31)[0m
[2m2025-05-14T23:07:35.642342[0m [[32m[1mdebug    [0m] [1mDefined room                  [0m [[0m[1m[34mgame.world.procgen[0m][0m [36mbase_floor_h[0m=[35m0[0m [36mleaf_rect[0m=[35mRect(x1=8, y1=23, x2=14, y2=32)[0m [36mroom_rect[0m=[35mRect(x1=8, y1=26, x2=12, y2=31)[0m
[2m2025-05-14T23:07:35.642387[0m [[32m[1mdebug    [0m] [1mDefined room                  [0m [[0m[1m[34mgame.world.procgen[0m][0m [36mbase_floor_h[0m=[35m0[0m [36mleaf_rect[0m=[35mRect(x1=1, y1=33, x2=6, y2=41)[0m [36mroom_rect[0m=[35mRect(x1=3, y1=38, x2=6, y2=41)[0m
[2m2025-05-14T23:07:35.642438[0m [[32m[1mdebug    [0m] [1mDefined room                  [0m [[0m[1m[34mgame.world.procgen[0m][0m [36mbase_floor_h[0m=[35m0[0m [36mleaf_rect[0m=[35mRect(x1=7, y1=33, x2=14, y2=41)[0m [36mroom_rect[0m=[35mRect(x1=8, y1=35, x2=13, y2=40)[0m
[2m2025-05-14T23:07:35.642484[0m [[32m[1mdebug    [0m] [1mDefined room                  [0m [[0m[1m[34mgame.world.procgen[0m][0m [36mbase_floor_h[0m=[35m0[0m [36mleaf_rect[0m=[35mRect(x1=1, y1=42, x2=6, y2=48)[0m [36mroom_rect[0m=[35mRect(x1=3, y1=42, x2=6, y2=46)[0m
[2m2025-05-14T23:07:35.642540[0m [[32m[1mdebug    [0m] [1mDefined room                  [0m [[0m[1m[34mgame.world.procgen[0m][0m [36mbase_floor_h[0m=[35m0[0m [36mleaf_rect[0m=[35mRect(x1=7, y1=42, x2=14, y2=48)[0m [36mroom_rect[0m=[35mRect(x1=9, y1=43, x2=13, y2=46)[0m
[2m2025-05-14T23:07:35.642598[0m [[32m[1mdebug    [0m] [1mDefined room                  [0m [[0m[1m[34mgame.world.procgen[0m][0m [36mbase_floor_h[0m=[35m0[0m [36mleaf_rect[0m=[35mRect(x1=15, y1=7, x2=25, y2=16)[0m [36mroom_rect[0m=[35mRect(x1=20, y1=8, x2=23, y2=11)[0m
[2m2025-05-14T23:07:35.642652[0m [[32m[1mdebug    [0m] [1mDefined room                  [0m [[0m[1m[34mgame.world.procgen[0m][0m [36mbase_floor_h[0m=[35m0[0m [36mleaf_rect[0m=[35mRect(x1=26, y1=7, x2=34, y2=16)[0m [36mroom_rect[0m=[35mRect(x1=27, y1=8, x2=33, y2=15)[0m
[2m2025-05-14T23:07:35.642715[0m [[32m[1mdebug    [0m] [1mDefined room                  [0m [[0m[1m[34mgame.world.procgen[0m][0m [36mbase_floor_h[0m=[35m0[0m [36mleaf_rect[0m=[35mRect(x1=15, y1=17, x2=21, y2=27)[0m [36mroom_rect[0m=[35mRect(x1=17, y1=19, x2=20, y2=25)[0m
[2m2025-05-14T23:07:35.642761[0m [[32m[1mdebug    [0m] [1mDefined room                  [0m [[0m[1m[34mgame.world.procgen[0m][0m [36mbase_floor_h[0m=[35m0[0m [36mleaf_rect[0m=[35mRect(x1=22, y1=17, x2=27, y2=27)[0m [36mroom_rect[0m=[35mRect(x1=22, y1=17, x2=25, y2=23)[0m
[2m2025-05-14T23:07:35.642816[0m [[32m[1mdebug    [0m] [1mDefined room                  [0m [[0m[1m[34mgame.world.procgen[0m][0m [36mbase_floor_h[0m=[35m0[0m [36mleaf_rect[0m=[35mRect(x1=28, y1=17, x2=34, y2=27)[0m [36mroom_rect[0m=[35mRect(x1=28, y1=20, x2=32, y2=26)[0m
[2m2025-05-14T23:07:35.642867[0m [[32m[1mdebug    [0m] [1mDefined room                  [0m [[0m[1m[34mgame.world.procgen[0m][0m [36mbase_floor_h[0m=[35m0[0m [36mleaf_rect[0m=[35mRect(x1=15, y1=28, x2=25, y2=37)[0m [36mroom_rect[0m=[35mRect(x1=18, y1=31, x2=24, y2=35)[0m
[2m2025-05-14T23:07:35.642928[0m [[32m[1mdebug    [0m] [1mDefined room                  [0m [[0m[1m[34mgame.world.procgen[0m][0m [36mbase_floor_h[0m=[35m0[0m [36mleaf_rect[0m=[35mRect(x1=15, y1=38, x2=25, y2=48)[0m [36mroom_rect[0m=[35mRect(x1=18, y1=39, x2=22, y2=46)[0m
[2m2025-05-14T23:07:35.642972[0m [[32m[1mdebug    [0m] [1mDefined room                  [0m [[0m[1m[34mgame.world.procgen[0m][0m [36mbase_floor_h[0m=[35m0[0m [36mleaf_rect[0m=[35mRect(x1=26, y1=28, x2=34, y2=33)[0m [36mroom_rect[0m=[35mRect(x1=27, y1=29, x2=32, y2=32)[0m
[2m2025-05-14T23:07:35.643016[0m [[32m[1mdebug    [0m] [1mDefined room                  [0m [[0m[1m[34mgame.world.procgen[0m][0m [36mbase_floor_h[0m=[35m0[0m [36mleaf_rect[0m=[35mRect(x1=26, y1=34, x2=34, y2=39)[0m [36mroom_rect[0m=[35mRect(x1=27, y1=34, x2=31, y2=37)[0m
[2m2025-05-14T23:07:35.643081[0m [[32m[1mdebug    [0m] [1mDefined room                  [0m [[0m[1m[34mgame.world.procgen[0m][0m [36mbase_floor_h[0m=[35m0[0m [36mleaf_rect[0m=[35mRect(x1=26, y1=40, x2=34, y2=48)[0m [36mroom_rect[0m=[35mRect(x1=27, y1=45, x2=31, y2=48)[0m
[2m2025-05-14T23:07:35.643139[0m [[32m[1mdebug    [0m] [1mDefined room                  [0m [[0m[1m[34mgame.world.procgen[0m][0m [36mbase_floor_h[0m=[35m0[0m [36mleaf_rect[0m=[35mRect(x1=35, y1=1, x2=46, y2=9)[0m [36mroom_rect[0m=[35mRect(x1=36, y1=2, x2=40, y2=5)[0m
[2m2025-05-14T23:07:35.643190[0m [[32m[1mdebug    [0m] [1mDefined room                  [0m [[0m[1m[34mgame.world.procgen[0m][0m [36mbase_floor_h[0m=[35m0[0m [36mleaf_rect[0m=[35mRect(x1=35, y1=10, x2=46, y2=20)[0m [36mroom_rect[0m=[35mRect(x1=38, y1=10, x2=43, y2=17)[0m
[2m2025-05-14T23:07:35.643239[0m [[32m[1mdebug    [0m] [1mDefined room                  [0m [[0m[1m[34mgame.world.procgen[0m][0m [36mbase_floor_h[0m=[35m0[0m [36mleaf_rect[0m=[35mRect(x1=35, y1=21, x2=46, y2=28)[0m [36mroom_rect[0m=[35mRect(x1=42, y1=23, x2=45, y2=28)[0m
[2m2025-05-14T23:07:35.643288[0m [[32m[1mdebug    [0m] [1mDefined room                  [0m [[0m[1m[34mgame.world.procgen[0m][0m [36mbase_floor_h[0m=[35m0[0m [36mleaf_rect[0m=[35mRect(x1=35, y1=29, x2=46, y2=40)[0m [36mroom_rect[0m=[35mRect(x1=39, y1=33, x2=46, y2=38)[0m
[2m2025-05-14T23:07:35.643345[0m [[32m[1mdebug    [0m] [1mDefined room                  [0m [[0m[1m[34mgame.world.procgen[0m][0m [36mbase_floor_h[0m=[35m0[0m [36mleaf_rect[0m=[35mRect(x1=35, y1=41, x2=46, y2=48)[0m [36mroom_rect[0m=[35mRect(x1=36, y1=42, x2=40, y2=45)[0m
[2m2025-05-14T23:07:35.643398[0m [[32m[1mdebug    [0m] [1mDefined room                  [0m [[0m[1m[34mgame.world.procgen[0m][0m [36mbase_floor_h[0m=[35m0[0m [36mleaf_rect[0m=[35mRect(x1=47, y1=1, x2=54, y2=7)[0m [36mroom_rect[0m=[35mRect(x1=49, y1=3, x2=54, y2=7)[0m
[2m2025-05-14T23:07:35.643443[0m [[32m[1mdebug    [0m] [1mDefined room                  [0m [[0m[1m[34mgame.world.procgen[0m][0m [36mbase_floor_h[0m=[35m0[0m [36mleaf_rect[0m=[35mRect(x1=47, y1=8, x2=54, y2=13)[0m [36mroom_rect[0m=[35mRect(x1=48, y1=8, x2=51, y2=11)[0m
[2m2025-05-14T23:07:35.643488[0m [[32m[1mdebug    [0m] [1mDefined room                  [0m [[0m[1m[34mgame.world.procgen[0m][0m [36mbase_floor_h[0m=[35m0[0m [36mleaf_rect[0m=[35mRect(x1=47, y1=14, x2=54, y2=20)[0m [36mroom_rect[0m=[35mRect(x1=49, y1=16, x2=52, y2=19)[0m
[2m2025-05-14T23:07:35.643553[0m [[32m[1mdebug    [0m] [1mDefined room                  [0m [[0m[1m[34mgame.world.procgen[0m][0m [36mbase_floor_h[0m=[35m0[0m [36mleaf_rect[0m=[35mRect(x1=55, y1=1, x2=63, y2=7)[0m [36mroom_rect[0m=[35mRect(x1=56, y1=1, x2=61, y2=5)[0m
[2m2025-05-14T23:07:35.643611[0m [[32m[1mdebug    [0m] [1mDefined room                  [0m [[0m[1m[34mgame.world.procgen[0m][0m [36mbase_floor_h[0m=[35m0[0m [36mleaf_rect[0m=[35mRect(x1=55, y1=8, x2=63, y2=13)[0m [36mroom_rect[0m=[35mRect(x1=57, y1=9, x2=61, y2=12)[0m
[2m2025-05-14T23:07:35.643664[0m [[32m[1mdebug    [0m] [1mDefined room                  [0m [[0m[1m[34mgame.world.procgen[0m][0m [36mbase_floor_h[0m=[35m0[0m [36mleaf_rect[0m=[35mRect(x1=55, y1=14, x2=63, y2=20)[0m [36mroom_rect[0m=[35mRect(x1=55, y1=14, x2=61, y2=17)[0m
[2m2025-05-14T23:07:35.643719[0m [[32m[1mdebug    [0m] [1mDefined room                  [0m [[0m[1m[34mgame.world.procgen[0m][0m [36mbase_floor_h[0m=[35m0[0m [36mleaf_rect[0m=[35mRect(x1=47, y1=21, x2=55, y2=27)[0m [36mroom_rect[0m=[35mRect(x1=49, y1=23, x2=53, y2=26)[0m
[2m2025-05-14T23:07:35.643771[0m [[32m[1mdebug    [0m] [1mDefined room                  [0m [[0m[1m[34mgame.world.procgen[0m][0m [36mbase_floor_h[0m=[35m0[0m [36mleaf_rect[0m=[35mRect(x1=56, y1=21, x2=63, y2=27)[0m [36mroom_rect[0m=[35mRect(x1=58, y1=21, x2=63, y2=25)[0m
[2m2025-05-14T23:07:35.643817[0m [[32m[1mdebug    [0m] [1mDefined room                  [0m [[0m[1m[34mgame.world.procgen[0m][0m [36mbase_floor_h[0m=[35m0[0m [36mleaf_rect[0m=[35mRect(x1=64, y1=1, x2=70, y2=6)[0m [36mroom_rect[0m=[35mRect(x1=65, y1=1, x2=69, y2=4)[0m
[2m2025-05-14T23:07:35.643872[0m [[32m[1mdebug    [0m] [1mDefined room                  [0m [[0m[1m[34mgame.world.procgen[0m][0m [36mbase_floor_h[0m=[35m0[0m [36mleaf_rect[0m=[35mRect(x1=64, y1=7, x2=70, y2=13)[0m [36mroom_rect[0m=[35mRect(x1=65, y1=8, x2=68, y2=12)[0m
[2m2025-05-14T23:07:35.643919[0m [[32m[1mdebug    [0m] [1mDefined room                  [0m [[0m[1m[34mgame.world.procgen[0m][0m [36mbase_floor_h[0m=[35m0[0m [36mleaf_rect[0m=[35mRect(x1=64, y1=14, x2=70, y2=20)[0m [36mroom_rect[0m=[35mRect(x1=64, y1=15, x2=68, y2=19)[0m
[2m2025-05-14T23:07:35.643974[0m [[32m[1mdebug    [0m] [1mDefined room                  [0m [[0m[1m[34mgame.world.procgen[0m][0m [36mbase_floor_h[0m=[35m0[0m [36mleaf_rect[0m=[35mRect(x1=64, y1=21, x2=70, y2=27)[0m [36mroom_rect[0m=[35mRect(x1=66, y1=21, x2=69, y2=25)[0m
[2m2025-05-14T23:07:35.644022[0m [[32m[1mdebug    [0m] [1mDefined room                  [0m [[0m[1m[34mgame.world.procgen[0m][0m [36mbase_floor_h[0m=[35m0[0m [36mleaf_rect[0m=[35mRect(x1=71, y1=1, x2=78, y2=9)[0m [36mroom_rect[0m=[35mRect(x1=71, y1=2, x2=75, y2=6)[0m
[2m2025-05-14T23:07:35.644075[0m [[32m[1mdebug    [0m] [1mDefined room                  [0m [[0m[1m[34mgame.world.procgen[0m][0m [36mbase_floor_h[0m=[35m0[0m [36mleaf_rect[0m=[35mRect(x1=71, y1=10, x2=78, y2=19)[0m [36mroom_rect[0m=[35mRect(x1=72, y1=14, x2=76, y2=18)[0m
[2m2025-05-14T23:07:35.644126[0m [[32m[1mdebug    [0m] [1mDefined room                  [0m [[0m[1m[34mgame.world.procgen[0m][0m [36mbase_floor_h[0m=[35m0[0m [36mleaf_rect[0m=[35mRect(x1=71, y1=20, x2=78, y2=27)[0m [36mroom_rect[0m=[35mRect(x1=72, y1=22, x2=76, y2=27)[0m
[2m2025-05-14T23:07:35.644176[0m [[32m[1mdebug    [0m] [1mDefined room                  [0m [[0m[1m[34mgame.world.procgen[0m][0m [36mbase_floor_h[0m=[35m0[0m [36mleaf_rect[0m=[35mRect(x1=47, y1=28, x2=58, y2=39)[0m [36mroom_rect[0m=[35mRect(x1=49, y1=28, x2=52, y2=31)[0m
[2m2025-05-14T23:07:35.644226[0m [[32m[1mdebug    [0m] [1mDefined room                  [0m [[0m[1m[34mgame.world.procgen[0m][0m [36mbase_floor_h[0m=[35m0[0m [36mleaf_rect[0m=[35mRect(x1=47, y1=40, x2=58, y2=48)[0m [36mroom_rect[0m=[35mRect(x1=47, y1=44, x2=54, y2=47)[0m
[2m2025-05-14T23:07:35.644284[0m [[32m[1mdebug    [0m] [1mDefined room                  [0m [[0m[1m[34mgame.world.procgen[0m][0m [36mbase_floor_h[0m=[35m0[0m [36mleaf_rect[0m=[35mRect(x1=59, y1=28, x2=67, y2=39)[0m [36mroom_rect[0m=[35mRect(x1=60, y1=33, x2=64, y2=37)[0m
[2m2025-05-14T23:07:35.644333[0m [[32m[1mdebug    [0m] [1mDefined room                  [0m [[0m[1m[34mgame.world.procgen[0m][0m [36mbase_floor_h[0m=[35m0[0m [36mleaf_rect[0m=[35mRect(x1=59, y1=40, x2=67, y2=48)[0m [36mroom_rect[0m=[35mRect(x1=62, y1=43, x2=66, y2=47)[0m
[2m2025-05-14T23:07:35.644386[0m [[32m[1mdebug    [0m] [1mDefined room                  [0m [[0m[1m[34mgame.world.procgen[0m][0m [36mbase_floor_h[0m=[35m0[0m [36mleaf_rect[0m=[35mRect(x1=68, y1=28, x2=78, y2=40)[0m [36mroom_rect[0m=[35mRect(x1=72, y1=29, x2=77, y2=34)[0m
[2m2025-05-14T23:07:35.644434[0m [[32m[1mdebug    [0m] [1mDefined room                  [0m [[0m[1m[34mgame.world.procgen[0m][0m [36mbase_floor_h[0m=[35m0[0m [36mleaf_rect[0m=[35mRect(x1=68, y1=41, x2=78, y2=48)[0m [36mroom_rect[0m=[35mRect(x1=70, y1=43, x2=76, y2=48)[0m
[2m2025-05-14T23:07:35.644461[0m [[32m[1minfo     [0m] [1mRoom definition finished      [0m [[0m[1m[34mgame.world.procgen[0m][0m [36mcreated[0m=[35m50[0m [36mskipped[0m=[35m0[0m
[2m2025-05-14T23:07:35.644485[0m [[32m[1minfo     [0m] [1mCarving rooms onto map...     [0m [[0m[1m[34mgame.world.procgen[0m][0m
[2m2025-05-14T23:07:35.644518[0m [[32m[1mdebug    [0m] [1mCarved rectangle area         [0m [[0m[1m[34mgame.world.procgen[0m][0m [36mceil_h[0m=[35m6[0m [36mfloor_h[0m=[35m0[0m [36mrect[0m=[35mRect(x1=2, y1=2, x2=6, y2=5)[0m [36mx_slice[0m=[35m2:7[0m [36my_slice[0m=[35m2:6[0m
[2m2025-05-14T23:07:35.644555[0m [[32m[1mdebug    [0m] [1mCarved rectangle area         [0m [[0m[1m[34mgame.world.procgen[0m][0m [36mceil_h[0m=[35m6[0m [36mfloor_h[0m=[35m0[0m [36mrect[0m=[35mRect(x1=10, y1=1, x2=15, y2=4)[0m [36mx_slice[0m=[35m10:16[0m [36my_slice[0m=[35m1:5[0m
[2m2025-05-14T23:07:35.644599[0m [[32m[1mdebug    [0m] [1mCarved rectangle area         [0m [[0m[1m[34mgame.world.procgen[0m][0m [36mceil_h[0m=[35m6[0m [36mfloor_h[0m=[35m0[0m [36mrect[0m=[35mRect(x1=18, y1=2, x2=22, y2=5)[0m [36mx_slice[0m=[35m18:23[0m [36my_slice[0m=[35m2:6[0m
[2m2025-05-14T23:07:35.644634[0m [[32m[1mdebug    [0m] [1mCarved rectangle area         [0m [[0m[1m[34mgame.world.procgen[0m][0m [36mceil_h[0m=[35m6[0m [36mfloor_h[0m=[35m0[0m [36mrect[0m=[35mRect(x1=25, y1=2, x2=32, y2=5)[0m [36mx_slice[0m=[35m25:33[0m [36my_slice[0m=[35m2:6[0m
[2m2025-05-14T23:07:35.644668[0m [[32m[1mdebug    [0m] [1mCarved rectangle area         [0m [[0m[1m[34mgame.world.procgen[0m][0m [36mceil_h[0m=[35m6[0m [36mfloor_h[0m=[35m0[0m [36mrect[0m=[35mRect(x1=2, y1=9, x2=6, y2=12)[0m [36mx_slice[0m=[35m2:7[0m [36my_slice[0m=[35m9:13[0m
[2m2025-05-14T23:07:35.644700[0m [[32m[1mdebug    [0m] [1mCarved rectangle area         [0m [[0m[1m[34mgame.world.procgen[0m][0m [36mceil_h[0m=[35m6[0m [36mfloor_h[0m=[35m0[0m [36mrect[0m=[35mRect(x1=10, y1=7, x2=13, y2=10)[0m [36mx_slice[0m=[35m10:14[0m [36my_slice[0m=[35m7:11[0m
[2m2025-05-14T23:07:35.644734[0m [[32m[1mdebug    [0m] [1mCarved rectangle area         [0m [[0m[1m[34mgame.world.procgen[0m][0m [36mceil_h[0m=[35m6[0m [36mfloor_h[0m=[35m0[0m [36mrect[0m=[35mRect(x1=3, y1=15, x2=6, y2=18)[0m [36mx_slice[0m=[35m3:7[0m [36my_slice[0m=[35m15:19[0m
[2m2025-05-14T23:07:35.644771[0m [[32m[1mdebug    [0m] [1mCarved rectangle area         [0m [[0m[1m[34mgame.world.procgen[0m][0m [36mceil_h[0m=[35m6[0m [36mfloor_h[0m=[35m0[0m [36mrect[0m=[35mRect(x1=9, y1=18, x2=14, y2=21)[0m [36mx_slice[0m=[35m9:15[0m [36my_slice[0m=[35m18:22[0m
[2m2025-05-14T23:07:35.644805[0m [[32m[1mdebug    [0m] [1mCarved rectangle area         [0m [[0m[1m[34mgame.world.procgen[0m][0m [36mceil_h[0m=[35m6[0m [36mfloor_h[0m=[35m0[0m [36mrect[0m=[35mRect(x1=4, y1=24, x2=7, y2=31)[0m [36mx_slice[0m=[35m4:8[0m [36my_slice[0m=[35m24:32[0m
[2m2025-05-14T23:07:35.644843[0m [[32m[1mdebug    [0m] [1mCarved rectangle area         [0m [[0m[1m[34mgame.world.procgen[0m][0m [36mceil_h[0m=[35m6[0m [36mfloor_h[0m=[35m0[0m [36mrect[0m=[35mRect(x1=8, y1=26, x2=12, y2=31)[0m [36mx_slice[0m=[35m8:13[0m [36my_slice[0m=[35m26:32[0m
[2m2025-05-14T23:07:35.644878[0m [[32m[1mdebug    [0m] [1mCarved rectangle area         [0m [[0m[1m[34mgame.world.procgen[0m][0m [36mceil_h[0m=[35m6[0m [36mfloor_h[0m=[35m0[0m [36mrect[0m=[35mRect(x1=3, y1=38, x2=6, y2=41)[0m [36mx_slice[0m=[35m3:7[0m [36my_slice[0m=[35m38:42[0m
[2m2025-05-14T23:07:35.644911[0m [[32m[1mdebug    [0m] [1mCarved rectangle area         [0m [[0m[1m[34mgame.world.procgen[0m][0m [36mceil_h[0m=[35m6[0m [36mfloor_h[0m=[35m0[0m [36mrect[0m=[35mRect(x1=8, y1=35, x2=13, y2=40)[0m [36mx_slice[0m=[35m8:14[0m [36my_slice[0m=[35m35:41[0m
[2m2025-05-14T23:07:35.644944[0m [[32m[1mdebug    [0m] [1mCarved rectangle area         [0m [[0m[1m[34mgame.world.procgen[0m][0m [36mceil_h[0m=[35m6[0m [36mfloor_h[0m=[35m0[0m [36mrect[0m=[35mRect(x1=3, y1=42, x2=6, y2=46)[0m [36mx_slice[0m=[35m3:7[0m [36my_slice[0m=[35m42:47[0m
[2m2025-05-14T23:07:35.644976[0m [[32m[1mdebug    [0m] [1mCarved rectangle area         [0m [[0m[1m[34mgame.world.procgen[0m][0m [36mceil_h[0m=[35m6[0m [36mfloor_h[0m=[35m0[0m [36mrect[0m=[35mRect(x1=9, y1=43, x2=13, y2=46)[0m [36mx_slice[0m=[35m9:14[0m [36my_slice[0m=[35m43:47[0m
[2m2025-05-14T23:07:35.645007[0m [[32m[1mdebug    [0m] [1mCarved rectangle area         [0m [[0m[1m[34mgame.world.procgen[0m][0m [36mceil_h[0m=[35m6[0m [36mfloor_h[0m=[35m0[0m [36mrect[0m=[35mRect(x1=20, y1=8, x2=23, y2=11)[0m [36mx_slice[0m=[35m20:24[0m [36my_slice[0m=[35m8:12[0m
[2m2025-05-14T23:07:35.645054[0m [[32m[1mdebug    [0m] [1mCarved rectangle area         [0m [[0m[1m[34mgame.world.procgen[0m][0m [36mceil_h[0m=[35m6[0m [36mfloor_h[0m=[35m0[0m [36mrect[0m=[35mRect(x1=27, y1=8, x2=33, y2=15)[0m [36mx_slice[0m=[35m27:34[0m [36my_slice[0m=[35m8:16[0m
[2m2025-05-14T23:07:35.645107[0m [[32m[1mdebug    [0m] [1mCarved rectangle area         [0m [[0m[1m[34mgame.world.procgen[0m][0m [36mceil_h[0m=[35m6[0m [36mfloor_h[0m=[35m0[0m [36mrect[0m=[35mRect(x1=17, y1=19, x2=20, y2=25)[0m [36mx_slice[0m=[35m17:21[0m [36my_slice[0m=[35m19:26[0m
[2m2025-05-14T23:07:35.645146[0m [[32m[1mdebug    [0m] [1mCarved rectangle area         [0m [[0m[1m[34mgame.world.procgen[0m][0m [36mceil_h[0m=[35m6[0m [36mfloor_h[0m=[35m0[0m [36mrect[0m=[35mRect(x1=22, y1=17, x2=25, y2=23)[0m [36mx_slice[0m=[35m22:26[0m [36my_slice[0m=[35m17:24[0m
[2m2025-05-14T23:07:35.645182[0m [[32m[1mdebug    [0m] [1mCarved rectangle area         [0m [[0m[1m[34mgame.world.procgen[0m][0m [36mceil_h[0m=[35m6[0m [36mfloor_h[0m=[35m0[0m [36mrect[0m=[35mRect(x1=28, y1=20, x2=32, y2=26)[0m [36mx_slice[0m=[35m28:33[0m [36my_slice[0m=[35m20:27[0m
[2m2025-05-14T23:07:35.645218[0m [[32m[1mdebug    [0m] [1mCarved rectangle area         [0m [[0m[1m[34mgame.world.procgen[0m][0m [36mceil_h[0m=[35m6[0m [36mfloor_h[0m=[35m0[0m [36mrect[0m=[35mRect(x1=18, y1=31, x2=24, y2=35)[0m [36mx_slice[0m=[35m18:25[0m [36my_slice[0m=[35m31:36[0m
[2m2025-05-14T23:07:35.645254[0m [[32m[1mdebug    [0m] [1mCarved rectangle area         [0m [[0m[1m[34mgame.world.procgen[0m][0m [36mceil_h[0m=[35m6[0m [36mfloor_h[0m=[35m0[0m [36mrect[0m=[35mRect(x1=18, y1=39, x2=22, y2=46)[0m [36mx_slice[0m=[35m18:23[0m [36my_slice[0m=[35m39:47[0m
[2m2025-05-14T23:07:35.645287[0m [[32m[1mdebug    [0m] [1mCarved rectangle area         [0m [[0m[1m[34mgame.world.procgen[0m][0m [36mceil_h[0m=[35m6[0m [36mfloor_h[0m=[35m0[0m [36mrect[0m=[35mRect(x1=27, y1=29, x2=32, y2=32)[0m [36mx_slice[0m=[35m27:33[0m [36my_slice[0m=[35m29:33[0m
[2m2025-05-14T23:07:35.645325[0m [[32m[1mdebug    [0m] [1mCarved rectangle area         [0m [[0m[1m[34mgame.world.procgen[0m][0m [36mceil_h[0m=[35m6[0m [36mfloor_h[0m=[35m0[0m [36mrect[0m=[35mRect(x1=27, y1=34, x2=31, y2=37)[0m [36mx_slice[0m=[35m27:32[0m [36my_slice[0m=[35m34:38[0m
[2m2025-05-14T23:07:35.645360[0m [[32m[1mdebug    [0m] [1mCarved rectangle area         [0m [[0m[1m[34mgame.world.procgen[0m][0m [36mceil_h[0m=[35m6[0m [36mfloor_h[0m=[35m0[0m [36mrect[0m=[35mRect(x1=27, y1=45, x2=31, y2=48)[0m [36mx_slice[0m=[35m27:32[0m [36my_slice[0m=[35m45:49[0m
[2m2025-05-14T23:07:35.645393[0m [[32m[1mdebug    [0m] [1mCarved rectangle area         [0m [[0m[1m[34mgame.world.procgen[0m][0m [36mceil_h[0m=[35m6[0m [36mfloor_h[0m=[35m0[0m [36mrect[0m=[35mRect(x1=36, y1=2, x2=40, y2=5)[0m [36mx_slice[0m=[35m36:41[0m [36my_slice[0m=[35m2:6[0m
[2m2025-05-14T23:07:35.645427[0m [[32m[1mdebug    [0m] [1mCarved rectangle area         [0m [[0m[1m[34mgame.world.procgen[0m][0m [36mceil_h[0m=[35m6[0m [36mfloor_h[0m=[35m0[0m [36mrect[0m=[35mRect(x1=38, y1=10, x2=43, y2=17)[0m [36mx_slice[0m=[35m38:44[0m [36my_slice[0m=[35m10:18[0m
[2m2025-05-14T23:07:35.645459[0m [[32m[1mdebug    [0m] [1mCarved rectangle area         [0m [[0m[1m[34mgame.world.procgen[0m][0m [36mceil_h[0m=[35m6[0m [36mfloor_h[0m=[35m0[0m [36mrect[0m=[35mRect(x1=42, y1=23, x2=45, y2=28)[0m [36mx_slice[0m=[35m42:46[0m [36my_slice[0m=[35m23:29[0m
[2m2025-05-14T23:07:35.645492[0m [[32m[1mdebug    [0m] [1mCarved rectangle area         [0m [[0m[1m[34mgame.world.procgen[0m][0m [36mceil_h[0m=[35m6[0m [36mfloor_h[0m=[35m0[0m [36mrect[0m=[35mRect(x1=39, y1=33, x2=46, y2=38)[0m [36mx_slice[0m=[35m39:47[0m [36my_slice[0m=[35m33:39[0m
[2m2025-05-14T23:07:35.645524[0m [[32m[1mdebug    [0m] [1mCarved rectangle area         [0m [[0m[1m[34mgame.world.procgen[0m][0m [36mceil_h[0m=[35m6[0m [36mfloor_h[0m=[35m0[0m [36mrect[0m=[35mRect(x1=36, y1=42, x2=40, y2=45)[0m [36mx_slice[0m=[35m36:41[0m [36my_slice[0m=[35m42:46[0m
[2m2025-05-14T23:07:35.645557[0m [[32m[1mdebug    [0m] [1mCarved rectangle area         [0m [[0m[1m[34mgame.world.procgen[0m][0m [36mceil_h[0m=[35m6[0m [36mfloor_h[0m=[35m0[0m [36mrect[0m=[35mRect(x1=49, y1=3, x2=54, y2=7)[0m [36mx_slice[0m=[35m49:55[0m [36my_slice[0m=[35m3:8[0m
[2m2025-05-14T23:07:35.645600[0m [[32m[1mdebug    [0m] [1mCarved rectangle area         [0m [[0m[1m[34mgame.world.procgen[0m][0m [36mceil_h[0m=[35m6[0m [36mfloor_h[0m=[35m0[0m [36mrect[0m=[35mRect(x1=48, y1=8, x2=51, y2=11)[0m [36mx_slice[0m=[35m48:52[0m [36my_slice[0m=[35m8:12[0m
[2m2025-05-14T23:07:35.645634[0m [[32m[1mdebug    [0m] [1mCarved rectangle area         [0m [[0m[1m[34mgame.world.procgen[0m][0m [36mceil_h[0m=[35m6[0m [36mfloor_h[0m=[35m0[0m [36mrect[0m=[35mRect(x1=49, y1=16, x2=52, y2=19)[0m [36mx_slice[0m=[35m49:53[0m [36my_slice[0m=[35m16:20[0m
[2m2025-05-14T23:07:35.645667[0m [[32m[1mdebug    [0m] [1mCarved rectangle area         [0m [[0m[1m[34mgame.world.procgen[0m][0m [36mceil_h[0m=[35m6[0m [36mfloor_h[0m=[35m0[0m [36mrect[0m=[35mRect(x1=56, y1=1, x2=61, y2=5)[0m [36mx_slice[0m=[35m56:62[0m [36my_slice[0m=[35m1:6[0m
[2m2025-05-14T23:07:35.645700[0m [[32m[1mdebug    [0m] [1mCarved rectangle area         [0m [[0m[1m[34mgame.world.procgen[0m][0m [36mceil_h[0m=[35m6[0m [36mfloor_h[0m=[35m0[0m [36mrect[0m=[35mRect(x1=57, y1=9, x2=61, y2=12)[0m [36mx_slice[0m=[35m57:62[0m [36my_slice[0m=[35m9:13[0m
[2m2025-05-14T23:07:35.645733[0m [[32m[1mdebug    [0m] [1mCarved rectangle area         [0m [[0m[1m[34mgame.world.procgen[0m][0m [36mceil_h[0m=[35m6[0m [36mfloor_h[0m=[35m0[0m [36mrect[0m=[35mRect(x1=55, y1=14, x2=61, y2=17)[0m [36mx_slice[0m=[35m55:62[0m [36my_slice[0m=[35m14:18[0m
[2m2025-05-14T23:07:35.645770[0m [[32m[1mdebug    [0m] [1mCarved rectangle area         [0m [[0m[1m[34mgame.world.procgen[0m][0m [36mceil_h[0m=[35m6[0m [36mfloor_h[0m=[35m0[0m [36mrect[0m=[35mRect(x1=49, y1=23, x2=53, y2=26)[0m [36mx_slice[0m=[35m49:54[0m [36my_slice[0m=[35m23:27[0m
[2m2025-05-14T23:07:35.645804[0m [[32m[1mdebug    [0m] [1mCarved rectangle area         [0m [[0m[1m[34mgame.world.procgen[0m][0m [36mceil_h[0m=[35m6[0m [36mfloor_h[0m=[35m0[0m [36mrect[0m=[35mRect(x1=58, y1=21, x2=63, y2=25)[0m [36mx_slice[0m=[35m58:64[0m [36my_slice[0m=[35m21:26[0m
[2m2025-05-14T23:07:35.645836[0m [[32m[1mdebug    [0m] [1mCarved rectangle area         [0m [[0m[1m[34mgame.world.procgen[0m][0m [36mceil_h[0m=[35m6[0m [36mfloor_h[0m=[35m0[0m [36mrect[0m=[35mRect(x1=65, y1=1, x2=69, y2=4)[0m [36mx_slice[0m=[35m65:70[0m [36my_slice[0m=[35m1:5[0m
[2m2025-05-14T23:07:35.645869[0m [[32m[1mdebug    [0m] [1mCarved rectangle area         [0m [[0m[1m[34mgame.world.procgen[0m][0m [36mceil_h[0m=[35m6[0m [36mfloor_h[0m=[35m0[0m [36mrect[0m=[35mRect(x1=65, y1=8, x2=68, y2=12)[0m [36mx_slice[0m=[35m65:69[0m [36my_slice[0m=[35m8:13[0m
[2m2025-05-14T23:07:35.645902[0m [[32m[1mdebug    [0m] [1mCarved rectangle area         [0m [[0m[1m[34mgame.world.procgen[0m][0m [36mceil_h[0m=[35m6[0m [36mfloor_h[0m=[35m0[0m [36mrect[0m=[35mRect(x1=64, y1=15, x2=68, y2=19)[0m [36mx_slice[0m=[35m64:69[0m [36my_slice[0m=[35m15:20[0m
[2m2025-05-14T23:07:35.645934[0m [[32m[1mdebug    [0m] [1mCarved rectangle area         [0m [[0m[1m[34mgame.world.procgen[0m][0m [36mceil_h[0m=[35m6[0m [36mfloor_h[0m=[35m0[0m [36mrect[0m=[35mRect(x1=66, y1=21, x2=69, y2=25)[0m [36mx_slice[0m=[35m66:70[0m [36my_slice[0m=[35m21:26[0m
[2m2025-05-14T23:07:35.645967[0m [[32m[1mdebug    [0m] [1mCarved rectangle area         [0m [[0m[1m[34mgame.world.procgen[0m][0m [36mceil_h[0m=[35m6[0m [36mfloor_h[0m=[35m0[0m [36mrect[0m=[35mRect(x1=71, y1=2, x2=75, y2=6)[0m [36mx_slice[0m=[35m71:76[0m [36my_slice[0m=[35m2:7[0m
[2m2025-05-14T23:07:35.646020[0m [[32m[1mdebug    [0m] [1mCarved rectangle area         [0m [[0m[1m[34mgame.world.procgen[0m][0m [36mceil_h[0m=[35m6[0m [36mfloor_h[0m=[35m0[0m [36mrect[0m=[35mRect(x1=72, y1=14, x2=76, y2=18)[0m [36mx_slice[0m=[35m72:77[0m [36my_slice[0m=[35m14:19[0m
[2m2025-05-14T23:07:35.646063[0m [[32m[1mdebug    [0m] [1mCarved rectangle area         [0m [[0m[1m[34mgame.world.procgen[0m][0m [36mceil_h[0m=[35m6[0m [36mfloor_h[0m=[35m0[0m [36mrect[0m=[35mRect(x1=72, y1=22, x2=76, y2=27)[0m [36mx_slice[0m=[35m72:77[0m [36my_slice[0m=[35m22:28[0m
[2m2025-05-14T23:07:35.646112[0m [[32m[1mdebug    [0m] [1mCarved rectangle area         [0m [[0m[1m[34mgame.world.procgen[0m][0m [36mceil_h[0m=[35m6[0m [36mfloor_h[0m=[35m0[0m [36mrect[0m=[35mRect(x1=49, y1=28, x2=52, y2=31)[0m [36mx_slice[0m=[35m49:53[0m [36my_slice[0m=[35m28:32[0m
[2m2025-05-14T23:07:35.646148[0m [[32m[1mdebug    [0m] [1mCarved rectangle area         [0m [[0m[1m[34mgame.world.procgen[0m][0m [36mceil_h[0m=[35m6[0m [36mfloor_h[0m=[35m0[0m [36mrect[0m=[35mRect(x1=47, y1=44, x2=54, y2=47)[0m [36mx_slice[0m=[35m47:55[0m [36my_slice[0m=[35m44:48[0m
[2m2025-05-14T23:07:35.646181[0m [[32m[1mdebug    [0m] [1mCarved rectangle area         [0m [[0m[1m[34mgame.world.procgen[0m][0m [36mceil_h[0m=[35m6[0m [36mfloor_h[0m=[35m0[0m [36mrect[0m=[35mRect(x1=60, y1=33, x2=64, y2=37)[0m [36mx_slice[0m=[35m60:65[0m [36my_slice[0m=[35m33:38[0m
[2m2025-05-14T23:07:35.646213[0m [[32m[1mdebug    [0m] [1mCarved rectangle area         [0m [[0m[1m[34mgame.world.procgen[0m][0m [36mceil_h[0m=[35m6[0m [36mfloor_h[0m=[35m0[0m [36mrect[0m=[35mRect(x1=62, y1=43, x2=66, y2=47)[0m [36mx_slice[0m=[35m62:67[0m [36my_slice[0m=[35m43:48[0m
[2m2025-05-14T23:07:35.646250[0m [[32m[1mdebug    [0m] [1mCarved rectangle area         [0m [[0m[1m[34mgame.world.procgen[0m][0m [36mceil_h[0m=[35m6[0m [36mfloor_h[0m=[35m0[0m [36mrect[0m=[35mRect(x1=72, y1=29, x2=77, y2=34)[0m [36mx_slice[0m=[35m72:78[0m [36my_slice[0m=[35m29:35[0m
[2m2025-05-14T23:07:35.646284[0m [[32m[1mdebug    [0m] [1mCarved rectangle area         [0m [[0m[1m[34mgame.world.procgen[0m][0m [36mceil_h[0m=[35m6[0m [36mfloor_h[0m=[35m0[0m [36mrect[0m=[35mRect(x1=70, y1=43, x2=76, y2=48)[0m [36mx_slice[0m=[35m70:77[0m [36my_slice[0m=[35m43:49[0m
[2m2025-05-14T23:07:35.646314[0m [[32m[1minfo     [0m] [1mRooms carved                  [0m [[0m[1m[34mgame.world.procgen[0m][0m [36mcount[0m=[35m50[0m
[2m2025-05-14T23:07:35.646338[0m [[32m[1minfo     [0m] [1mConnecting rooms...           [0m [[0m[1m[34mgame.world.procgen[0m][0m
[2m2025-05-14T23:07:35.646361[0m [[32m[1mdebug    [0m] [1mConnecting rooms for node     [0m [[0m[1m[34mgame.world.procgen[0m][0m [36mis_leaf[0m=[35mFalse[0m [36mrect[0m=[35mRect(x1=1, y1=1, x2=78, y2=48)[0m
[2m2025-05-14T23:07:35.646386[0m [[32m[1mdebug    [0m] [1mConnecting rooms for node     [0m [[0m[1m[34mgame.world.procgen[0m][0m [36mis_leaf[0m=[35mFalse[0m [36mrect[0m=[35mRect(x1=1, y1=1, x2=34, y2=48)[0m
[2m2025-05-14T23:07:35.646410[0m [[32m[1mdebug    [0m] [1mConnecting rooms for node     [0m [[0m[1m[34mgame.world.procgen[0m][0m [36mis_leaf[0m=[35mFalse[0m [36mrect[0m=[35mRect(x1=1, y1=1, x2=34, y2=6)[0m
[2m2025-05-14T23:07:35.646434[0m [[32m[1mdebug    [0m] [1mConnecting rooms for node     [0m [[0m[1m[34mgame.world.procgen[0m][0m [36mis_leaf[0m=[35mFalse[0m [36mrect[0m=[35mRect(x1=1, y1=1, x2=16, y2=6)[0m
[2m2025-05-14T23:07:35.646461[0m [[32m[1mdebug    [0m] [1mConnecting rooms for node     [0m [[0m[1m[34mgame.world.procgen[0m][0m [36mis_leaf[0m=[35mTrue[0m [36mrect[0m=[35mRect(x1=1, y1=1, x2=7, y2=6)[0m
[2m2025-05-14T23:07:35.646486[0m [[32m[1mdebug    [0m] [1mConnecting rooms for node     [0m [[0m[1m[34mgame.world.procgen[0m][0m [36mis_leaf[0m=[35mTrue[0m [36mrect[0m=[35mRect(x1=8, y1=1, x2=16, y2=6)[0m
[2m2025-05-14T23:07:35.646541[0m [[32m[1mdebug    [0m] [1mConnecting sibling rooms      [0m [[0m[1m[34mgame.world.procgen[0m][0m [36mconnect_left[0m=[35m(5, 3)[0m [36mconnect_right[0m=[35m(15, 4)[0m [36mend_floor_h[0m=[35m0[0m [36mleft_center[0m=[35m(4, 3)[0m [36mright_center[0m=[35m(12, 2)[0m [36mstart_floor_h[0m=[35m0[0m
[2m2025-05-14T23:07:35.646586[0m [[32m[1mdebug    [0m] [1mCarving tunnel                [0m [[0m[1m[34mgame.world.procgen[0m][0m [36mend_floor_h[0m=[35m0[0m [36mend_pos[0m=[35m(15, 4)[0m [36mstart_floor_h[0m=[35m0[0m [36mstart_pos[0m=[35m(5, 3)[0m
[2m2025-05-14T23:07:35.646628[0m [[32m[1mdebug    [0m] [1mCarved rectangle area         [0m [[0m[1m[34mgame.world.procgen[0m][0m [36mceil_h[0m=[35m4[0m [36mfloor_h[0m=[35m0[0m [36mrect[0m=[35mRect(x1=5, y1=3, x2=5, y2=4)[0m [36mx_slice[0m=[35m5:6[0m [36my_slice[0m=[35m3:5[0m
[2m2025-05-14T23:07:35.646664[0m [[32m[1mdebug    [0m] [1mCarved vertical tunnel segment[0m [[0m[1m[34mgame.world.procgen[0m][0m [36mceil_h[0m=[35m4[0m [36mfloor_h[0m=[35m0[0m [36mrect[0m=[35mRect(x1=5, y1=3, x2=5, y2=4)[0m
[2m2025-05-14T23:07:35.646697[0m [[32m[1mdebug    [0m] [1mCarved rectangle area         [0m [[0m[1m[34mgame.world.procgen[0m][0m [36mceil_h[0m=[35m4[0m [36mfloor_h[0m=[35m0[0m [36mrect[0m=[35mRect(x1=6, y1=4, x2=15, y2=4)[0m [36mx_slice[0m=[35m6:16[0m [36my_slice[0m=[35m4:5[0m
[2m2025-05-14T23:07:35.646727[0m [[32m[1mdebug    [0m] [1mCarved horizontal tunnel segment[0m [[0m[1m[34mgame.world.procgen[0m][0m [36mceil_h[0m=[35m4[0m [36mfloor_h[0m=[35m0[0m [36mrect[0m=[35mRect(x1=6, y1=4, x2=15, y2=4)[0m
[2m2025-05-14T23:07:35.646757[0m [[32m[1mdebug    [0m] [1mConnecting rooms for node     [0m [[0m[1m[34mgame.world.procgen[0m][0m [36mis_leaf[0m=[35mFalse[0m [36mrect[0m=[35mRect(x1=17, y1=1, x2=34, y2=6)[0m
[2m2025-05-14T23:07:35.646785[0m [[32m[1mdebug    [0m] [1mConnecting rooms for node     [0m [[0m[1m[34mgame.world.procgen[0m][0m [36mis_leaf[0m=[35mTrue[0m [36mrect[0m=[35mRect(x1=17, y1=1, x2=23, y2=6)[0m
[2m2025-05-14T23:07:35.646810[0m [[32m[1mdebug    [0m] [1mConnecting rooms for node     [0m [[0m[1m[34mgame.world.procgen[0m][0m [36mis_leaf[0m=[35mTrue[0m [36mrect[0m=[35mRect(x1=24, y1=1, x2=34, y2=6)[0m
[2m2025-05-14T23:07:35.646869[0m [[32m[1mdebug    [0m] [1mConnecting sibling rooms      [0m [[0m[1m[34mgame.world.procgen[0m][0m [36mconnect_left[0m=[35m(22, 2)[0m [36mconnect_right[0m=[35m(27, 3)[0m [36mend_floor_h[0m=[35m0[0m [36mleft_center[0m=[35m(20, 3)[0m [36mright_center[0m=[35m(28, 3)[0m [36mstart_floor_h[0m=[35m0[0m
[2m2025-05-14T23:07:35.646902[0m [[32m[1mdebug    [0m] [1mCarving tunnel                [0m [[0m[1m[34mgame.world.procgen[0m][0m [36mend_floor_h[0m=[35m0[0m [36mend_pos[0m=[35m(27, 3)[0m [36mstart_floor_h[0m=[35m0[0m [36mstart_pos[0m=[35m(22, 2)[0m
[2m2025-05-14T23:07:35.646939[0m [[32m[1mdebug    [0m] [1mCarved rectangle area         [0m [[0m[1m[34mgame.world.procgen[0m][0m [36mceil_h[0m=[35m4[0m [36mfloor_h[0m=[35m0[0m [36mrect[0m=[35mRect(x1=22, y1=2, x2=22, y2=3)[0m [36mx_slice[0m=[35m22:23[0m [36my_slice[0m=[35m2:4[0m
[2m2025-05-14T23:07:35.646969[0m [[32m[1mdebug    [0m] [1mCarved vertical tunnel segment[0m [[0m[1m[34mgame.world.procgen[0m][0m [36mceil_h[0m=[35m4[0m [36mfloor_h[0m=[35m0[0m [36mrect[0m=[35mRect(x1=22, y1=2, x2=22, y2=3)[0m
[2m2025-05-14T23:07:35.646999[0m [[32m[1mdebug    [0m] [1mCarved rectangle area         [0m [[0m[1m[34mgame.world.procgen[0m][0m [36mceil_h[0m=[35m4[0m [36mfloor_h[0m=[35m0[0m [36mrect[0m=[35mRect(x1=23, y1=3, x2=27, y2=3)[0m [36mx_slice[0m=[35m23:28[0m [36my_slice[0m=[35m3:4[0m
[2m2025-05-14T23:07:35.647028[0m [[32m[1mdebug    [0m] [1mCarved horizontal tunnel segment[0m [[0m[1m[34mgame.world.procgen[0m][0m [36mceil_h[0m=[35m4[0m [36mfloor_h[0m=[35m0[0m [36mrect[0m=[35mRect(x1=23, y1=3, x2=27, y2=3)[0m
[2m2025-05-14T23:07:35.647084[0m [[32m[1mdebug    [0m] [1mConnecting sibling rooms      [0m [[0m[1m[34mgame.world.procgen[0m][0m [36mconnect_left[0m=[35m(6, 2)[0m [36mconnect_right[0m=[35m(20, 2)[0m [36mend_floor_h[0m=[35m0[0m [36mleft_center[0m=[35m(4, 3)[0m [36mright_center[0m=[35m(20, 3)[0m [36mstart_floor_h[0m=[35m0[0m
[2m2025-05-14T23:07:35.647115[0m [[32m[1mdebug    [0m] [1mCarving tunnel                [0m [[0m[1m[34mgame.world.procgen[0m][0m [36mend_floor_h[0m=[35m0[0m [36mend_pos[0m=[35m(20, 2)[0m [36mstart_floor_h[0m=[35m0[0m [36mstart_pos[0m=[35m(6, 2)[0m
[2m2025-05-14T23:07:35.647150[0m [[32m[1mdebug    [0m] [1mCarved rectangle area         [0m [[0m[1m[34mgame.world.procgen[0m][0m [36mceil_h[0m=[35m4[0m [36mfloor_h[0m=[35m0[0m [36mrect[0m=[35mRect(x1=6, y1=2, x2=6, y2=2)[0m [36mx_slice[0m=[35m6:7[0m [36my_slice[0m=[35m2:3[0m
[2m2025-05-14T23:07:35.647181[0m [[32m[1mdebug    [0m] [1mCarved vertical tunnel segment[0m [[0m[1m[34mgame.world.procgen[0m][0m [36mceil_h[0m=[35m4[0m [36mfloor_h[0m=[35m0[0m [36mrect[0m=[35mRect(x1=6, y1=2, x2=6, y2=2)[0m
[2m2025-05-14T23:07:35.647211[0m [[32m[1mdebug    [0m] [1mCarved rectangle area         [0m [[0m[1m[34mgame.world.procgen[0m][0m [36mceil_h[0m=[35m4[0m [36mfloor_h[0m=[35m0[0m [36mrect[0m=[35mRect(x1=7, y1=2, x2=20, y2=2)[0m [36mx_slice[0m=[35m7:21[0m [36my_slice[0m=[35m2:3[0m
[2m2025-05-14T23:07:35.647245[0m [[32m[1mdebug    [0m] [1mCarved horizontal tunnel segment[0m [[0m[1m[34mgame.world.procgen[0m][0m [36mceil_h[0m=[35m4[0m [36mfloor_h[0m=[35m0[0m [36mrect[0m=[35mRect(x1=7, y1=2, x2=20, y2=2)[0m
[2m2025-05-14T23:07:35.647272[0m [[32m[1mdebug    [0m] [1mConnecting rooms for node     [0m [[0m[1m[34mgame.world.procgen[0m][0m [36mis_leaf[0m=[35mFalse[0m [36mrect[0m=[35mRect(x1=1, y1=7, x2=34, y2=48)[0m
[2m2025-05-14T23:07:35.647296[0m [[32m[1mdebug    [0m] [1mConnecting rooms for node     [0m [[0m[1m[34mgame.world.procgen[0m][0m [36mis_leaf[0m=[35mFalse[0m [36mrect[0m=[35mRect(x1=1, y1=7, x2=14, y2=48)[0m
[2m2025-05-14T23:07:35.647319[0m [[32m[1mdebug    [0m] [1mConnecting rooms for node     [0m [[0m[1m[34mgame.world.procgen[0m][0m [36mis_leaf[0m=[35mFalse[0m [36mrect[0m=[35mRect(x1=1, y1=7, x2=14, y2=41)[0m
[2m2025-05-14T23:07:35.647342[0m [[32m[1mdebug    [0m] [1mConnecting rooms for node     [0m [[0m[1m[34mgame.world.procgen[0m][0m [36mis_leaf[0m=[35mFalse[0m [36mrect[0m=[35mRect(x1=1, y1=7, x2=14, y2=12)[0m
[2m2025-05-14T23:07:35.647365[0m [[32m[1mdebug    [0m] [1mConnecting rooms for node     [0m [[0m[1m[34mgame.world.procgen[0m][0m [36mis_leaf[0m=[35mTrue[0m [36mrect[0m=[35mRect(x1=1, y1=7, x2=7, y2=12)[0m
[2m2025-05-14T23:07:35.647387[0m [[32m[1mdebug    [0m] [1mConnecting rooms for node     [0m [[0m[1m[34mgame.world.procgen[0m][0m [36mis_leaf[0m=[35mTrue[0m [36mrect[0m=[35mRect(x1=8, y1=7, x2=14, y2=12)[0m
[2m2025-05-14T23:07:35.647437[0m [[32m[1mdebug    [0m] [1mConnecting sibling rooms      [0m [[0m[1m[34mgame.world.procgen[0m][0m [36mconnect_left[0m=[35m(5, 9)[0m [36mconnect_right[0m=[35m(10, 8)[0m [36mend_floor_h[0m=[35m0[0m [36mleft_center[0m=[35m(4, 10)[0m [36mright_center[0m=[35m(11, 8)[0m [36mstart_floor_h[0m=[35m0[0m
[2m2025-05-14T23:07:35.647468[0m [[32m[1mdebug    [0m] [1mCarving tunnel                [0m [[0m[1m[34mgame.world.procgen[0m][0m [36mend_floor_h[0m=[35m0[0m [36mend_pos[0m=[35m(10, 8)[0m [36mstart_floor_h[0m=[35m0[0m [36mstart_pos[0m=[35m(5, 9)[0m
[2m2025-05-14T23:07:35.647505[0m [[32m[1mdebug    [0m] [1mCarved rectangle area         [0m [[0m[1m[34mgame.world.procgen[0m][0m [36mceil_h[0m=[35m4[0m [36mfloor_h[0m=[35m0[0m [36mrect[0m=[35mRect(x1=5, y1=8, x2=5, y2=9)[0m [36mx_slice[0m=[35m5:6[0m [36my_slice[0m=[35m8:10[0m
[2m2025-05-14T23:07:35.647536[0m [[32m[1mdebug    [0m] [1mCarved vertical tunnel segment[0m [[0m[1m[34mgame.world.procgen[0m][0m [36mceil_h[0m=[35m4[0m [36mfloor_h[0m=[35m0[0m [36mrect[0m=[35mRect(x1=5, y1=8, x2=5, y2=9)[0m
[2m2025-05-14T23:07:35.647567[0m [[32m[1mdebug    [0m] [1mCarved rectangle area         [0m [[0m[1m[34mgame.world.procgen[0m][0m [36mceil_h[0m=[35m4[0m [36mfloor_h[0m=[35m0[0m [36mrect[0m=[35mRect(x1=6, y1=8, x2=10, y2=8)[0m [36mx_slice[0m=[35m6:11[0m [36my_slice[0m=[35m8:9[0m
[2m2025-05-14T23:07:35.647607[0m [[32m[1mdebug    [0m] [1mCarved horizontal tunnel segment[0m [[0m[1m[34mgame.world.procgen[0m][0m [36mceil_h[0m=[35m4[0m [36mfloor_h[0m=[35m0[0m [36mrect[0m=[35mRect(x1=6, y1=8, x2=10, y2=8)[0m
[2m2025-05-14T23:07:35.647634[0m [[32m[1mdebug    [0m] [1mConnecting rooms for node     [0m [[0m[1m[34mgame.world.procgen[0m][0m [36mis_leaf[0m=[35mFalse[0m [36mrect[0m=[35mRect(x1=1, y1=13, x2=14, y2=41)[0m
[2m2025-05-14T23:07:35.647658[0m [[32m[1mdebug    [0m] [1mConnecting rooms for node     [0m [[0m[1m[34mgame.world.procgen[0m][0m [36mis_leaf[0m=[35mFalse[0m [36mrect[0m=[35mRect(x1=1, y1=13, x2=14, y2=22)[0m
[2m2025-05-14T23:07:35.647681[0m [[32m[1mdebug    [0m] [1mConnecting rooms for node     [0m [[0m[1m[34mgame.world.procgen[0m][0m [36mis_leaf[0m=[35mTrue[0m [36mrect[0m=[35mRect(x1=1, y1=13, x2=6, y2=22)[0m
[2m2025-05-14T23:07:35.647708[0m [[32m[1mdebug    [0m] [1mConnecting rooms for node     [0m [[0m[1m[34mgame.world.procgen[0m][0m [36mis_leaf[0m=[35mTrue[0m [36mrect[0m=[35mRect(x1=7, y1=13, x2=14, y2=22)[0m
[2m2025-05-14T23:07:35.647758[0m [[32m[1mdebug    [0m] [1mConnecting sibling rooms      [0m [[0m[1m[34mgame.world.procgen[0m][0m [36mconnect_left[0m=[35m(3, 15)[0m [36mconnect_right[0m=[35m(13, 20)[0m [36mend_floor_h[0m=[35m0[0m [36mleft_center[0m=[35m(4, 16)[0m [36mright_center[0m=[35m(11, 19)[0m [36mstart_floor_h[0m=[35m0[0m
[2m2025-05-14T23:07:35.647791[0m [[32m[1mdebug    [0m] [1mCarving tunnel                [0m [[0m[1m[34mgame.world.procgen[0m][0m [36mend_floor_h[0m=[35m0[0m [36mend_pos[0m=[35m(13, 20)[0m [36mstart_floor_h[0m=[35m0[0m [36mstart_pos[0m=[35m(3, 15)[0m
[2m2025-05-14T23:07:35.647828[0m [[32m[1mdebug    [0m] [1mCarved rectangle area         [0m [[0m[1m[34mgame.world.procgen[0m][0m [36mceil_h[0m=[35m4[0m [36mfloor_h[0m=[35m0[0m [36mrect[0m=[35mRect(x1=3, y1=15, x2=3, y2=20)[0m [36mx_slice[0m=[35m3:4[0m [36my_slice[0m=[35m15:21[0m
[2m2025-05-14T23:07:35.647858[0m [[32m[1mdebug    [0m] [1mCarved vertical tunnel segment[0m [[0m[1m[34mgame.world.procgen[0m][0m [36mceil_h[0m=[35m4[0m [36mfloor_h[0m=[35m0[0m [36mrect[0m=[35mRect(x1=3, y1=15, x2=3, y2=20)[0m
[2m2025-05-14T23:07:35.647888[0m [[32m[1mdebug    [0m] [1mCarved rectangle area         [0m [[0m[1m[34mgame.world.procgen[0m][0m [36mceil_h[0m=[35m4[0m [36mfloor_h[0m=[35m0[0m [36mrect[0m=[35mRect(x1=4, y1=20, x2=13, y2=20)[0m [36mx_slice[0m=[35m4:14[0m [36my_slice[0m=[35m20:21[0m
[2m2025-05-14T23:07:35.647917[0m [[32m[1mdebug    [0m] [1mCarved horizontal tunnel segment[0m [[0m[1m[34mgame.world.procgen[0m][0m [36mceil_h[0m=[35m4[0m [36mfloor_h[0m=[35m0[0m [36mrect[0m=[35mRect(x1=4, y1=20, x2=13, y2=20)[0m
[2m2025-05-14T23:07:35.647943[0m [[32m[1mdebug    [0m] [1mConnecting rooms for node     [0m [[0m[1m[34mgame.world.procgen[0m][0m [36mis_leaf[0m=[35mFalse[0m [36mrect[0m=[35mRect(x1=1, y1=23, x2=14, y2=41)[0m
[2m2025-05-14T23:07:35.647967[0m [[32m[1mdebug    [0m] [1mConnecting rooms for node     [0m [[0m[1m[34mgame.world.procgen[0m][0m [36mis_leaf[0m=[35mFalse[0m [36mrect[0m=[35mRect(x1=1, y1=23, x2=14, y2=32)[0m
[2m2025-05-14T23:07:35.647990[0m [[32m[1mdebug    [0m] [1mConnecting rooms for node     [0m [[0m[1m[34mgame.world.procgen[0m][0m [36mis_leaf[0m=[35mTrue[0m [36mrect[0m=[35mRect(x1=1, y1=23, x2=7, y2=32)[0m
[2m2025-05-14T23:07:35.648013[0m [[32m[1mdebug    [0m] [1mConnecting rooms for node     [0m [[0m[1m[34mgame.world.procgen[0m][0m [36mis_leaf[0m=[35mTrue[0m [36mrect[0m=[35mRect(x1=8, y1=23, x2=14, y2=32)[0m
[2m2025-05-14T23:07:35.648061[0m [[32m[1mdebug    [0m] [1mConnecting sibling rooms      [0m [[0m[1m[34mgame.world.procgen[0m][0m [36mconnect_left[0m=[35m(6, 28)[0m [36mconnect_right[0m=[35m(12, 29)[0m [36mend_floor_h[0m=[35m0[0m [36mleft_center[0m=[35m(5, 27)[0m [36mright_center[0m=[35m(10, 28)[0m [36mstart_floor_h[0m=[35m0[0m
[2m2025-05-14T23:07:35.648092[0m [[32m[1mdebug    [0m] [1mCarving tunnel                [0m [[0m[1m[34mgame.world.procgen[0m][0m [36mend_floor_h[0m=[35m0[0m [36mend_pos[0m=[35m(12, 29)[0m [36mstart_floor_h[0m=[35m0[0m [36mstart_pos[0m=[35m(6, 28)[0m
[2m2025-05-14T23:07:35.648128[0m [[32m[1mdebug    [0m] [1mCarved rectangle area         [0m [[0m[1m[34mgame.world.procgen[0m][0m [36mceil_h[0m=[35m4[0m [36mfloor_h[0m=[35m0[0m [36mrect[0m=[35mRect(x1=6, y1=28, x2=6, y2=29)[0m [36mx_slice[0m=[35m6:7[0m [36my_slice[0m=[35m28:30[0m
[2m2025-05-14T23:07:35.648159[0m [[32m[1mdebug    [0m] [1mCarved vertical tunnel segment[0m [[0m[1m[34mgame.world.procgen[0m][0m [36mceil_h[0m=[35m4[0m [36mfloor_h[0m=[35m0[0m [36mrect[0m=[35mRect(x1=6, y1=28, x2=6, y2=29)[0m
[2m2025-05-14T23:07:35.648194[0m [[32m[1mdebug    [0m] [1mCarved rectangle area         [0m [[0m[1m[34mgame.world.procgen[0m][0m [36mceil_h[0m=[35m4[0m [36mfloor_h[0m=[35m0[0m [36mrect[0m=[35mRect(x1=7, y1=29, x2=12, y2=29)[0m [36mx_slice[0m=[35m7:13[0m [36my_slice[0m=[35m29:30[0m
[2m2025-05-14T23:07:35.648225[0m [[32m[1mdebug    [0m] [1mCarved horizontal tunnel segment[0m [[0m[1m[34mgame.world.procgen[0m][0m [36mceil_h[0m=[35m4[0m [36mfloor_h[0m=[35m0[0m [36mrect[0m=[35mRect(x1=7, y1=29, x2=12, y2=29)[0m
[2m2025-05-14T23:07:35.648251[0m [[32m[1mdebug    [0m] [1mConnecting rooms for node     [0m [[0m[1m[34mgame.world.procgen[0m][0m [36mis_leaf[0m=[35mFalse[0m [36mrect[0m=[35mRect(x1=1, y1=33, x2=14, y2=41)[0m
[2m2025-05-14T23:07:35.648275[0m [[32m[1mdebug    [0m] [1mConnecting rooms for node     [0m [[0m[1m[34mgame.world.procgen[0m][0m [36mis_leaf[0m=[35mTrue[0m [36mrect[0m=[35mRect(x1=1, y1=33, x2=6, y2=41)[0m
[2m2025-05-14T23:07:35.648298[0m [[32m[1mdebug    [0m] [1mConnecting rooms for node     [0m [[0m[1m[34mgame.world.procgen[0m][0m [36mis_leaf[0m=[35mTrue[0m [36mrect[0m=[35mRect(x1=7, y1=33, x2=14, y2=41)[0m
[2m2025-05-14T23:07:35.648344[0m [[32m[1mdebug    [0m] [1mConnecting sibling rooms      [0m [[0m[1m[34mgame.world.procgen[0m][0m [36mconnect_left[0m=[35m(5, 40)[0m [36mconnect_right[0m=[35m(10, 35)[0m [36mend_floor_h[0m=[35m0[0m [36mleft_center[0m=[35m(4, 39)[0m [36mright_center[0m=[35m(10, 37)[0m [36mstart_floor_h[0m=[35m0[0m
[2m2025-05-14T23:07:35.648375[0m [[32m[1mdebug    [0m] [1mCarving tunnel                [0m [[0m[1m[34mgame.world.procgen[0m][0m [36mend_floor_h[0m=[35m0[0m [36mend_pos[0m=[35m(10, 35)[0m [36mstart_floor_h[0m=[35m0[0m [36mstart_pos[0m=[35m(5, 40)[0m
[2m2025-05-14T23:07:35.648409[0m [[32m[1mdebug    [0m] [1mCarved rectangle area         [0m [[0m[1m[34mgame.world.procgen[0m][0m [36mceil_h[0m=[35m4[0m [36mfloor_h[0m=[35m0[0m [36mrect[0m=[35mRect(x1=5, y1=35, x2=5, y2=40)[0m [36mx_slice[0m=[35m5:6[0m [36my_slice[0m=[35m35:41[0m
[2m2025-05-14T23:07:35.648440[0m [[32m[1mdebug    [0m] [1mCarved vertical tunnel segment[0m [[0m[1m[34mgame.world.procgen[0m][0m [36mceil_h[0m=[35m4[0m [36mfloor_h[0m=[35m0[0m [36mrect[0m=[35mRect(x1=5, y1=35, x2=5, y2=40)[0m
[2m2025-05-14T23:07:35.648471[0m [[32m[1mdebug    [0m] [1mCarved rectangle area         [0m [[0m[1m[34mgame.world.procgen[0m][0m [36mceil_h[0m=[35m4[0m [36mfloor_h[0m=[35m0[0m [36mrect[0m=[35mRect(x1=6, y1=35, x2=10, y2=35)[0m [36mx_slice[0m=[35m6:11[0m [36my_slice[0m=[35m35:36[0m
[2m2025-05-14T23:07:35.648500[0m [[32m[1mdebug    [0m] [1mCarved horizontal tunnel segment[0m [[0m[1m[34mgame.world.procgen[0m][0m [36mceil_h[0m=[35m4[0m [36mfloor_h[0m=[35m0[0m [36mrect[0m=[35mRect(x1=6, y1=35, x2=10, y2=35)[0m
[2m2025-05-14T23:07:35.648561[0m [[32m[1mdebug    [0m] [1mConnecting sibling rooms      [0m [[0m[1m[34mgame.world.procgen[0m][0m [36mconnect_left[0m=[35m(5, 31)[0m [36mconnect_right[0m=[35m(5, 39)[0m [36mend_floor_h[0m=[35m0[0m [36mleft_center[0m=[35m(5, 27)[0m [36mright_center[0m=[35m(4, 39)[0m [36mstart_floor_h[0m=[35m0[0m
[2m2025-05-14T23:07:35.648605[0m [[32m[1mdebug    [0m] [1mCarving tunnel                [0m [[0m[1m[34mgame.world.procgen[0m][0m [36mend_floor_h[0m=[35m0[0m [36mend_pos[0m=[35m(5, 39)[0m [36mstart_floor_h[0m=[35m0[0m [36mstart_pos[0m=[35m(5, 31)[0m
[2m2025-05-14T23:07:35.648644[0m [[32m[1mdebug    [0m] [1mCarved rectangle area         [0m [[0m[1m[34mgame.world.procgen[0m][0m [36mceil_h[0m=[35m4[0m [36mfloor_h[0m=[35m0[0m [36mrect[0m=[35mRect(x1=5, y1=31, x2=5, y2=39)[0m [36mx_slice[0m=[35m5:6[0m [36my_slice[0m=[35m31:40[0m
[2m2025-05-14T23:07:35.648675[0m [[32m[1mdebug    [0m] [1mCarved vertical tunnel segment[0m [[0m[1m[34mgame.world.procgen[0m][0m [36mceil_h[0m=[35m4[0m [36mfloor_h[0m=[35m0[0m [36mrect[0m=[35mRect(x1=5, y1=31, x2=5, y2=39)[0m
[2m2025-05-14T23:07:35.648710[0m [[32m[1mdebug    [0m] [1mCarved rectangle area         [0m [[0m[1m[34mgame.world.procgen[0m][0m [36mceil_h[0m=[35m4[0m [36mfloor_h[0m=[35m0[0m [36mrect[0m=[35mRect(x1=5, y1=39, x2=5, y2=39)[0m [36mx_slice[0m=[35m5:6[0m [36my_slice[0m=[35m39:40[0m
[2m2025-05-14T23:07:35.648741[0m [[32m[1mdebug    [0m] [1mCarved horizontal tunnel segment[0m [[0m[1m[34mgame.world.procgen[0m][0m [36mceil_h[0m=[35m4[0m [36mfloor_h[0m=[35m0[0m [36mrect[0m=[35mRect(x1=5, y1=39, x2=5, y2=39)[0m
[2m2025-05-14T23:07:35.648793[0m [[32m[1mdebug    [0m] [1mConnecting sibling rooms      [0m [[0m[1m[34mgame.world.procgen[0m][0m [36mconnect_left[0m=[35m(6, 18)[0m [36mconnect_right[0m=[35m(6, 31)[0m [36mend_floor_h[0m=[35m0[0m [36mleft_center[0m=[35m(4, 16)[0m [36mright_center[0m=[35m(5, 27)[0m [36mstart_floor_h[0m=[35m0[0m
[2m2025-05-14T23:07:35.648824[0m [[32m[1mdebug    [0m] [1mCarving tunnel                [0m [[0m[1m[34mgame.world.procgen[0m][0m [36mend_floor_h[0m=[35m0[0m [36mend_pos[0m=[35m(6, 31)[0m [36mstart_floor_h[0m=[35m0[0m [36mstart_pos[0m=[35m(6, 18)[0m
[2m2025-05-14T23:07:35.648859[0m [[32m[1mdebug    [0m] [1mCarved rectangle area         [0m [[0m[1m[34mgame.world.procgen[0m][0m [36mceil_h[0m=[35m4[0m [36mfloor_h[0m=[35m0[0m [36mrect[0m=[35mRect(x1=6, y1=18, x2=6, y2=31)[0m [36mx_slice[0m=[35m6:7[0m [36my_slice[0m=[35m18:32[0m
[2m2025-05-14T23:07:35.648889[0m [[32m[1mdebug    [0m] [1mCarved vertical tunnel segment[0m [[0m[1m[34mgame.world.procgen[0m][0m [36mceil_h[0m=[35m4[0m [36mfloor_h[0m=[35m0[0m [36mrect[0m=[35mRect(x1=6, y1=18, x2=6, y2=31)[0m
[2m2025-05-14T23:07:35.648920[0m [[32m[1mdebug    [0m] [1mCarved rectangle area         [0m [[0m[1m[34mgame.world.procgen[0m][0m [36mceil_h[0m=[35m4[0m [36mfloor_h[0m=[35m0[0m [36mrect[0m=[35mRect(x1=6, y1=31, x2=6, y2=31)[0m [36mx_slice[0m=[35m6:7[0m [36my_slice[0m=[35m31:32[0m
[2m2025-05-14T23:07:35.648949[0m [[32m[1mdebug    [0m] [1mCarved horizontal tunnel segment[0m [[0m[1m[34mgame.world.procgen[0m][0m [36mceil_h[0m=[35m4[0m [36mfloor_h[0m=[35m0[0m [36mrect[0m=[35mRect(x1=6, y1=31, x2=6, y2=31)[0m
[2m2025-05-14T23:07:35.648999[0m [[32m[1mdebug    [0m] [1mConnecting sibling rooms      [0m [[0m[1m[34mgame.world.procgen[0m][0m [36mconnect_left[0m=[35m(6, 9)[0m [36mconnect_right[0m=[35m(3, 16)[0m [36mend_floor_h[0m=[35m0[0m [36mleft_center[0m=[35m(4, 10)[0m [36mright_center[0m=[35m(4, 16)[0m [36mstart_floor_h[0m=[35m0[0m
[2m2025-05-14T23:07:35.649029[0m [[32m[1mdebug    [0m] [1mCarving tunnel                [0m [[0m[1m[34mgame.world.procgen[0m][0m [36mend_floor_h[0m=[35m0[0m [36mend_pos[0m=[35m(3, 16)[0m [36mstart_floor_h[0m=[35m0[0m [36mstart_pos[0m=[35m(6, 9)[0m
[2m2025-05-14T23:07:35.649064[0m [[32m[1mdebug    [0m] [1mCarved rectangle area         [0m [[0m[1m[34mgame.world.procgen[0m][0m [36mceil_h[0m=[35m4[0m [36mfloor_h[0m=[35m0[0m [36mrect[0m=[35mRect(x1=6, y1=9, x2=6, y2=16)[0m [36mx_slice[0m=[35m6:7[0m [36my_slice[0m=[35m9:17[0m
[2m2025-05-14T23:07:35.649093[0m [[32m[1mdebug    [0m] [1mCarved vertical tunnel segment[0m [[0m[1m[34mgame.world.procgen[0m][0m [36mceil_h[0m=[35m4[0m [36mfloor_h[0m=[35m0[0m [36mrect[0m=[35mRect(x1=6, y1=9, x2=6, y2=16)[0m
[2m2025-05-14T23:07:35.649122[0m [[32m[1mdebug    [0m] [1mCarved rectangle area         [0m [[0m[1m[34mgame.world.procgen[0m][0m [36mceil_h[0m=[35m4[0m [36mfloor_h[0m=[35m0[0m [36mrect[0m=[35mRect(x1=3, y1=16, x2=5, y2=16)[0m [36mx_slice[0m=[35m3:6[0m [36my_slice[0m=[35m16:17[0m
[2m2025-05-14T23:07:35.649151[0m [[32m[1mdebug    [0m] [1mCarved horizontal tunnel segment[0m [[0m[1m[34mgame.world.procgen[0m][0m [36mceil_h[0m=[35m4[0m [36mfloor_h[0m=[35m0[0m [36mrect[0m=[35mRect(x1=3, y1=16, x2=5, y2=16)[0m
[2m2025-05-14T23:07:35.649181[0m [[32m[1mdebug    [0m] [1mConnecting rooms for node     [0m [[0m[1m[34mgame.world.procgen[0m][0m [36mis_leaf[0m=[35mFalse[0m [36mrect[0m=[35mRect(x1=1, y1=42, x2=14, y2=48)[0m
[2m2025-05-14T23:07:35.649206[0m [[32m[1mdebug    [0m] [1mConnecting rooms for node     [0m [[0m[1m[34mgame.world.procgen[0m][0m [36mis_leaf[0m=[35mTrue[0m [36mrect[0m=[35mRect(x1=1, y1=42, x2=6, y2=48)[0m
[2m2025-05-14T23:07:35.649229[0m [[32m[1mdebug    [0m] [1mConnecting rooms for node     [0m [[0m[1m[34mgame.world.procgen[0m][0m [36mis_leaf[0m=[35mTrue[0m [36mrect[0m=[35mRect(x1=7, y1=42, x2=14, y2=48)[0m
[2m2025-05-14T23:07:35.649273[0m [[32m[1mdebug    [0m] [1mConnecting sibling rooms      [0m [[0m[1m[34mgame.world.procgen[0m][0m [36mconnect_left[0m=[35m(4, 46)[0m [36mconnect_right[0m=[35m(12, 46)[0m [36mend_floor_h[0m=[35m0[0m [36mleft_center[0m=[35m(4, 44)[0m [36mright_center[0m=[35m(11, 44)[0m [36mstart_floor_h[0m=[35m0[0m
[2m2025-05-14T23:07:35.649304[0m [[32m[1mdebug    [0m] [1mCarving tunnel                [0m [[0m[1m[34mgame.world.procgen[0m][0m [36mend_floor_h[0m=[35m0[0m [36mend_pos[0m=[35m(12, 46)[0m [36mstart_floor_h[0m=[35m0[0m [36mstart_pos[0m=[35m(4, 46)[0m
[2m2025-05-14T23:07:35.649338[0m [[32m[1mdebug    [0m] [1mCarved rectangle area         [0m [[0m[1m[34mgame.world.procgen[0m][0m [36mceil_h[0m=[35m4[0m [36mfloor_h[0m=[35m0[0m [36mrect[0m=[35mRect(x1=4, y1=46, x2=4, y2=46)[0m [36mx_slice[0m=[35m4:5[0m [36my_slice[0m=[35m46:47[0m
[2m2025-05-14T23:07:35.649369[0m [[32m[1mdebug    [0m] [1mCarved vertical tunnel segment[0m [[0m[1m[34mgame.world.procgen[0m][0m [36mceil_h[0m=[35m4[0m [36mfloor_h[0m=[35m0[0m [36mrect[0m=[35mRect(x1=4, y1=46, x2=4, y2=46)[0m
[2m2025-05-14T23:07:35.649399[0m [[32m[1mdebug    [0m] [1mCarved rectangle area         [0m [[0m[1m[34mgame.world.procgen[0m][0m [36mceil_h[0m=[35m4[0m [36mfloor_h[0m=[35m0[0m [36mrect[0m=[35mRect(x1=5, y1=46, x2=12, y2=46)[0m [36mx_slice[0m=[35m5:13[0m [36my_slice[0m=[35m46:47[0m
[2m2025-05-14T23:07:35.649427[0m [[32m[1mdebug    [0m] [1mCarved horizontal tunnel segment[0m [[0m[1m[34mgame.world.procgen[0m][0m [36mceil_h[0m=[35m4[0m [36mfloor_h[0m=[35m0[0m [36mrect[0m=[35mRect(x1=5, y1=46, x2=12, y2=46)[0m
[2m2025-05-14T23:07:35.649480[0m [[32m[1mdebug    [0m] [1mConnecting sibling rooms      [0m [[0m[1m[34mgame.world.procgen[0m][0m [36mconnect_left[0m=[35m(5, 12)[0m [36mconnect_right[0m=[35m(5, 42)[0m [36mend_floor_h[0m=[35m0[0m [36mleft_center[0m=[35m(4, 10)[0m [36mright_center[0m=[35m(4, 44)[0m [36mstart_floor_h[0m=[35m0[0m
[2m2025-05-14T23:07:35.649510[0m [[32m[1mdebug    [0m] [1mCarving tunnel                [0m [[0m[1m[34mgame.world.procgen[0m][0m [36mend_floor_h[0m=[35m0[0m [36mend_pos[0m=[35m(5, 42)[0m [36mstart_floor_h[0m=[35m0[0m [36mstart_pos[0m=[35m(5, 12)[0m
[2m2025-05-14T23:07:35.649545[0m [[32m[1mdebug    [0m] [1mCarved rectangle area         [0m [[0m[1m[34mgame.world.procgen[0m][0m [36mceil_h[0m=[35m4[0m [36mfloor_h[0m=[35m0[0m [36mrect[0m=[35mRect(x1=5, y1=12, x2=5, y2=42)[0m [36mx_slice[0m=[35m5:6[0m [36my_slice[0m=[35m12:43[0m
[2m2025-05-14T23:07:35.649584[0m [[32m[1mdebug    [0m] [1mCarved vertical tunnel segment[0m [[0m[1m[34mgame.world.procgen[0m][0m [36mceil_h[0m=[35m4[0m [36mfloor_h[0m=[35m0[0m [36mrect[0m=[35mRect(x1=5, y1=12, x2=5, y2=42)[0m
[2m2025-05-14T23:07:35.649616[0m [[32m[1mdebug    [0m] [1mCarved rectangle area         [0m [[0m[1m[34mgame.world.procgen[0m][0m [36mceil_h[0m=[35m4[0m [36mfloor_h[0m=[35m0[0m [36mrect[0m=[35mRect(x1=5, y1=42, x2=5, y2=42)[0m [36mx_slice[0m=[35m5:6[0m [36my_slice[0m=[35m42:43[0m
[2m2025-05-14T23:07:35.649649[0m [[32m[1mdebug    [0m] [1mCarved horizontal tunnel segment[0m [[0m[1m[34mgame.world.procgen[0m][0m [36mceil_h[0m=[35m4[0m [36mfloor_h[0m=[35m0[0m [36mrect[0m=[35mRect(x1=5, y1=42, x2=5, y2=42)[0m
[2m2025-05-14T23:07:35.649677[0m [[32m[1mdebug    [0m] [1mConnecting rooms for node     [0m [[0m[1m[34mgame.world.procgen[0m][0m [36mis_leaf[0m=[35mFalse[0m [36mrect[0m=[35mRect(x1=15, y1=7, x2=34, y2=48)[0m
[2m2025-05-14T23:07:35.649701[0m [[32m[1mdebug    [0m] [1mConnecting rooms for node     [0m [[0m[1m[34mgame.world.procgen[0m][0m [36mis_leaf[0m=[35mFalse[0m [36mrect[0m=[35mRect(x1=15, y1=7, x2=34, y2=16)[0m
[2m2025-05-14T23:07:35.649724[0m [[32m[1mdebug    [0m] [1mConnecting rooms for node     [0m [[0m[1m[34mgame.world.procgen[0m][0m [36mis_leaf[0m=[35mTrue[0m [36mrect[0m=[35mRect(x1=15, y1=7, x2=25, y2=16)[0m
[2m2025-05-14T23:07:35.649746[0m [[32m[1mdebug    [0m] [1mConnecting rooms for node     [0m [[0m[1m[34mgame.world.procgen[0m][0m [36mis_leaf[0m=[35mTrue[0m [36mrect[0m=[35mRect(x1=26, y1=7, x2=34, y2=16)[0m
[2m2025-05-14T23:07:35.649797[0m [[32m[1mdebug    [0m] [1mConnecting sibling rooms      [0m [[0m[1m[34mgame.world.procgen[0m][0m [36mconnect_left[0m=[35m(21, 9)[0m [36mconnect_right[0m=[35m(28, 12)[0m [36mend_floor_h[0m=[35m0[0m [36mleft_center[0m=[35m(21, 9)[0m [36mright_center[0m=[35m(30, 11)[0m [36mstart_floor_h[0m=[35m0[0m
[2m2025-05-14T23:07:35.649829[0m [[32m[1mdebug    [0m] [1mCarving tunnel                [0m [[0m[1m[34mgame.world.procgen[0m][0m [36mend_floor_h[0m=[35m0[0m [36mend_pos[0m=[35m(28, 12)[0m [36mstart_floor_h[0m=[35m0[0m [36mstart_pos[0m=[35m(21, 9)[0m
[2m2025-05-14T23:07:35.649864[0m [[32m[1mdebug    [0m] [1mCarved rectangle area         [0m [[0m[1m[34mgame.world.procgen[0m][0m [36mceil_h[0m=[35m4[0m [36mfloor_h[0m=[35m0[0m [36mrect[0m=[35mRect(x1=21, y1=9, x2=21, y2=12)[0m [36mx_slice[0m=[35m21:22[0m [36my_slice[0m=[35m9:13[0m
[2m2025-05-14T23:07:35.649894[0m [[32m[1mdebug    [0m] [1mCarved vertical tunnel segment[0m [[0m[1m[34mgame.world.procgen[0m][0m [36mceil_h[0m=[35m4[0m [36mfloor_h[0m=[35m0[0m [36mrect[0m=[35mRect(x1=21, y1=9, x2=21, y2=12)[0m
[2m2025-05-14T23:07:35.649924[0m [[32m[1mdebug    [0m] [1mCarved rectangle area         [0m [[0m[1m[34mgame.world.procgen[0m][0m [36mceil_h[0m=[35m4[0m [36mfloor_h[0m=[35m0[0m [36mrect[0m=[35mRect(x1=22, y1=12, x2=28, y2=12)[0m [36mx_slice[0m=[35m22:29[0m [36my_slice[0m=[35m12:13[0m
[2m2025-05-14T23:07:35.649953[0m [[32m[1mdebug    [0m] [1mCarved horizontal tunnel segment[0m [[0m[1m[34mgame.world.procgen[0m][0m [36mceil_h[0m=[35m4[0m [36mfloor_h[0m=[35m0[0m [36mrect[0m=[35mRect(x1=22, y1=12, x2=28, y2=12)[0m
[2m2025-05-14T23:07:35.649979[0m [[32m[1mdebug    [0m] [1mConnecting rooms for node     [0m [[0m[1m[34mgame.world.procgen[0m][0m [36mis_leaf[0m=[35mFalse[0m [36mrect[0m=[35mRect(x1=15, y1=17, x2=34, y2=48)[0m
[2m2025-05-14T23:07:35.650002[0m [[32m[1mdebug    [0m] [1mConnecting rooms for node     [0m [[0m[1m[34mgame.world.procgen[0m][0m [36mis_leaf[0m=[35mFalse[0m [36mrect[0m=[35mRect(x1=15, y1=17, x2=34, y2=27)[0m
[2m2025-05-14T23:07:35.650025[0m [[32m[1mdebug    [0m] [1mConnecting rooms for node     [0m [[0m[1m[34mgame.world.procgen[0m][0m [36mis_leaf[0m=[35mTrue[0m [36mrect[0m=[35mRect(x1=15, y1=17, x2=21, y2=27)[0m
[2m2025-05-14T23:07:35.650047[0m [[32m[1mdebug    [0m] [1mConnecting rooms for node     [0m [[0m[1m[34mgame.world.procgen[0m][0m [36mis_leaf[0m=[35mFalse[0m [36mrect[0m=[35mRect(x1=22, y1=17, x2=34, y2=27)[0m
[2m2025-05-14T23:07:35.650070[0m [[32m[1mdebug    [0m] [1mConnecting rooms for node     [0m [[0m[1m[34mgame.world.procgen[0m][0m [36mis_leaf[0m=[35mTrue[0m [36mrect[0m=[35mRect(x1=22, y1=17, x2=27, y2=27)[0m
[2m2025-05-14T23:07:35.650096[0m [[32m[1mdebug    [0m] [1mConnecting rooms for node     [0m [[0m[1m[34mgame.world.procgen[0m][0m [36mis_leaf[0m=[35mTrue[0m [36mrect[0m=[35mRect(x1=28, y1=17, x2=34, y2=27)[0m
[2m2025-05-14T23:07:35.650143[0m [[32m[1mdebug    [0m] [1mConnecting sibling rooms      [0m [[0m[1m[34mgame.world.procgen[0m][0m [36mconnect_left[0m=[35m(23, 18)[0m [36mconnect_right[0m=[35m(31, 26)[0m [36mend_floor_h[0m=[35m0[0m [36mleft_center[0m=[35m(23, 20)[0m [36mright_center[0m=[35m(30, 23)[0m [36mstart_floor_h[0m=[35m0[0m
[2m2025-05-14T23:07:35.650173[0m [[32m[1mdebug    [0m] [1mCarving tunnel                [0m [[0m[1m[34mgame.world.procgen[0m][0m [36mend_floor_h[0m=[35m0[0m [36mend_pos[0m=[35m(31, 26)[0m [36mstart_floor_h[0m=[35m0[0m [36mstart_pos[0m=[35m(23, 18)[0m
[2m2025-05-14T23:07:35.650208[0m [[32m[1mdebug    [0m] [1mCarved rectangle area         [0m [[0m[1m[34mgame.world.procgen[0m][0m [36mceil_h[0m=[35m4[0m [36mfloor_h[0m=[35m0[0m [36mrect[0m=[35mRect(x1=23, y1=18, x2=23, y2=26)[0m [36mx_slice[0m=[35m23:24[0m [36my_slice[0m=[35m18:27[0m
[2m2025-05-14T23:07:35.650239[0m [[32m[1mdebug    [0m] [1mCarved vertical tunnel segment[0m [[0m[1m[34mgame.world.procgen[0m][0m [36mceil_h[0m=[35m4[0m [36mfloor_h[0m=[35m0[0m [36mrect[0m=[35mRect(x1=23, y1=18, x2=23, y2=26)[0m
[2m2025-05-14T23:07:35.650269[0m [[32m[1mdebug    [0m] [1mCarved rectangle area         [0m [[0m[1m[34mgame.world.procgen[0m][0m [36mceil_h[0m=[35m4[0m [36mfloor_h[0m=[35m0[0m [36mrect[0m=[35mRect(x1=24, y1=26, x2=31, y2=26)[0m [36mx_slice[0m=[35m24:32[0m [36my_slice[0m=[35m26:27[0m
[2m2025-05-14T23:07:35.650297[0m [[32m[1mdebug    [0m] [1mCarved horizontal tunnel segment[0m [[0m[1m[34mgame.world.procgen[0m][0m [36mceil_h[0m=[35m4[0m [36mfloor_h[0m=[35m0[0m [36mrect[0m=[35mRect(x1=24, y1=26, x2=31, y2=26)[0m
[2m2025-05-14T23:07:35.650341[0m [[32m[1mdebug    [0m] [1mConnecting sibling rooms      [0m [[0m[1m[34mgame.world.procgen[0m][0m [36mconnect_left[0m=[35m(18, 25)[0m [36mconnect_right[0m=[35m(24, 23)[0m [36mend_floor_h[0m=[35m0[0m [36mleft_center[0m=[35m(18, 22)[0m [36mright_center[0m=[35m(23, 20)[0m [36mstart_floor_h[0m=[35m0[0m
[2m2025-05-14T23:07:35.650371[0m [[32m[1mdebug    [0m] [1mCarving tunnel                [0m [[0m[1m[34mgame.world.procgen[0m][0m [36mend_floor_h[0m=[35m0[0m [36mend_pos[0m=[35m(24, 23)[0m [36mstart_floor_h[0m=[35m0[0m [36mstart_pos[0m=[35m(18, 25)[0m
[2m2025-05-14T23:07:35.650405[0m [[32m[1mdebug    [0m] [1mCarved rectangle area         [0m [[0m[1m[34mgame.world.procgen[0m][0m [36mceil_h[0m=[35m4[0m [36mfloor_h[0m=[35m0[0m [36mrect[0m=[35mRect(x1=18, y1=23, x2=18, y2=25)[0m [36mx_slice[0m=[35m18:19[0m [36my_slice[0m=[35m23:26[0m
[2m2025-05-14T23:07:35.650434[0m [[32m[1mdebug    [0m] [1mCarved vertical tunnel segment[0m [[0m[1m[34mgame.world.procgen[0m][0m [36mceil_h[0m=[35m4[0m [36mfloor_h[0m=[35m0[0m [36mrect[0m=[35mRect(x1=18, y1=23, x2=18, y2=25)[0m
[2m2025-05-14T23:07:35.650464[0m [[32m[1mdebug    [0m] [1mCarved rectangle area         [0m [[0m[1m[34mgame.world.procgen[0m][0m [36mceil_h[0m=[35m4[0m [36mfloor_h[0m=[35m0[0m [36mrect[0m=[35mRect(x1=19, y1=23, x2=24, y2=23)[0m [36mx_slice[0m=[35m19:25[0m [36my_slice[0m=[35m23:24[0m
[2m2025-05-14T23:07:35.650492[0m [[32m[1mdebug    [0m] [1mCarved horizontal tunnel segment[0m [[0m[1m[34mgame.world.procgen[0m][0m [36mceil_h[0m=[35m4[0m [36mfloor_h[0m=[35m0[0m [36mrect[0m=[35mRect(x1=19, y1=23, x2=24, y2=23)[0m
[2m2025-05-14T23:07:35.650517[0m [[32m[1mdebug    [0m] [1mConnecting rooms for node     [0m [[0m[1m[34mgame.world.procgen[0m][0m [36mis_leaf[0m=[35mFalse[0m [36mrect[0m=[35mRect(x1=15, y1=28, x2=34, y2=48)[0m
[2m2025-05-14T23:07:35.650541[0m [[32m[1mdebug    [0m] [1mConnecting rooms for node     [0m [[0m[1m[34mgame.world.procgen[0m][0m [36mis_leaf[0m=[35mFalse[0m [36mrect[0m=[35mRect(x1=15, y1=28, x2=25, y2=48)[0m
[2m2025-05-14T23:07:35.650577[0m [[32m[1mdebug    [0m] [1mConnecting rooms for node     [0m [[0m[1m[34mgame.world.procgen[0m][0m [36mis_leaf[0m=[35mTrue[0m [36mrect[0m=[35mRect(x1=15, y1=28, x2=25, y2=37)[0m
[2m2025-05-14T23:07:35.650604[0m [[32m[1mdebug    [0m] [1mConnecting rooms for node     [0m [[0m[1m[34mgame.world.procgen[0m][0m [36mis_leaf[0m=[35mTrue[0m [36mrect[0m=[35mRect(x1=15, y1=38, x2=25, y2=48)[0m
[2m2025-05-14T23:07:35.650650[0m [[32m[1mdebug    [0m] [1mConnecting sibling rooms      [0m [[0m[1m[34mgame.world.procgen[0m][0m [36mconnect_left[0m=[35m(23, 32)[0m [36mconnect_right[0m=[35m(21, 42)[0m [36mend_floor_h[0m=[35m0[0m [36mleft_center[0m=[35m(21, 33)[0m [36mright_center[0m=[35m(20, 42)[0m [36mstart_floor_h[0m=[35m0[0m
[2m2025-05-14T23:07:35.650680[0m [[32m[1mdebug    [0m] [1mCarving tunnel                [0m [[0m[1m[34mgame.world.procgen[0m][0m [36mend_floor_h[0m=[35m0[0m [36mend_pos[0m=[35m(21, 42)[0m [36mstart_floor_h[0m=[35m0[0m [36mstart_pos[0m=[35m(23, 32)[0m
[2m2025-05-14T23:07:35.650716[0m [[32m[1mdebug    [0m] [1mCarved rectangle area         [0m [[0m[1m[34mgame.world.procgen[0m][0m [36mceil_h[0m=[35m4[0m [36mfloor_h[0m=[35m0[0m [36mrect[0m=[35mRect(x1=23, y1=32, x2=23, y2=42)[0m [36mx_slice[0m=[35m23:24[0m [36my_slice[0m=[35m32:43[0m
[2m2025-05-14T23:07:35.650746[0m [[32m[1mdebug    [0m] [1mCarved vertical tunnel segment[0m [[0m[1m[34mgame.world.procgen[0m][0m [36mceil_h[0m=[35m4[0m [36mfloor_h[0m=[35m0[0m [36mrect[0m=[35mRect(x1=23, y1=32, x2=23, y2=42)[0m
[2m2025-05-14T23:07:35.650776[0m [[32m[1mdebug    [0m] [1mCarved rectangle area         [0m [[0m[1m[34mgame.world.procgen[0m][0m [36mceil_h[0m=[35m4[0m [36mfloor_h[0m=[35m0[0m [36mrect[0m=[35mRect(x1=21, y1=42, x2=22, y2=42)[0m [36mx_slice[0m=[35m21:23[0m [36my_slice[0m=[35m42:43[0m
[2m2025-05-14T23:07:35.650804[0m [[32m[1mdebug    [0m] [1mCarved horizontal tunnel segment[0m [[0m[1m[34mgame.world.procgen[0m][0m [36mceil_h[0m=[35m4[0m [36mfloor_h[0m=[35m0[0m [36mrect[0m=[35mRect(x1=21, y1=42, x2=22, y2=42)[0m
[2m2025-05-14T23:07:35.650830[0m [[32m[1mdebug    [0m] [1mConnecting rooms for node     [0m [[0m[1m[34mgame.world.procgen[0m][0m [36mis_leaf[0m=[35mFalse[0m [36mrect[0m=[35mRect(x1=26, y1=28, x2=34, y2=48)[0m
[2m2025-05-14T23:07:35.650853[0m [[32m[1mdebug    [0m] [1mConnecting rooms for node     [0m [[0m[1m[34mgame.world.procgen[0m][0m [36mis_leaf[0m=[35mTrue[0m [36mrect[0m=[35mRect(x1=26, y1=28, x2=34, y2=33)[0m
[2m2025-05-14T23:07:35.650876[0m [[32m[1mdebug    [0m] [1mConnecting rooms for node     [0m [[0m[1m[34mgame.world.procgen[0m][0m [36mis_leaf[0m=[35mFalse[0m [36mrect[0m=[35mRect(x1=26, y1=34, x2=34, y2=48)[0m
[2m2025-05-14T23:07:35.650898[0m [[32m[1mdebug    [0m] [1mConnecting rooms for node     [0m [[0m[1m[34mgame.world.procgen[0m][0m [36mis_leaf[0m=[35mTrue[0m [36mrect[0m=[35mRect(x1=26, y1=34, x2=34, y2=39)[0m
[2m2025-05-14T23:07:35.650921[0m [[32m[1mdebug    [0m] [1mConnecting rooms for node     [0m [[0m[1m[34mgame.world.procgen[0m][0m [36mis_leaf[0m=[35mTrue[0m [36mrect[0m=[35mRect(x1=26, y1=40, x2=34, y2=48)[0m
[2m2025-05-14T23:07:35.650975[0m [[32m[1mdebug    [0m] [1mConnecting sibling rooms      [0m [[0m[1m[34mgame.world.procgen[0m][0m [36mconnect_left[0m=[35m(28, 36)[0m [36mconnect_right[0m=[35m(31, 46)[0m [36mend_floor_h[0m=[35m0[0m [36mleft_center[0m=[35m(29, 35)[0m [36mright_center[0m=[35m(29, 46)[0m [36mstart_floor_h[0m=[35m0[0m
[2m2025-05-14T23:07:35.651005[0m [[32m[1mdebug    [0m] [1mCarving tunnel                [0m [[0m[1m[34mgame.world.procgen[0m][0m [36mend_floor_h[0m=[35m0[0m [36mend_pos[0m=[35m(31, 46)[0m [36mstart_floor_h[0m=[35m0[0m [36mstart_pos[0m=[35m(28, 36)[0m
[2m2025-05-14T23:07:35.651043[0m [[32m[1mdebug    [0m] [1mCarved rectangle area         [0m [[0m[1m[34mgame.world.procgen[0m][0m [36mceil_h[0m=[35m4[0m [36mfloor_h[0m=[35m0[0m [36mrect[0m=[35mRect(x1=28, y1=36, x2=28, y2=46)[0m [36mx_slice[0m=[35m28:29[0m [36my_slice[0m=[35m36:47[0m
[2m2025-05-14T23:07:35.651074[0m [[32m[1mdebug    [0m] [1mCarved vertical tunnel segment[0m [[0m[1m[34mgame.world.procgen[0m][0m [36mceil_h[0m=[35m4[0m [36mfloor_h[0m=[35m0[0m [36mrect[0m=[35mRect(x1=28, y1=36, x2=28, y2=46)[0m
[2m2025-05-14T23:07:35.651105[0m [[32m[1mdebug    [0m] [1mCarved rectangle area         [0m [[0m[1m[34mgame.world.procgen[0m][0m [36mceil_h[0m=[35m4[0m [36mfloor_h[0m=[35m0[0m [36mrect[0m=[35mRect(x1=29, y1=46, x2=31, y2=46)[0m [36mx_slice[0m=[35m29:32[0m [36my_slice[0m=[35m46:47[0m
[2m2025-05-14T23:07:35.651134[0m [[32m[1mdebug    [0m] [1mCarved horizontal tunnel segment[0m [[0m[1m[34mgame.world.procgen[0m][0m [36mceil_h[0m=[35m4[0m [36mfloor_h[0m=[35m0[0m [36mrect[0m=[35mRect(x1=29, y1=46, x2=31, y2=46)[0m
[2m2025-05-14T23:07:35.651186[0m [[32m[1mdebug    [0m] [1mConnecting sibling rooms      [0m [[0m[1m[34mgame.world.procgen[0m][0m [36mconnect_left[0m=[35m(28, 32)[0m [36mconnect_right[0m=[35m(30, 36)[0m [36mend_floor_h[0m=[35m0[0m [36mleft_center[0m=[35m(29, 30)[0m [36mright_center[0m=[35m(29, 35)[0m [36mstart_floor_h[0m=[35m0[0m
[2m2025-05-14T23:07:35.651217[0m [[32m[1mdebug    [0m] [1mCarving tunnel                [0m [[0m[1m[34mgame.world.procgen[0m][0m [36mend_floor_h[0m=[35m0[0m [36mend_pos[0m=[35m(30, 36)[0m [36mstart_floor_h[0m=[35m0[0m [36mstart_pos[0m=[35m(28, 32)[0m
[2m2025-05-14T23:07:35.651251[0m [[32m[1mdebug    [0m] [1mCarved rectangle area         [0m [[0m[1m[34mgame.world.procgen[0m][0m [36mceil_h[0m=[35m4[0m [36mfloor_h[0m=[35m0[0m [36mrect[0m=[35mRect(x1=28, y1=32, x2=28, y2=36)[0m [36mx_slice[0m=[35m28:29[0m [36my_slice[0m=[35m32:37[0m
[2m2025-05-14T23:07:35.651281[0m [[32m[1mdebug    [0m] [1mCarved vertical tunnel segment[0m [[0m[1m[34mgame.world.procgen[0m][0m [36mceil_h[0m=[35m4[0m [36mfloor_h[0m=[35m0[0m [36mrect[0m=[35mRect(x1=28, y1=32, x2=28, y2=36)[0m
[2m2025-05-14T23:07:35.651311[0m [[32m[1mdebug    [0m] [1mCarved rectangle area         [0m [[0m[1m[34mgame.world.procgen[0m][0m [36mceil_h[0m=[35m4[0m [36mfloor_h[0m=[35m0[0m [36mrect[0m=[35mRect(x1=29, y1=36, x2=30, y2=36)[0m [36mx_slice[0m=[35m29:31[0m [36my_slice[0m=[35m36:37[0m
[2m2025-05-14T23:07:35.651339[0m [[32m[1mdebug    [0m] [1mCarved horizontal tunnel segment[0m [[0m[1m[34mgame.world.procgen[0m][0m [36mceil_h[0m=[35m4[0m [36mfloor_h[0m=[35m0[0m [36mrect[0m=[35mRect(x1=29, y1=36, x2=30, y2=36)[0m
[2m2025-05-14T23:07:35.651385[0m [[32m[1mdebug    [0m] [1mConnecting sibling rooms      [0m [[0m[1m[34mgame.world.procgen[0m][0m [36mconnect_left[0m=[35m(21, 35)[0m [36mconnect_right[0m=[35m(32, 31)[0m [36mend_floor_h[0m=[35m0[0m [36mleft_center[0m=[35m(21, 33)[0m [36mright_center[0m=[35m(29, 30)[0m [36mstart_floor_h[0m=[35m0[0m
[2m2025-05-14T23:07:35.651416[0m [[32m[1mdebug    [0m] [1mCarving tunnel                [0m [[0m[1m[34mgame.world.procgen[0m][0m [36mend_floor_h[0m=[35m0[0m [36mend_pos[0m=[35m(32, 31)[0m [36mstart_floor_h[0m=[35m0[0m [36mstart_pos[0m=[35m(21, 35)[0m
[2m2025-05-14T23:07:35.651451[0m [[32m[1mdebug    [0m] [1mCarved rectangle area         [0m [[0m[1m[34mgame.world.procgen[0m][0m [36mceil_h[0m=[35m4[0m [36mfloor_h[0m=[35m0[0m [36mrect[0m=[35mRect(x1=21, y1=31, x2=21, y2=35)[0m [36mx_slice[0m=[35m21:22[0m [36my_slice[0m=[35m31:36[0m
[2m2025-05-14T23:07:35.651481[0m [[32m[1mdebug    [0m] [1mCarved vertical tunnel segment[0m [[0m[1m[34mgame.world.procgen[0m][0m [36mceil_h[0m=[35m4[0m [36mfloor_h[0m=[35m0[0m [36mrect[0m=[35mRect(x1=21, y1=31, x2=21, y2=35)[0m
[2m2025-05-14T23:07:35.651514[0m [[32m[1mdebug    [0m] [1mCarved rectangle area         [0m [[0m[1m[34mgame.world.procgen[0m][0m [36mceil_h[0m=[35m4[0m [36mfloor_h[0m=[35m0[0m [36mrect[0m=[35mRect(x1=22, y1=31, x2=32, y2=31)[0m [36mx_slice[0m=[35m22:33[0m [36my_slice[0m=[35m31:32[0m
[2m2025-05-14T23:07:35.651543[0m [[32m[1mdebug    [0m] [1mCarved horizontal tunnel segment[0m [[0m[1m[34mgame.world.procgen[0m][0m [36mceil_h[0m=[35m4[0m [36mfloor_h[0m=[35m0[0m [36mrect[0m=[35mRect(x1=22, y1=31, x2=32, y2=31)[0m
[2m2025-05-14T23:07:35.651598[0m [[32m[1mdebug    [0m] [1mConnecting sibling rooms      [0m [[0m[1m[34mgame.world.procgen[0m][0m [36mconnect_left[0m=[35m(20, 25)[0m [36mconnect_right[0m=[35m(23, 34)[0m [36mend_floor_h[0m=[35m0[0m [36mleft_center[0m=[35m(18, 22)[0m [36mright_center[0m=[35m(21, 33)[0m [36mstart_floor_h[0m=[35m0[0m
[2m2025-05-14T23:07:35.651632[0m [[32m[1mdebug    [0m] [1mCarving tunnel                [0m [[0m[1m[34mgame.world.procgen[0m][0m [36mend_floor_h[0m=[35m0[0m [36mend_pos[0m=[35m(23, 34)[0m [36mstart_floor_h[0m=[35m0[0m [36mstart_pos[0m=[35m(20, 25)[0m
[2m2025-05-14T23:07:35.651668[0m [[32m[1mdebug    [0m] [1mCarved rectangle area         [0m [[0m[1m[34mgame.world.procgen[0m][0m [36mceil_h[0m=[35m4[0m [36mfloor_h[0m=[35m0[0m [36mrect[0m=[35mRect(x1=20, y1=25, x2=20, y2=34)[0m [36mx_slice[0m=[35m20:21[0m [36my_slice[0m=[35m25:35[0m
[2m2025-05-14T23:07:35.651699[0m [[32m[1mdebug    [0m] [1mCarved vertical tunnel segment[0m [[0m[1m[34mgame.world.procgen[0m][0m [36mceil_h[0m=[35m4[0m [36mfloor_h[0m=[35m0[0m [36mrect[0m=[35mRect(x1=20, y1=25, x2=20, y2=34)[0m
[2m2025-05-14T23:07:35.651728[0m [[32m[1mdebug    [0m] [1mCarved rectangle area         [0m [[0m[1m[34mgame.world.procgen[0m][0m [36mceil_h[0m=[35m4[0m [36mfloor_h[0m=[35m0[0m [36mrect[0m=[35mRect(x1=21, y1=34, x2=23, y2=34)[0m [36mx_slice[0m=[35m21:24[0m [36my_slice[0m=[35m34:35[0m
[2m2025-05-14T23:07:35.651757[0m [[32m[1mdebug    [0m] [1mCarved horizontal tunnel segment[0m [[0m[1m[34mgame.world.procgen[0m][0m [36mceil_h[0m=[35m4[0m [36mfloor_h[0m=[35m0[0m [36mrect[0m=[35mRect(x1=21, y1=34, x2=23, y2=34)[0m
[2m2025-05-14T23:07:35.651803[0m [[32m[1mdebug    [0m] [1mConnecting sibling rooms      [0m [[0m[1m[34mgame.world.procgen[0m][0m [36mconnect_left[0m=[35m(21, 9)[0m [36mconnect_right[0m=[35m(17, 21)[0m [36mend_floor_h[0m=[35m0[0m [36mleft_center[0m=[35m(21, 9)[0m [36mright_center[0m=[35m(18, 22)[0m [36mstart_floor_h[0m=[35m0[0m
[2m2025-05-14T23:07:35.651833[0m [[32m[1mdebug    [0m] [1mCarving tunnel                [0m [[0m[1m[34mgame.world.procgen[0m][0m [36mend_floor_h[0m=[35m0[0m [36mend_pos[0m=[35m(17, 21)[0m [36mstart_floor_h[0m=[35m0[0m [36mstart_pos[0m=[35m(21, 9)[0m
[2m2025-05-14T23:07:35.651868[0m [[32m[1mdebug    [0m] [1mCarved rectangle area         [0m [[0m[1m[34mgame.world.procgen[0m][0m [36mceil_h[0m=[35m4[0m [36mfloor_h[0m=[35m0[0m [36mrect[0m=[35mRect(x1=21, y1=9, x2=21, y2=21)[0m [36mx_slice[0m=[35m21:22[0m [36my_slice[0m=[35m9:22[0m
[2m2025-05-14T23:07:35.651898[0m [[32m[1mdebug    [0m] [1mCarved vertical tunnel segment[0m [[0m[1m[34mgame.world.procgen[0m][0m [36mceil_h[0m=[35m4[0m [36mfloor_h[0m=[35m0[0m [36mrect[0m=[35mRect(x1=21, y1=9, x2=21, y2=21)[0m
[2m2025-05-14T23:07:35.651928[0m [[32m[1mdebug    [0m] [1mCarved rectangle area         [0m [[0m[1m[34mgame.world.procgen[0m][0m [36mceil_h[0m=[35m4[0m [36mfloor_h[0m=[35m0[0m [36mrect[0m=[35mRect(x1=17, y1=21, x2=20, y2=21)[0m [36mx_slice[0m=[35m17:21[0m [36my_slice[0m=[35m21:22[0m
[2m2025-05-14T23:07:35.651956[0m [[32m[1mdebug    [0m] [1mCarved horizontal tunnel segment[0m [[0m[1m[34mgame.world.procgen[0m][0m [36mceil_h[0m=[35m4[0m [36mfloor_h[0m=[35m0[0m [36mrect[0m=[35mRect(x1=17, y1=21, x2=20, y2=21)[0m
[2m2025-05-14T23:07:35.652019[0m [[32m[1mdebug    [0m] [1mConnecting sibling rooms      [0m [[0m[1m[34mgame.world.procgen[0m][0m [36mconnect_left[0m=[35m(6, 9)[0m [36mconnect_right[0m=[35m(20, 11)[0m [36mend_floor_h[0m=[35m0[0m [36mleft_center[0m=[35m(4, 10)[0m [36mright_center[0m=[35m(21, 9)[0m [36mstart_floor_h[0m=[35m0[0m
[2m2025-05-14T23:07:35.652056[0m [[32m[1mdebug    [0m] [1mCarving tunnel                [0m [[0m[1m[34mgame.world.procgen[0m][0m [36mend_floor_h[0m=[35m0[0m [36mend_pos[0m=[35m(20, 11)[0m [36mstart_floor_h[0m=[35m0[0m [36mstart_pos[0m=[35m(6, 9)[0m
[2m2025-05-14T23:07:35.652093[0m [[32m[1mdebug    [0m] [1mCarved rectangle area         [0m [[0m[1m[34mgame.world.procgen[0m][0m [36mceil_h[0m=[35m4[0m [36mfloor_h[0m=[35m0[0m [36mrect[0m=[35mRect(x1=6, y1=9, x2=6, y2=11)[0m [36mx_slice[0m=[35m6:7[0m [36my_slice[0m=[35m9:12[0m
[2m2025-05-14T23:07:35.652124[0m [[32m[1mdebug    [0m] [1mCarved vertical tunnel segment[0m [[0m[1m[34mgame.world.procgen[0m][0m [36mceil_h[0m=[35m4[0m [36mfloor_h[0m=[35m0[0m [36mrect[0m=[35mRect(x1=6, y1=9, x2=6, y2=11)[0m
[2m2025-05-14T23:07:35.652154[0m [[32m[1mdebug    [0m] [1mCarved rectangle area         [0m [[0m[1m[34mgame.world.procgen[0m][0m [36mceil_h[0m=[35m4[0m [36mfloor_h[0m=[35m0[0m [36mrect[0m=[35mRect(x1=7, y1=11, x2=20, y2=11)[0m [36mx_slice[0m=[35m7:21[0m [36my_slice[0m=[35m11:12[0m
[2m2025-05-14T23:07:35.652183[0m [[32m[1mdebug    [0m] [1mCarved horizontal tunnel segment[0m [[0m[1m[34mgame.world.procgen[0m][0m [36mceil_h[0m=[35m4[0m [36mfloor_h[0m=[35m0[0m [36mrect[0m=[35mRect(x1=7, y1=11, x2=20, y2=11)[0m
[2m2025-05-14T23:07:35.652241[0m [[32m[1mdebug    [0m] [1mConnecting sibling rooms      [0m [[0m[1m[34mgame.world.procgen[0m][0m [36mconnect_left[0m=[35m(4, 2)[0m [36mconnect_right[0m=[35m(3, 10)[0m [36mend_floor_h[0m=[35m0[0m [36mleft_center[0m=[35m(4, 3)[0m [36mright_center[0m=[35m(4, 10)[0m [36mstart_floor_h[0m=[35m0[0m
[2m2025-05-14T23:07:35.652281[0m [[32m[1mdebug    [0m] [1mCarving tunnel                [0m [[0m[1m[34mgame.world.procgen[0m][0m [36mend_floor_h[0m=[35m0[0m [36mend_pos[0m=[35m(3, 10)[0m [36mstart_floor_h[0m=[35m0[0m [36mstart_pos[0m=[35m(4, 2)[0m
[2m2025-05-14T23:07:35.652332[0m [[32m[1mdebug    [0m] [1mCarved rectangle area         [0m [[0m[1m[34mgame.world.procgen[0m][0m [36mceil_h[0m=[35m4[0m [36mfloor_h[0m=[35m0[0m [36mrect[0m=[35mRect(x1=4, y1=2, x2=4, y2=10)[0m [36mx_slice[0m=[35m4:5[0m [36my_slice[0m=[35m2:11[0m
[2m2025-05-14T23:07:35.652376[0m [[32m[1mdebug    [0m] [1mCarved vertical tunnel segment[0m [[0m[1m[34mgame.world.procgen[0m][0m [36mceil_h[0m=[35m4[0m [36mfloor_h[0m=[35m0[0m [36mrect[0m=[35mRect(x1=4, y1=2, x2=4, y2=10)[0m
[2m2025-05-14T23:07:35.652409[0m [[32m[1mdebug    [0m] [1mCarved rectangle area         [0m [[0m[1m[34mgame.world.procgen[0m][0m [36mceil_h[0m=[35m4[0m [36mfloor_h[0m=[35m0[0m [36mrect[0m=[35mRect(x1=3, y1=10, x2=3, y2=10)[0m [36mx_slice[0m=[35m3:4[0m [36my_slice[0m=[35m10:11[0m
[2m2025-05-14T23:07:35.652438[0m [[32m[1mdebug    [0m] [1mCarved horizontal tunnel segment[0m [[0m[1m[34mgame.world.procgen[0m][0m [36mceil_h[0m=[35m4[0m [36mfloor_h[0m=[35m0[0m [36mrect[0m=[35mRect(x1=3, y1=10, x2=3, y2=10)[0m
[2m2025-05-14T23:07:35.652465[0m [[32m[1mdebug    [0m] [1mConnecting rooms for node     [0m [[0m[1m[34mgame.world.procgen[0m][0m [36mis_leaf[0m=[35mFalse[0m [36mrect[0m=[35mRect(x1=35, y1=1, x2=78, y2=48)[0m
[2m2025-05-14T23:07:35.652490[0m [[32m[1mdebug    [0m] [1mConnecting rooms for node     [0m [[0m[1m[34mgame.world.procgen[0m][0m [36mis_leaf[0m=[35mFalse[0m [36mrect[0m=[35mRect(x1=35, y1=1, x2=46, y2=48)[0m
[2m2025-05-14T23:07:35.652519[0m [[32m[1mdebug    [0m] [1mConnecting rooms for node     [0m [[0m[1m[34mgame.world.procgen[0m][0m [36mis_leaf[0m=[35mTrue[0m [36mrect[0m=[35mRect(x1=35, y1=1, x2=46, y2=9)[0m
[2m2025-05-14T23:07:35.652544[0m [[32m[1mdebug    [0m] [1mConnecting rooms for node     [0m [[0m[1m[34mgame.world.procgen[0m][0m [36mis_leaf[0m=[35mFalse[0m [36mrect[0m=[35mRect(x1=35, y1=10, x2=46, y2=48)[0m
[2m2025-05-14T23:07:35.652567[0m [[32m[1mdebug    [0m] [1mConnecting rooms for node     [0m [[0m[1m[34mgame.world.procgen[0m][0m [36mis_leaf[0m=[35mFalse[0m [36mrect[0m=[35mRect(x1=35, y1=10, x2=46, y2=28)[0m
[2m2025-05-14T23:07:35.652601[0m [[32m[1mdebug    [0m] [1mConnecting rooms for node     [0m [[0m[1m[34mgame.world.procgen[0m][0m [36mis_leaf[0m=[35mTrue[0m [36mrect[0m=[35mRect(x1=35, y1=10, x2=46, y2=20)[0m
[2m2025-05-14T23:07:35.652625[0m [[32m[1mdebug    [0m] [1mConnecting rooms for node     [0m [[0m[1m[34mgame.world.procgen[0m][0m [36mis_leaf[0m=[35mTrue[0m [36mrect[0m=[35mRect(x1=35, y1=21, x2=46, y2=28)[0m
[2m2025-05-14T23:07:35.652676[0m [[32m[1mdebug    [0m] [1mConnecting sibling rooms      [0m [[0m[1m[34mgame.world.procgen[0m][0m [36mconnect_left[0m=[35m(39, 12)[0m [36mconnect_right[0m=[35m(43, 25)[0m [36mend_floor_h[0m=[35m0[0m [36mleft_center[0m=[35m(40, 13)[0m [36mright_center[0m=[35m(43, 25)[0m [36mstart_floor_h[0m=[35m0[0m
[2m2025-05-14T23:07:35.652707[0m [[32m[1mdebug    [0m] [1mCarving tunnel                [0m [[0m[1m[34mgame.world.procgen[0m][0m [36mend_floor_h[0m=[35m0[0m [36mend_pos[0m=[35m(43, 25)[0m [36mstart_floor_h[0m=[35m0[0m [36mstart_pos[0m=[35m(39, 12)[0m
[2m2025-05-14T23:07:35.652743[0m [[32m[1mdebug    [0m] [1mCarved rectangle area         [0m [[0m[1m[34mgame.world.procgen[0m][0m [36mceil_h[0m=[35m4[0m [36mfloor_h[0m=[35m0[0m [36mrect[0m=[35mRect(x1=39, y1=12, x2=39, y2=25)[0m [36mx_slice[0m=[35m39:40[0m [36my_slice[0m=[35m12:26[0m
[2m2025-05-14T23:07:35.652774[0m [[32m[1mdebug    [0m] [1mCarved vertical tunnel segment[0m [[0m[1m[34mgame.world.procgen[0m][0m [36mceil_h[0m=[35m4[0m [36mfloor_h[0m=[35m0[0m [36mrect[0m=[35mRect(x1=39, y1=12, x2=39, y2=25)[0m
[2m2025-05-14T23:07:35.652804[0m [[32m[1mdebug    [0m] [1mCarved rectangle area         [0m [[0m[1m[34mgame.world.procgen[0m][0m [36mceil_h[0m=[35m4[0m [36mfloor_h[0m=[35m0[0m [36mrect[0m=[35mRect(x1=40, y1=25, x2=43, y2=25)[0m [36mx_slice[0m=[35m40:44[0m [36my_slice[0m=[35m25:26[0m
[2m2025-05-14T23:07:35.652833[0m [[32m[1mdebug    [0m] [1mCarved horizontal tunnel segment[0m [[0m[1m[34mgame.world.procgen[0m][0m [36mceil_h[0m=[35m4[0m [36mfloor_h[0m=[35m0[0m [36mrect[0m=[35mRect(x1=40, y1=25, x2=43, y2=25)[0m
[2m2025-05-14T23:07:35.652859[0m [[32m[1mdebug    [0m] [1mConnecting rooms for node     [0m [[0m[1m[34mgame.world.procgen[0m][0m [36mis_leaf[0m=[35mFalse[0m [36mrect[0m=[35mRect(x1=35, y1=29, x2=46, y2=48)[0m
[2m2025-05-14T23:07:35.652883[0m [[32m[1mdebug    [0m] [1mConnecting rooms for node     [0m [[0m[1m[34mgame.world.procgen[0m][0m [36mis_leaf[0m=[35mTrue[0m [36mrect[0m=[35mRect(x1=35, y1=29, x2=46, y2=40)[0m
[2m2025-05-14T23:07:35.652906[0m [[32m[1mdebug    [0m] [1mConnecting rooms for node     [0m [[0m[1m[34mgame.world.procgen[0m][0m [36mis_leaf[0m=[35mTrue[0m [36mrect[0m=[35mRect(x1=35, y1=41, x2=46, y2=48)[0m
[2m2025-05-14T23:07:35.652952[0m [[32m[1mdebug    [0m] [1mConnecting sibling rooms      [0m [[0m[1m[34mgame.world.procgen[0m][0m [36mconnect_left[0m=[35m(43, 34)[0m [36mconnect_right[0m=[35m(39, 45)[0m [36mend_floor_h[0m=[35m0[0m [36mleft_center[0m=[35m(42, 35)[0m [36mright_center[0m=[35m(38, 43)[0m [36mstart_floor_h[0m=[35m0[0m
[2m2025-05-14T23:07:35.652982[0m [[32m[1mdebug    [0m] [1mCarving tunnel                [0m [[0m[1m[34mgame.world.procgen[0m][0m [36mend_floor_h[0m=[35m0[0m [36mend_pos[0m=[35m(39, 45)[0m [36mstart_floor_h[0m=[35m0[0m [36mstart_pos[0m=[35m(43, 34)[0m
[2m2025-05-14T23:07:35.653022[0m [[32m[1mdebug    [0m] [1mCarved rectangle area         [0m [[0m[1m[34mgame.world.procgen[0m][0m [36mceil_h[0m=[35m4[0m [36mfloor_h[0m=[35m0[0m [36mrect[0m=[35mRect(x1=43, y1=34, x2=43, y2=45)[0m [36mx_slice[0m=[35m43:44[0m [36my_slice[0m=[35m34:46[0m
[2m2025-05-14T23:07:35.653053[0m [[32m[1mdebug    [0m] [1mCarved vertical tunnel segment[0m [[0m[1m[34mgame.world.procgen[0m][0m [36mceil_h[0m=[35m4[0m [36mfloor_h[0m=[35m0[0m [36mrect[0m=[35mRect(x1=43, y1=34, x2=43, y2=45)[0m
[2m2025-05-14T23:07:35.653083[0m [[32m[1mdebug    [0m] [1mCarved rectangle area         [0m [[0m[1m[34mgame.world.procgen[0m][0m [36mceil_h[0m=[35m4[0m [36mfloor_h[0m=[35m0[0m [36mrect[0m=[35mRect(x1=39, y1=45, x2=42, y2=45)[0m [36mx_slice[0m=[35m39:43[0m [36my_slice[0m=[35m45:46[0m
[2m2025-05-14T23:07:35.653111[0m [[32m[1mdebug    [0m] [1mCarved horizontal tunnel segment[0m [[0m[1m[34mgame.world.procgen[0m][0m [36mceil_h[0m=[35m4[0m [36mfloor_h[0m=[35m0[0m [36mrect[0m=[35mRect(x1=39, y1=45, x2=42, y2=45)[0m
[2m2025-05-14T23:07:35.653159[0m [[32m[1mdebug    [0m] [1mConnecting sibling rooms      [0m [[0m[1m[34mgame.world.procgen[0m][0m [36mconnect_left[0m=[35m(39, 11)[0m [36mconnect_right[0m=[35m(44, 36)[0m [36mend_floor_h[0m=[35m0[0m [36mleft_center[0m=[35m(40, 13)[0m [36mright_center[0m=[35m(42, 35)[0m [36mstart_floor_h[0m=[35m0[0m
[2m2025-05-14T23:07:35.653190[0m [[32m[1mdebug    [0m] [1mCarving tunnel                [0m [[0m[1m[34mgame.world.procgen[0m][0m [36mend_floor_h[0m=[35m0[0m [36mend_pos[0m=[35m(44, 36)[0m [36mstart_floor_h[0m=[35m0[0m [36mstart_pos[0m=[35m(39, 11)[0m
[2m2025-05-14T23:07:35.653223[0m [[32m[1mdebug    [0m] [1mCarved rectangle area         [0m [[0m[1m[34mgame.world.procgen[0m][0m [36mceil_h[0m=[35m4[0m [36mfloor_h[0m=[35m0[0m [36mrect[0m=[35mRect(x1=39, y1=11, x2=39, y2=36)[0m [36mx_slice[0m=[35m39:40[0m [36my_slice[0m=[35m11:37[0m
[2m2025-05-14T23:07:35.653253[0m [[32m[1mdebug    [0m] [1mCarved vertical tunnel segment[0m [[0m[1m[34mgame.world.procgen[0m][0m [36mceil_h[0m=[35m4[0m [36mfloor_h[0m=[35m0[0m [36mrect[0m=[35mRect(x1=39, y1=11, x2=39, y2=36)[0m
[2m2025-05-14T23:07:35.653283[0m [[32m[1mdebug    [0m] [1mCarved rectangle area         [0m [[0m[1m[34mgame.world.procgen[0m][0m [36mceil_h[0m=[35m4[0m [36mfloor_h[0m=[35m0[0m [36mrect[0m=[35mRect(x1=40, y1=36, x2=44, y2=36)[0m [36mx_slice[0m=[35m40:45[0m [36my_slice[0m=[35m36:37[0m
[2m2025-05-14T23:07:35.653311[0m [[32m[1mdebug    [0m] [1mCarved horizontal tunnel segment[0m [[0m[1m[34mgame.world.procgen[0m][0m [36mceil_h[0m=[35m4[0m [36mfloor_h[0m=[35m0[0m [36mrect[0m=[35mRect(x1=40, y1=36, x2=44, y2=36)[0m
[2m2025-05-14T23:07:35.653361[0m [[32m[1mdebug    [0m] [1mConnecting sibling rooms      [0m [[0m[1m[34mgame.world.procgen[0m][0m [36mconnect_left[0m=[35m(39, 2)[0m [36mconnect_right[0m=[35m(39, 16)[0m [36mend_floor_h[0m=[35m0[0m [36mleft_center[0m=[35m(38, 3)[0m [36mright_center[0m=[35m(40, 13)[0m [36mstart_floor_h[0m=[35m0[0m
[2m2025-05-14T23:07:35.653392[0m [[32m[1mdebug    [0m] [1mCarving tunnel                [0m [[0m[1m[34mgame.world.procgen[0m][0m [36mend_floor_h[0m=[35m0[0m [36mend_pos[0m=[35m(39, 16)[0m [36mstart_floor_h[0m=[35m0[0m [36mstart_pos[0m=[35m(39, 2)[0m
[2m2025-05-14T23:07:35.653426[0m [[32m[1mdebug    [0m] [1mCarved rectangle area         [0m [[0m[1m[34mgame.world.procgen[0m][0m [36mceil_h[0m=[35m4[0m [36mfloor_h[0m=[35m0[0m [36mrect[0m=[35mRect(x1=39, y1=2, x2=39, y2=16)[0m [36mx_slice[0m=[35m39:40[0m [36my_slice[0m=[35m2:17[0m
[2m2025-05-14T23:07:35.653459[0m [[32m[1mdebug    [0m] [1mCarved vertical tunnel segment[0m [[0m[1m[34mgame.world.procgen[0m][0m [36mceil_h[0m=[35m4[0m [36mfloor_h[0m=[35m0[0m [36mrect[0m=[35mRect(x1=39, y1=2, x2=39, y2=16)[0m
[2m2025-05-14T23:07:35.653490[0m [[32m[1mdebug    [0m] [1mCarved rectangle area         [0m [[0m[1m[34mgame.world.procgen[0m][0m [36mceil_h[0m=[35m4[0m [36mfloor_h[0m=[35m0[0m [36mrect[0m=[35mRect(x1=39, y1=16, x2=39, y2=16)[0m [36mx_slice[0m=[35m39:40[0m [36my_slice[0m=[35m16:17[0m
[2m2025-05-14T23:07:35.653519[0m [[32m[1mdebug    [0m] [1mCarved horizontal tunnel segment[0m [[0m[1m[34mgame.world.procgen[0m][0m [36mceil_h[0m=[35m4[0m [36mfloor_h[0m=[35m0[0m [36mrect[0m=[35mRect(x1=39, y1=16, x2=39, y2=16)[0m
[2m2025-05-14T23:07:35.653544[0m [[32m[1mdebug    [0m] [1mConnecting rooms for node     [0m [[0m[1m[34mgame.world.procgen[0m][0m [36mis_leaf[0m=[35mFalse[0m [36mrect[0m=[35mRect(x1=47, y1=1, x2=78, y2=48)[0m
[2m2025-05-14T23:07:35.653567[0m [[32m[1mdebug    [0m] [1mConnecting rooms for node     [0m [[0m[1m[34mgame.world.procgen[0m][0m [36mis_leaf[0m=[35mFalse[0m [36mrect[0m=[35mRect(x1=47, y1=1, x2=78, y2=27)[0m
[2m2025-05-14T23:07:35.653599[0m [[32m[1mdebug    [0m] [1mConnecting rooms for node     [0m [[0m[1m[34mgame.world.procgen[0m][0m [36mis_leaf[0m=[35mFalse[0m [36mrect[0m=[35mRect(x1=47, y1=1, x2=70, y2=27)[0m
[2m2025-05-14T23:07:35.653623[0m [[32m[1mdebug    [0m] [1mConnecting rooms for node     [0m [[0m[1m[34mgame.world.procgen[0m][0m [36mis_leaf[0m=[35mFalse[0m [36mrect[0m=[35mRect(x1=47, y1=1, x2=63, y2=27)[0m
[2m2025-05-14T23:07:35.653646[0m [[32m[1mdebug    [0m] [1mConnecting rooms for node     [0m [[0m[1m[34mgame.world.procgen[0m][0m [36mis_leaf[0m=[35mFalse[0m [36mrect[0m=[35mRect(x1=47, y1=1, x2=63, y2=20)[0m
[2m2025-05-14T23:07:35.653669[0m [[32m[1mdebug    [0m] [1mConnecting rooms for node     [0m [[0m[1m[34mgame.world.procgen[0m][0m [36mis_leaf[0m=[35mFalse[0m [36mrect[0m=[35mRect(x1=47, y1=1, x2=54, y2=20)[0m
[2m2025-05-14T23:07:35.653692[0m [[32m[1mdebug    [0m] [1mConnecting rooms for node     [0m [[0m[1m[34mgame.world.procgen[0m][0m [36mis_leaf[0m=[35mTrue[0m [36mrect[0m=[35mRect(x1=47, y1=1, x2=54, y2=7)[0m
[2m2025-05-14T23:07:35.653715[0m [[32m[1mdebug    [0m] [1mConnecting rooms for node     [0m [[0m[1m[34mgame.world.procgen[0m][0m [36mis_leaf[0m=[35mFalse[0m [36mrect[0m=[35mRect(x1=47, y1=8, x2=54, y2=20)[0m
[2m2025-05-14T23:07:35.653738[0m [[32m[1mdebug    [0m] [1mConnecting rooms for node     [0m [[0m[1m[34mgame.world.procgen[0m][0m [36mis_leaf[0m=[35mTrue[0m [36mrect[0m=[35mRect(x1=47, y1=8, x2=54, y2=13)[0m
[2m2025-05-14T23:07:35.653760[0m [[32m[1mdebug    [0m] [1mConnecting rooms for node     [0m [[0m[1m[34mgame.world.procgen[0m][0m [36mis_leaf[0m=[35mTrue[0m [36mrect[0m=[35mRect(x1=47, y1=14, x2=54, y2=20)[0m
[2m2025-05-14T23:07:35.653805[0m [[32m[1mdebug    [0m] [1mConnecting sibling rooms      [0m [[0m[1m[34mgame.world.procgen[0m][0m [36mconnect_left[0m=[35m(50, 11)[0m [36mconnect_right[0m=[35m(49, 19)[0m [36mend_floor_h[0m=[35m0[0m [36mleft_center[0m=[35m(49, 9)[0m [36mright_center[0m=[35m(50, 17)[0m [36mstart_floor_h[0m=[35m0[0m
[2m2025-05-14T23:07:35.653836[0m [[32m[1mdebug    [0m] [1mCarving tunnel                [0m [[0m[1m[34mgame.world.procgen[0m][0m [36mend_floor_h[0m=[35m0[0m [36mend_pos[0m=[35m(49, 19)[0m [36mstart_floor_h[0m=[35m0[0m [36mstart_pos[0m=[35m(50, 11)[0m
[2m2025-05-14T23:07:35.653871[0m [[32m[1mdebug    [0m] [1mCarved rectangle area         [0m [[0m[1m[34mgame.world.procgen[0m][0m [36mceil_h[0m=[35m4[0m [36mfloor_h[0m=[35m0[0m [36mrect[0m=[35mRect(x1=50, y1=11, x2=50, y2=19)[0m [36mx_slice[0m=[35m50:51[0m [36my_slice[0m=[35m11:20[0m
[2m2025-05-14T23:07:35.653902[0m [[32m[1mdebug    [0m] [1mCarved vertical tunnel segment[0m [[0m[1m[34mgame.world.procgen[0m][0m [36mceil_h[0m=[35m4[0m [36mfloor_h[0m=[35m0[0m [36mrect[0m=[35mRect(x1=50, y1=11, x2=50, y2=19)[0m
[2m2025-05-14T23:07:35.653936[0m [[32m[1mdebug    [0m] [1mCarved rectangle area         [0m [[0m[1m[34mgame.world.procgen[0m][0m [36mceil_h[0m=[35m4[0m [36mfloor_h[0m=[35m0[0m [36mrect[0m=[35mRect(x1=49, y1=19, x2=49, y2=19)[0m [36mx_slice[0m=[35m49:50[0m [36my_slice[0m=[35m19:20[0m
[2m2025-05-14T23:07:35.653966[0m [[32m[1mdebug    [0m] [1mCarved horizontal tunnel segment[0m [[0m[1m[34mgame.world.procgen[0m][0m [36mceil_h[0m=[35m4[0m [36mfloor_h[0m=[35m0[0m [36mrect[0m=[35mRect(x1=49, y1=19, x2=49, y2=19)[0m
[2m2025-05-14T23:07:35.654013[0m [[32m[1mdebug    [0m] [1mConnecting sibling rooms      [0m [[0m[1m[34mgame.world.procgen[0m][0m [36mconnect_left[0m=[35m(54, 4)[0m [36mconnect_right[0m=[35m(48, 10)[0m [36mend_floor_h[0m=[35m0[0m [36mleft_center[0m=[35m(51, 5)[0m [36mright_center[0m=[35m(49, 9)[0m [36mstart_floor_h[0m=[35m0[0m
[2m2025-05-14T23:07:35.654044[0m [[32m[1mdebug    [0m] [1mCarving tunnel                [0m [[0m[1m[34mgame.world.procgen[0m][0m [36mend_floor_h[0m=[35m0[0m [36mend_pos[0m=[35m(48, 10)[0m [36mstart_floor_h[0m=[35m0[0m [36mstart_pos[0m=[35m(54, 4)[0m
[2m2025-05-14T23:07:35.654078[0m [[32m[1mdebug    [0m] [1mCarved rectangle area         [0m [[0m[1m[34mgame.world.procgen[0m][0m [36mceil_h[0m=[35m4[0m [36mfloor_h[0m=[35m0[0m [36mrect[0m=[35mRect(x1=54, y1=4, x2=54, y2=10)[0m [36mx_slice[0m=[35m54:55[0m [36my_slice[0m=[35m4:11[0m
[2m2025-05-14T23:07:35.654108[0m [[32m[1mdebug    [0m] [1mCarved vertical tunnel segment[0m [[0m[1m[34mgame.world.procgen[0m][0m [36mceil_h[0m=[35m4[0m [36mfloor_h[0m=[35m0[0m [36mrect[0m=[35mRect(x1=54, y1=4, x2=54, y2=10)[0m
[2m2025-05-14T23:07:35.654137[0m [[32m[1mdebug    [0m] [1mCarved rectangle area         [0m [[0m[1m[34mgame.world.procgen[0m][0m [36mceil_h[0m=[35m4[0m [36mfloor_h[0m=[35m0[0m [36mrect[0m=[35mRect(x1=48, y1=10, x2=53, y2=10)[0m [36mx_slice[0m=[35m48:54[0m [36my_slice[0m=[35m10:11[0m
[2m2025-05-14T23:07:35.654166[0m [[32m[1mdebug    [0m] [1mCarved horizontal tunnel segment[0m [[0m[1m[34mgame.world.procgen[0m][0m [36mceil_h[0m=[35m4[0m [36mfloor_h[0m=[35m0[0m [36mrect[0m=[35mRect(x1=48, y1=10, x2=53, y2=10)[0m
[2m2025-05-14T23:07:35.654191[0m [[32m[1mdebug    [0m] [1mConnecting rooms for node     [0m [[0m[1m[34mgame.world.procgen[0m][0m [36mis_leaf[0m=[35mFalse[0m [36mrect[0m=[35mRect(x1=55, y1=1, x2=63, y2=20)[0m
[2m2025-05-14T23:07:35.654214[0m [[32m[1mdebug    [0m] [1mConnecting rooms for node     [0m [[0m[1m[34mgame.world.procgen[0m][0m [36mis_leaf[0m=[35mTrue[0m [36mrect[0m=[35mRect(x1=55, y1=1, x2=63, y2=7)[0m
[2m2025-05-14T23:07:35.654237[0m [[32m[1mdebug    [0m] [1mConnecting rooms for node     [0m [[0m[1m[34mgame.world.procgen[0m][0m [36mis_leaf[0m=[35mFalse[0m [36mrect[0m=[35mRect(x1=55, y1=8, x2=63, y2=20)[0m
[2m2025-05-14T23:07:35.654260[0m [[32m[1mdebug    [0m] [1mConnecting rooms for node     [0m [[0m[1m[34mgame.world.procgen[0m][0m [36mis_leaf[0m=[35mTrue[0m [36mrect[0m=[35mRect(x1=55, y1=8, x2=63, y2=13)[0m
[2m2025-05-14T23:07:35.654282[0m [[32m[1mdebug    [0m] [1mConnecting rooms for node     [0m [[0m[1m[34mgame.world.procgen[0m][0m [36mis_leaf[0m=[35mTrue[0m [36mrect[0m=[35mRect(x1=55, y1=14, x2=63, y2=20)[0m
[2m2025-05-14T23:07:35.654332[0m [[32m[1mdebug    [0m] [1mConnecting sibling rooms      [0m [[0m[1m[34mgame.world.procgen[0m][0m [36mconnect_left[0m=[35m(60, 12)[0m [36mconnect_right[0m=[35m(56, 16)[0m [36mend_floor_h[0m=[35m0[0m [36mleft_center[0m=[35m(59, 10)[0m [36mright_center[0m=[35m(58, 15)[0m [36mstart_floor_h[0m=[35m0[0m
[2m2025-05-14T23:07:35.654363[0m [[32m[1mdebug    [0m] [1mCarving tunnel                [0m [[0m[1m[34mgame.world.procgen[0m][0m [36mend_floor_h[0m=[35m0[0m [36mend_pos[0m=[35m(56, 16)[0m [36mstart_floor_h[0m=[35m0[0m [36mstart_pos[0m=[35m(60, 12)[0m
[2m2025-05-14T23:07:35.654402[0m [[32m[1mdebug    [0m] [1mCarved rectangle area         [0m [[0m[1m[34mgame.world.procgen[0m][0m [36mceil_h[0m=[35m4[0m [36mfloor_h[0m=[35m0[0m [36mrect[0m=[35mRect(x1=60, y1=12, x2=60, y2=16)[0m [36mx_slice[0m=[35m60:61[0m [36my_slice[0m=[35m12:17[0m
[2m2025-05-14T23:07:35.654433[0m [[32m[1mdebug    [0m] [1mCarved vertical tunnel segment[0m [[0m[1m[34mgame.world.procgen[0m][0m [36mceil_h[0m=[35m4[0m [36mfloor_h[0m=[35m0[0m [36mrect[0m=[35mRect(x1=60, y1=12, x2=60, y2=16)[0m
[2m2025-05-14T23:07:35.654463[0m [[32m[1mdebug    [0m] [1mCarved rectangle area         [0m [[0m[1m[34mgame.world.procgen[0m][0m [36mceil_h[0m=[35m4[0m [36mfloor_h[0m=[35m0[0m [36mrect[0m=[35mRect(x1=56, y1=16, x2=59, y2=16)[0m [36mx_slice[0m=[35m56:60[0m [36my_slice[0m=[35m16:17[0m
[2m2025-05-14T23:07:35.654491[0m [[32m[1mdebug    [0m] [1mCarved horizontal tunnel segment[0m [[0m[1m[34mgame.world.procgen[0m][0m [36mceil_h[0m=[35m4[0m [36mfloor_h[0m=[35m0[0m [36mrect[0m=[35mRect(x1=56, y1=16, x2=59, y2=16)[0m
[2m2025-05-14T23:07:35.654538[0m [[32m[1mdebug    [0m] [1mConnecting sibling rooms      [0m [[0m[1m[34mgame.world.procgen[0m][0m [36mconnect_left[0m=[35m(58, 4)[0m [36mconnect_right[0m=[35m(57, 11)[0m [36mend_floor_h[0m=[35m0[0m [36mleft_center[0m=[35m(58, 3)[0m [36mright_center[0m=[35m(59, 10)[0m [36mstart_floor_h[0m=[35m0[0m
[2m2025-05-14T23:07:35.654573[0m [[32m[1mdebug    [0m] [1mCarving tunnel                [0m [[0m[1m[34mgame.world.procgen[0m][0m [36mend_floor_h[0m=[35m0[0m [36mend_pos[0m=[35m(57, 11)[0m [36mstart_floor_h[0m=[35m0[0m [36mstart_pos[0m=[35m(58, 4)[0m
[2m2025-05-14T23:07:35.654612[0m [[32m[1mdebug    [0m] [1mCarved rectangle area         [0m [[0m[1m[34mgame.world.procgen[0m][0m [36mceil_h[0m=[35m4[0m [36mfloor_h[0m=[35m0[0m [36mrect[0m=[35mRect(x1=58, y1=4, x2=58, y2=11)[0m [36mx_slice[0m=[35m58:59[0m [36my_slice[0m=[35m4:12[0m
[2m2025-05-14T23:07:35.654643[0m [[32m[1mdebug    [0m] [1mCarved vertical tunnel segment[0m [[0m[1m[34mgame.world.procgen[0m][0m [36mceil_h[0m=[35m4[0m [36mfloor_h[0m=[35m0[0m [36mrect[0m=[35mRect(x1=58, y1=4, x2=58, y2=11)[0m
[2m2025-05-14T23:07:35.654673[0m [[32m[1mdebug    [0m] [1mCarved rectangle area         [0m [[0m[1m[34mgame.world.procgen[0m][0m [36mceil_h[0m=[35m4[0m [36mfloor_h[0m=[35m0[0m [36mrect[0m=[35mRect(x1=57, y1=11, x2=57, y2=11)[0m [36mx_slice[0m=[35m57:58[0m [36my_slice[0m=[35m11:12[0m
[2m2025-05-14T23:07:35.654702[0m [[32m[1mdebug    [0m] [1mCarved horizontal tunnel segment[0m [[0m[1m[34mgame.world.procgen[0m][0m [36mceil_h[0m=[35m4[0m [36mfloor_h[0m=[35m0[0m [36mrect[0m=[35mRect(x1=57, y1=11, x2=57, y2=11)[0m
[2m2025-05-14T23:07:35.654750[0m [[32m[1mdebug    [0m] [1mConnecting sibling rooms      [0m [[0m[1m[34mgame.world.procgen[0m][0m [36mconnect_left[0m=[35m(53, 5)[0m [36mconnect_right[0m=[35m(57, 1)[0m [36mend_floor_h[0m=[35m0[0m [36mleft_center[0m=[35m(51, 5)[0m [36mright_center[0m=[35m(58, 3)[0m [36mstart_floor_h[0m=[35m0[0m
[2m2025-05-14T23:07:35.654780[0m [[32m[1mdebug    [0m] [1mCarving tunnel                [0m [[0m[1m[34mgame.world.procgen[0m][0m [36mend_floor_h[0m=[35m0[0m [36mend_pos[0m=[35m(57, 1)[0m [36mstart_floor_h[0m=[35m0[0m [36mstart_pos[0m=[35m(53, 5)[0m
[2m2025-05-14T23:07:35.654815[0m [[32m[1mdebug    [0m] [1mCarved rectangle area         [0m [[0m[1m[34mgame.world.procgen[0m][0m [36mceil_h[0m=[35m4[0m [36mfloor_h[0m=[35m0[0m [36mrect[0m=[35mRect(x1=53, y1=1, x2=53, y2=5)[0m [36mx_slice[0m=[35m53:54[0m [36my_slice[0m=[35m1:6[0m
[2m2025-05-14T23:07:35.654848[0m [[32m[1mdebug    [0m] [1mCarved vertical tunnel segment[0m [[0m[1m[34mgame.world.procgen[0m][0m [36mceil_h[0m=[35m4[0m [36mfloor_h[0m=[35m0[0m [36mrect[0m=[35mRect(x1=53, y1=1, x2=53, y2=5)[0m
[2m2025-05-14T23:07:35.654880[0m [[32m[1mdebug    [0m] [1mCarved rectangle area         [0m [[0m[1m[34mgame.world.procgen[0m][0m [36mceil_h[0m=[35m4[0m [36mfloor_h[0m=[35m0[0m [36mrect[0m=[35mRect(x1=54, y1=1, x2=57, y2=1)[0m [36mx_slice[0m=[35m54:58[0m [36my_slice[0m=[35m1:2[0m
[2m2025-05-14T23:07:35.654908[0m [[32m[1mdebug    [0m] [1mCarved horizontal tunnel segment[0m [[0m[1m[34mgame.world.procgen[0m][0m [36mceil_h[0m=[35m4[0m [36mfloor_h[0m=[35m0[0m [36mrect[0m=[35mRect(x1=54, y1=1, x2=57, y2=1)[0m
[2m2025-05-14T23:07:35.654933[0m [[32m[1mdebug    [0m] [1mConnecting rooms for node     [0m [[0m[1m[34mgame.world.procgen[0m][0m [36mis_leaf[0m=[35mFalse[0m [36mrect[0m=[35mRect(x1=47, y1=21, x2=63, y2=27)[0m
[2m2025-05-14T23:07:35.654957[0m [[32m[1mdebug    [0m] [1mConnecting rooms for node     [0m [[0m[1m[34mgame.world.procgen[0m][0m [36mis_leaf[0m=[35mTrue[0m [36mrect[0m=[35mRect(x1=47, y1=21, x2=55, y2=27)[0m
[2m2025-05-14T23:07:35.654980[0m [[32m[1mdebug    [0m] [1mConnecting rooms for node     [0m [[0m[1m[34mgame.world.procgen[0m][0m [36mis_leaf[0m=[35mTrue[0m [36mrect[0m=[35mRect(x1=56, y1=21, x2=63, y2=27)[0m
[2m2025-05-14T23:07:35.655025[0m [[32m[1mdebug    [0m] [1mConnecting sibling rooms      [0m [[0m[1m[34mgame.world.procgen[0m][0m [36mconnect_left[0m=[35m(50, 24)[0m [36mconnect_right[0m=[35m(58, 24)[0m [36mend_floor_h[0m=[35m0[0m [36mleft_center[0m=[35m(51, 24)[0m [36mright_center[0m=[35m(60, 23)[0m [36mstart_floor_h[0m=[35m0[0m
[2m2025-05-14T23:07:35.655056[0m [[32m[1mdebug    [0m] [1mCarving tunnel                [0m [[0m[1m[34mgame.world.procgen[0m][0m [36mend_floor_h[0m=[35m0[0m [36mend_pos[0m=[35m(58, 24)[0m [36mstart_floor_h[0m=[35m0[0m [36mstart_pos[0m=[35m(50, 24)[0m
[2m2025-05-14T23:07:35.655091[0m [[32m[1mdebug    [0m] [1mCarved rectangle area         [0m [[0m[1m[34mgame.world.procgen[0m][0m [36mceil_h[0m=[35m4[0m [36mfloor_h[0m=[35m0[0m [36mrect[0m=[35mRect(x1=50, y1=24, x2=50, y2=24)[0m [36mx_slice[0m=[35m50:51[0m [36my_slice[0m=[35m24:25[0m
[2m2025-05-14T23:07:35.655121[0m [[32m[1mdebug    [0m] [1mCarved vertical tunnel segment[0m [[0m[1m[34mgame.world.procgen[0m][0m [36mceil_h[0m=[35m4[0m [36mfloor_h[0m=[35m0[0m [36mrect[0m=[35mRect(x1=50, y1=24, x2=50, y2=24)[0m
[2m2025-05-14T23:07:35.655151[0m [[32m[1mdebug    [0m] [1mCarved rectangle area         [0m [[0m[1m[34mgame.world.procgen[0m][0m [36mceil_h[0m=[35m4[0m [36mfloor_h[0m=[35m0[0m [36mrect[0m=[35mRect(x1=51, y1=24, x2=58, y2=24)[0m [36mx_slice[0m=[35m51:59[0m [36my_slice[0m=[35m24:25[0m
[2m2025-05-14T23:07:35.655179[0m [[32m[1mdebug    [0m] [1mCarved horizontal tunnel segment[0m [[0m[1m[34mgame.world.procgen[0m][0m [36mceil_h[0m=[35m4[0m [36mfloor_h[0m=[35m0[0m [36mrect[0m=[35mRect(x1=51, y1=24, x2=58, y2=24)[0m
[2m2025-05-14T23:07:35.655236[0m [[32m[1mdebug    [0m] [1mConnecting sibling rooms      [0m [[0m[1m[34mgame.world.procgen[0m][0m [36mconnect_left[0m=[35m(50, 5)[0m [36mconnect_right[0m=[35m(52, 24)[0m [36mend_floor_h[0m=[35m0[0m [36mleft_center[0m=[35m(51, 5)[0m [36mright_center[0m=[35m(51, 24)[0m [36mstart_floor_h[0m=[35m0[0m
[2m2025-05-14T23:07:35.655267[0m [[32m[1mdebug    [0m] [1mCarving tunnel                [0m [[0m[1m[34mgame.world.procgen[0m][0m [36mend_floor_h[0m=[35m0[0m [36mend_pos[0m=[35m(52, 24)[0m [36mstart_floor_h[0m=[35m0[0m [36mstart_pos[0m=[35m(50, 5)[0m
[2m2025-05-14T23:07:35.655302[0m [[32m[1mdebug    [0m] [1mCarved rectangle area         [0m [[0m[1m[34mgame.world.procgen[0m][0m [36mceil_h[0m=[35m4[0m [36mfloor_h[0m=[35m0[0m [36mrect[0m=[35mRect(x1=50, y1=5, x2=50, y2=24)[0m [36mx_slice[0m=[35m50:51[0m [36my_slice[0m=[35m5:25[0m
[2m2025-05-14T23:07:35.655335[0m [[32m[1mdebug    [0m] [1mCarved vertical tunnel segment[0m [[0m[1m[34mgame.world.procgen[0m][0m [36mceil_h[0m=[35m4[0m [36mfloor_h[0m=[35m0[0m [36mrect[0m=[35mRect(x1=50, y1=5, x2=50, y2=24)[0m
[2m2025-05-14T23:07:35.655366[0m [[32m[1mdebug    [0m] [1mCarved rectangle area         [0m [[0m[1m[34mgame.world.procgen[0m][0m [36mceil_h[0m=[35m4[0m [36mfloor_h[0m=[35m0[0m [36mrect[0m=[35mRect(x1=51, y1=24, x2=52, y2=24)[0m [36mx_slice[0m=[35m51:53[0m [36my_slice[0m=[35m24:25[0m
[2m2025-05-14T23:07:35.655395[0m [[32m[1mdebug    [0m] [1mCarved horizontal tunnel segment[0m [[0m[1m[34mgame.world.procgen[0m][0m [36mceil_h[0m=[35m4[0m [36mfloor_h[0m=[35m0[0m [36mrect[0m=[35mRect(x1=51, y1=24, x2=52, y2=24)[0m
[2m2025-05-14T23:07:35.655421[0m [[32m[1mdebug    [0m] [1mConnecting rooms for node     [0m [[0m[1m[34mgame.world.procgen[0m][0m [36mis_leaf[0m=[35mFalse[0m [36mrect[0m=[35mRect(x1=64, y1=1, x2=70, y2=27)[0m
[2m2025-05-14T23:07:35.655445[0m [[32m[1mdebug    [0m] [1mConnecting rooms for node     [0m [[0m[1m[34mgame.world.procgen[0m][0m [36mis_leaf[0m=[35mFalse[0m [36mrect[0m=[35mRect(x1=64, y1=1, x2=70, y2=13)[0m
[2m2025-05-14T23:07:35.655468[0m [[32m[1mdebug    [0m] [1mConnecting rooms for node     [0m [[0m[1m[34mgame.world.procgen[0m][0m [36mis_leaf[0m=[35mTrue[0m [36mrect[0m=[35mRect(x1=64, y1=1, x2=70, y2=6)[0m
[2m2025-05-14T23:07:35.655490[0m [[32m[1mdebug    [0m] [1mConnecting rooms for node     [0m [[0m[1m[34mgame.world.procgen[0m][0m [36mis_leaf[0m=[35mTrue[0m [36mrect[0m=[35mRect(x1=64, y1=7, x2=70, y2=13)[0m
[2m2025-05-14T23:07:35.655533[0m [[32m[1mdebug    [0m] [1mConnecting sibling rooms      [0m [[0m[1m[34mgame.world.procgen[0m][0m [36mconnect_left[0m=[35m(67, 4)[0m [36mconnect_right[0m=[35m(67, 9)[0m [36mend_floor_h[0m=[35m0[0m [36mleft_center[0m=[35m(67, 2)[0m [36mright_center[0m=[35m(66, 10)[0m [36mstart_floor_h[0m=[35m0[0m
[2m2025-05-14T23:07:35.655563[0m [[32m[1mdebug    [0m] [1mCarving tunnel                [0m [[0m[1m[34mgame.world.procgen[0m][0m [36mend_floor_h[0m=[35m0[0m [36mend_pos[0m=[35m(67, 9)[0m [36mstart_floor_h[0m=[35m0[0m [36mstart_pos[0m=[35m(67, 4)[0m
[2m2025-05-14T23:07:35.655609[0m [[32m[1mdebug    [0m] [1mCarved rectangle area         [0m [[0m[1m[34mgame.world.procgen[0m][0m [36mceil_h[0m=[35m4[0m [36mfloor_h[0m=[35m0[0m [36mrect[0m=[35mRect(x1=67, y1=4, x2=67, y2=9)[0m [36mx_slice[0m=[35m67:68[0m [36my_slice[0m=[35m4:10[0m
[2m2025-05-14T23:07:35.655640[0m [[32m[1mdebug    [0m] [1mCarved vertical tunnel segment[0m [[0m[1m[34mgame.world.procgen[0m][0m [36mceil_h[0m=[35m4[0m [36mfloor_h[0m=[35m0[0m [36mrect[0m=[35mRect(x1=67, y1=4, x2=67, y2=9)[0m
[2m2025-05-14T23:07:35.655671[0m [[32m[1mdebug    [0m] [1mCarved rectangle area         [0m [[0m[1m[34mgame.world.procgen[0m][0m [36mceil_h[0m=[35m4[0m [36mfloor_h[0m=[35m0[0m [36mrect[0m=[35mRect(x1=67, y1=9, x2=67, y2=9)[0m [36mx_slice[0m=[35m67:68[0m [36my_slice[0m=[35m9:10[0m
[2m2025-05-14T23:07:35.655699[0m [[32m[1mdebug    [0m] [1mCarved horizontal tunnel segment[0m [[0m[1m[34mgame.world.procgen[0m][0m [36mceil_h[0m=[35m4[0m [36mfloor_h[0m=[35m0[0m [36mrect[0m=[35mRect(x1=67, y1=9, x2=67, y2=9)[0m
[2m2025-05-14T23:07:35.655724[0m [[32m[1mdebug    [0m] [1mConnecting rooms for node     [0m [[0m[1m[34mgame.world.procgen[0m][0m [36mis_leaf[0m=[35mFalse[0m [36mrect[0m=[35mRect(x1=64, y1=14, x2=70, y2=27)[0m
[2m2025-05-14T23:07:35.655747[0m [[32m[1mdebug    [0m] [1mConnecting rooms for node     [0m [[0m[1m[34mgame.world.procgen[0m][0m [36mis_leaf[0m=[35mTrue[0m [36mrect[0m=[35mRect(x1=64, y1=14, x2=70, y2=20)[0m
[2m2025-05-14T23:07:35.655773[0m [[32m[1mdebug    [0m] [1mConnecting rooms for node     [0m [[0m[1m[34mgame.world.procgen[0m][0m [36mis_leaf[0m=[35mTrue[0m [36mrect[0m=[35mRect(x1=64, y1=21, x2=70, y2=27)[0m
[2m2025-05-14T23:07:35.655818[0m [[32m[1mdebug    [0m] [1mConnecting sibling rooms      [0m [[0m[1m[34mgame.world.procgen[0m][0m [36mconnect_left[0m=[35m(67, 18)[0m [36mconnect_right[0m=[35m(67, 23)[0m [36mend_floor_h[0m=[35m0[0m [36mleft_center[0m=[35m(66, 17)[0m [36mright_center[0m=[35m(67, 23)[0m [36mstart_floor_h[0m=[35m0[0m
[2m2025-05-14T23:07:35.655849[0m [[32m[1mdebug    [0m] [1mCarving tunnel                [0m [[0m[1m[34mgame.world.procgen[0m][0m [36mend_floor_h[0m=[35m0[0m [36mend_pos[0m=[35m(67, 23)[0m [36mstart_floor_h[0m=[35m0[0m [36mstart_pos[0m=[35m(67, 18)[0m
[2m2025-05-14T23:07:35.655882[0m [[32m[1mdebug    [0m] [1mCarved rectangle area         [0m [[0m[1m[34mgame.world.procgen[0m][0m [36mceil_h[0m=[35m4[0m [36mfloor_h[0m=[35m0[0m [36mrect[0m=[35mRect(x1=67, y1=18, x2=67, y2=23)[0m [36mx_slice[0m=[35m67:68[0m [36my_slice[0m=[35m18:24[0m
[2m2025-05-14T23:07:35.655913[0m [[32m[1mdebug    [0m] [1mCarved vertical tunnel segment[0m [[0m[1m[34mgame.world.procgen[0m][0m [36mceil_h[0m=[35m4[0m [36mfloor_h[0m=[35m0[0m [36mrect[0m=[35mRect(x1=67, y1=18, x2=67, y2=23)[0m
[2m2025-05-14T23:07:35.655942[0m [[32m[1mdebug    [0m] [1mCarved rectangle area         [0m [[0m[1m[34mgame.world.procgen[0m][0m [36mceil_h[0m=[35m4[0m [36mfloor_h[0m=[35m0[0m [36mrect[0m=[35mRect(x1=67, y1=23, x2=67, y2=23)[0m [36mx_slice[0m=[35m67:68[0m [36my_slice[0m=[35m23:24[0m
[2m2025-05-14T23:07:35.655971[0m [[32m[1mdebug    [0m] [1mCarved horizontal tunnel segment[0m [[0m[1m[34mgame.world.procgen[0m][0m [36mceil_h[0m=[35m4[0m [36mfloor_h[0m=[35m0[0m [36mrect[0m=[35mRect(x1=67, y1=23, x2=67, y2=23)[0m
[2m2025-05-14T23:07:35.656035[0m [[32m[1mdebug    [0m] [1mConnecting sibling rooms      [0m [[0m[1m[34mgame.world.procgen[0m][0m [36mconnect_left[0m=[35m(68, 4)[0m [36mconnect_right[0m=[35m(67, 19)[0m [36mend_floor_h[0m=[35m0[0m [36mleft_center[0m=[35m(67, 2)[0m [36mright_center[0m=[35m(66, 17)[0m [36mstart_floor_h[0m=[35m0[0m
[2m2025-05-14T23:07:35.656065[0m [[32m[1mdebug    [0m] [1mCarving tunnel                [0m [[0m[1m[34mgame.world.procgen[0m][0m [36mend_floor_h[0m=[35m0[0m [36mend_pos[0m=[35m(67, 19)[0m [36mstart_floor_h[0m=[35m0[0m [36mstart_pos[0m=[35m(68, 4)[0m
[2m2025-05-14T23:07:35.656100[0m [[32m[1mdebug    [0m] [1mCarved rectangle area         [0m [[0m[1m[34mgame.world.procgen[0m][0m [36mceil_h[0m=[35m4[0m [36mfloor_h[0m=[35m0[0m [36mrect[0m=[35mRect(x1=68, y1=4, x2=68, y2=19)[0m [36mx_slice[0m=[35m68:69[0m [36my_slice[0m=[35m4:20[0m
[2m2025-05-14T23:07:35.656129[0m [[32m[1mdebug    [0m] [1mCarved vertical tunnel segment[0m [[0m[1m[34mgame.world.procgen[0m][0m [36mceil_h[0m=[35m4[0m [36mfloor_h[0m=[35m0[0m [36mrect[0m=[35mRect(x1=68, y1=4, x2=68, y2=19)[0m
[2m2025-05-14T23:07:35.656159[0m [[32m[1mdebug    [0m] [1mCarved rectangle area         [0m [[0m[1m[34mgame.world.procgen[0m][0m [36mceil_h[0m=[35m4[0m [36mfloor_h[0m=[35m0[0m [36mrect[0m=[35mRect(x1=67, y1=19, x2=67, y2=19)[0m [36mx_slice[0m=[35m67:68[0m [36my_slice[0m=[35m19:20[0m
[2m2025-05-14T23:07:35.656188[0m [[32m[1mdebug    [0m] [1mCarved horizontal tunnel segment[0m [[0m[1m[34mgame.world.procgen[0m][0m [36mceil_h[0m=[35m4[0m [36mfloor_h[0m=[35m0[0m [36mrect[0m=[35mRect(x1=67, y1=19, x2=67, y2=19)[0m
[2m2025-05-14T23:07:35.656236[0m [[32m[1mdebug    [0m] [1mConnecting sibling rooms      [0m [[0m[1m[34mgame.world.procgen[0m][0m [36mconnect_left[0m=[35m(51, 6)[0m [36mconnect_right[0m=[35m(68, 2)[0m [36mend_floor_h[0m=[35m0[0m [36mleft_center[0m=[35m(51, 5)[0m [36mright_center[0m=[35m(67, 2)[0m [36mstart_floor_h[0m=[35m0[0m
[2m2025-05-14T23:07:35.656270[0m [[32m[1mdebug    [0m] [1mCarving tunnel                [0m [[0m[1m[34mgame.world.procgen[0m][0m [36mend_floor_h[0m=[35m0[0m [36mend_pos[0m=[35m(68, 2)[0m [36mstart_floor_h[0m=[35m0[0m [36mstart_pos[0m=[35m(51, 6)[0m
[2m2025-05-14T23:07:35.656306[0m [[32m[1mdebug    [0m] [1mCarved rectangle area         [0m [[0m[1m[34mgame.world.procgen[0m][0m [36mceil_h[0m=[35m4[0m [36mfloor_h[0m=[35m0[0m [36mrect[0m=[35mRect(x1=51, y1=2, x2=51, y2=6)[0m [36mx_slice[0m=[35m51:52[0m [36my_slice[0m=[35m2:7[0m
[2m2025-05-14T23:07:35.656336[0m [[32m[1mdebug    [0m] [1mCarved vertical tunnel segment[0m [[0m[1m[34mgame.world.procgen[0m][0m [36mceil_h[0m=[35m4[0m [36mfloor_h[0m=[35m0[0m [36mrect[0m=[35mRect(x1=51, y1=2, x2=51, y2=6)[0m
[2m2025-05-14T23:07:35.656366[0m [[32m[1mdebug    [0m] [1mCarved rectangle area         [0m [[0m[1m[34mgame.world.procgen[0m][0m [36mceil_h[0m=[35m4[0m [36mfloor_h[0m=[35m0[0m [36mrect[0m=[35mRect(x1=52, y1=2, x2=68, y2=2)[0m [36mx_slice[0m=[35m52:69[0m [36my_slice[0m=[35m2:3[0m
[2m2025-05-14T23:07:35.656395[0m [[32m[1mdebug    [0m] [1mCarved horizontal tunnel segment[0m [[0m[1m[34mgame.world.procgen[0m][0m [36mceil_h[0m=[35m4[0m [36mfloor_h[0m=[35m0[0m [36mrect[0m=[35mRect(x1=52, y1=2, x2=68, y2=2)[0m
[2m2025-05-14T23:07:35.656421[0m [[32m[1mdebug    [0m] [1mConnecting rooms for node     [0m [[0m[1m[34mgame.world.procgen[0m][0m [36mis_leaf[0m=[35mFalse[0m [36mrect[0m=[35mRect(x1=71, y1=1, x2=78, y2=27)[0m
[2m2025-05-14T23:07:35.656444[0m [[32m[1mdebug    [0m] [1mConnecting rooms for node     [0m [[0m[1m[34mgame.world.procgen[0m][0m [36mis_leaf[0m=[35mTrue[0m [36mrect[0m=[35mRect(x1=71, y1=1, x2=78, y2=9)[0m
[2m2025-05-14T23:07:35.656467[0m [[32m[1mdebug    [0m] [1mConnecting rooms for node     [0m [[0m[1m[34mgame.world.procgen[0m][0m [36mis_leaf[0m=[35mFalse[0m [36mrect[0m=[35mRect(x1=71, y1=10, x2=78, y2=27)[0m
[2m2025-05-14T23:07:35.656490[0m [[32m[1mdebug    [0m] [1mConnecting rooms for node     [0m [[0m[1m[34mgame.world.procgen[0m][0m [36mis_leaf[0m=[35mTrue[0m [36mrect[0m=[35mRect(x1=71, y1=10, x2=78, y2=19)[0m
[2m2025-05-14T23:07:35.656513[0m [[32m[1mdebug    [0m] [1mConnecting rooms for node     [0m [[0m[1m[34mgame.world.procgen[0m][0m [36mis_leaf[0m=[35mTrue[0m [36mrect[0m=[35mRect(x1=71, y1=20, x2=78, y2=27)[0m
[2m2025-05-14T23:07:35.656564[0m [[32m[1mdebug    [0m] [1mConnecting sibling rooms      [0m [[0m[1m[34mgame.world.procgen[0m][0m [36mconnect_left[0m=[35m(73, 17)[0m [36mconnect_right[0m=[35m(72, 24)[0m [36mend_floor_h[0m=[35m0[0m [36mleft_center[0m=[35m(74, 16)[0m [36mright_center[0m=[35m(74, 24)[0m [36mstart_floor_h[0m=[35m0[0m
[2m2025-05-14T23:07:35.656605[0m [[32m[1mdebug    [0m] [1mCarving tunnel                [0m [[0m[1m[34mgame.world.procgen[0m][0m [36mend_floor_h[0m=[35m0[0m [36mend_pos[0m=[35m(72, 24)[0m [36mstart_floor_h[0m=[35m0[0m [36mstart_pos[0m=[35m(73, 17)[0m
[2m2025-05-14T23:07:35.656643[0m [[32m[1mdebug    [0m] [1mCarved rectangle area         [0m [[0m[1m[34mgame.world.procgen[0m][0m [36mceil_h[0m=[35m4[0m [36mfloor_h[0m=[35m0[0m [36mrect[0m=[35mRect(x1=73, y1=17, x2=73, y2=24)[0m [36mx_slice[0m=[35m73:74[0m [36my_slice[0m=[35m17:25[0m
[2m2025-05-14T23:07:35.656674[0m [[32m[1mdebug    [0m] [1mCarved vertical tunnel segment[0m [[0m[1m[34mgame.world.procgen[0m][0m [36mceil_h[0m=[35m4[0m [36mfloor_h[0m=[35m0[0m [36mrect[0m=[35mRect(x1=73, y1=17, x2=73, y2=24)[0m
[2m2025-05-14T23:07:35.656704[0m [[32m[1mdebug    [0m] [1mCarved rectangle area         [0m [[0m[1m[34mgame.world.procgen[0m][0m [36mceil_h[0m=[35m4[0m [36mfloor_h[0m=[35m0[0m [36mrect[0m=[35mRect(x1=72, y1=24, x2=72, y2=24)[0m [36mx_slice[0m=[35m72:73[0m [36my_slice[0m=[35m24:25[0m
[2m2025-05-14T23:07:35.656737[0m [[32m[1mdebug    [0m] [1mCarved horizontal tunnel segment[0m [[0m[1m[34mgame.world.procgen[0m][0m [36mceil_h[0m=[35m4[0m [36mfloor_h[0m=[35m0[0m [36mrect[0m=[35mRect(x1=72, y1=24, x2=72, y2=24)[0m
[2m2025-05-14T23:07:35.656812[0m [[32m[1mdebug    [0m] [1mConnecting sibling rooms      [0m [[0m[1m[34mgame.world.procgen[0m][0m [36mconnect_left[0m=[35m(73, 2)[0m [36mconnect_right[0m=[35m(76, 17)[0m [36mend_floor_h[0m=[35m0[0m [36mleft_center[0m=[35m(73, 4)[0m [36mright_center[0m=[35m(74, 16)[0m [36mstart_floor_h[0m=[35m0[0m
[2m2025-05-14T23:07:35.656860[0m [[32m[1mdebug    [0m] [1mCarving tunnel                [0m [[0m[1m[34mgame.world.procgen[0m][0m [36mend_floor_h[0m=[35m0[0m [36mend_pos[0m=[35m(76, 17)[0m [36mstart_floor_h[0m=[35m0[0m [36mstart_pos[0m=[35m(73, 2)[0m
[2m2025-05-14T23:07:35.656903[0m [[32m[1mdebug    [0m] [1mCarved rectangle area         [0m [[0m[1m[34mgame.world.procgen[0m][0m [36mceil_h[0m=[35m4[0m [36mfloor_h[0m=[35m0[0m [36mrect[0m=[35mRect(x1=73, y1=2, x2=73, y2=17)[0m [36mx_slice[0m=[35m73:74[0m [36my_slice[0m=[35m2:18[0m
[2m2025-05-14T23:07:35.656937[0m [[32m[1mdebug    [0m] [1mCarved vertical tunnel segment[0m [[0m[1m[34mgame.world.procgen[0m][0m [36mceil_h[0m=[35m4[0m [36mfloor_h[0m=[35m0[0m [36mrect[0m=[35mRect(x1=73, y1=2, x2=73, y2=17)[0m
[2m2025-05-14T23:07:35.656970[0m [[32m[1mdebug    [0m] [1mCarved rectangle area         [0m [[0m[1m[34mgame.world.procgen[0m][0m [36mceil_h[0m=[35m4[0m [36mfloor_h[0m=[35m0[0m [36mrect[0m=[35mRect(x1=74, y1=17, x2=76, y2=17)[0m [36mx_slice[0m=[35m74:77[0m [36my_slice[0m=[35m17:18[0m
[2m2025-05-14T23:07:35.657000[0m [[32m[1mdebug    [0m] [1mCarved horizontal tunnel segment[0m [[0m[1m[34mgame.world.procgen[0m][0m [36mceil_h[0m=[35m4[0m [36mfloor_h[0m=[35m0[0m [36mrect[0m=[35mRect(x1=74, y1=17, x2=76, y2=17)[0m
[2m2025-05-14T23:07:35.657053[0m [[32m[1mdebug    [0m] [1mConnecting sibling rooms      [0m [[0m[1m[34mgame.world.procgen[0m][0m [36mconnect_left[0m=[35m(49, 6)[0m [36mconnect_right[0m=[35m(75, 6)[0m [36mend_floor_h[0m=[35m0[0m [36mleft_center[0m=[35m(51, 5)[0m [36mright_center[0m=[35m(73, 4)[0m [36mstart_floor_h[0m=[35m0[0m
[2m2025-05-14T23:07:35.657085[0m [[32m[1mdebug    [0m] [1mCarving tunnel                [0m [[0m[1m[34mgame.world.procgen[0m][0m [36mend_floor_h[0m=[35m0[0m [36mend_pos[0m=[35m(75, 6)[0m [36mstart_floor_h[0m=[35m0[0m [36mstart_pos[0m=[35m(49, 6)[0m
[2m2025-05-14T23:07:35.657121[0m [[32m[1mdebug    [0m] [1mCarved rectangle area         [0m [[0m[1m[34mgame.world.procgen[0m][0m [36mceil_h[0m=[35m4[0m [36mfloor_h[0m=[35m0[0m [36mrect[0m=[35mRect(x1=49, y1=6, x2=49, y2=6)[0m [36mx_slice[0m=[35m49:50[0m [36my_slice[0m=[35m6:7[0m
[2m2025-05-14T23:07:35.657153[0m [[32m[1mdebug    [0m] [1mCarved vertical tunnel segment[0m [[0m[1m[34mgame.world.procgen[0m][0m [36mceil_h[0m=[35m4[0m [36mfloor_h[0m=[35m0[0m [36mrect[0m=[35mRect(x1=49, y1=6, x2=49, y2=6)[0m
[2m2025-05-14T23:07:35.657183[0m [[32m[1mdebug    [0m] [1mCarved rectangle area         [0m [[0m[1m[34mgame.world.procgen[0m][0m [36mceil_h[0m=[35m4[0m [36mfloor_h[0m=[35m0[0m [36mrect[0m=[35mRect(x1=50, y1=6, x2=75, y2=6)[0m [36mx_slice[0m=[35m50:76[0m [36my_slice[0m=[35m6:7[0m
[2m2025-05-14T23:07:35.657213[0m [[32m[1mdebug    [0m] [1mCarved horizontal tunnel segment[0m [[0m[1m[34mgame.world.procgen[0m][0m [36mceil_h[0m=[35m4[0m [36mfloor_h[0m=[35m0[0m [36mrect[0m=[35mRect(x1=50, y1=6, x2=75, y2=6)[0m
[2m2025-05-14T23:07:35.657239[0m [[32m[1mdebug    [0m] [1mConnecting rooms for node     [0m [[0m[1m[34mgame.world.procgen[0m][0m [36mis_leaf[0m=[35mFalse[0m [36mrect[0m=[35mRect(x1=47, y1=28, x2=78, y2=48)[0m
[2m2025-05-14T23:07:35.657268[0m [[32m[1mdebug    [0m] [1mConnecting rooms for node     [0m [[0m[1m[34mgame.world.procgen[0m][0m [36mis_leaf[0m=[35mFalse[0m [36mrect[0m=[35mRect(x1=47, y1=28, x2=67, y2=48)[0m
[2m2025-05-14T23:07:35.657293[0m [[32m[1mdebug    [0m] [1mConnecting rooms for node     [0m [[0m[1m[34mgame.world.procgen[0m][0m [36mis_leaf[0m=[35mFalse[0m [36mrect[0m=[35mRect(x1=47, y1=28, x2=58, y2=48)[0m
[2m2025-05-14T23:07:35.657317[0m [[32m[1mdebug    [0m] [1mConnecting rooms for node     [0m [[0m[1m[34mgame.world.procgen[0m][0m [36mis_leaf[0m=[35mTrue[0m [36mrect[0m=[35mRect(x1=47, y1=28, x2=58, y2=39)[0m
[2m2025-05-14T23:07:35.657341[0m [[32m[1mdebug    [0m] [1mConnecting rooms for node     [0m [[0m[1m[34mgame.world.procgen[0m][0m [36mis_leaf[0m=[35mTrue[0m [36mrect[0m=[35mRect(x1=47, y1=40, x2=58, y2=48)[0m
[2m2025-05-14T23:07:35.657393[0m [[32m[1mdebug    [0m] [1mConnecting sibling rooms      [0m [[0m[1m[34mgame.world.procgen[0m][0m [36mconnect_left[0m=[35m(51, 30)[0m [36mconnect_right[0m=[35m(52, 45)[0m [36mend_floor_h[0m=[35m0[0m [36mleft_center[0m=[35m(50, 29)[0m [36mright_center[0m=[35m(50, 45)[0m [36mstart_floor_h[0m=[35m0[0m
[2m2025-05-14T23:07:35.657425[0m [[32m[1mdebug    [0m] [1mCarving tunnel                [0m [[0m[1m[34mgame.world.procgen[0m][0m [36mend_floor_h[0m=[35m0[0m [36mend_pos[0m=[35m(52, 45)[0m [36mstart_floor_h[0m=[35m0[0m [36mstart_pos[0m=[35m(51, 30)[0m
[2m2025-05-14T23:07:35.657461[0m [[32m[1mdebug    [0m] [1mCarved rectangle area         [0m [[0m[1m[34mgame.world.procgen[0m][0m [36mceil_h[0m=[35m4[0m [36mfloor_h[0m=[35m0[0m [36mrect[0m=[35mRect(x1=51, y1=30, x2=51, y2=45)[0m [36mx_slice[0m=[35m51:52[0m [36my_slice[0m=[35m30:46[0m
[2m2025-05-14T23:07:35.657492[0m [[32m[1mdebug    [0m] [1mCarved vertical tunnel segment[0m [[0m[1m[34mgame.world.procgen[0m][0m [36mceil_h[0m=[35m4[0m [36mfloor_h[0m=[35m0[0m [36mrect[0m=[35mRect(x1=51, y1=30, x2=51, y2=45)[0m
[2m2025-05-14T23:07:35.657522[0m [[32m[1mdebug    [0m] [1mCarved rectangle area         [0m [[0m[1m[34mgame.world.procgen[0m][0m [36mceil_h[0m=[35m4[0m [36mfloor_h[0m=[35m0[0m [36mrect[0m=[35mRect(x1=52, y1=45, x2=52, y2=45)[0m [36mx_slice[0m=[35m52:53[0m [36my_slice[0m=[35m45:46[0m
[2m2025-05-14T23:07:35.657550[0m [[32m[1mdebug    [0m] [1mCarved horizontal tunnel segment[0m [[0m[1m[34mgame.world.procgen[0m][0m [36mceil_h[0m=[35m4[0m [36mfloor_h[0m=[35m0[0m [36mrect[0m=[35mRect(x1=52, y1=45, x2=52, y2=45)[0m
[2m2025-05-14T23:07:35.657587[0m [[32m[1mdebug    [0m] [1mConnecting rooms for node     [0m [[0m[1m[34mgame.world.procgen[0m][0m [36mis_leaf[0m=[35mFalse[0m [36mrect[0m=[35mRect(x1=59, y1=28, x2=67, y2=48)[0m
[2m2025-05-14T23:07:35.657613[0m [[32m[1mdebug    [0m] [1mConnecting rooms for node     [0m [[0m[1m[34mgame.world.procgen[0m][0m [36mis_leaf[0m=[35mTrue[0m [36mrect[0m=[35mRect(x1=59, y1=28, x2=67, y2=39)[0m
[2m2025-05-14T23:07:35.657637[0m [[32m[1mdebug    [0m] [1mConnecting rooms for node     [0m [[0m[1m[34mgame.world.procgen[0m][0m [36mis_leaf[0m=[35mTrue[0m [36mrect[0m=[35mRect(x1=59, y1=40, x2=67, y2=48)[0m
[2m2025-05-14T23:07:35.657682[0m [[32m[1mdebug    [0m] [1mConnecting sibling rooms      [0m [[0m[1m[34mgame.world.procgen[0m][0m [36mconnect_left[0m=[35m(61, 36)[0m [36mconnect_right[0m=[35m(62, 45)[0m [36mend_floor_h[0m=[35m0[0m [36mleft_center[0m=[35m(62, 35)[0m [36mright_center[0m=[35m(64, 45)[0m [36mstart_floor_h[0m=[35m0[0m
[2m2025-05-14T23:07:35.657714[0m [[32m[1mdebug    [0m] [1mCarving tunnel                [0m [[0m[1m[34mgame.world.procgen[0m][0m [36mend_floor_h[0m=[35m0[0m [36mend_pos[0m=[35m(62, 45)[0m [36mstart_floor_h[0m=[35m0[0m [36mstart_pos[0m=[35m(61, 36)[0m
[2m2025-05-14T23:07:35.657749[0m [[32m[1mdebug    [0m] [1mCarved rectangle area         [0m [[0m[1m[34mgame.world.procgen[0m][0m [36mceil_h[0m=[35m4[0m [36mfloor_h[0m=[35m0[0m [36mrect[0m=[35mRect(x1=61, y1=36, x2=61, y2=45)[0m [36mx_slice[0m=[35m61:62[0m [36my_slice[0m=[35m36:46[0m
[2m2025-05-14T23:07:35.657784[0m [[32m[1mdebug    [0m] [1mCarved vertical tunnel segment[0m [[0m[1m[34mgame.world.procgen[0m][0m [36mceil_h[0m=[35m4[0m [36mfloor_h[0m=[35m0[0m [36mrect[0m=[35mRect(x1=61, y1=36, x2=61, y2=45)[0m
[2m2025-05-14T23:07:35.657816[0m [[32m[1mdebug    [0m] [1mCarved rectangle area         [0m [[0m[1m[34mgame.world.procgen[0m][0m [36mceil_h[0m=[35m4[0m [36mfloor_h[0m=[35m0[0m [36mrect[0m=[35mRect(x1=62, y1=45, x2=62, y2=45)[0m [36mx_slice[0m=[35m62:63[0m [36my_slice[0m=[35m45:46[0m
[2m2025-05-14T23:07:35.657844[0m [[32m[1mdebug    [0m] [1mCarved horizontal tunnel segment[0m [[0m[1m[34mgame.world.procgen[0m][0m [36mceil_h[0m=[35m4[0m [36mfloor_h[0m=[35m0[0m [36mrect[0m=[35mRect(x1=62, y1=45, x2=62, y2=45)[0m
[2m2025-05-14T23:07:35.657896[0m [[32m[1mdebug    [0m] [1mConnecting sibling rooms      [0m [[0m[1m[34mgame.world.procgen[0m][0m [36mconnect_left[0m=[35m(51, 30)[0m [36mconnect_right[0m=[35m(63, 33)[0m [36mend_floor_h[0m=[35m0[0m [36mleft_center[0m=[35m(50, 29)[0m [36mright_center[0m=[35m(62, 35)[0m [36mstart_floor_h[0m=[35m0[0m
[2m2025-05-14T23:07:35.657927[0m [[32m[1mdebug    [0m] [1mCarving tunnel                [0m [[0m[1m[34mgame.world.procgen[0m][0m [36mend_floor_h[0m=[35m0[0m [36mend_pos[0m=[35m(63, 33)[0m [36mstart_floor_h[0m=[35m0[0m [36mstart_pos[0m=[35m(51, 30)[0m
[2m2025-05-14T23:07:35.657961[0m [[32m[1mdebug    [0m] [1mCarved rectangle area         [0m [[0m[1m[34mgame.world.procgen[0m][0m [36mceil_h[0m=[35m4[0m [36mfloor_h[0m=[35m0[0m [36mrect[0m=[35mRect(x1=51, y1=30, x2=51, y2=33)[0m [36mx_slice[0m=[35m51:52[0m [36my_slice[0m=[35m30:34[0m
[2m2025-05-14T23:07:35.657991[0m [[32m[1mdebug    [0m] [1mCarved vertical tunnel segment[0m [[0m[1m[34mgame.world.procgen[0m][0m [36mceil_h[0m=[35m4[0m [36mfloor_h[0m=[35m0[0m [36mrect[0m=[35mRect(x1=51, y1=30, x2=51, y2=33)[0m
[2m2025-05-14T23:07:35.658021[0m [[32m[1mdebug    [0m] [1mCarved rectangle area         [0m [[0m[1m[34mgame.world.procgen[0m][0m [36mceil_h[0m=[35m4[0m [36mfloor_h[0m=[35m0[0m [36mrect[0m=[35mRect(x1=52, y1=33, x2=63, y2=33)[0m [36mx_slice[0m=[35m52:64[0m [36my_slice[0m=[35m33:34[0m
[2m2025-05-14T23:07:35.658050[0m [[32m[1mdebug    [0m] [1mCarved horizontal tunnel segment[0m [[0m[1m[34mgame.world.procgen[0m][0m [36mceil_h[0m=[35m4[0m [36mfloor_h[0m=[35m0[0m [36mrect[0m=[35mRect(x1=52, y1=33, x2=63, y2=33)[0m
[2m2025-05-14T23:07:35.658075[0m [[32m[1mdebug    [0m] [1mConnecting rooms for node     [0m [[0m[1m[34mgame.world.procgen[0m][0m [36mis_leaf[0m=[35mFalse[0m [36mrect[0m=[35mRect(x1=68, y1=28, x2=78, y2=48)[0m
[2m2025-05-14T23:07:35.658099[0m [[32m[1mdebug    [0m] [1mConnecting rooms for node     [0m [[0m[1m[34mgame.world.procgen[0m][0m [36mis_leaf[0m=[35mTrue[0m [36mrect[0m=[35mRect(x1=68, y1=28, x2=78, y2=40)[0m
[2m2025-05-14T23:07:35.658121[0m [[32m[1mdebug    [0m] [1mConnecting rooms for node     [0m [[0m[1m[34mgame.world.procgen[0m][0m [36mis_leaf[0m=[35mTrue[0m [36mrect[0m=[35mRect(x1=68, y1=41, x2=78, y2=48)[0m
[2m2025-05-14T23:07:35.658169[0m [[32m[1mdebug    [0m] [1mConnecting sibling rooms      [0m [[0m[1m[34mgame.world.procgen[0m][0m [36mconnect_left[0m=[35m(77, 30)[0m [36mconnect_right[0m=[35m(70, 44)[0m [36mend_floor_h[0m=[35m0[0m [36mleft_center[0m=[35m(74, 31)[0m [36mright_center[0m=[35m(73, 45)[0m [36mstart_floor_h[0m=[35m0[0m
[2m2025-05-14T23:07:35.658200[0m [[32m[1mdebug    [0m] [1mCarving tunnel                [0m [[0m[1m[34mgame.world.procgen[0m][0m [36mend_floor_h[0m=[35m0[0m [36mend_pos[0m=[35m(70, 44)[0m [36mstart_floor_h[0m=[35m0[0m [36mstart_pos[0m=[35m(77, 30)[0m
[2m2025-05-14T23:07:35.658240[0m [[32m[1mdebug    [0m] [1mCarved rectangle area         [0m [[0m[1m[34mgame.world.procgen[0m][0m [36mceil_h[0m=[35m4[0m [36mfloor_h[0m=[35m0[0m [36mrect[0m=[35mRect(x1=77, y1=30, x2=77, y2=44)[0m [36mx_slice[0m=[35m77:78[0m [36my_slice[0m=[35m30:45[0m
[2m2025-05-14T23:07:35.658272[0m [[32m[1mdebug    [0m] [1mCarved vertical tunnel segment[0m [[0m[1m[34mgame.world.procgen[0m][0m [36mceil_h[0m=[35m4[0m [36mfloor_h[0m=[35m0[0m [36mrect[0m=[35mRect(x1=77, y1=30, x2=77, y2=44)[0m
[2m2025-05-14T23:07:35.658303[0m [[32m[1mdebug    [0m] [1mCarved rectangle area         [0m [[0m[1m[34mgame.world.procgen[0m][0m [36mceil_h[0m=[35m4[0m [36mfloor_h[0m=[35m0[0m [36mrect[0m=[35mRect(x1=70, y1=44, x2=76, y2=44)[0m [36mx_slice[0m=[35m70:77[0m [36my_slice[0m=[35m44:45[0m
[2m2025-05-14T23:07:35.658332[0m [[32m[1mdebug    [0m] [1mCarved horizontal tunnel segment[0m [[0m[1m[34mgame.world.procgen[0m][0m [36mceil_h[0m=[35m4[0m [36mfloor_h[0m=[35m0[0m [36mrect[0m=[35mRect(x1=70, y1=44, x2=76, y2=44)[0m
[2m2025-05-14T23:07:35.658377[0m [[32m[1mdebug    [0m] [1mConnecting sibling rooms      [0m [[0m[1m[34mgame.world.procgen[0m][0m [36mconnect_left[0m=[35m(52, 29)[0m [36mconnect_right[0m=[35m(73, 34)[0m [36mend_floor_h[0m=[35m0[0m [36mleft_center[0m=[35m(50, 29)[0m [36mright_center[0m=[35m(74, 31)[0m [36mstart_floor_h[0m=[35m0[0m
[2m2025-05-14T23:07:35.658410[0m [[32m[1mdebug    [0m] [1mCarving tunnel                [0m [[0m[1m[34mgame.world.procgen[0m][0m [36mend_floor_h[0m=[35m0[0m [36mend_pos[0m=[35m(73, 34)[0m [36mstart_floor_h[0m=[35m0[0m [36mstart_pos[0m=[35m(52, 29)[0m
[2m2025-05-14T23:07:35.658481[0m [[32m[1mdebug    [0m] [1mCarved rectangle area         [0m [[0m[1m[34mgame.world.procgen[0m][0m [36mceil_h[0m=[35m4[0m [36mfloor_h[0m=[35m0[0m [36mrect[0m=[35mRect(x1=52, y1=29, x2=52, y2=34)[0m [36mx_slice[0m=[35m52:53[0m [36my_slice[0m=[35m29:35[0m
[2m2025-05-14T23:07:35.658530[0m [[32m[1mdebug    [0m] [1mCarved vertical tunnel segment[0m [[0m[1m[34mgame.world.procgen[0m][0m [36mceil_h[0m=[35m4[0m [36mfloor_h[0m=[35m0[0m [36mrect[0m=[35mRect(x1=52, y1=29, x2=52, y2=34)[0m
[2m2025-05-14T23:07:35.658596[0m [[32m[1mdebug    [0m] [1mCarved rectangle area         [0m [[0m[1m[34mgame.world.procgen[0m][0m [36mceil_h[0m=[35m4[0m [36mfloor_h[0m=[35m0[0m [36mrect[0m=[35mRect(x1=53, y1=34, x2=73, y2=34)[0m [36mx_slice[0m=[35m53:74[0m [36my_slice[0m=[35m34:35[0m
[2m2025-05-14T23:07:35.658643[0m [[32m[1mdebug    [0m] [1mCarved horizontal tunnel segment[0m [[0m[1m[34mgame.world.procgen[0m][0m [36mceil_h[0m=[35m4[0m [36mfloor_h[0m=[35m0[0m [36mrect[0m=[35mRect(x1=53, y1=34, x2=73, y2=34)[0m
[2m2025-05-14T23:07:35.658704[0m [[32m[1mdebug    [0m] [1mConnecting sibling rooms      [0m [[0m[1m[34mgame.world.procgen[0m][0m [36mconnect_left[0m=[35m(49, 5)[0m [36mconnect_right[0m=[35m(51, 28)[0m [36mend_floor_h[0m=[35m0[0m [36mleft_center[0m=[35m(51, 5)[0m [36mright_center[0m=[35m(50, 29)[0m [36mstart_floor_h[0m=[35m0[0m
[2m2025-05-14T23:07:35.658737[0m [[32m[1mdebug    [0m] [1mCarving tunnel                [0m [[0m[1m[34mgame.world.procgen[0m][0m [36mend_floor_h[0m=[35m0[0m [36mend_pos[0m=[35m(51, 28)[0m [36mstart_floor_h[0m=[35m0[0m [36mstart_pos[0m=[35m(49, 5)[0m
[2m2025-05-14T23:07:35.658801[0m [[32m[1mdebug    [0m] [1mCarved rectangle area         [0m [[0m[1m[34mgame.world.procgen[0m][0m [36mceil_h[0m=[35m4[0m [36mfloor_h[0m=[35m0[0m [36mrect[0m=[35mRect(x1=49, y1=5, x2=49, y2=28)[0m [36mx_slice[0m=[35m49:50[0m [36my_slice[0m=[35m5:29[0m
[2m2025-05-14T23:07:35.658851[0m [[32m[1mdebug    [0m] [1mCarved vertical tunnel segment[0m [[0m[1m[34mgame.world.procgen[0m][0m [36mceil_h[0m=[35m4[0m [36mfloor_h[0m=[35m0[0m [36mrect[0m=[35mRect(x1=49, y1=5, x2=49, y2=28)[0m
[2m2025-05-14T23:07:35.658890[0m [[32m[1mdebug    [0m] [1mCarved rectangle area         [0m [[0m[1m[34mgame.world.procgen[0m][0m [36mceil_h[0m=[35m4[0m [36mfloor_h[0m=[35m0[0m [36mrect[0m=[35mRect(x1=50, y1=28, x2=51, y2=28)[0m [36mx_slice[0m=[35m50:52[0m [36my_slice[0m=[35m28:29[0m
[2m2025-05-14T23:07:35.658922[0m [[32m[1mdebug    [0m] [1mCarved horizontal tunnel segment[0m [[0m[1m[34mgame.world.procgen[0m][0m [36mceil_h[0m=[35m4[0m [36mfloor_h[0m=[35m0[0m [36mrect[0m=[35mRect(x1=50, y1=28, x2=51, y2=28)[0m
[2m2025-05-14T23:07:35.659004[0m [[32m[1mdebug    [0m] [1mConnecting sibling rooms      [0m [[0m[1m[34mgame.world.procgen[0m][0m [36mconnect_left[0m=[35m(36, 2)[0m [36mconnect_right[0m=[35m(51, 4)[0m [36mend_floor_h[0m=[35m0[0m [36mleft_center[0m=[35m(38, 3)[0m [36mright_center[0m=[35m(51, 5)[0m [36mstart_floor_h[0m=[35m0[0m
[2m2025-05-14T23:07:35.659042[0m [[32m[1mdebug    [0m] [1mCarving tunnel                [0m [[0m[1m[34mgame.world.procgen[0m][0m [36mend_floor_h[0m=[35m0[0m [36mend_pos[0m=[35m(51, 4)[0m [36mstart_floor_h[0m=[35m0[0m [36mstart_pos[0m=[35m(36, 2)[0m
[2m2025-05-14T23:07:35.659081[0m [[32m[1mdebug    [0m] [1mCarved rectangle area         [0m [[0m[1m[34mgame.world.procgen[0m][0m [36mceil_h[0m=[35m4[0m [36mfloor_h[0m=[35m0[0m [36mrect[0m=[35mRect(x1=36, y1=2, x2=36, y2=4)[0m [36mx_slice[0m=[35m36:37[0m [36my_slice[0m=[35m2:5[0m
[2m2025-05-14T23:07:35.659113[0m [[32m[1mdebug    [0m] [1mCarved vertical tunnel segment[0m [[0m[1m[34mgame.world.procgen[0m][0m [36mceil_h[0m=[35m4[0m [36mfloor_h[0m=[35m0[0m [36mrect[0m=[35mRect(x1=36, y1=2, x2=36, y2=4)[0m
[2m2025-05-14T23:07:35.659145[0m [[32m[1mdebug    [0m] [1mCarved rectangle area         [0m [[0m[1m[34mgame.world.procgen[0m][0m [36mceil_h[0m=[35m4[0m [36mfloor_h[0m=[35m0[0m [36mrect[0m=[35mRect(x1=37, y1=4, x2=51, y2=4)[0m [36mx_slice[0m=[35m37:52[0m [36my_slice[0m=[35m4:5[0m
[2m2025-05-14T23:07:35.659175[0m [[32m[1mdebug    [0m] [1mCarved horizontal tunnel segment[0m [[0m[1m[34mgame.world.procgen[0m][0m [36mceil_h[0m=[35m4[0m [36mfloor_h[0m=[35m0[0m [36mrect[0m=[35mRect(x1=37, y1=4, x2=51, y2=4)[0m
[2m2025-05-14T23:07:35.659221[0m [[32m[1mdebug    [0m] [1mConnecting sibling rooms      [0m [[0m[1m[34mgame.world.procgen[0m][0m [36mconnect_left[0m=[35m(6, 2)[0m [36mconnect_right[0m=[35m(40, 3)[0m [36mend_floor_h[0m=[35m0[0m [36mleft_center[0m=[35m(4, 3)[0m [36mright_center[0m=[35m(38, 3)[0m [36mstart_floor_h[0m=[35m0[0m
[2m2025-05-14T23:07:35.659252[0m [[32m[1mdebug    [0m] [1mCarving tunnel                [0m [[0m[1m[34mgame.world.procgen[0m][0m [36mend_floor_h[0m=[35m0[0m [36mend_pos[0m=[35m(40, 3)[0m [36mstart_floor_h[0m=[35m0[0m [36mstart_pos[0m=[35m(6, 2)[0m
[2m2025-05-14T23:07:35.659287[0m [[32m[1mdebug    [0m] [1mCarved rectangle area         [0m [[0m[1m[34mgame.world.procgen[0m][0m [36mceil_h[0m=[35m4[0m [36mfloor_h[0m=[35m0[0m [36mrect[0m=[35mRect(x1=6, y1=2, x2=6, y2=3)[0m [36mx_slice[0m=[35m6:7[0m [36my_slice[0m=[35m2:4[0m
[2m2025-05-14T23:07:35.659317[0m [[32m[1mdebug    [0m] [1mCarved vertical tunnel segment[0m [[0m[1m[34mgame.world.procgen[0m][0m [36mceil_h[0m=[35m4[0m [36mfloor_h[0m=[35m0[0m [36mrect[0m=[35mRect(x1=6, y1=2, x2=6, y2=3)[0m
[2m2025-05-14T23:07:35.659347[0m [[32m[1mdebug    [0m] [1mCarved rectangle area         [0m [[0m[1m[34mgame.world.procgen[0m][0m [36mceil_h[0m=[35m4[0m [36mfloor_h[0m=[35m0[0m [36mrect[0m=[35mRect(x1=7, y1=3, x2=40, y2=3)[0m [36mx_slice[0m=[35m7:41[0m [36my_slice[0m=[35m3:4[0m
[2m2025-05-14T23:07:35.659376[0m [[32m[1mdebug    [0m] [1mCarved horizontal tunnel segment[0m [[0m[1m[34mgame.world.procgen[0m][0m [36mceil_h[0m=[35m4[0m [36mfloor_h[0m=[35m0[0m [36mrect[0m=[35mRect(x1=7, y1=3, x2=40, y2=3)[0m
[2m2025-05-14T23:07:35.659407[0m [[32m[1minfo     [0m] [1mDetermined player start position[0m [[0m[1m[34mgame.world.procgen[0m][0m [36mfirst_room_rect[0m=[35mRect(x1=2, y1=2, x2=6, y2=5)[0m [36mpos[0m=[35m(4, 3)[0m [36mroom_center[0m=[35m(4, 3)[0m
[2m2025-05-14T23:07:35.659435[0m [[32m[1minfo     [0m] [1mUpdating transparency map...  [0m [[0m[1m[34mgame.world.procgen[0m][0m
[2m2025-05-14T23:07:35.659516[0m [[32m[1minfo     [0m] [1mTransparency map updated      [0m [[0m[1m[34mgame.world.game_map[0m][0m [36mtransparent_count[0m=[35mnp.int64(1595)[0m
[2m2025-05-14T23:07:35.659560[0m [[32m[1minfo     [0m] [1mDungeon generation complete   [0m [[0m[1m[34mgame.world.procgen[0m][0m [36mplayer_start[0m=[35m(4, 3)[0m
[2m2025-05-14T23:07:35.659618[0m [[32m[1minfo     [0m] [1mDungeon generated             [0m [[0m[1m[34m__main__[0m][0m [36mplayer_start[0m=[35m(4, 3)[0m
[2m2025-05-14T23:07:35.659712[0m [[32m[1minfo     [0m] [1mInitializing game state...    [0m [[0m[1m[34m__main__[0m][0m
[2m2025-05-14T23:07:35.659752[0m [[32m[1minfo     [0m] [1mInitializing GameState...     [0m [[0m[1m[34mgame.game_state[0m][0m
[2m2025-05-14T23:07:35.662126[0m [[32m[1mdebug    [0m] [1mGameRNG initialized           [0m [[0m[1m[34mgame.game_state[0m][0m [36mseed[0m=[35m1747260455632[0m
[2m2025-05-14T23:07:35.662180[0m [[32m[1minfo     [0m] [1mInitializing EntityRegistry with body_plan schema[0m [[0m[1m[34mgame.entities.registry[0m][0m
[2m2025-05-14T23:07:35.662662[0m [[32m[1mdebug    [0m] [1mEntityRegistry initialized    [0m [[0m[1m[34mgame.entities.registry[0m][0m [36mschema[0m=[35m['entity_id', 'is_active', 'x', 'y', 'glyph', 'color_fg_r', 'color_fg_g', 'color_fg_b', 'name', 'blocks_movement', 'hp', 'max_hp', 'inventory_capacity', 'status_effects', 'mana', 'max_mana', 'fullness', 'max_fullness', 'equipped_item_ids', 'body_plan'][0m
[2m2025-05-14T23:07:35.662710[0m [[32m[1mdebug    [0m] [1mEntityRegistry initialized    [0m [[0m[1m[34mgame.game_state[0m][0m
[2m2025-05-14T23:07:35.662749[0m [[32m[1minfo     [0m] [1mInitializing ItemRegistry with expanded schema[0m [[0m[1m[34mgame.items.registry[0m][0m
[2m2025-05-14T23:07:35.662822[0m [[32m[1mdebug    [0m] [1mItemRegistry schema updated: template_id Enum[0m [[0m[1m[34mgame.items.registry[0m][0m [36mcount[0m=[35m15[0m
[2m2025-05-14T23:07:35.663134[0m [[32m[1mdebug    [0m] [1mItemRegistry initialized      [0m [[0m[1m[34mgame.items.registry[0m][0m [36mtemplates_loaded[0m=[35m15[0m
[2m2025-05-14T23:07:35.663173[0m [[32m[1mdebug    [0m] [1mItemRegistry initialized      [0m [[0m[1m[34mgame.game_state[0m][0m [36mtemplates[0m=[35m15[0m
[2m2025-05-14T23:07:35.663200[0m [[32m[1mdebug    [0m] [1mEffect definitions stored     [0m [[0m[1m[34mgame.game_state[0m][0m [36meffects[0m=[35m4[0m
[2m2025-05-14T23:07:35.663228[0m [[32m[1mdebug    [0m] [1mAttempting to create entity   [0m [[0m[1m[34mgame.entities.registry[0m][0m [36mglyph[0m=[35m113[0m [36mhp[0m=[35m30[0m [36mname[0m=[35mPlayer[0m [36mpos[0m=[35m(4, 3)[0m
[2m2025-05-14T23:07:35.663662[0m [[32m[1minfo     [0m] [1mEntity created successfully   [0m [[0m[1m[34mgame.entities.registry[0m][0m [36mentity_id[0m=[35m0[0m [36mglyph[0m=[35m113[0m [36mhp[0m=[35m30[0m [36mname[0m=[35mPlayer[0m [36mpos[0m=[35m(4, 3)[0m
[2m2025-05-14T23:07:35.663713[0m [[32m[1mdebug    [0m] [1mPlayer entity created         [0m [[0m[1m[34mgame.game_state[0m][0m [36mglyph[0m=[35m113[0m [36mhp[0m=[35m30[0m [36mplayer_id[0m=[35m0[0m [36mpos[0m=[35m(4, 3)[0m
[2m2025-05-14T23:07:35.663747[0m [[32m[1mdebug    [0m] [1mMessage added                 [0m [[0m[1m[34mgame.game_state[0m][0m [36mcolor[0m=[35m(0, 255, 0)[0m [36mmessage[0m=[35m'Welcome to BasicRL!'[0m
[2m2025-05-14T23:07:35.663783[0m [[32m[1minfo     [0m] [1mGame state initialized        [0m [[0m[1m[34mgame.game_state[0m][0m [36meffect_definitions_loaded[0m=[35m4[0m [36mitem_templates_loaded[0m=[35m15[0m [36mmap_size[0m=[35m80x50[0m [36mplayer_id[0m=[35m0[0m [36mrng_seed[0m=[35m1747260455632[0m
[2m2025-05-14T23:07:35.668127[0m [[32m[1mdebug    [0m] [1mCalling fov.compute_fov       [0m [[0m[1m[34mgame.world.game_map[0m][0m [36mexplored_in_sum[0m=[35mnp.int64(0)[0m [36mopaque_sum[0m=[35mnp.int64(2405)[0m [36morigin[0m=[35m(4, 3)[0m [36morigin_h[0m=[35m0[0m [36mradius[0m=[35m4[0m [36mvisible_in_sum[0m=[35mnp.int64(0)[0m
[2m2025-05-14T23:07:35.668197[0m [[32m[1minfo     [0m] [1mStarting FOV computation      [0m [[0m[1m[34mgame.world.fov[0m][0m [36mgrid_shape[0m=[35m(50, 80)[0m [36morigin[0m=[35m(4, 3)[0m [36mrange_limit[0m=[35m4[0m
[2m2025-05-14T23:07:35.676133[0m [[32m[1minfo     [0m] [1mFOV computation finished      [0m [[0m[1m[34mgame.world.fov[0m][0m [36mduration_ms[0m=[35m7.88[0m [36mgrid_shape[0m=[35m(50, 80)[0m [36morigin[0m=[35m(4, 3)[0m [36mrange_limit[0m=[35m4[0m [36mvisible_count[0m=[35mnp.int64(1)[0m
[2m2025-05-14T23:07:35.676207[0m [[32m[1mdebug    [0m] [1mfov.compute_fov call finished [0m [[0m[1m[34mgame.world.game_map[0m][0m [36mexplored_out_sum[0m=[35mnp.int64(1)[0m [36morigin[0m=[35m(4, 3)[0m [36mradius[0m=[35m4[0m [36mvisible_out_sum[0m=[35mnp.int64(1)[0m
[2m2025-05-14T23:07:35.676254[0m [[32m[1minfo     [0m] [1mSpawning initial items near player[0m [[0m[1m[34m__main__[0m][0m [36mpos[0m=[35m(4, 3)[0m
[2m2025-05-14T23:07:35.676976[0m [[32m[1minfo     [0m] [1mItem created successfully     [0m [[0m[1m[34mgame.items.registry[0m][0m [36mitem_id[0m=[35m0[0m [36mlocation[0m=[35mground[0m [36mtemplate[0m=[35msimple_dagger[0m
[2m2025-05-14T23:07:35.677594[0m [[32m[1minfo     [0m] [1mItem created successfully     [0m [[0m[1m[34mgame.items.registry[0m][0m [36mitem_id[0m=[35m1[0m [36mlocation[0m=[35mground[0m [36mtemplate[0m=[35mcookies[0m
[2m2025-05-14T23:07:35.678187[0m [[32m[1minfo     [0m] [1mItem created successfully     [0m [[0m[1m[34mgame.items.registry[0m][0m [36mitem_id[0m=[35m2[0m [36mlocation[0m=[35mground[0m [36mtemplate[0m=[35mtorch[0m
[2m2025-05-14T23:07:35.678245[0m [[32m[1minfo     [0m] [1mCreating main window...       [0m [[0m[1m[34m__main__[0m][0m
[2m2025-05-14T23:07:35.678433[0m [[32m[1minfo     [0m] [1mInitializing WindowManager... [0m [[0m[1m[34mengine.window_manager[0m][0m
[2m2025-05-14T23:07:35.678482[0m [[32m[1minfo     [0m] [1mInitializing TilesetManager...[0m [[0m[1m[34mengine.window_manager_modules.tileset_manager[0m][0m
bytecode dump:
>          0	NOP(arg=None, lineno=21)
           2	RESUME(arg=0, lineno=21)
           4	LOAD_GLOBAL(arg=1, lineno=23)
          16	LOAD_ATTR(arg=1, lineno=23)
          26	LOAD_GLOBAL(arg=1, lineno=23)
          38	LOAD_ATTR(arg=2, lineno=23)
          48	LOAD_FAST(arg=0, lineno=23)
          50	LOAD_FAST(arg=1, lineno=23)
          52	LOAD_FAST(arg=2, lineno=24)
          54	KW_NAMES(arg=1, lineno=23)
          56	PRECALL(arg=3, lineno=23)
          60	CALL(arg=3, lineno=23)
          70	PRECALL(arg=1, lineno=23)
          74	CALL(arg=1, lineno=23)
          84	RETURN_VALUE(arg=None, lineno=23)
pending: deque([State(pc_initial=0 nstack_initial=0)])
stack: []
state.pc_initial: State(pc_initial=0 nstack_initial=0)
dispatch pc=0, inst=NOP(arg=None, lineno=21)
stack []
dispatch pc=2, inst=RESUME(arg=0, lineno=21)
stack []
dispatch pc=4, inst=LOAD_GLOBAL(arg=1, lineno=23)
stack []
dispatch pc=16, inst=LOAD_ATTR(arg=1, lineno=23)
stack ['$null$4.1', '$4load_global.0']
dispatch pc=26, inst=LOAD_GLOBAL(arg=1, lineno=23)
stack ['$null$4.1', '$16load_attr.2']
dispatch pc=38, inst=LOAD_ATTR(arg=2, lineno=23)
stack ['$null$4.1', '$16load_attr.2', '$null$26.4', '$26load_global.3']
dispatch pc=48, inst=LOAD_FAST(arg=0, lineno=23)
stack ['$null$4.1', '$16load_attr.2', '$null$26.4', '$38load_attr.5']
dispatch pc=50, inst=LOAD_FAST(arg=1, lineno=23)
stack ['$null$4.1', '$16load_attr.2', '$null$26.4', '$38load_attr.5', '$keyty48.6']
dispatch pc=52, inst=LOAD_FAST(arg=2, lineno=24)
stack ['$null$4.1', '$16load_attr.2', '$null$26.4', '$38load_attr.5', '$keyty48.6', '$valty50.7']
dispatch pc=54, inst=KW_NAMES(arg=1, lineno=23)
stack ['$null$4.1', '$16load_attr.2', '$null$26.4', '$38load_attr.5', '$keyty48.6', '$valty50.7', '$n_keys52.8']
dispatch pc=56, inst=PRECALL(arg=3, lineno=23)
stack ['$null$4.1', '$16load_attr.2', '$null$26.4', '$38load_attr.5', '$keyty48.6', '$valty50.7', '$n_keys52.8']
dispatch pc=60, inst=CALL(arg=3, lineno=23)
stack ['$null$4.1', '$16load_attr.2', '$null$26.4', '$38load_attr.5', '$keyty48.6', '$valty50.7', '$n_keys52.8']
dispatch pc=70, inst=PRECALL(arg=1, lineno=23)
stack ['$null$4.1', '$16load_attr.2', '$60call.9']
dispatch pc=74, inst=CALL(arg=1, lineno=23)
stack ['$null$4.1', '$16load_attr.2', '$60call.9']
dispatch pc=84, inst=RETURN_VALUE(arg=None, lineno=23)
stack ['$74call.10']
end state. edges=[]
-------------------------Prune PHIs-------------------------
Used_phis: defaultdict(<class 'set'>, {State(pc_initial=0 nstack_initial=0): set()})
defmap: {}
phismap: defaultdict(<class 'set'>, {})
changing phismap: defaultdict(<class 'set'>, {})
keep phismap: {}
new_out: defaultdict(<class 'dict'>, {})
----------------------DONE Prune PHIs-----------------------
block_infos State(pc_initial=0 nstack_initial=0):
AdaptBlockInfo(insts=((0, {}), (2, {}), (4, {'idx': 0, 'res': '$4load_global.0'}), (6, {}), (8, {}), (10, {}), (12, {}), (14, {}), (16, {'item': '$4load_global.0', 'res': '$16load_attr.2'}), (18, {}), (20, {}), (22, {}), (24, {}), (26, {'idx': 0, 'res': '$26load_global.3'}), (28, {}), (30, {}), (32, {}), (34, {}), (36, {}), (38, {'item': '$26load_global.3', 'res': '$38load_attr.5'}), (40, {}), (42, {}), (44, {}), (46, {}), (48, {'res': '$keyty48.6'}), (50, {'res': '$valty50.7'}), (52, {'res': '$n_keys52.8'}), (56, {}), (58, {}), (60, {'func': '$38load_attr.5', 'args': ['$keyty48.6', '$valty50.7', '$n_keys52.8'], 'kw_names': 1, 'res': '$60call.9'}), (62, {}), (64, {}), (66, {}), (68, {}), (70, {}), (72, {}), (74, {'func': '$16load_attr.2', 'args': ['$60call.9'], 'kw_names': None, 'res': '$74call.10'}), (76, {}), (78, {}), (80, {}), (82, {}), (84, {'retval': '$74call.10', 'castval': '$84return_value.11'})), outgoing_phis={}, blockstack=(), active_try_block=None, outgoing_edgepushed={})
label 0:
    keyty = arg(0, name=keyty)               ['keyty']
    valty = arg(1, name=valty)               ['valty']
    n_keys = arg(2, name=n_keys)             ['n_keys']
    $4load_global.0 = global(dictobject: <module 'numba.typed.dictobject' from '/home/earnest/.local/share/mamba/envs/basicrl/lib/python3.11/site-packages/numba/typed/dictobject.py'>) ['$4load_global.0']
    $16load_attr.2 = getattr(value=$4load_global.0, attr=_as_meminfo) ['$16load_attr.2', '$4load_global.0']
    $26load_global.3 = global(dictobject: <module 'numba.typed.dictobject' from '/home/earnest/.local/share/mamba/envs/basicrl/lib/python3.11/site-packages/numba/typed/dictobject.py'>) ['$26load_global.3']
    $38load_attr.5 = getattr(value=$26load_global.3, attr=new_dict) ['$26load_global.3', '$38load_attr.5']
    $60call.9 = call $38load_attr.5(keyty, valty, func=$38load_attr.5, args=[Var(keyty, typeddict.py:21), Var(valty, typeddict.py:21)], kws=[('n_keys', Var(n_keys, typeddict.py:21))], vararg=None, varkwarg=None, target=None) ['$38load_attr.5', '$60call.9', 'keyty', 'n_keys', 'valty']
    $74call.10 = call $16load_attr.2($60call.9, func=$16load_attr.2, args=[Var($60call.9, typeddict.py:23)], kws=(), vararg=None, varkwarg=None, target=None) ['$16load_attr.2', '$60call.9', '$74call.10']
    $84return_value.11 = cast(value=$74call.10) ['$74call.10', '$84return_value.11']
    return $84return_value.11                ['$84return_value.11']

==== SSA block analysis pass on 0
Running <numba.core.ssa._GatherDefsHandler object at 0x7f61c001ead0>
on stmt: keyty = arg(0, name=keyty)
on stmt: valty = arg(1, name=valty)
on stmt: n_keys = arg(2, name=n_keys)
on stmt: $4load_global.0 = global(dictobject: <module 'numba.typed.dictobject' from '/home/earnest/.local/share/mamba/envs/basicrl/lib/python3.11/site-packages/numba/typed/dictobject.py'>)
on stmt: $16load_attr.2 = getattr(value=$4load_global.0, attr=_as_meminfo)
on stmt: $26load_global.3 = global(dictobject: <module 'numba.typed.dictobject' from '/home/earnest/.local/share/mamba/envs/basicrl/lib/python3.11/site-packages/numba/typed/dictobject.py'>)
on stmt: $38load_attr.5 = getattr(value=$26load_global.3, attr=new_dict)
on stmt: $60call.9 = call $38load_attr.5(keyty, valty, func=$38load_attr.5, args=[Var(keyty, typeddict.py:21), Var(valty, typeddict.py:21)], kws=[('n_keys', Var(n_keys, typeddict.py:21))], vararg=None, varkwarg=None, target=None)
on stmt: $74call.10 = call $16load_attr.2($60call.9, func=$16load_attr.2, args=[Var($60call.9, typeddict.py:23)], kws=(), vararg=None, varkwarg=None, target=None)
on stmt: $84return_value.11 = cast(value=$74call.10)
on stmt: return $84return_value.11
defs defaultdict(<class 'list'>,
            {'$16load_attr.2': [(<numba.core.ir.Assign object at 0x7f61c01b7e90>,
                                 0)],
             '$26load_global.3': [(<numba.core.ir.Assign object at 0x7f61c01bc150>,
                                   0)],
             '$38load_attr.5': [(<numba.core.ir.Assign object at 0x7f61c01bc450>,
                                 0)],
             '$4load_global.0': [(<numba.core.ir.Assign object at 0x7f61c01b7b90>,
                                  0)],
             '$60call.9': [(<numba.core.ir.Assign object at 0x7f61c01bcc90>,
                            0)],
             '$74call.10': [(<numba.core.ir.Assign object at 0x7f61c01bcf90>,
                             0)],
             '$84return_value.11': [(<numba.core.ir.Assign object at 0x7f61c01bd2d0>,
                                     0)],
             'keyty': [(<numba.core.ir.Assign object at 0x7f61ca2d7d90>, 0)],
             'n_keys': [(<numba.core.ir.Assign object at 0x7f61c01b7a10>, 0)],
             'valty': [(<numba.core.ir.Assign object at 0x7f61c01b7910>, 0)]})
SSA violators <numba.core.utils.OrderedSet object at 0x7f61ca2d5ed0>
bytecode dump:
>          0	NOP(arg=None, lineno=668)
           2	COPY_FREE_VARS(arg=2, lineno=668)
           4	RESUME(arg=0, lineno=668)
           6	LOAD_FAST(arg=2, lineno=669)
           8	LOAD_CONST(arg=1, lineno=669)
          10	COMPARE_OP(arg=0, lineno=669)
          16	POP_JUMP_FORWARD_IF_FALSE(arg=15, lineno=669)
          18	LOAD_GLOBAL(arg=1, lineno=670)
          30	LOAD_CONST(arg=2, lineno=670)
          32	PRECALL(arg=1, lineno=670)
          36	CALL(arg=1, lineno=670)
          46	RAISE_VARARGS(arg=1, lineno=670)
>         48	LOAD_GLOBAL(arg=3, lineno=671)
          60	LOAD_FAST(arg=2, lineno=671)
          62	LOAD_DEREF(arg=5, lineno=671)
          64	LOAD_DEREF(arg=6, lineno=671)
          66	PRECALL(arg=3, lineno=671)
          70	CALL(arg=3, lineno=671)
          80	STORE_FAST(arg=3, lineno=671)
          82	LOAD_GLOBAL(arg=5, lineno=672)
          94	LOAD_FAST(arg=3, lineno=672)
          96	LOAD_DEREF(arg=5, lineno=672)
          98	LOAD_DEREF(arg=6, lineno=672)
         100	PRECALL(arg=3, lineno=672)
         104	CALL(arg=3, lineno=672)
         114	POP_TOP(arg=None, lineno=672)
         116	LOAD_GLOBAL(arg=7, lineno=673)
         128	LOAD_DEREF(arg=5, lineno=673)
         130	LOAD_DEREF(arg=6, lineno=673)
         132	LOAD_FAST(arg=3, lineno=673)
         134	PRECALL(arg=3, lineno=673)
         138	CALL(arg=3, lineno=673)
         148	STORE_FAST(arg=4, lineno=673)
         150	LOAD_FAST(arg=4, lineno=674)
         152	RETURN_VALUE(arg=None, lineno=674)
pending: deque([State(pc_initial=0 nstack_initial=0)])
stack: []
state.pc_initial: State(pc_initial=0 nstack_initial=0)
dispatch pc=0, inst=NOP(arg=None, lineno=668)
stack []
dispatch pc=2, inst=COPY_FREE_VARS(arg=2, lineno=668)
stack []
dispatch pc=4, inst=RESUME(arg=0, lineno=668)
stack []
dispatch pc=6, inst=LOAD_FAST(arg=2, lineno=669)
stack []
dispatch pc=8, inst=LOAD_CONST(arg=1, lineno=669)
stack ['$n_keys6.0']
dispatch pc=10, inst=COMPARE_OP(arg=0, lineno=669)
stack ['$n_keys6.0', '$const8.1.1']
dispatch pc=16, inst=POP_JUMP_FORWARD_IF_FALSE(arg=15, lineno=669)
stack ['$10compare_op.2']
end state. edges=[Edge(pc=18, stack=(), blockstack=(), npush=0), Edge(pc=48, stack=(), blockstack=(), npush=0)]
pending: deque([State(pc_initial=18 nstack_initial=0), State(pc_initial=48 nstack_initial=0)])
stack: []
state.pc_initial: State(pc_initial=18 nstack_initial=0)
dispatch pc=18, inst=LOAD_GLOBAL(arg=1, lineno=670)
stack []
dispatch pc=30, inst=LOAD_CONST(arg=2, lineno=670)
stack ['$null$18.1', '$18load_global.0']
dispatch pc=32, inst=PRECALL(arg=1, lineno=670)
stack ['$null$18.1', '$18load_global.0', '$const30.2.2']
dispatch pc=36, inst=CALL(arg=1, lineno=670)
stack ['$null$18.1', '$18load_global.0', '$const30.2.2']
dispatch pc=46, inst=RAISE_VARARGS(arg=1, lineno=670)
stack ['$36call.3']
end state. edges=[]
pending: deque([State(pc_initial=48 nstack_initial=0)])
stack: []
state.pc_initial: State(pc_initial=48 nstack_initial=0)
dispatch pc=48, inst=LOAD_GLOBAL(arg=3, lineno=671)
stack []
dispatch pc=60, inst=LOAD_FAST(arg=2, lineno=671)
stack ['$null$48.1', '$48load_global.0']
dispatch pc=62, inst=LOAD_DEREF(arg=5, lineno=671)
stack ['$null$48.1', '$48load_global.0', '$n_keys60.2']
dispatch pc=64, inst=LOAD_DEREF(arg=6, lineno=671)
stack ['$null$48.1', '$48load_global.0', '$n_keys60.2', '$62load_deref.3']
dispatch pc=66, inst=PRECALL(arg=3, lineno=671)
stack ['$null$48.1', '$48load_global.0', '$n_keys60.2', '$62load_deref.3', '$64load_deref.4']
dispatch pc=70, inst=CALL(arg=3, lineno=671)
stack ['$null$48.1', '$48load_global.0', '$n_keys60.2', '$62load_deref.3', '$64load_deref.4']
dispatch pc=80, inst=STORE_FAST(arg=3, lineno=671)
stack ['$70call.5']
dispatch pc=82, inst=LOAD_GLOBAL(arg=5, lineno=672)
stack []
dispatch pc=94, inst=LOAD_FAST(arg=3, lineno=672)
stack ['$null$82.7', '$82load_global.6']
dispatch pc=96, inst=LOAD_DEREF(arg=5, lineno=672)
stack ['$null$82.7', '$82load_global.6', '$dp94.8']
dispatch pc=98, inst=LOAD_DEREF(arg=6, lineno=672)
stack ['$null$82.7', '$82load_global.6', '$dp94.8', '$96load_deref.9']
dispatch pc=100, inst=PRECALL(arg=3, lineno=672)
stack ['$null$82.7', '$82load_global.6', '$dp94.8', '$96load_deref.9', '$98load_deref.10']
dispatch pc=104, inst=CALL(arg=3, lineno=672)
stack ['$null$82.7', '$82load_global.6', '$dp94.8', '$96load_deref.9', '$98load_deref.10']
dispatch pc=114, inst=POP_TOP(arg=None, lineno=672)
stack ['$104call.11']
dispatch pc=116, inst=LOAD_GLOBAL(arg=7, lineno=673)
stack []
dispatch pc=128, inst=LOAD_DEREF(arg=5, lineno=673)
stack ['$null$116.13', '$116load_global.12']
dispatch pc=130, inst=LOAD_DEREF(arg=6, lineno=673)
stack ['$null$116.13', '$116load_global.12', '$128load_deref.14']
dispatch pc=132, inst=LOAD_FAST(arg=3, lineno=673)
stack ['$null$116.13', '$116load_global.12', '$128load_deref.14', '$130load_deref.15']
dispatch pc=134, inst=PRECALL(arg=3, lineno=673)
stack ['$null$116.13', '$116load_global.12', '$128load_deref.14', '$130load_deref.15', '$dp132.16']
dispatch pc=138, inst=CALL(arg=3, lineno=673)
stack ['$null$116.13', '$116load_global.12', '$128load_deref.14', '$130load_deref.15', '$dp132.16']
dispatch pc=148, inst=STORE_FAST(arg=4, lineno=673)
stack ['$138call.17']
dispatch pc=150, inst=LOAD_FAST(arg=4, lineno=674)
stack []
dispatch pc=152, inst=RETURN_VALUE(arg=None, lineno=674)
stack ['$d150.18']
end state. edges=[]
-------------------------Prune PHIs-------------------------
Used_phis: defaultdict(<class 'set'>,
            {State(pc_initial=0 nstack_initial=0): set(),
             State(pc_initial=18 nstack_initial=0): set(),
             State(pc_initial=48 nstack_initial=0): set()})
defmap: {}
phismap: defaultdict(<class 'set'>, {})
changing phismap: defaultdict(<class 'set'>, {})
keep phismap: {}
new_out: defaultdict(<class 'dict'>, {})
----------------------DONE Prune PHIs-----------------------
block_infos State(pc_initial=0 nstack_initial=0):
AdaptBlockInfo(insts=((0, {}), (2, {}), (4, {}), (6, {'res': '$n_keys6.0'}), (8, {'res': '$const8.1.1'}), (10, {'lhs': '$n_keys6.0', 'rhs': '$const8.1.1', 'res': '$10compare_op.2'}), (12, {}), (14, {}), (16, {'pred': '$10compare_op.2'})), outgoing_phis={}, blockstack=(), active_try_block=None, outgoing_edgepushed={18: (), 48: ()})
block_infos State(pc_initial=18 nstack_initial=0):
AdaptBlockInfo(insts=((18, {'idx': 0, 'res': '$18load_global.0'}), (20, {}), (22, {}), (24, {}), (26, {}), (28, {}), (30, {'res': '$const30.2.2'}), (32, {}), (34, {}), (36, {'func': '$18load_global.0', 'args': ['$const30.2.2'], 'kw_names': None, 'res': '$36call.3'}), (38, {}), (40, {}), (42, {}), (44, {}), (46, {'exc': '$36call.3'})), outgoing_phis={}, blockstack=(), active_try_block=None, outgoing_edgepushed={})
block_infos State(pc_initial=48 nstack_initial=0):
AdaptBlockInfo(insts=((48, {'idx': 1, 'res': '$48load_global.0'}), (50, {}), (52, {}), (54, {}), (56, {}), (58, {}), (60, {'res': '$n_keys60.2'}), (62, {'res': '$62load_deref.3'}), (64, {'res': '$64load_deref.4'}), (66, {}), (68, {}), (70, {'func': '$48load_global.0', 'args': ['$n_keys60.2', '$62load_deref.3', '$64load_deref.4'], 'kw_names': None, 'res': '$70call.5'}), (72, {}), (74, {}), (76, {}), (78, {}), (80, {'value': '$70call.5'}), (82, {'idx': 2, 'res': '$82load_global.6'}), (84, {}), (86, {}), (88, {}), (90, {}), (92, {}), (94, {'res': '$dp94.8'}), (96, {'res': '$96load_deref.9'}), (98, {'res': '$98load_deref.10'}), (100, {}), (102, {}), (104, {'func': '$82load_global.6', 'args': ['$dp94.8', '$96load_deref.9', '$98load_deref.10'], 'kw_names': None, 'res': '$104call.11'}), (106, {}), (108, {}), (110, {}), (112, {}), (116, {'idx': 3, 'res': '$116load_global.12'}), (118, {}), (120, {}), (122, {}), (124, {}), (126, {}), (128, {'res': '$128load_deref.14'}), (130, {'res': '$130load_deref.15'}), (132, {'res': '$dp132.16'}), (134, {}), (136, {}), (138, {'func': '$116load_global.12', 'args': ['$128load_deref.14', '$130load_deref.15', '$dp132.16'], 'kw_names': None, 'res': '$138call.17'}), (140, {}), (142, {}), (144, {}), (146, {}), (148, {'value': '$138call.17'}), (150, {'res': '$d150.18'}), (152, {'retval': '$d150.18', 'castval': '$152return_value.19'})), outgoing_phis={}, blockstack=(), active_try_block=None, outgoing_edgepushed={})
label 0:
    key = arg(0, name=key)                   ['key']
    value = arg(1, name=value)               ['value']
    n_keys = arg(2, name=n_keys)             ['n_keys']
    $const8.1.1 = const(int, 0)              ['$const8.1.1']
    $10compare_op.2 = n_keys < $const8.1.1   ['$10compare_op.2', '$const8.1.1', 'n_keys']
    bool16 = global(bool: <class 'bool'>)    ['bool16']
    $16pred = call bool16($10compare_op.2, func=bool16, args=(Var($10compare_op.2, dictobject.py:669),), kws=(), vararg=None, varkwarg=None, target=None) ['$10compare_op.2', '$16pred', 'bool16']
    branch $16pred, 18, 48                   ['$16pred']
label 18:
    $18load_global.0 = global(RuntimeError: <class 'RuntimeError'>) ['$18load_global.0']
    $const30.2.2 = const(str, expecting *n_keys* to be >= 0) ['$const30.2.2']
    $36call.3 = call $18load_global.0($const30.2.2, func=$18load_global.0, args=[Var($const30.2.2, dictobject.py:670)], kws=(), vararg=None, varkwarg=None, target=None) ['$18load_global.0', '$36call.3', '$const30.2.2']
    raise $36call.3                          ['$36call.3']
label 48:
    $48load_global.0 = global(_dict_new_sized: <intrinsic _dict_new_sized>) ['$48load_global.0']
    $62load_deref.3 = freevar(keyty: class(int64)) ['$62load_deref.3']
    $64load_deref.4 = freevar(valty: typeref[array(uint8, 3d, C)]) ['$64load_deref.4']
    dp = call $48load_global.0(n_keys, $62load_deref.3, $64load_deref.4, func=$48load_global.0, args=[Var(n_keys, dictobject.py:668), Var($62load_deref.3, dictobject.py:671), Var($64load_deref.4, dictobject.py:671)], kws=(), vararg=None, varkwarg=None, target=None) ['$48load_global.0', '$62load_deref.3', '$64load_deref.4', 'dp', 'n_keys']
    $82load_global.6 = global(_dict_set_method_table: <intrinsic _dict_set_method_table>) ['$82load_global.6']
    $96load_deref.9 = freevar(keyty: class(int64)) ['$96load_deref.9']
    $98load_deref.10 = freevar(valty: typeref[array(uint8, 3d, C)]) ['$98load_deref.10']
    $104call.11 = call $82load_global.6(dp, $96load_deref.9, $98load_deref.10, func=$82load_global.6, args=[Var(dp, dictobject.py:671), Var($96load_deref.9, dictobject.py:672), Var($98load_deref.10, dictobject.py:672)], kws=(), vararg=None, varkwarg=None, target=None) ['$104call.11', '$82load_global.6', '$96load_deref.9', '$98load_deref.10', 'dp']
    $116load_global.12 = global(_make_dict: <intrinsic _make_dict>) ['$116load_global.12']
    $128load_deref.14 = freevar(keyty: class(int64)) ['$128load_deref.14']
    $130load_deref.15 = freevar(valty: typeref[array(uint8, 3d, C)]) ['$130load_deref.15']
    d = call $116load_global.12($128load_deref.14, $130load_deref.15, dp, func=$116load_global.12, args=[Var($128load_deref.14, dictobject.py:673), Var($130load_deref.15, dictobject.py:673), Var(dp, dictobject.py:671)], kws=(), vararg=None, varkwarg=None, target=None) ['$116load_global.12', '$128load_deref.14', '$130load_deref.15', 'd', 'dp']
    $152return_value.19 = cast(value=d)      ['$152return_value.19', 'd']
    return $152return_value.19               ['$152return_value.19']

==== SSA block analysis pass on 0
Running <numba.core.ssa._GatherDefsHandler object at 0x7f61c004d510>
on stmt: key = arg(0, name=key)
on stmt: value = arg(1, name=value)
on stmt: n_keys = arg(2, name=n_keys)
on stmt: $const8.1.1 = const(int, 0)
on stmt: $10compare_op.2 = n_keys < $const8.1.1
on stmt: bool16 = global(bool: <class 'bool'>)
on stmt: $16pred = call bool16($10compare_op.2, func=bool16, args=(Var($10compare_op.2, dictobject.py:669),), kws=(), vararg=None, varkwarg=None, target=None)
on stmt: branch $16pred, 18, 48
==== SSA block analysis pass on 18
Running <numba.core.ssa._GatherDefsHandler object at 0x7f61c004d510>
on stmt: $18load_global.0 = global(RuntimeError: <class 'RuntimeError'>)
on stmt: $const30.2.2 = const(str, expecting *n_keys* to be >= 0)
on stmt: $36call.3 = call $18load_global.0($const30.2.2, func=$18load_global.0, args=[Var($const30.2.2, dictobject.py:670)], kws=(), vararg=None, varkwarg=None, target=None)
on stmt: <static> raise <class 'RuntimeError'>('expecting *n_keys* to be >= 0')
==== SSA block analysis pass on 48
Running <numba.core.ssa._GatherDefsHandler object at 0x7f61c004d510>
on stmt: $48load_global.0 = global(_dict_new_sized: <intrinsic _dict_new_sized>)
on stmt: $62load_deref.3 = freevar(keyty: class(int64))
on stmt: $64load_deref.4 = freevar(valty: typeref[array(uint8, 3d, C)])
on stmt: dp = call $48load_global.0(n_keys, $62load_deref.3, $64load_deref.4, func=$48load_global.0, args=[Var(n_keys, dictobject.py:668), Var($62load_deref.3, dictobject.py:671), Var($64load_deref.4, dictobject.py:671)], kws=(), vararg=None, varkwarg=None, target=None)
on stmt: $82load_global.6 = global(_dict_set_method_table: <intrinsic _dict_set_method_table>)
on stmt: $96load_deref.9 = freevar(keyty: class(int64))
on stmt: $98load_deref.10 = freevar(valty: typeref[array(uint8, 3d, C)])
on stmt: $104call.11 = call $82load_global.6(dp, $96load_deref.9, $98load_deref.10, func=$82load_global.6, args=[Var(dp, dictobject.py:671), Var($96load_deref.9, dictobject.py:672), Var($98load_deref.10, dictobject.py:672)], kws=(), vararg=None, varkwarg=None, target=None)
on stmt: $116load_global.12 = global(_make_dict: <intrinsic _make_dict>)
on stmt: $128load_deref.14 = freevar(keyty: class(int64))
on stmt: $130load_deref.15 = freevar(valty: typeref[array(uint8, 3d, C)])
on stmt: d = call $116load_global.12($128load_deref.14, $130load_deref.15, dp, func=$116load_global.12, args=[Var($128load_deref.14, dictobject.py:673), Var($130load_deref.15, dictobject.py:673), Var(dp, dictobject.py:671)], kws=(), vararg=None, varkwarg=None, target=None)
on stmt: $152return_value.19 = cast(value=d)
on stmt: return $152return_value.19
defs defaultdict(<class 'list'>,
            {'$104call.11': [(<numba.core.ir.Assign object at 0x7f61c00b5e10>,
                              48)],
             '$10compare_op.2': [(<numba.core.ir.Assign object at 0x7f61c00afd10>,
                                  0)],
             '$116load_global.12': [(<numba.core.ir.Assign object at 0x7f61c00b60d0>,
                                     48)],
             '$128load_deref.14': [(<numba.core.ir.Assign object at 0x7f61c00b6390>,
                                    48)],
             '$130load_deref.15': [(<numba.core.ir.Assign object at 0x7f61c00b6510>,
                                    48)],
             '$152return_value.19': [(<numba.core.ir.Assign object at 0x7f61c00b6f90>,
                                      48)],
             '$16pred': [(<numba.core.ir.Assign object at 0x7f61c00b4110>, 0)],
             '$18load_global.0': [(<numba.core.ir.Assign object at 0x7f61c00b4290>,
                                   18)],
             '$36call.3': [(<numba.core.ir.Assign object at 0x7f61c00b46d0>,
                            18)],
             '$48load_global.0': [(<numba.core.ir.Assign object at 0x7f61c00b4a50>,
                                   48)],
             '$62load_deref.3': [(<numba.core.ir.Assign object at 0x7f61c004ce90>,
                                  48)],
             '$64load_deref.4': [(<numba.core.ir.Assign object at 0x7f61c00b4e90>,
                                  48)],
             '$82load_global.6': [(<numba.core.ir.Assign object at 0x7f61c00b5550>,
                                   48)],
             '$96load_deref.9': [(<numba.core.ir.Assign object at 0x7f61c00b59d0>,
                                  48)],
             '$98load_deref.10': [(<numba.core.ir.Assign object at 0x7f61c00b5b50>,
                                   48)],
             '$const30.2.2': [(<numba.core.ir.Assign object at 0x7f61c00b44d0>,
                               18)],
             '$const8.1.1': [(<numba.core.ir.Assign object at 0x7f61c00afb50>,
                              0)],
             'bool16': [(<numba.core.ir.Assign object at 0x7f61c00aff10>, 0)],
             'd': [(<numba.core.ir.Assign object at 0x7f61c00b6910>, 48)],
             'dp': [(<numba.core.ir.Assign object at 0x7f61c00b50d0>, 48)],
             'key': [(<numba.core.ir.Assign object at 0x7f61c004d250>, 0)],
             'n_keys': [(<numba.core.ir.Assign object at 0x7f61c00af790>, 0)],
             'value': [(<numba.core.ir.Assign object at 0x7f61c00af490>, 0)]})
SSA violators <numba.core.utils.OrderedSet object at 0x7f61c004d510>
[2m2025-05-14T23:07:35.740757[0m [[32m[1minfo     [0m] [1mLoading tileset               [0m [[0m[1m[34mengine.window_manager_modules.tileset_manager[0m][0m [36mh[0m=[35m16[0m [36mpath[0m=[35m/home/earnest/code_projects/basicrl/fonts/classic_roguelike_sliced_svgs[0m [36mw[0m=[35m16[0m
[2m2025-05-14T23:07:35.740839[0m [[32m[1minfo     [0m] [1mLoading tileset               [0m [[0m[1m[34mengine.tileset_loader[0m][0m [36mheight[0m=[35m16[0m [36mpath[0m=[35m/home/earnest/code_projects/basicrl/fonts/classic_roguelike_sliced_svgs[0m [36mwidth[0m=[35m16[0m
[2m2025-05-14T23:07:35.742000[0m [[32m[1mdebug    [0m] [1mInitial file scan complete    [0m [[0m[1m[34mengine.tileset_loader[0m][0m [36mpng_found[0m=[35m0[0m [36msvg_found[0m=[35m195[0m
[2m2025-05-14T23:07:35.742046[0m [[32m[1minfo     [0m] [1mRasterizing SVG tiles...      [0m [[0m[1m[34mengine.tileset_loader[0m][0m
[2m2025-05-14T23:07:35.742077[0m [[32m[1mdebug    [0m] [1mRasterizing SVG               [0m [[0m[1m[34mengine.tileset_loader[0m][0m [36mheight[0m=[35m16[0m [36mpath[0m=[35m/home/earnest/code_projects/basicrl/fonts/classic_roguelike_sliced_svgs/classic_roguelike_32.svg[0m [36mwidth[0m=[35m16[0m
STREAM b'IHDR' 16 13
STREAM b'bKGD' 41 6
b'bKGD' 41 6 (unknown)
STREAM b'IDAT' 59 48
[2m2025-05-14T23:07:35.760278[0m [[32m[1mdebug    [0m] [1mRasterizing SVG               [0m [[0m[1m[34mengine.tileset_loader[0m][0m [36mheight[0m=[35m16[0m [36mpath[0m=[35m/home/earnest/code_projects/basicrl/fonts/classic_roguelike_sliced_svgs/classic_roguelike_117.svg[0m [36mwidth[0m=[35m16[0m
STREAM b'IHDR' 16 13
STREAM b'bKGD' 41 6
b'bKGD' 41 6 (unknown)
STREAM b'IDAT' 59 54
[2m2025-05-14T23:07:35.761114[0m [[32m[1mdebug    [0m] [1mRasterizing SVG               [0m [[0m[1m[34mengine.tileset_loader[0m][0m [36mheight[0m=[35m16[0m [36mpath[0m=[35m/home/earnest/code_projects/basicrl/fonts/classic_roguelike_sliced_svgs/classic_roguelike_101.svg[0m [36mwidth[0m=[35m16[0m
STREAM b'IHDR' 16 13
STREAM b'bKGD' 41 6
b'bKGD' 41 6 (unknown)
STREAM b'IDAT' 59 58
[2m2025-05-14T23:07:35.762061[0m [[32m[1mdebug    [0m] [1mRasterizing SVG               [0m [[0m[1m[34mengine.tileset_loader[0m][0m [36mheight[0m=[35m16[0m [36mpath[0m=[35m/home/earnest/code_projects/basicrl/fonts/classic_roguelike_sliced_svgs/classic_roguelike_92.svg[0m [36mwidth[0m=[35m16[0m
STREAM b'IHDR' 16 13
STREAM b'bKGD' 41 6
b'bKGD' 41 6 (unknown)
STREAM b'IDAT' 59 51
[2m2025-05-14T23:07:35.763161[0m [[32m[1mdebug    [0m] [1mRasterizing SVG               [0m [[0m[1m[34mengine.tileset_loader[0m][0m [36mheight[0m=[35m16[0m [36mpath[0m=[35m/home/earnest/code_projects/basicrl/fonts/classic_roguelike_sliced_svgs/classic_roguelike_179.svg[0m [36mwidth[0m=[35m16[0m
STREAM b'IHDR' 16 13
STREAM b'bKGD' 41 6
b'bKGD' 41 6 (unknown)
STREAM b'IDAT' 59 88
[2m2025-05-14T23:07:35.765041[0m [[32m[1mdebug    [0m] [1mRasterizing SVG               [0m [[0m[1m[34mengine.tileset_loader[0m][0m [36mheight[0m=[35m16[0m [36mpath[0m=[35m/home/earnest/code_projects/basicrl/fonts/classic_roguelike_sliced_svgs/classic_roguelike_180.svg[0m [36mwidth[0m=[35m16[0m
STREAM b'IHDR' 16 13
STREAM b'bKGD' 41 6
b'bKGD' 41 6 (unknown)
STREAM b'IDAT' 59 61
[2m2025-05-14T23:07:35.765733[0m [[32m[1mdebug    [0m] [1mRasterizing SVG               [0m [[0m[1m[34mengine.tileset_loader[0m][0m [36mheight[0m=[35m16[0m [36mpath[0m=[35m/home/earnest/code_projects/basicrl/fonts/classic_roguelike_sliced_svgs/classic_roguelike_104.svg[0m [36mwidth[0m=[35m16[0m
STREAM b'IHDR' 16 13
STREAM b'bKGD' 41 6
b'bKGD' 41 6 (unknown)
STREAM b'IDAT' 59 54
[2m2025-05-14T23:07:35.766697[0m [[32m[1mdebug    [0m] [1mRasterizing SVG               [0m [[0m[1m[34mengine.tileset_loader[0m][0m [36mheight[0m=[35m16[0m [36mpath[0m=[35m/home/earnest/code_projects/basicrl/fonts/classic_roguelike_sliced_svgs/classic_roguelike_71.svg[0m [36mwidth[0m=[35m16[0m
STREAM b'IHDR' 16 13
STREAM b'bKGD' 41 6
b'bKGD' 41 6 (unknown)
STREAM b'IDAT' 59 78
[2m2025-05-14T23:07:35.767868[0m [[32m[1mdebug    [0m] [1mRasterizing SVG               [0m [[0m[1m[34mengine.tileset_loader[0m][0m [36mheight[0m=[35m16[0m [36mpath[0m=[35m/home/earnest/code_projects/basicrl/fonts/classic_roguelike_sliced_svgs/classic_roguelike_127.svg[0m [36mwidth[0m=[35m16[0m
STREAM b'IHDR' 16 13
STREAM b'bKGD' 41 6
b'bKGD' 41 6 (unknown)
STREAM b'IDAT' 59 39
[2m2025-05-14T23:07:35.768599[0m [[32m[1mdebug    [0m] [1mRasterizing SVG               [0m [[0m[1m[34mengine.tileset_loader[0m][0m [36mheight[0m=[35m16[0m [36mpath[0m=[35m/home/earnest/code_projects/basicrl/fonts/classic_roguelike_sliced_svgs/classic_roguelike_123.svg[0m [36mwidth[0m=[35m16[0m
STREAM b'IHDR' 16 13
STREAM b'bKGD' 41 6
b'bKGD' 41 6 (unknown)
STREAM b'IDAT' 59 36
[2m2025-05-14T23:07:35.769325[0m [[32m[1mdebug    [0m] [1mRasterizing SVG               [0m [[0m[1m[34mengine.tileset_loader[0m][0m [36mheight[0m=[35m16[0m [36mpath[0m=[35m/home/earnest/code_projects/basicrl/fonts/classic_roguelike_sliced_svgs/classic_roguelike_18.svg[0m [36mwidth[0m=[35m16[0m
STREAM b'IHDR' 16 13
STREAM b'bKGD' 41 6
b'bKGD' 41 6 (unknown)
STREAM b'IDAT' 59 56
[2m2025-05-14T23:07:35.769999[0m [[32m[1mdebug    [0m] [1mRasterizing SVG               [0m [[0m[1m[34mengine.tileset_loader[0m][0m [36mheight[0m=[35m16[0m [36mpath[0m=[35m/home/earnest/code_projects/basicrl/fonts/classic_roguelike_sliced_svgs/classic_roguelike_87.svg[0m [36mwidth[0m=[35m16[0m
STREAM b'IHDR' 16 13
STREAM b'bKGD' 41 6
b'bKGD' 41 6 (unknown)
STREAM b'IDAT' 59 69
[2m2025-05-14T23:07:35.771046[0m [[32m[1mdebug    [0m] [1mRasterizing SVG               [0m [[0m[1m[34mengine.tileset_loader[0m][0m [36mheight[0m=[35m16[0m [36mpath[0m=[35m/home/earnest/code_projects/basicrl/fonts/classic_roguelike_sliced_svgs/classic_roguelike_113.svg[0m [36mwidth[0m=[35m16[0m
STREAM b'IHDR' 16 13
STREAM b'bKGD' 41 6
b'bKGD' 41 6 (unknown)
STREAM b'IDAT' 59 63
[2m2025-05-14T23:07:35.771714[0m [[32m[1mdebug    [0m] [1mRasterizing SVG               [0m [[0m[1m[34mengine.tileset_loader[0m][0m [36mheight[0m=[35m16[0m [36mpath[0m=[35m/home/earnest/code_projects/basicrl/fonts/classic_roguelike_sliced_svgs/classic_roguelike_28.svg[0m [36mwidth[0m=[35m16[0m
STREAM b'IHDR' 16 13
STREAM b'bKGD' 41 6
b'bKGD' 41 6 (unknown)
STREAM b'IDAT' 59 52
[2m2025-05-14T23:07:35.772331[0m [[32m[1mdebug    [0m] [1mRasterizing SVG               [0m [[0m[1m[34mengine.tileset_loader[0m][0m [36mheight[0m=[35m16[0m [36mpath[0m=[35m/home/earnest/code_projects/basicrl/fonts/classic_roguelike_sliced_svgs/classic_roguelike_129.svg[0m [36mwidth[0m=[35m16[0m
STREAM b'IHDR' 16 13
STREAM b'bKGD' 41 6
b'bKGD' 41 6 (unknown)
STREAM b'IDAT' 59 48
[2m2025-05-14T23:07:35.773061[0m [[32m[1mdebug    [0m] [1mRasterizing SVG               [0m [[0m[1m[34mengine.tileset_loader[0m][0m [36mheight[0m=[35m16[0m [36mpath[0m=[35m/home/earnest/code_projects/basicrl/fonts/classic_roguelike_sliced_svgs/classic_roguelike_36.svg[0m [36mwidth[0m=[35m16[0m
STREAM b'IHDR' 16 13
STREAM b'bKGD' 41 6
b'bKGD' 41 6 (unknown)
STREAM b'IDAT' 59 58
[2m2025-05-14T23:07:35.773706[0m [[32m[1mdebug    [0m] [1mRasterizing SVG               [0m [[0m[1m[34mengine.tileset_loader[0m][0m [36mheight[0m=[35m16[0m [36mpath[0m=[35m/home/earnest/code_projects/basicrl/fonts/classic_roguelike_sliced_svgs/classic_roguelike_07.svg[0m [36mwidth[0m=[35m16[0m
STREAM b'IHDR' 16 13
STREAM b'bKGD' 41 6
b'bKGD' 41 6 (unknown)
STREAM b'IDAT' 59 62
[2m2025-05-14T23:07:35.775125[0m [[32m[1mdebug    [0m] [1mRasterizing SVG               [0m [[0m[1m[34mengine.tileset_loader[0m][0m [36mheight[0m=[35m16[0m [36mpath[0m=[35m/home/earnest/code_projects/basicrl/fonts/classic_roguelike_sliced_svgs/classic_roguelike_195.svg[0m [36mwidth[0m=[35m16[0m
STREAM b'IHDR' 16 13
STREAM b'bKGD' 41 6
b'bKGD' 41 6 (unknown)
STREAM b'IDAT' 59 55
[2m2025-05-14T23:07:35.775784[0m [[32m[1mdebug    [0m] [1mRasterizing SVG               [0m [[0m[1m[34mengine.tileset_loader[0m][0m [36mheight[0m=[35m16[0m [36mpath[0m=[35m/home/earnest/code_projects/basicrl/fonts/classic_roguelike_sliced_svgs/classic_roguelike_192.svg[0m [36mwidth[0m=[35m16[0m
STREAM b'IHDR' 16 13
STREAM b'bKGD' 41 6
b'bKGD' 41 6 (unknown)
STREAM b'IDAT' 59 49
[2m2025-05-14T23:07:35.776406[0m [[32m[1mdebug    [0m] [1mRasterizing SVG               [0m [[0m[1m[34mengine.tileset_loader[0m][0m [36mheight[0m=[35m16[0m [36mpath[0m=[35m/home/earnest/code_projects/basicrl/fonts/classic_roguelike_sliced_svgs/classic_roguelike_158.svg[0m [36mwidth[0m=[35m16[0m
STREAM b'IHDR' 16 13
STREAM b'bKGD' 41 6
b'bKGD' 41 6 (unknown)
STREAM b'IDAT' 59 64
[2m2025-05-14T23:07:35.777060[0m [[32m[1mdebug    [0m] [1mRasterizing SVG               [0m [[0m[1m[34mengine.tileset_loader[0m][0m [36mheight[0m=[35m16[0m [36mpath[0m=[35m/home/earnest/code_projects/basicrl/fonts/classic_roguelike_sliced_svgs/classic_roguelike_118.svg[0m [36mwidth[0m=[35m16[0m
STREAM b'IHDR' 16 13
STREAM b'bKGD' 41 6
b'bKGD' 41 6 (unknown)
STREAM b'IDAT' 59 63
[2m2025-05-14T23:07:35.777855[0m [[32m[1mdebug    [0m] [1mRasterizing SVG               [0m [[0m[1m[34mengine.tileset_loader[0m][0m [36mheight[0m=[35m16[0m [36mpath[0m=[35m/home/earnest/code_projects/basicrl/fonts/classic_roguelike_sliced_svgs/classic_roguelike_49.svg[0m [36mwidth[0m=[35m16[0m
STREAM b'IHDR' 16 13
STREAM b'bKGD' 41 6
b'bKGD' 41 6 (unknown)
STREAM b'IDAT' 59 53
[2m2025-05-14T23:07:35.778765[0m [[32m[1mdebug    [0m] [1mRasterizing SVG               [0m [[0m[1m[34mengine.tileset_loader[0m][0m [36mheight[0m=[35m16[0m [36mpath[0m=[35m/home/earnest/code_projects/basicrl/fonts/classic_roguelike_sliced_svgs/classic_roguelike_110.svg[0m [36mwidth[0m=[35m16[0m
STREAM b'IHDR' 16 13
STREAM b'bKGD' 41 6
b'bKGD' 41 6 (unknown)
STREAM b'IDAT' 59 79
[2m2025-05-14T23:07:35.779509[0m [[32m[1mdebug    [0m] [1mRasterizing SVG               [0m [[0m[1m[34mengine.tileset_loader[0m][0m [36mheight[0m=[35m16[0m [36mpath[0m=[35m/home/earnest/code_projects/basicrl/fonts/classic_roguelike_sliced_svgs/classic_roguelike_131.svg[0m [36mwidth[0m=[35m16[0m
STREAM b'IHDR' 16 13
STREAM b'bKGD' 41 6
b'bKGD' 41 6 (unknown)
STREAM b'IDAT' 59 53
[2m2025-05-14T23:07:35.780156[0m [[32m[1mdebug    [0m] [1mRasterizing SVG               [0m [[0m[1m[34mengine.tileset_loader[0m][0m [36mheight[0m=[35m16[0m [36mpath[0m=[35m/home/earnest/code_projects/basicrl/fonts/classic_roguelike_sliced_svgs/classic_roguelike_47.svg[0m [36mwidth[0m=[35m16[0m
STREAM b'IHDR' 16 13
STREAM b'bKGD' 41 6
b'bKGD' 41 6 (unknown)
STREAM b'IDAT' 59 56
[2m2025-05-14T23:07:35.781047[0m [[32m[1mdebug    [0m] [1mRasterizing SVG               [0m [[0m[1m[34mengine.tileset_loader[0m][0m [36mheight[0m=[35m16[0m [36mpath[0m=[35m/home/earnest/code_projects/basicrl/fonts/classic_roguelike_sliced_svgs/classic_roguelike_10.svg[0m [36mwidth[0m=[35m16[0m
STREAM b'IHDR' 16 13
STREAM b'bKGD' 41 6
b'bKGD' 41 6 (unknown)
STREAM b'IDAT' 59 69
[2m2025-05-14T23:07:35.781789[0m [[32m[1mdebug    [0m] [1mRasterizing SVG               [0m [[0m[1m[34mengine.tileset_loader[0m][0m [36mheight[0m=[35m16[0m [36mpath[0m=[35m/home/earnest/code_projects/basicrl/fonts/classic_roguelike_sliced_svgs/classic_roguelike_25.svg[0m [36mwidth[0m=[35m16[0m
STREAM b'IHDR' 16 13
STREAM b'bKGD' 41 6
b'bKGD' 41 6 (unknown)
STREAM b'IDAT' 59 45
[2m2025-05-14T23:07:35.782767[0m [[32m[1mdebug    [0m] [1mRasterizing SVG               [0m [[0m[1m[34mengine.tileset_loader[0m][0m [36mheight[0m=[35m16[0m [36mpath[0m=[35m/home/earnest/code_projects/basicrl/fonts/classic_roguelike_sliced_svgs/classic_roguelike_128.svg[0m [36mwidth[0m=[35m16[0m
STREAM b'IHDR' 16 13
STREAM b'bKGD' 41 6
b'bKGD' 41 6 (unknown)
STREAM b'IDAT' 59 49
[2m2025-05-14T23:07:35.783460[0m [[32m[1mdebug    [0m] [1mRasterizing SVG               [0m [[0m[1m[34mengine.tileset_loader[0m][0m [36mheight[0m=[35m16[0m [36mpath[0m=[35m/home/earnest/code_projects/basicrl/fonts/classic_roguelike_sliced_svgs/classic_roguelike_03.svg[0m [36mwidth[0m=[35m16[0m
STREAM b'IHDR' 16 13
STREAM b'bKGD' 41 6
b'bKGD' 41 6 (unknown)
STREAM b'IDAT' 59 51
[2m2025-05-14T23:07:35.784275[0m [[32m[1mdebug    [0m] [1mRasterizing SVG               [0m [[0m[1m[34mengine.tileset_loader[0m][0m [36mheight[0m=[35m16[0m [36mpath[0m=[35m/home/earnest/code_projects/basicrl/fonts/classic_roguelike_sliced_svgs/classic_roguelike_01.svg[0m [36mwidth[0m=[35m16[0m
STREAM b'IHDR' 16 13
STREAM b'bKGD' 41 6
b'bKGD' 41 6 (unknown)
STREAM b'IDAT' 59 55
[2m2025-05-14T23:07:35.785244[0m [[32m[1mdebug    [0m] [1mRasterizing SVG               [0m [[0m[1m[34mengine.tileset_loader[0m][0m [36mheight[0m=[35m16[0m [36mpath[0m=[35m/home/earnest/code_projects/basicrl/fonts/classic_roguelike_sliced_svgs/classic_roguelike_68.svg[0m [36mwidth[0m=[35m16[0m
STREAM b'IHDR' 16 13
STREAM b'bKGD' 41 6
b'bKGD' 41 6 (unknown)
STREAM b'IDAT' 59 77
[2m2025-05-14T23:07:35.786341[0m [[32m[1mdebug    [0m] [1mRasterizing SVG               [0m [[0m[1m[34mengine.tileset_loader[0m][0m [36mheight[0m=[35m16[0m [36mpath[0m=[35m/home/earnest/code_projects/basicrl/fonts/classic_roguelike_sliced_svgs/classic_roguelike_157.svg[0m [36mwidth[0m=[35m16[0m
STREAM b'IHDR' 16 13
STREAM b'bKGD' 41 6
b'bKGD' 41 6 (unknown)
STREAM b'IDAT' 59 56
[2m2025-05-14T23:07:35.787008[0m [[32m[1mdebug    [0m] [1mRasterizing SVG               [0m [[0m[1m[34mengine.tileset_loader[0m][0m [36mheight[0m=[35m16[0m [36mpath[0m=[35m/home/earnest/code_projects/basicrl/fonts/classic_roguelike_sliced_svgs/classic_roguelike_105.svg[0m [36mwidth[0m=[35m16[0m
STREAM b'IHDR' 16 13
STREAM b'bKGD' 41 6
b'bKGD' 41 6 (unknown)
STREAM b'IDAT' 59 62
[2m2025-05-14T23:07:35.787678[0m [[32m[1mdebug    [0m] [1mRasterizing SVG               [0m [[0m[1m[34mengine.tileset_loader[0m][0m [36mheight[0m=[35m16[0m [36mpath[0m=[35m/home/earnest/code_projects/basicrl/fonts/classic_roguelike_sliced_svgs/classic_roguelike_156.svg[0m [36mwidth[0m=[35m16[0m
STREAM b'IHDR' 16 13
STREAM b'bKGD' 41 6
b'bKGD' 41 6 (unknown)
STREAM b'IDAT' 59 54
[2m2025-05-14T23:07:35.788328[0m [[32m[1mdebug    [0m] [1mRasterizing SVG               [0m [[0m[1m[34mengine.tileset_loader[0m][0m [36mheight[0m=[35m16[0m [36mpath[0m=[35m/home/earnest/code_projects/basicrl/fonts/classic_roguelike_sliced_svgs/classic_roguelike_162.svg[0m [36mwidth[0m=[35m16[0m
STREAM b'IHDR' 16 13
STREAM b'bKGD' 41 6
b'bKGD' 41 6 (unknown)
STREAM b'IDAT' 59 54
[2m2025-05-14T23:07:35.788980[0m [[32m[1mdebug    [0m] [1mRasterizing SVG               [0m [[0m[1m[34mengine.tileset_loader[0m][0m [36mheight[0m=[35m16[0m [36mpath[0m=[35m/home/earnest/code_projects/basicrl/fonts/classic_roguelike_sliced_svgs/classic_roguelike_177.svg[0m [36mwidth[0m=[35m16[0m
STREAM b'IHDR' 16 13
STREAM b'bKGD' 41 6
b'bKGD' 41 6 (unknown)
STREAM b'IDAT' 59 49
[2m2025-05-14T23:07:35.789623[0m [[32m[1mdebug    [0m] [1mRasterizing SVG               [0m [[0m[1m[34mengine.tileset_loader[0m][0m [36mheight[0m=[35m16[0m [36mpath[0m=[35m/home/earnest/code_projects/basicrl/fonts/classic_roguelike_sliced_svgs/classic_roguelike_21.svg[0m [36mwidth[0m=[35m16[0m
STREAM b'IHDR' 16 13
STREAM b'bKGD' 41 6
b'bKGD' 41 6 (unknown)
STREAM b'IDAT' 59 66
[2m2025-05-14T23:07:35.790263[0m [[32m[1mdebug    [0m] [1mRasterizing SVG               [0m [[0m[1m[34mengine.tileset_loader[0m][0m [36mheight[0m=[35m16[0m [36mpath[0m=[35m/home/earnest/code_projects/basicrl/fonts/classic_roguelike_sliced_svgs/classic_roguelike_11.svg[0m [36mwidth[0m=[35m16[0m
STREAM b'IHDR' 16 13
STREAM b'bKGD' 41 6
b'bKGD' 41 6 (unknown)
STREAM b'IDAT' 59 47
[2m2025-05-14T23:07:35.790913[0m [[32m[1mdebug    [0m] [1mRasterizing SVG               [0m [[0m[1m[34mengine.tileset_loader[0m][0m [36mheight[0m=[35m16[0m [36mpath[0m=[35m/home/earnest/code_projects/basicrl/fonts/classic_roguelike_sliced_svgs/classic_roguelike_52.svg[0m [36mwidth[0m=[35m16[0m
STREAM b'IHDR' 16 13
STREAM b'bKGD' 41 6
b'bKGD' 41 6 (unknown)
STREAM b'IDAT' 59 50
[2m2025-05-14T23:07:35.791711[0m [[32m[1mdebug    [0m] [1mRasterizing SVG               [0m [[0m[1m[34mengine.tileset_loader[0m][0m [36mheight[0m=[35m16[0m [36mpath[0m=[35m/home/earnest/code_projects/basicrl/fonts/classic_roguelike_sliced_svgs/classic_roguelike_126.svg[0m [36mwidth[0m=[35m16[0m
STREAM b'IHDR' 16 13
STREAM b'bKGD' 41 6
b'bKGD' 41 6 (unknown)
STREAM b'IDAT' 59 44
[2m2025-05-14T23:07:35.792303[0m [[32m[1mdebug    [0m] [1mRasterizing SVG               [0m [[0m[1m[34mengine.tileset_loader[0m][0m [36mheight[0m=[35m16[0m [36mpath[0m=[35m/home/earnest/code_projects/basicrl/fonts/classic_roguelike_sliced_svgs/classic_roguelike_41.svg[0m [36mwidth[0m=[35m16[0m
STREAM b'IHDR' 16 13
STREAM b'bKGD' 41 6
b'bKGD' 41 6 (unknown)
STREAM b'IDAT' 59 71
[2m2025-05-14T23:07:35.794078[0m [[32m[1mdebug    [0m] [1mRasterizing SVG               [0m [[0m[1m[34mengine.tileset_loader[0m][0m [36mheight[0m=[35m16[0m [36mpath[0m=[35m/home/earnest/code_projects/basicrl/fonts/classic_roguelike_sliced_svgs/classic_roguelike_97.svg[0m [36mwidth[0m=[35m16[0m
STREAM b'IHDR' 16 13
STREAM b'bKGD' 41 6
b'bKGD' 41 6 (unknown)
STREAM b'IDAT' 59 59
[2m2025-05-14T23:07:35.794861[0m [[32m[1mdebug    [0m] [1mRasterizing SVG               [0m [[0m[1m[34mengine.tileset_loader[0m][0m [36mheight[0m=[35m16[0m [36mpath[0m=[35m/home/earnest/code_projects/basicrl/fonts/classic_roguelike_sliced_svgs/classic_roguelike_24.svg[0m [36mwidth[0m=[35m16[0m
STREAM b'IHDR' 16 13
STREAM b'bKGD' 41 6
b'bKGD' 41 6 (unknown)
STREAM b'IDAT' 59 65
[2m2025-05-14T23:07:35.795949[0m [[32m[1mdebug    [0m] [1mRasterizing SVG               [0m [[0m[1m[34mengine.tileset_loader[0m][0m [36mheight[0m=[35m16[0m [36mpath[0m=[35m/home/earnest/code_projects/basicrl/fonts/classic_roguelike_sliced_svgs/classic_roguelike_132.svg[0m [36mwidth[0m=[35m16[0m
STREAM b'IHDR' 16 13
STREAM b'bKGD' 41 6
b'bKGD' 41 6 (unknown)
STREAM b'IDAT' 59 62
[2m2025-05-14T23:07:35.796682[0m [[32m[1mdebug    [0m] [1mRasterizing SVG               [0m [[0m[1m[34mengine.tileset_loader[0m][0m [36mheight[0m=[35m16[0m [36mpath[0m=[35m/home/earnest/code_projects/basicrl/fonts/classic_roguelike_sliced_svgs/classic_roguelike_75.svg[0m [36mwidth[0m=[35m16[0m
STREAM b'IHDR' 16 13
STREAM b'bKGD' 41 6
b'bKGD' 41 6 (unknown)
STREAM b'IDAT' 59 75
[2m2025-05-14T23:07:35.797860[0m [[32m[1mdebug    [0m] [1mRasterizing SVG               [0m [[0m[1m[34mengine.tileset_loader[0m][0m [36mheight[0m=[35m16[0m [36mpath[0m=[35m/home/earnest/code_projects/basicrl/fonts/classic_roguelike_sliced_svgs/classic_roguelike_08.svg[0m [36mwidth[0m=[35m16[0m
STREAM b'IHDR' 16 13
STREAM b'bKGD' 41 6
b'bKGD' 41 6 (unknown)
STREAM b'IDAT' 59 52
[2m2025-05-14T23:07:35.798476[0m [[32m[1mdebug    [0m] [1mRasterizing SVG               [0m [[0m[1m[34mengine.tileset_loader[0m][0m [36mheight[0m=[35m16[0m [36mpath[0m=[35m/home/earnest/code_projects/basicrl/fonts/classic_roguelike_sliced_svgs/classic_roguelike_02.svg[0m [36mwidth[0m=[35m16[0m
STREAM b'IHDR' 16 13
STREAM b'bKGD' 41 6
b'bKGD' 41 6 (unknown)
STREAM b'IDAT' 59 32
[2m2025-05-14T23:07:35.799191[0m [[32m[1mdebug    [0m] [1mRasterizing SVG               [0m [[0m[1m[34mengine.tileset_loader[0m][0m [36mheight[0m=[35m16[0m [36mpath[0m=[35m/home/earnest/code_projects/basicrl/fonts/classic_roguelike_sliced_svgs/classic_roguelike_57.svg[0m [36mwidth[0m=[35m16[0m
STREAM b'IHDR' 16 13
STREAM b'bKGD' 41 6
b'bKGD' 41 6 (unknown)
STREAM b'IDAT' 59 72
[2m2025-05-14T23:07:35.800115[0m [[32m[1mdebug    [0m] [1mRasterizing SVG               [0m [[0m[1m[34mengine.tileset_loader[0m][0m [36mheight[0m=[35m16[0m [36mpath[0m=[35m/home/earnest/code_projects/basicrl/fonts/classic_roguelike_sliced_svgs/classic_roguelike_16.svg[0m [36mwidth[0m=[35m16[0m
STREAM b'IHDR' 16 13
STREAM b'bKGD' 41 6
b'bKGD' 41 6 (unknown)
STREAM b'IDAT' 59 56
[2m2025-05-14T23:07:35.801094[0m [[32m[1mdebug    [0m] [1mRasterizing SVG               [0m [[0m[1m[34mengine.tileset_loader[0m][0m [36mheight[0m=[35m16[0m [36mpath[0m=[35m/home/earnest/code_projects/basicrl/fonts/classic_roguelike_sliced_svgs/classic_roguelike_147.svg[0m [36mwidth[0m=[35m16[0m
STREAM b'IHDR' 16 13
STREAM b'bKGD' 41 6
b'bKGD' 41 6 (unknown)
STREAM b'IDAT' 59 53
[2m2025-05-14T23:07:35.801722[0m [[32m[1mdebug    [0m] [1mRasterizing SVG               [0m [[0m[1m[34mengine.tileset_loader[0m][0m [36mheight[0m=[35m16[0m [36mpath[0m=[35m/home/earnest/code_projects/basicrl/fonts/classic_roguelike_sliced_svgs/classic_roguelike_12.svg[0m [36mwidth[0m=[35m16[0m
STREAM b'IHDR' 16 13
STREAM b'bKGD' 41 6
b'bKGD' 41 6 (unknown)
STREAM b'IDAT' 59 69
[2m2025-05-14T23:07:35.802463[0m [[32m[1mdebug    [0m] [1mRasterizing SVG               [0m [[0m[1m[34mengine.tileset_loader[0m][0m [36mheight[0m=[35m16[0m [36mpath[0m=[35m/home/earnest/code_projects/basicrl/fonts/classic_roguelike_sliced_svgs/classic_roguelike_27.svg[0m [36mwidth[0m=[35m16[0m
STREAM b'IHDR' 16 13
STREAM b'bKGD' 41 6
b'bKGD' 41 6 (unknown)
STREAM b'IDAT' 59 63
[2m2025-05-14T23:07:35.803438[0m [[32m[1mdebug    [0m] [1mRasterizing SVG               [0m [[0m[1m[34mengine.tileset_loader[0m][0m [36mheight[0m=[35m16[0m [36mpath[0m=[35m/home/earnest/code_projects/basicrl/fonts/classic_roguelike_sliced_svgs/classic_roguelike_72.svg[0m [36mwidth[0m=[35m16[0m
STREAM b'IHDR' 16 13
STREAM b'bKGD' 41 6
b'bKGD' 41 6 (unknown)
STREAM b'IDAT' 59 67
[2m2025-05-14T23:07:35.804360[0m [[32m[1mdebug    [0m] [1mRasterizing SVG               [0m [[0m[1m[34mengine.tileset_loader[0m][0m [36mheight[0m=[35m16[0m [36mpath[0m=[35m/home/earnest/code_projects/basicrl/fonts/classic_roguelike_sliced_svgs/classic_roguelike_178.svg[0m [36mwidth[0m=[35m16[0m
STREAM b'IHDR' 16 13
STREAM b'bKGD' 41 6
b'bKGD' 41 6 (unknown)
STREAM b'IDAT' 59 88
[2m2025-05-14T23:07:35.806081[0m [[32m[1mdebug    [0m] [1mRasterizing SVG               [0m [[0m[1m[34mengine.tileset_loader[0m][0m [36mheight[0m=[35m16[0m [36mpath[0m=[35m/home/earnest/code_projects/basicrl/fonts/classic_roguelike_sliced_svgs/classic_roguelike_88.svg[0m [36mwidth[0m=[35m16[0m
STREAM b'IHDR' 16 13
STREAM b'bKGD' 41 6
b'bKGD' 41 6 (unknown)
STREAM b'IDAT' 59 58
[2m2025-05-14T23:07:35.806724[0m [[32m[1mdebug    [0m] [1mRasterizing SVG               [0m [[0m[1m[34mengine.tileset_loader[0m][0m [36mheight[0m=[35m16[0m [36mpath[0m=[35m/home/earnest/code_projects/basicrl/fonts/classic_roguelike_sliced_svgs/classic_roguelike_40.svg[0m [36mwidth[0m=[35m16[0m
STREAM b'IHDR' 16 13
STREAM b'bKGD' 41 6
b'bKGD' 41 6 (unknown)
STREAM b'IDAT' 59 59
[2m2025-05-14T23:07:35.807394[0m [[32m[1mdebug    [0m] [1mRasterizing SVG               [0m [[0m[1m[34mengine.tileset_loader[0m][0m [36mheight[0m=[35m16[0m [36mpath[0m=[35m/home/earnest/code_projects/basicrl/fonts/classic_roguelike_sliced_svgs/classic_roguelike_133.svg[0m [36mwidth[0m=[35m16[0m
STREAM b'IHDR' 16 13
STREAM b'bKGD' 41 6
b'bKGD' 41 6 (unknown)
STREAM b'IDAT' 59 60
[2m2025-05-14T23:07:35.808057[0m [[32m[1mdebug    [0m] [1mRasterizing SVG               [0m [[0m[1m[34mengine.tileset_loader[0m][0m [36mheight[0m=[35m16[0m [36mpath[0m=[35m/home/earnest/code_projects/basicrl/fonts/classic_roguelike_sliced_svgs/classic_roguelike_166.svg[0m [36mwidth[0m=[35m16[0m
STREAM b'IHDR' 16 13
STREAM b'bKGD' 41 6
b'bKGD' 41 6 (unknown)
STREAM b'IDAT' 59 49
[2m2025-05-14T23:07:35.808700[0m [[32m[1mdebug    [0m] [1mRasterizing SVG               [0m [[0m[1m[34mengine.tileset_loader[0m][0m [36mheight[0m=[35m16[0m [36mpath[0m=[35m/home/earnest/code_projects/basicrl/fonts/classic_roguelike_sliced_svgs/classic_roguelike_05.svg[0m [36mwidth[0m=[35m16[0m
STREAM b'IHDR' 16 13
STREAM b'bKGD' 41 6
b'bKGD' 41 6 (unknown)
STREAM b'IDAT' 59 62
[2m2025-05-14T23:07:35.809372[0m [[32m[1mdebug    [0m] [1mRasterizing SVG               [0m [[0m[1m[34mengine.tileset_loader[0m][0m [36mheight[0m=[35m16[0m [36mpath[0m=[35m/home/earnest/code_projects/basicrl/fonts/classic_roguelike_sliced_svgs/classic_roguelike_145.svg[0m [36mwidth[0m=[35m16[0m
STREAM b'IHDR' 16 13
STREAM b'bKGD' 41 6
b'bKGD' 41 6 (unknown)
STREAM b'IDAT' 59 53
[2m2025-05-14T23:07:35.810015[0m [[32m[1mdebug    [0m] [1mRasterizing SVG               [0m [[0m[1m[34mengine.tileset_loader[0m][0m [36mheight[0m=[35m16[0m [36mpath[0m=[35m/home/earnest/code_projects/basicrl/fonts/classic_roguelike_sliced_svgs/classic_roguelike_65.svg[0m [36mwidth[0m=[35m16[0m
STREAM b'IHDR' 16 13
STREAM b'bKGD' 41 6
b'bKGD' 41 6 (unknown)
STREAM b'IDAT' 59 69
[2m2025-05-14T23:07:35.811307[0m [[32m[1mdebug    [0m] [1mRasterizing SVG               [0m [[0m[1m[34mengine.tileset_loader[0m][0m [36mheight[0m=[35m16[0m [36mpath[0m=[35m/home/earnest/code_projects/basicrl/fonts/classic_roguelike_sliced_svgs/classic_roguelike_09.svg[0m [36mwidth[0m=[35m16[0m
STREAM b'IHDR' 16 13
STREAM b'bKGD' 41 6
b'bKGD' 41 6 (unknown)
STREAM b'IDAT' 59 57
[2m2025-05-14T23:07:35.811965[0m [[32m[1mdebug    [0m] [1mRasterizing SVG               [0m [[0m[1m[34mengine.tileset_loader[0m][0m [36mheight[0m=[35m16[0m [36mpath[0m=[35m/home/earnest/code_projects/basicrl/fonts/classic_roguelike_sliced_svgs/classic_roguelike_119.svg[0m [36mwidth[0m=[35m16[0m
STREAM b'IHDR' 16 13
STREAM b'bKGD' 41 6
b'bKGD' 41 6 (unknown)
STREAM b'IDAT' 59 79
[2m2025-05-14T23:07:35.813001[0m [[32m[1mdebug    [0m] [1mRasterizing SVG               [0m [[0m[1m[34mengine.tileset_loader[0m][0m [36mheight[0m=[35m16[0m [36mpath[0m=[35m/home/earnest/code_projects/basicrl/fonts/classic_roguelike_sliced_svgs/classic_roguelike_39.svg[0m [36mwidth[0m=[35m16[0m
STREAM b'IHDR' 16 13
STREAM b'bKGD' 41 6
b'bKGD' 41 6 (unknown)
STREAM b'IDAT' 59 69
[2m2025-05-14T23:07:35.814856[0m [[32m[1mdebug    [0m] [1mRasterizing SVG               [0m [[0m[1m[34mengine.tileset_loader[0m][0m [36mheight[0m=[35m16[0m [36mpath[0m=[35m/home/earnest/code_projects/basicrl/fonts/classic_roguelike_sliced_svgs/classic_roguelike_163.svg[0m [36mwidth[0m=[35m16[0m
STREAM b'IHDR' 16 13
STREAM b'bKGD' 41 6
b'bKGD' 41 6 (unknown)
STREAM b'IDAT' 59 60
[2m2025-05-14T23:07:35.815544[0m [[32m[1mdebug    [0m] [1mRasterizing SVG               [0m [[0m[1m[34mengine.tileset_loader[0m][0m [36mheight[0m=[35m16[0m [36mpath[0m=[35m/home/earnest/code_projects/basicrl/fonts/classic_roguelike_sliced_svgs/classic_roguelike_17.svg[0m [36mwidth[0m=[35m16[0m
STREAM b'IHDR' 16 13
STREAM b'bKGD' 41 6
b'bKGD' 41 6 (unknown)
STREAM b'IDAT' 59 55
[2m2025-05-14T23:07:35.816533[0m [[32m[1mdebug    [0m] [1mRasterizing SVG               [0m [[0m[1m[34mengine.tileset_loader[0m][0m [36mheight[0m=[35m16[0m [36mpath[0m=[35m/home/earnest/code_projects/basicrl/fonts/classic_roguelike_sliced_svgs/classic_roguelike_155.svg[0m [36mwidth[0m=[35m16[0m
STREAM b'IHDR' 16 13
STREAM b'bKGD' 41 6
b'bKGD' 41 6 (unknown)
STREAM b'IDAT' 59 56
[2m2025-05-14T23:07:35.817177[0m [[32m[1mdebug    [0m] [1mRasterizing SVG               [0m [[0m[1m[34mengine.tileset_loader[0m][0m [36mheight[0m=[35m16[0m [36mpath[0m=[35m/home/earnest/code_projects/basicrl/fonts/classic_roguelike_sliced_svgs/classic_roguelike_83.svg[0m [36mwidth[0m=[35m16[0m
STREAM b'IHDR' 16 13
STREAM b'bKGD' 41 6
b'bKGD' 41 6 (unknown)
STREAM b'IDAT' 59 73
[2m2025-05-14T23:07:35.818011[0m [[32m[1mdebug    [0m] [1mRasterizing SVG               [0m [[0m[1m[34mengine.tileset_loader[0m][0m [36mheight[0m=[35m16[0m [36mpath[0m=[35m/home/earnest/code_projects/basicrl/fonts/classic_roguelike_sliced_svgs/classic_roguelike_37.svg[0m [36mwidth[0m=[35m16[0m
STREAM b'IHDR' 16 13
STREAM b'bKGD' 41 6
b'bKGD' 41 6 (unknown)
STREAM b'IDAT' 59 18
[2m2025-05-14T23:07:35.818497[0m [[32m[1mdebug    [0m] [1mRasterizing SVG               [0m [[0m[1m[34mengine.tileset_loader[0m][0m [36mheight[0m=[35m16[0m [36mpath[0m=[35m/home/earnest/code_projects/basicrl/fonts/classic_roguelike_sliced_svgs/classic_roguelike_96.svg[0m [36mwidth[0m=[35m16[0m
STREAM b'IHDR' 16 13
STREAM b'bKGD' 41 6
b'bKGD' 41 6 (unknown)
STREAM b'IDAT' 59 58
[2m2025-05-14T23:07:35.819252[0m [[32m[1mdebug    [0m] [1mRasterizing SVG               [0m [[0m[1m[34mengine.tileset_loader[0m][0m [36mheight[0m=[35m16[0m [36mpath[0m=[35m/home/earnest/code_projects/basicrl/fonts/classic_roguelike_sliced_svgs/classic_roguelike_185.svg[0m [36mwidth[0m=[35m16[0m
STREAM b'IHDR' 16 13
STREAM b'bKGD' 41 6
b'bKGD' 41 6 (unknown)
STREAM b'IDAT' 59 42
[2m2025-05-14T23:07:35.819876[0m [[32m[1mdebug    [0m] [1mRasterizing SVG               [0m [[0m[1m[34mengine.tileset_loader[0m][0m [36mheight[0m=[35m16[0m [36mpath[0m=[35m/home/earnest/code_projects/basicrl/fonts/classic_roguelike_sliced_svgs/classic_roguelike_33.svg[0m [36mwidth[0m=[35m16[0m
STREAM b'IHDR' 16 13
STREAM b'bKGD' 41 6
b'bKGD' 41 6 (unknown)
STREAM b'IDAT' 59 52
[2m2025-05-14T23:07:35.820770[0m [[32m[1mdebug    [0m] [1mRasterizing SVG               [0m [[0m[1m[34mengine.tileset_loader[0m][0m [36mheight[0m=[35m16[0m [36mpath[0m=[35m/home/earnest/code_projects/basicrl/fonts/classic_roguelike_sliced_svgs/classic_roguelike_34.svg[0m [36mwidth[0m=[35m16[0m
STREAM b'IHDR' 16 13
STREAM b'bKGD' 41 6
b'bKGD' 41 6 (unknown)
STREAM b'IDAT' 59 41
[2m2025-05-14T23:07:35.821664[0m [[32m[1mdebug    [0m] [1mRasterizing SVG               [0m [[0m[1m[34mengine.tileset_loader[0m][0m [36mheight[0m=[35m16[0m [36mpath[0m=[35m/home/earnest/code_projects/basicrl/fonts/classic_roguelike_sliced_svgs/classic_roguelike_124.svg[0m [36mwidth[0m=[35m16[0m
STREAM b'IHDR' 16 13
STREAM b'bKGD' 41 6
b'bKGD' 41 6 (unknown)
STREAM b'IDAT' 59 54
[2m2025-05-14T23:07:35.822285[0m [[32m[1mdebug    [0m] [1mRasterizing SVG               [0m [[0m[1m[34mengine.tileset_loader[0m][0m [36mheight[0m=[35m16[0m [36mpath[0m=[35m/home/earnest/code_projects/basicrl/fonts/classic_roguelike_sliced_svgs/classic_roguelike_30.svg[0m [36mwidth[0m=[35m16[0m
STREAM b'IHDR' 16 13
STREAM b'bKGD' 41 6
b'bKGD' 41 6 (unknown)
STREAM b'IDAT' 59 52
[2m2025-05-14T23:07:35.823601[0m [[32m[1mdebug    [0m] [1mRasterizing SVG               [0m [[0m[1m[34mengine.tileset_loader[0m][0m [36mheight[0m=[35m16[0m [36mpath[0m=[35m/home/earnest/code_projects/basicrl/fonts/classic_roguelike_sliced_svgs/classic_roguelike_48.svg[0m [36mwidth[0m=[35m16[0m
STREAM b'IHDR' 16 13
STREAM b'bKGD' 41 6
b'bKGD' 41 6 (unknown)
STREAM b'IDAT' 59 58
[2m2025-05-14T23:07:35.824485[0m [[32m[1mdebug    [0m] [1mRasterizing SVG               [0m [[0m[1m[34mengine.tileset_loader[0m][0m [36mheight[0m=[35m16[0m [36mpath[0m=[35m/home/earnest/code_projects/basicrl/fonts/classic_roguelike_sliced_svgs/classic_roguelike_164.svg[0m [36mwidth[0m=[35m16[0m
STREAM b'IHDR' 16 13
STREAM b'bKGD' 41 6
b'bKGD' 41 6 (unknown)
STREAM b'IDAT' 59 59
[2m2025-05-14T23:07:35.825143[0m [[32m[1mdebug    [0m] [1mRasterizing SVG               [0m [[0m[1m[34mengine.tileset_loader[0m][0m [36mheight[0m=[35m16[0m [36mpath[0m=[35m/home/earnest/code_projects/basicrl/fonts/classic_roguelike_sliced_svgs/classic_roguelike_152.svg[0m [36mwidth[0m=[35m16[0m
STREAM b'IHDR' 16 13
STREAM b'bKGD' 41 6
b'bKGD' 41 6 (unknown)
STREAM b'IDAT' 59 67
[2m2025-05-14T23:07:35.825798[0m [[32m[1mdebug    [0m] [1mRasterizing SVG               [0m [[0m[1m[34mengine.tileset_loader[0m][0m [36mheight[0m=[35m16[0m [36mpath[0m=[35m/home/earnest/code_projects/basicrl/fonts/classic_roguelike_sliced_svgs/classic_roguelike_43.svg[0m [36mwidth[0m=[35m16[0m
STREAM b'IHDR' 16 13
STREAM b'bKGD' 41 6
b'bKGD' 41 6 (unknown)
STREAM b'IDAT' 59 75
[2m2025-05-14T23:07:35.827417[0m [[32m[1mdebug    [0m] [1mRasterizing SVG               [0m [[0m[1m[34mengine.tileset_loader[0m][0m [36mheight[0m=[35m16[0m [36mpath[0m=[35m/home/earnest/code_projects/basicrl/fonts/classic_roguelike_sliced_svgs/classic_roguelike_62.svg[0m [36mwidth[0m=[35m16[0m
STREAM b'IHDR' 16 13
STREAM b'bKGD' 41 6
b'bKGD' 41 6 (unknown)
STREAM b'IDAT' 59 69
[2m2025-05-14T23:07:35.828431[0m [[32m[1mdebug    [0m] [1mRasterizing SVG               [0m [[0m[1m[34mengine.tileset_loader[0m][0m [36mheight[0m=[35m16[0m [36mpath[0m=[35m/home/earnest/code_projects/basicrl/fonts/classic_roguelike_sliced_svgs/classic_roguelike_114.svg[0m [36mwidth[0m=[35m16[0m
STREAM b'IHDR' 16 13
STREAM b'bKGD' 41 6
b'bKGD' 41 6 (unknown)
STREAM b'IDAT' 59 44
[2m2025-05-14T23:07:35.829137[0m [[32m[1mdebug    [0m] [1mRasterizing SVG               [0m [[0m[1m[34mengine.tileset_loader[0m][0m [36mheight[0m=[35m16[0m [36mpath[0m=[35m/home/earnest/code_projects/basicrl/fonts/classic_roguelike_sliced_svgs/classic_roguelike_94.svg[0m [36mwidth[0m=[35m16[0m
STREAM b'IHDR' 16 13
STREAM b'bKGD' 41 6
b'bKGD' 41 6 (unknown)
STREAM b'IDAT' 59 70
[2m2025-05-14T23:07:35.829805[0m [[32m[1mdebug    [0m] [1mRasterizing SVG               [0m [[0m[1m[34mengine.tileset_loader[0m][0m [36mheight[0m=[35m16[0m [36mpath[0m=[35m/home/earnest/code_projects/basicrl/fonts/classic_roguelike_sliced_svgs/classic_roguelike_194.svg[0m [36mwidth[0m=[35m16[0m
STREAM b'IHDR' 16 13
STREAM b'bKGD' 41 6
b'bKGD' 41 6 (unknown)
STREAM b'IDAT' 59 56
[2m2025-05-14T23:07:35.830453[0m [[32m[1mdebug    [0m] [1mRasterizing SVG               [0m [[0m[1m[34mengine.tileset_loader[0m][0m [36mheight[0m=[35m16[0m [36mpath[0m=[35m/home/earnest/code_projects/basicrl/fonts/classic_roguelike_sliced_svgs/classic_roguelike_20.svg[0m [36mwidth[0m=[35m16[0m
STREAM b'IHDR' 16 13
STREAM b'bKGD' 41 6
b'bKGD' 41 6 (unknown)
STREAM b'IDAT' 59 60
[2m2025-05-14T23:07:35.831201[0m [[32m[1mdebug    [0m] [1mRasterizing SVG               [0m [[0m[1m[34mengine.tileset_loader[0m][0m [36mheight[0m=[35m16[0m [36mpath[0m=[35m/home/earnest/code_projects/basicrl/fonts/classic_roguelike_sliced_svgs/classic_roguelike_102.svg[0m [36mwidth[0m=[35m16[0m
STREAM b'IHDR' 16 13
STREAM b'bKGD' 41 6
b'bKGD' 41 6 (unknown)
STREAM b'IDAT' 59 59
[2m2025-05-14T23:07:35.832032[0m [[32m[1mdebug    [0m] [1mRasterizing SVG               [0m [[0m[1m[34mengine.tileset_loader[0m][0m [36mheight[0m=[35m16[0m [36mpath[0m=[35m/home/earnest/code_projects/basicrl/fonts/classic_roguelike_sliced_svgs/classic_roguelike_103.svg[0m [36mwidth[0m=[35m16[0m
STREAM b'IHDR' 16 13
STREAM b'bKGD' 41 6
b'bKGD' 41 6 (unknown)
STREAM b'IDAT' 59 51
[2m2025-05-14T23:07:35.832693[0m [[32m[1mdebug    [0m] [1mRasterizing SVG               [0m [[0m[1m[34mengine.tileset_loader[0m][0m [36mheight[0m=[35m16[0m [36mpath[0m=[35m/home/earnest/code_projects/basicrl/fonts/classic_roguelike_sliced_svgs/classic_roguelike_60.svg[0m [36mwidth[0m=[35m16[0m
STREAM b'IHDR' 16 13
STREAM b'bKGD' 41 6
b'bKGD' 41 6 (unknown)
STREAM b'IDAT' 59 53
[2m2025-05-14T23:07:35.833416[0m [[32m[1mdebug    [0m] [1mRasterizing SVG               [0m [[0m[1m[34mengine.tileset_loader[0m][0m [36mheight[0m=[35m16[0m [36mpath[0m=[35m/home/earnest/code_projects/basicrl/fonts/classic_roguelike_sliced_svgs/classic_roguelike_58.svg[0m [36mwidth[0m=[35m16[0m
STREAM b'IHDR' 16 13
STREAM b'bKGD' 41 6
b'bKGD' 41 6 (unknown)
STREAM b'IDAT' 59 56
[2m2025-05-14T23:07:35.834160[0m [[32m[1mdebug    [0m] [1mRasterizing SVG               [0m [[0m[1m[34mengine.tileset_loader[0m][0m [36mheight[0m=[35m16[0m [36mpath[0m=[35m/home/earnest/code_projects/basicrl/fonts/classic_roguelike_sliced_svgs/classic_roguelike_187.svg[0m [36mwidth[0m=[35m16[0m
STREAM b'IHDR' 16 13
STREAM b'bKGD' 41 6
b'bKGD' 41 6 (unknown)
STREAM b'IDAT' 59 49
[2m2025-05-14T23:07:35.835052[0m [[32m[1mdebug    [0m] [1mRasterizing SVG               [0m [[0m[1m[34mengine.tileset_loader[0m][0m [36mheight[0m=[35m16[0m [36mpath[0m=[35m/home/earnest/code_projects/basicrl/fonts/classic_roguelike_sliced_svgs/classic_roguelike_99.svg[0m [36mwidth[0m=[35m16[0m
STREAM b'IHDR' 16 13
STREAM b'bKGD' 41 6
b'bKGD' 41 6 (unknown)
STREAM b'IDAT' 59 74
[2m2025-05-14T23:07:35.836198[0m [[32m[1mdebug    [0m] [1mRasterizing SVG               [0m [[0m[1m[34mengine.tileset_loader[0m][0m [36mheight[0m=[35m16[0m [36mpath[0m=[35m/home/earnest/code_projects/basicrl/fonts/classic_roguelike_sliced_svgs/classic_roguelike_135.svg[0m [36mwidth[0m=[35m16[0m
STREAM b'IHDR' 16 13
STREAM b'bKGD' 41 6
b'bKGD' 41 6 (unknown)
STREAM b'IDAT' 59 39
[2m2025-05-14T23:07:35.836819[0m [[32m[1mdebug    [0m] [1mRasterizing SVG               [0m [[0m[1m[34mengine.tileset_loader[0m][0m [36mheight[0m=[35m16[0m [36mpath[0m=[35m/home/earnest/code_projects/basicrl/fonts/classic_roguelike_sliced_svgs/classic_roguelike_149.svg[0m [36mwidth[0m=[35m16[0m
STREAM b'IHDR' 16 13
STREAM b'bKGD' 41 6
b'bKGD' 41 6 (unknown)
STREAM b'IDAT' 59 60
[2m2025-05-14T23:07:35.837453[0m [[32m[1mdebug    [0m] [1mRasterizing SVG               [0m [[0m[1m[34mengine.tileset_loader[0m][0m [36mheight[0m=[35m16[0m [36mpath[0m=[35m/home/earnest/code_projects/basicrl/fonts/classic_roguelike_sliced_svgs/classic_roguelike_04.svg[0m [36mwidth[0m=[35m16[0m
STREAM b'IHDR' 16 13
STREAM b'bKGD' 41 6
b'bKGD' 41 6 (unknown)
STREAM b'IDAT' 59 44
[2m2025-05-14T23:07:35.838355[0m [[32m[1mdebug    [0m] [1mRasterizing SVG               [0m [[0m[1m[34mengine.tileset_loader[0m][0m [36mheight[0m=[35m16[0m [36mpath[0m=[35m/home/earnest/code_projects/basicrl/fonts/classic_roguelike_sliced_svgs/classic_roguelike_191.svg[0m [36mwidth[0m=[35m16[0m
STREAM b'IHDR' 16 13
STREAM b'bKGD' 41 6
b'bKGD' 41 6 (unknown)
STREAM b'IDAT' 59 38
[2m2025-05-14T23:07:35.838964[0m [[32m[1mdebug    [0m] [1mRasterizing SVG               [0m [[0m[1m[34mengine.tileset_loader[0m][0m [36mheight[0m=[35m16[0m [36mpath[0m=[35m/home/earnest/code_projects/basicrl/fonts/classic_roguelike_sliced_svgs/classic_roguelike_15.svg[0m [36mwidth[0m=[35m16[0m
STREAM b'IHDR' 16 13
STREAM b'bKGD' 41 6
b'bKGD' 41 6 (unknown)
STREAM b'IDAT' 59 57
[2m2025-05-14T23:07:35.840235[0m [[32m[1mdebug    [0m] [1mRasterizing SVG               [0m [[0m[1m[34mengine.tileset_loader[0m][0m [36mheight[0m=[35m16[0m [36mpath[0m=[35m/home/earnest/code_projects/basicrl/fonts/classic_roguelike_sliced_svgs/classic_roguelike_89.svg[0m [36mwidth[0m=[35m16[0m
STREAM b'IHDR' 16 13
STREAM b'bKGD' 41 6
b'bKGD' 41 6 (unknown)
STREAM b'IDAT' 59 69
[2m2025-05-14T23:07:35.841159[0m [[32m[1mdebug    [0m] [1mRasterizing SVG               [0m [[0m[1m[34mengine.tileset_loader[0m][0m [36mheight[0m=[35m16[0m [36mpath[0m=[35m/home/earnest/code_projects/basicrl/fonts/classic_roguelike_sliced_svgs/classic_roguelike_193.svg[0m [36mwidth[0m=[35m16[0m
STREAM b'IHDR' 16 13
STREAM b'bKGD' 41 6
b'bKGD' 41 6 (unknown)
STREAM b'IDAT' 59 37
[2m2025-05-14T23:07:35.841781[0m [[32m[1mdebug    [0m] [1mRasterizing SVG               [0m [[0m[1m[34mengine.tileset_loader[0m][0m [36mheight[0m=[35m16[0m [36mpath[0m=[35m/home/earnest/code_projects/basicrl/fonts/classic_roguelike_sliced_svgs/classic_roguelike_26.svg[0m [36mwidth[0m=[35m16[0m
STREAM b'IHDR' 16 13
STREAM b'bKGD' 41 6
b'bKGD' 41 6 (unknown)
STREAM b'IDAT' 59 28
[2m2025-05-14T23:07:35.842670[0m [[32m[1mdebug    [0m] [1mRasterizing SVG               [0m [[0m[1m[34mengine.tileset_loader[0m][0m [36mheight[0m=[35m16[0m [36mpath[0m=[35m/home/earnest/code_projects/basicrl/fonts/classic_roguelike_sliced_svgs/classic_roguelike_66.svg[0m [36mwidth[0m=[35m16[0m
STREAM b'IHDR' 16 13
STREAM b'bKGD' 41 6
b'bKGD' 41 6 (unknown)
STREAM b'IDAT' 59 66
[2m2025-05-14T23:07:35.844178[0m [[32m[1mdebug    [0m] [1mRasterizing SVG               [0m [[0m[1m[34mengine.tileset_loader[0m][0m [36mheight[0m=[35m16[0m [36mpath[0m=[35m/home/earnest/code_projects/basicrl/fonts/classic_roguelike_sliced_svgs/classic_roguelike_06.svg[0m [36mwidth[0m=[35m16[0m
STREAM b'IHDR' 16 13
STREAM b'bKGD' 41 6
b'bKGD' 41 6 (unknown)
STREAM b'IDAT' 59 68
[2m2025-05-14T23:07:35.845220[0m [[32m[1mdebug    [0m] [1mRasterizing SVG               [0m [[0m[1m[34mengine.tileset_loader[0m][0m [36mheight[0m=[35m16[0m [36mpath[0m=[35m/home/earnest/code_projects/basicrl/fonts/classic_roguelike_sliced_svgs/classic_roguelike_136.svg[0m [36mwidth[0m=[35m16[0m
STREAM b'IHDR' 16 13
STREAM b'bKGD' 41 6
b'bKGD' 41 6 (unknown)
STREAM b'IDAT' 59 40
[2m2025-05-14T23:07:35.845842[0m [[32m[1mdebug    [0m] [1mRasterizing SVG               [0m [[0m[1m[34mengine.tileset_loader[0m][0m [36mheight[0m=[35m16[0m [36mpath[0m=[35m/home/earnest/code_projects/basicrl/fonts/classic_roguelike_sliced_svgs/classic_roguelike_56.svg[0m [36mwidth[0m=[35m16[0m
STREAM b'IHDR' 16 13
STREAM b'bKGD' 41 6
b'bKGD' 41 6 (unknown)
STREAM b'IDAT' 59 60
[2m2025-05-14T23:07:35.846641[0m [[32m[1mdebug    [0m] [1mRasterizing SVG               [0m [[0m[1m[34mengine.tileset_loader[0m][0m [36mheight[0m=[35m16[0m [36mpath[0m=[35m/home/earnest/code_projects/basicrl/fonts/classic_roguelike_sliced_svgs/classic_roguelike_35.svg[0m [36mwidth[0m=[35m16[0m
STREAM b'IHDR' 16 13
STREAM b'bKGD' 41 6
b'bKGD' 41 6 (unknown)
STREAM b'IDAT' 59 50
[2m2025-05-14T23:07:35.847283[0m [[32m[1mdebug    [0m] [1mRasterizing SVG               [0m [[0m[1m[34mengine.tileset_loader[0m][0m [36mheight[0m=[35m16[0m [36mpath[0m=[35m/home/earnest/code_projects/basicrl/fonts/classic_roguelike_sliced_svgs/classic_roguelike_64.svg[0m [36mwidth[0m=[35m16[0m
STREAM b'IHDR' 16 13
STREAM b'bKGD' 41 6
b'bKGD' 41 6 (unknown)
STREAM b'IDAT' 59 70
[2m2025-05-14T23:07:35.848132[0m [[32m[1mdebug    [0m] [1mRasterizing SVG               [0m [[0m[1m[34mengine.tileset_loader[0m][0m [36mheight[0m=[35m16[0m [36mpath[0m=[35m/home/earnest/code_projects/basicrl/fonts/classic_roguelike_sliced_svgs/classic_roguelike_51.svg[0m [36mwidth[0m=[35m16[0m
STREAM b'IHDR' 16 13
STREAM b'bKGD' 41 6
b'bKGD' 41 6 (unknown)
STREAM b'IDAT' 59 54
[2m2025-05-14T23:07:35.848766[0m [[32m[1mdebug    [0m] [1mRasterizing SVG               [0m [[0m[1m[34mengine.tileset_loader[0m][0m [36mheight[0m=[35m16[0m [36mpath[0m=[35m/home/earnest/code_projects/basicrl/fonts/classic_roguelike_sliced_svgs/classic_roguelike_186.svg[0m [36mwidth[0m=[35m16[0m
STREAM b'IHDR' 16 13
STREAM b'bKGD' 41 6
b'bKGD' 41 6 (unknown)
STREAM b'IDAT' 59 60
[2m2025-05-14T23:07:35.849422[0m [[32m[1mdebug    [0m] [1mRasterizing SVG               [0m [[0m[1m[34mengine.tileset_loader[0m][0m [36mheight[0m=[35m16[0m [36mpath[0m=[35m/home/earnest/code_projects/basicrl/fonts/classic_roguelike_sliced_svgs/classic_roguelike_190.svg[0m [36mwidth[0m=[35m16[0m
STREAM b'IHDR' 16 13
STREAM b'bKGD' 41 6
b'bKGD' 41 6 (unknown)
STREAM b'IDAT' 59 48
[2m2025-05-14T23:07:35.850049[0m [[32m[1mdebug    [0m] [1mRasterizing SVG               [0m [[0m[1m[34mengine.tileset_loader[0m][0m [36mheight[0m=[35m16[0m [36mpath[0m=[35m/home/earnest/code_projects/basicrl/fonts/classic_roguelike_sliced_svgs/classic_roguelike_150.svg[0m [36mwidth[0m=[35m16[0m
STREAM b'IHDR' 16 13
STREAM b'bKGD' 41 6
b'bKGD' 41 6 (unknown)
STREAM b'IDAT' 59 63
[2m2025-05-14T23:07:35.850713[0m [[32m[1mdebug    [0m] [1mRasterizing SVG               [0m [[0m[1m[34mengine.tileset_loader[0m][0m [36mheight[0m=[35m16[0m [36mpath[0m=[35m/home/earnest/code_projects/basicrl/fonts/classic_roguelike_sliced_svgs/classic_roguelike_172.svg[0m [36mwidth[0m=[35m16[0m
STREAM b'IHDR' 16 13
STREAM b'bKGD' 41 6
b'bKGD' 41 6 (unknown)
STREAM b'IDAT' 59 63
[2m2025-05-14T23:07:35.851342[0m [[32m[1mdebug    [0m] [1mRasterizing SVG               [0m [[0m[1m[34mengine.tileset_loader[0m][0m [36mheight[0m=[35m16[0m [36mpath[0m=[35m/home/earnest/code_projects/basicrl/fonts/classic_roguelike_sliced_svgs/classic_roguelike_146.svg[0m [36mwidth[0m=[35m16[0m
STREAM b'IHDR' 16 13
STREAM b'bKGD' 41 6
b'bKGD' 41 6 (unknown)
STREAM b'IDAT' 59 68
[2m2025-05-14T23:07:35.851982[0m [[32m[1mdebug    [0m] [1mRasterizing SVG               [0m [[0m[1m[34mengine.tileset_loader[0m][0m [36mheight[0m=[35m16[0m [36mpath[0m=[35m/home/earnest/code_projects/basicrl/fonts/classic_roguelike_sliced_svgs/classic_roguelike_38.svg[0m [36mwidth[0m=[35m16[0m
STREAM b'IHDR' 16 13
STREAM b'bKGD' 41 6
b'bKGD' 41 6 (unknown)
STREAM b'IDAT' 59 55
[2m2025-05-14T23:07:35.853217[0m [[32m[1mdebug    [0m] [1mRasterizing SVG               [0m [[0m[1m[34mengine.tileset_loader[0m][0m [36mheight[0m=[35m16[0m [36mpath[0m=[35m/home/earnest/code_projects/basicrl/fonts/classic_roguelike_sliced_svgs/classic_roguelike_140.svg[0m [36mwidth[0m=[35m16[0m
STREAM b'IHDR' 16 13
STREAM b'bKGD' 41 6
b'bKGD' 41 6 (unknown)
STREAM b'IDAT' 59 59
[2m2025-05-14T23:07:35.853944[0m [[32m[1mdebug    [0m] [1mRasterizing SVG               [0m [[0m[1m[34mengine.tileset_loader[0m][0m [36mheight[0m=[35m16[0m [36mpath[0m=[35m/home/earnest/code_projects/basicrl/fonts/classic_roguelike_sliced_svgs/classic_roguelike_45.svg[0m [36mwidth[0m=[35m16[0m
STREAM b'IHDR' 16 13
STREAM b'bKGD' 41 6
b'bKGD' 41 6 (unknown)
STREAM b'IDAT' 59 38
[2m2025-05-14T23:07:35.854852[0m [[32m[1mdebug    [0m] [1mRasterizing SVG               [0m [[0m[1m[34mengine.tileset_loader[0m][0m [36mheight[0m=[35m16[0m [36mpath[0m=[35m/home/earnest/code_projects/basicrl/fonts/classic_roguelike_sliced_svgs/classic_roguelike_116.svg[0m [36mwidth[0m=[35m16[0m
STREAM b'IHDR' 16 13
STREAM b'bKGD' 41 6
b'bKGD' 41 6 (unknown)
STREAM b'IDAT' 59 76
[2m2025-05-14T23:07:35.856104[0m [[32m[1mdebug    [0m] [1mRasterizing SVG               [0m [[0m[1m[34mengine.tileset_loader[0m][0m [36mheight[0m=[35m16[0m [36mpath[0m=[35m/home/earnest/code_projects/basicrl/fonts/classic_roguelike_sliced_svgs/classic_roguelike_189.svg[0m [36mwidth[0m=[35m16[0m
STREAM b'IHDR' 16 13
STREAM b'bKGD' 41 6
b'bKGD' 41 6 (unknown)
STREAM b'IDAT' 59 49
[2m2025-05-14T23:07:35.859498[0m [[32m[1mdebug    [0m] [1mRasterizing SVG               [0m [[0m[1m[34mengine.tileset_loader[0m][0m [36mheight[0m=[35m16[0m [36mpath[0m=[35m/home/earnest/code_projects/basicrl/fonts/classic_roguelike_sliced_svgs/classic_roguelike_168.svg[0m [36mwidth[0m=[35m16[0m
STREAM b'IHDR' 16 13
STREAM b'bKGD' 41 6
b'bKGD' 41 6 (unknown)
STREAM b'IDAT' 59 45
[2m2025-05-14T23:07:35.860128[0m [[32m[1mdebug    [0m] [1mRasterizing SVG               [0m [[0m[1m[34mengine.tileset_loader[0m][0m [36mheight[0m=[35m16[0m [36mpath[0m=[35m/home/earnest/code_projects/basicrl/fonts/classic_roguelike_sliced_svgs/classic_roguelike_181.svg[0m [36mwidth[0m=[35m16[0m
STREAM b'IHDR' 16 13
STREAM b'bKGD' 41 6
b'bKGD' 41 6 (unknown)
STREAM b'IDAT' 59 64
[2m2025-05-14T23:07:35.860778[0m [[32m[1mdebug    [0m] [1mRasterizing SVG               [0m [[0m[1m[34mengine.tileset_loader[0m][0m [36mheight[0m=[35m16[0m [36mpath[0m=[35m/home/earnest/code_projects/basicrl/fonts/classic_roguelike_sliced_svgs/classic_roguelike_160.svg[0m [36mwidth[0m=[35m16[0m
STREAM b'IHDR' 16 13
STREAM b'bKGD' 41 6
b'bKGD' 41 6 (unknown)
STREAM b'IDAT' 59 54
[2m2025-05-14T23:07:35.861428[0m [[32m[1mdebug    [0m] [1mRasterizing SVG               [0m [[0m[1m[34mengine.tileset_loader[0m][0m [36mheight[0m=[35m16[0m [36mpath[0m=[35m/home/earnest/code_projects/basicrl/fonts/classic_roguelike_sliced_svgs/classic_roguelike_137.svg[0m [36mwidth[0m=[35m16[0m
STREAM b'IHDR' 16 13
STREAM b'bKGD' 41 6
b'bKGD' 41 6 (unknown)
STREAM b'IDAT' 59 39
[2m2025-05-14T23:07:35.862132[0m [[32m[1mdebug    [0m] [1mRasterizing SVG               [0m [[0m[1m[34mengine.tileset_loader[0m][0m [36mheight[0m=[35m16[0m [36mpath[0m=[35m/home/earnest/code_projects/basicrl/fonts/classic_roguelike_sliced_svgs/classic_roguelike_184.svg[0m [36mwidth[0m=[35m16[0m
STREAM b'IHDR' 16 13
STREAM b'bKGD' 41 6
b'bKGD' 41 6 (unknown)
STREAM b'IDAT' 59 70
[2m2025-05-14T23:07:35.862854[0m [[32m[1mdebug    [0m] [1mRasterizing SVG               [0m [[0m[1m[34mengine.tileset_loader[0m][0m [36mheight[0m=[35m16[0m [36mpath[0m=[35m/home/earnest/code_projects/basicrl/fonts/classic_roguelike_sliced_svgs/classic_roguelike_74.svg[0m [36mwidth[0m=[35m16[0m
STREAM b'IHDR' 16 13
STREAM b'bKGD' 41 6
b'bKGD' 41 6 (unknown)
STREAM b'IDAT' 59 71
[2m2025-05-14T23:07:35.863691[0m [[32m[1mdebug    [0m] [1mRasterizing SVG               [0m [[0m[1m[34mengine.tileset_loader[0m][0m [36mheight[0m=[35m16[0m [36mpath[0m=[35m/home/earnest/code_projects/basicrl/fonts/classic_roguelike_sliced_svgs/classic_roguelike_170.svg[0m [36mwidth[0m=[35m16[0m
STREAM b'IHDR' 16 13
STREAM b'bKGD' 41 6
b'bKGD' 41 6 (unknown)
STREAM b'IDAT' 59 53
[2m2025-05-14T23:07:35.864343[0m [[32m[1mdebug    [0m] [1mRasterizing SVG               [0m [[0m[1m[34mengine.tileset_loader[0m][0m [36mheight[0m=[35m16[0m [36mpath[0m=[35m/home/earnest/code_projects/basicrl/fonts/classic_roguelike_sliced_svgs/classic_roguelike_115.svg[0m [36mwidth[0m=[35m16[0m
STREAM b'IHDR' 16 13
STREAM b'bKGD' 41 6
b'bKGD' 41 6 (unknown)
STREAM b'IDAT' 59 64
[2m2025-05-14T23:07:35.865018[0m [[32m[1mdebug    [0m] [1mRasterizing SVG               [0m [[0m[1m[34mengine.tileset_loader[0m][0m [36mheight[0m=[35m16[0m [36mpath[0m=[35m/home/earnest/code_projects/basicrl/fonts/classic_roguelike_sliced_svgs/classic_roguelike_142.svg[0m [36mwidth[0m=[35m16[0m
STREAM b'IHDR' 16 13
STREAM b'bKGD' 41 6
b'bKGD' 41 6 (unknown)
STREAM b'IDAT' 59 62
[2m2025-05-14T23:07:35.865680[0m [[32m[1mdebug    [0m] [1mRasterizing SVG               [0m [[0m[1m[34mengine.tileset_loader[0m][0m [36mheight[0m=[35m16[0m [36mpath[0m=[35m/home/earnest/code_projects/basicrl/fonts/classic_roguelike_sliced_svgs/classic_roguelike_86.svg[0m [36mwidth[0m=[35m16[0m
STREAM b'IHDR' 16 13
STREAM b'bKGD' 41 6
b'bKGD' 41 6 (unknown)
STREAM b'IDAT' 59 78
[2m2025-05-14T23:07:35.866612[0m [[32m[1mdebug    [0m] [1mRasterizing SVG               [0m [[0m[1m[34mengine.tileset_loader[0m][0m [36mheight[0m=[35m16[0m [36mpath[0m=[35m/home/earnest/code_projects/basicrl/fonts/classic_roguelike_sliced_svgs/classic_roguelike_70.svg[0m [36mwidth[0m=[35m16[0m
STREAM b'IHDR' 16 13
STREAM b'bKGD' 41 6
b'bKGD' 41 6 (unknown)
STREAM b'IDAT' 59 61
[2m2025-05-14T23:07:35.867261[0m [[32m[1mdebug    [0m] [1mRasterizing SVG               [0m [[0m[1m[34mengine.tileset_loader[0m][0m [36mheight[0m=[35m16[0m [36mpath[0m=[35m/home/earnest/code_projects/basicrl/fonts/classic_roguelike_sliced_svgs/classic_roguelike_144.svg[0m [36mwidth[0m=[35m16[0m
STREAM b'IHDR' 16 13
STREAM b'bKGD' 41 6
b'bKGD' 41 6 (unknown)
STREAM b'IDAT' 59 56
[2m2025-05-14T23:07:35.867894[0m [[32m[1mdebug    [0m] [1mRasterizing SVG               [0m [[0m[1m[34mengine.tileset_loader[0m][0m [36mheight[0m=[35m16[0m [36mpath[0m=[35m/home/earnest/code_projects/basicrl/fonts/classic_roguelike_sliced_svgs/classic_roguelike_82.svg[0m [36mwidth[0m=[35m16[0m
STREAM b'IHDR' 16 13
STREAM b'bKGD' 41 6
b'bKGD' 41 6 (unknown)
STREAM b'IDAT' 59 65
[2m2025-05-14T23:07:35.868953[0m [[32m[1mdebug    [0m] [1mRasterizing SVG               [0m [[0m[1m[34mengine.tileset_loader[0m][0m [36mheight[0m=[35m16[0m [36mpath[0m=[35m/home/earnest/code_projects/basicrl/fonts/classic_roguelike_sliced_svgs/classic_roguelike_134.svg[0m [36mwidth[0m=[35m16[0m
STREAM b'IHDR' 16 13
STREAM b'bKGD' 41 6
b'bKGD' 41 6 (unknown)
STREAM b'IDAT' 59 59
[2m2025-05-14T23:07:35.869625[0m [[32m[1mdebug    [0m] [1mRasterizing SVG               [0m [[0m[1m[34mengine.tileset_loader[0m][0m [36mheight[0m=[35m16[0m [36mpath[0m=[35m/home/earnest/code_projects/basicrl/fonts/classic_roguelike_sliced_svgs/classic_roguelike_22.svg[0m [36mwidth[0m=[35m16[0m
STREAM b'IHDR' 16 13
STREAM b'bKGD' 41 6
b'bKGD' 41 6 (unknown)
STREAM b'IDAT' 59 48
[2m2025-05-14T23:07:35.870250[0m [[32m[1mdebug    [0m] [1mRasterizing SVG               [0m [[0m[1m[34mengine.tileset_loader[0m][0m [36mheight[0m=[35m16[0m [36mpath[0m=[35m/home/earnest/code_projects/basicrl/fonts/classic_roguelike_sliced_svgs/classic_roguelike_121.svg[0m [36mwidth[0m=[35m16[0m
STREAM b'IHDR' 16 13
STREAM b'bKGD' 41 6
b'bKGD' 41 6 (unknown)
STREAM b'IDAT' 59 45
[2m2025-05-14T23:07:35.870882[0m [[32m[1mdebug    [0m] [1mRasterizing SVG               [0m [[0m[1m[34mengine.tileset_loader[0m][0m [36mheight[0m=[35m16[0m [36mpath[0m=[35m/home/earnest/code_projects/basicrl/fonts/classic_roguelike_sliced_svgs/classic_roguelike_46.svg[0m [36mwidth[0m=[35m16[0m
STREAM b'IHDR' 16 13
STREAM b'bKGD' 41 6
b'bKGD' 41 6 (unknown)
STREAM b'IDAT' 59 40
[2m2025-05-14T23:07:35.871769[0m [[32m[1mdebug    [0m] [1mRasterizing SVG               [0m [[0m[1m[34mengine.tileset_loader[0m][0m [36mheight[0m=[35m16[0m [36mpath[0m=[35m/home/earnest/code_projects/basicrl/fonts/classic_roguelike_sliced_svgs/classic_roguelike_13.svg[0m [36mwidth[0m=[35m16[0m
STREAM b'IHDR' 16 13
STREAM b'bKGD' 41 6
b'bKGD' 41 6 (unknown)
STREAM b'IDAT' 59 18
[2m2025-05-14T23:07:35.872259[0m [[32m[1mdebug    [0m] [1mRasterizing SVG               [0m [[0m[1m[34mengine.tileset_loader[0m][0m [36mheight[0m=[35m16[0m [36mpath[0m=[35m/home/earnest/code_projects/basicrl/fonts/classic_roguelike_sliced_svgs/classic_roguelike_59.svg[0m [36mwidth[0m=[35m16[0m
STREAM b'IHDR' 16 13
STREAM b'bKGD' 41 6
b'bKGD' 41 6 (unknown)
STREAM b'IDAT' 59 58
[2m2025-05-14T23:07:35.872887[0m [[32m[1mdebug    [0m] [1mRasterizing SVG               [0m [[0m[1m[34mengine.tileset_loader[0m][0m [36mheight[0m=[35m16[0m [36mpath[0m=[35m/home/earnest/code_projects/basicrl/fonts/classic_roguelike_sliced_svgs/classic_roguelike_79.svg[0m [36mwidth[0m=[35m16[0m
STREAM b'IHDR' 16 13
STREAM b'bKGD' 41 6
b'bKGD' 41 6 (unknown)
STREAM b'IDAT' 59 60
[2m2025-05-14T23:07:35.873598[0m [[32m[1mdebug    [0m] [1mRasterizing SVG               [0m [[0m[1m[34mengine.tileset_loader[0m][0m [36mheight[0m=[35m16[0m [36mpath[0m=[35m/home/earnest/code_projects/basicrl/fonts/classic_roguelike_sliced_svgs/classic_roguelike_183.svg[0m [36mwidth[0m=[35m16[0m
STREAM b'IHDR' 16 13
STREAM b'bKGD' 41 6
b'bKGD' 41 6 (unknown)
STREAM b'IDAT' 59 62
[2m2025-05-14T23:07:35.874220[0m [[32m[1mdebug    [0m] [1mRasterizing SVG               [0m [[0m[1m[34mengine.tileset_loader[0m][0m [36mheight[0m=[35m16[0m [36mpath[0m=[35m/home/earnest/code_projects/basicrl/fonts/classic_roguelike_sliced_svgs/classic_roguelike_109.svg[0m [36mwidth[0m=[35m16[0m
STREAM b'IHDR' 16 13
STREAM b'bKGD' 41 6
b'bKGD' 41 6 (unknown)
STREAM b'IDAT' 59 68
[2m2025-05-14T23:07:35.875162[0m [[32m[1mdebug    [0m] [1mRasterizing SVG               [0m [[0m[1m[34mengine.tileset_loader[0m][0m [36mheight[0m=[35m16[0m [36mpath[0m=[35m/home/earnest/code_projects/basicrl/fonts/classic_roguelike_sliced_svgs/classic_roguelike_42.svg[0m [36mwidth[0m=[35m16[0m
STREAM b'IHDR' 16 13
STREAM b'bKGD' 41 6
b'bKGD' 41 6 (unknown)
STREAM b'IDAT' 59 38
[2m2025-05-14T23:07:35.875863[0m [[32m[1mdebug    [0m] [1mRasterizing SVG               [0m [[0m[1m[34mengine.tileset_loader[0m][0m [36mheight[0m=[35m16[0m [36mpath[0m=[35m/home/earnest/code_projects/basicrl/fonts/classic_roguelike_sliced_svgs/classic_roguelike_90.svg[0m [36mwidth[0m=[35m16[0m
STREAM b'IHDR' 16 13
STREAM b'bKGD' 41 6
b'bKGD' 41 6 (unknown)
STREAM b'IDAT' 59 66
[2m2025-05-14T23:07:35.876778[0m [[32m[1mdebug    [0m] [1mRasterizing SVG               [0m [[0m[1m[34mengine.tileset_loader[0m][0m [36mheight[0m=[35m16[0m [36mpath[0m=[35m/home/earnest/code_projects/basicrl/fonts/classic_roguelike_sliced_svgs/classic_roguelike_85.svg[0m [36mwidth[0m=[35m16[0m
STREAM b'IHDR' 16 13
STREAM b'bKGD' 41 6
b'bKGD' 41 6 (unknown)
STREAM b'IDAT' 59 68
[2m2025-05-14T23:07:35.877709[0m [[32m[1mdebug    [0m] [1mRasterizing SVG               [0m [[0m[1m[34mengine.tileset_loader[0m][0m [36mheight[0m=[35m16[0m [36mpath[0m=[35m/home/earnest/code_projects/basicrl/fonts/classic_roguelike_sliced_svgs/classic_roguelike_153.svg[0m [36mwidth[0m=[35m16[0m
STREAM b'IHDR' 16 13
STREAM b'bKGD' 41 6
b'bKGD' 41 6 (unknown)
STREAM b'IDAT' 59 67
[2m2025-05-14T23:07:35.878347[0m [[32m[1mdebug    [0m] [1mRasterizing SVG               [0m [[0m[1m[34mengine.tileset_loader[0m][0m [36mheight[0m=[35m16[0m [36mpath[0m=[35m/home/earnest/code_projects/basicrl/fonts/classic_roguelike_sliced_svgs/classic_roguelike_73.svg[0m [36mwidth[0m=[35m16[0m
STREAM b'IHDR' 16 13
STREAM b'bKGD' 41 6
b'bKGD' 41 6 (unknown)
STREAM b'IDAT' 59 62
[2m2025-05-14T23:07:35.879526[0m [[32m[1mdebug    [0m] [1mRasterizing SVG               [0m [[0m[1m[34mengine.tileset_loader[0m][0m [36mheight[0m=[35m16[0m [36mpath[0m=[35m/home/earnest/code_projects/basicrl/fonts/classic_roguelike_sliced_svgs/classic_roguelike_111.svg[0m [36mwidth[0m=[35m16[0m
STREAM b'IHDR' 16 13
STREAM b'bKGD' 41 6
b'bKGD' 41 6 (unknown)
STREAM b'IDAT' 59 55
[2m2025-05-14T23:07:35.880166[0m [[32m[1mdebug    [0m] [1mRasterizing SVG               [0m [[0m[1m[34mengine.tileset_loader[0m][0m [36mheight[0m=[35m16[0m [36mpath[0m=[35m/home/earnest/code_projects/basicrl/fonts/classic_roguelike_sliced_svgs/classic_roguelike_154.svg[0m [36mwidth[0m=[35m16[0m
STREAM b'IHDR' 16 13
STREAM b'bKGD' 41 6
b'bKGD' 41 6 (unknown)
STREAM b'IDAT' 59 49
[2m2025-05-14T23:07:35.880817[0m [[32m[1mdebug    [0m] [1mRasterizing SVG               [0m [[0m[1m[34mengine.tileset_loader[0m][0m [36mheight[0m=[35m16[0m [36mpath[0m=[35m/home/earnest/code_projects/basicrl/fonts/classic_roguelike_sliced_svgs/classic_roguelike_81.svg[0m [36mwidth[0m=[35m16[0m
STREAM b'IHDR' 16 13
STREAM b'bKGD' 41 6
b'bKGD' 41 6 (unknown)
STREAM b'IDAT' 59 72
[2m2025-05-14T23:07:35.882083[0m [[32m[1mdebug    [0m] [1mRasterizing SVG               [0m [[0m[1m[34mengine.tileset_loader[0m][0m [36mheight[0m=[35m16[0m [36mpath[0m=[35m/home/earnest/code_projects/basicrl/fonts/classic_roguelike_sliced_svgs/classic_roguelike_138.svg[0m [36mwidth[0m=[35m16[0m
STREAM b'IHDR' 16 13
STREAM b'bKGD' 41 6
b'bKGD' 41 6 (unknown)
STREAM b'IDAT' 59 60
[2m2025-05-14T23:07:35.882832[0m [[32m[1mdebug    [0m] [1mRasterizing SVG               [0m [[0m[1m[34mengine.tileset_loader[0m][0m [36mheight[0m=[35m16[0m [36mpath[0m=[35m/home/earnest/code_projects/basicrl/fonts/classic_roguelike_sliced_svgs/classic_roguelike_61.svg[0m [36mwidth[0m=[35m16[0m
STREAM b'IHDR' 16 13
STREAM b'bKGD' 41 6
b'bKGD' 41 6 (unknown)
STREAM b'IDAT' 59 70
[2m2025-05-14T23:07:35.883998[0m [[32m[1mdebug    [0m] [1mRasterizing SVG               [0m [[0m[1m[34mengine.tileset_loader[0m][0m [36mheight[0m=[35m16[0m [36mpath[0m=[35m/home/earnest/code_projects/basicrl/fonts/classic_roguelike_sliced_svgs/classic_roguelike_14.svg[0m [36mwidth[0m=[35m16[0m
STREAM b'IHDR' 16 13
STREAM b'bKGD' 41 6
b'bKGD' 41 6 (unknown)
STREAM b'IDAT' 59 50
[2m2025-05-14T23:07:35.885248[0m [[32m[1mdebug    [0m] [1mRasterizing SVG               [0m [[0m[1m[34mengine.tileset_loader[0m][0m [36mheight[0m=[35m16[0m [36mpath[0m=[35m/home/earnest/code_projects/basicrl/fonts/classic_roguelike_sliced_svgs/classic_roguelike_167.svg[0m [36mwidth[0m=[35m16[0m
STREAM b'IHDR' 16 13
STREAM b'bKGD' 41 6
b'bKGD' 41 6 (unknown)
STREAM b'IDAT' 59 54
[2m2025-05-14T23:07:35.885899[0m [[32m[1mdebug    [0m] [1mRasterizing SVG               [0m [[0m[1m[34mengine.tileset_loader[0m][0m [36mheight[0m=[35m16[0m [36mpath[0m=[35m/home/earnest/code_projects/basicrl/fonts/classic_roguelike_sliced_svgs/classic_roguelike_108.svg[0m [36mwidth[0m=[35m16[0m
STREAM b'IHDR' 16 13
STREAM b'bKGD' 41 6
b'bKGD' 41 6 (unknown)
STREAM b'IDAT' 59 72
[2m2025-05-14T23:07:35.887003[0m [[32m[1mdebug    [0m] [1mRasterizing SVG               [0m [[0m[1m[34mengine.tileset_loader[0m][0m [36mheight[0m=[35m16[0m [36mpath[0m=[35m/home/earnest/code_projects/basicrl/fonts/classic_roguelike_sliced_svgs/classic_roguelike_107.svg[0m [36mwidth[0m=[35m16[0m
STREAM b'IHDR' 16 13
STREAM b'bKGD' 41 6
b'bKGD' 41 6 (unknown)
STREAM b'IDAT' 59 60
[2m2025-05-14T23:07:35.887678[0m [[32m[1mdebug    [0m] [1mRasterizing SVG               [0m [[0m[1m[34mengine.tileset_loader[0m][0m [36mheight[0m=[35m16[0m [36mpath[0m=[35m/home/earnest/code_projects/basicrl/fonts/classic_roguelike_sliced_svgs/classic_roguelike_63.svg[0m [36mwidth[0m=[35m16[0m
STREAM b'IHDR' 16 13
STREAM b'bKGD' 41 6
b'bKGD' 41 6 (unknown)
STREAM b'IDAT' 59 70
[2m2025-05-14T23:07:35.888595[0m [[32m[1mdebug    [0m] [1mRasterizing SVG               [0m [[0m[1m[34mengine.tileset_loader[0m][0m [36mheight[0m=[35m16[0m [36mpath[0m=[35m/home/earnest/code_projects/basicrl/fonts/classic_roguelike_sliced_svgs/classic_roguelike_31.svg[0m [36mwidth[0m=[35m16[0m
STREAM b'IHDR' 16 13
STREAM b'bKGD' 41 6
b'bKGD' 41 6 (unknown)
STREAM b'IDAT' 59 48
[2m2025-05-14T23:07:35.889327[0m [[32m[1mdebug    [0m] [1mRasterizing SVG               [0m [[0m[1m[34mengine.tileset_loader[0m][0m [36mheight[0m=[35m16[0m [36mpath[0m=[35m/home/earnest/code_projects/basicrl/fonts/classic_roguelike_sliced_svgs/classic_roguelike_188.svg[0m [36mwidth[0m=[35m16[0m
STREAM b'IHDR' 16 13
STREAM b'bKGD' 41 6
b'bKGD' 41 6 (unknown)
STREAM b'IDAT' 59 32
[2m2025-05-14T23:07:35.891509[0m [[32m[1mdebug    [0m] [1mRasterizing SVG               [0m [[0m[1m[34mengine.tileset_loader[0m][0m [36mheight[0m=[35m16[0m [36mpath[0m=[35m/home/earnest/code_projects/basicrl/fonts/classic_roguelike_sliced_svgs/classic_roguelike_93.svg[0m [36mwidth[0m=[35m16[0m
STREAM b'IHDR' 16 13
STREAM b'bKGD' 41 6
b'bKGD' 41 6 (unknown)
STREAM b'IDAT' 59 44
[2m2025-05-14T23:07:35.893127[0m [[32m[1mdebug    [0m] [1mRasterizing SVG               [0m [[0m[1m[34mengine.tileset_loader[0m][0m [36mheight[0m=[35m16[0m [36mpath[0m=[35m/home/earnest/code_projects/basicrl/fonts/classic_roguelike_sliced_svgs/classic_roguelike_120.svg[0m [36mwidth[0m=[35m16[0m
STREAM b'IHDR' 16 13
STREAM b'bKGD' 41 6
b'bKGD' 41 6 (unknown)
STREAM b'IDAT' 59 45
[2m2025-05-14T23:07:35.893770[0m [[32m[1mdebug    [0m] [1mRasterizing SVG               [0m [[0m[1m[34mengine.tileset_loader[0m][0m [36mheight[0m=[35m16[0m [36mpath[0m=[35m/home/earnest/code_projects/basicrl/fonts/classic_roguelike_sliced_svgs/classic_roguelike_182.svg[0m [36mwidth[0m=[35m16[0m
STREAM b'IHDR' 16 13
STREAM b'bKGD' 41 6
b'bKGD' 41 6 (unknown)
STREAM b'IDAT' 59 62
[2m2025-05-14T23:07:35.894396[0m [[32m[1mdebug    [0m] [1mRasterizing SVG               [0m [[0m[1m[34mengine.tileset_loader[0m][0m [36mheight[0m=[35m16[0m [36mpath[0m=[35m/home/earnest/code_projects/basicrl/fonts/classic_roguelike_sliced_svgs/classic_roguelike_19.svg[0m [36mwidth[0m=[35m16[0m
STREAM b'IHDR' 16 13
STREAM b'bKGD' 41 6
b'bKGD' 41 6 (unknown)
STREAM b'IDAT' 59 52
[2m2025-05-14T23:07:35.895065[0m [[32m[1mdebug    [0m] [1mRasterizing SVG               [0m [[0m[1m[34mengine.tileset_loader[0m][0m [36mheight[0m=[35m16[0m [36mpath[0m=[35m/home/earnest/code_projects/basicrl/fonts/classic_roguelike_sliced_svgs/classic_roguelike_148.svg[0m [36mwidth[0m=[35m16[0m
STREAM b'IHDR' 16 13
STREAM b'bKGD' 41 6
b'bKGD' 41 6 (unknown)
STREAM b'IDAT' 59 47
[2m2025-05-14T23:07:35.895702[0m [[32m[1mdebug    [0m] [1mRasterizing SVG               [0m [[0m[1m[34mengine.tileset_loader[0m][0m [36mheight[0m=[35m16[0m [36mpath[0m=[35m/home/earnest/code_projects/basicrl/fonts/classic_roguelike_sliced_svgs/classic_roguelike_122.svg[0m [36mwidth[0m=[35m16[0m
STREAM b'IHDR' 16 13
STREAM b'bKGD' 41 6
b'bKGD' 41 6 (unknown)
STREAM b'IDAT' 59 35
[2m2025-05-14T23:07:35.896308[0m [[32m[1mdebug    [0m] [1mRasterizing SVG               [0m [[0m[1m[34mengine.tileset_loader[0m][0m [36mheight[0m=[35m16[0m [36mpath[0m=[35m/home/earnest/code_projects/basicrl/fonts/classic_roguelike_sliced_svgs/classic_roguelike_125.svg[0m [36mwidth[0m=[35m16[0m
STREAM b'IHDR' 16 13
STREAM b'bKGD' 41 6
b'bKGD' 41 6 (unknown)
STREAM b'IDAT' 59 38
[2m2025-05-14T23:07:35.896906[0m [[32m[1mdebug    [0m] [1mRasterizing SVG               [0m [[0m[1m[34mengine.tileset_loader[0m][0m [36mheight[0m=[35m16[0m [36mpath[0m=[35m/home/earnest/code_projects/basicrl/fonts/classic_roguelike_sliced_svgs/classic_roguelike_143.svg[0m [36mwidth[0m=[35m16[0m
STREAM b'IHDR' 16 13
STREAM b'bKGD' 41 6
b'bKGD' 41 6 (unknown)
STREAM b'IDAT' 59 47
[2m2025-05-14T23:07:35.897520[0m [[32m[1mdebug    [0m] [1mRasterizing SVG               [0m [[0m[1m[34mengine.tileset_loader[0m][0m [36mheight[0m=[35m16[0m [36mpath[0m=[35m/home/earnest/code_projects/basicrl/fonts/classic_roguelike_sliced_svgs/classic_roguelike_80.svg[0m [36mwidth[0m=[35m16[0m
STREAM b'IHDR' 16 13
STREAM b'bKGD' 41 6
b'bKGD' 41 6 (unknown)
STREAM b'IDAT' 59 72
[2m2025-05-14T23:07:35.898367[0m [[32m[1mdebug    [0m] [1mRasterizing SVG               [0m [[0m[1m[34mengine.tileset_loader[0m][0m [36mheight[0m=[35m16[0m [36mpath[0m=[35m/home/earnest/code_projects/basicrl/fonts/classic_roguelike_sliced_svgs/classic_roguelike_141.svg[0m [36mwidth[0m=[35m16[0m
STREAM b'IHDR' 16 13
STREAM b'bKGD' 41 6
b'bKGD' 41 6 (unknown)
STREAM b'IDAT' 59 50
[2m2025-05-14T23:07:35.899021[0m [[32m[1mdebug    [0m] [1mRasterizing SVG               [0m [[0m[1m[34mengine.tileset_loader[0m][0m [36mheight[0m=[35m16[0m [36mpath[0m=[35m/home/earnest/code_projects/basicrl/fonts/classic_roguelike_sliced_svgs/classic_roguelike_84.svg[0m [36mwidth[0m=[35m16[0m
STREAM b'IHDR' 16 13
STREAM b'bKGD' 41 6
b'bKGD' 41 6 (unknown)
STREAM b'IDAT' 59 62
[2m2025-05-14T23:07:35.900095[0m [[32m[1mdebug    [0m] [1mRasterizing SVG               [0m [[0m[1m[34mengine.tileset_loader[0m][0m [36mheight[0m=[35m16[0m [36mpath[0m=[35m/home/earnest/code_projects/basicrl/fonts/classic_roguelike_sliced_svgs/classic_roguelike_112.svg[0m [36mwidth[0m=[35m16[0m
STREAM b'IHDR' 16 13
STREAM b'bKGD' 41 6
b'bKGD' 41 6 (unknown)
STREAM b'IDAT' 59 42
[2m2025-05-14T23:07:35.900792[0m [[32m[1mdebug    [0m] [1mRasterizing SVG               [0m [[0m[1m[34mengine.tileset_loader[0m][0m [36mheight[0m=[35m16[0m [36mpath[0m=[35m/home/earnest/code_projects/basicrl/fonts/classic_roguelike_sliced_svgs/classic_roguelike_169.svg[0m [36mwidth[0m=[35m16[0m
STREAM b'IHDR' 16 13
STREAM b'bKGD' 41 6
b'bKGD' 41 6 (unknown)
STREAM b'IDAT' 59 64
[2m2025-05-14T23:07:35.901422[0m [[32m[1mdebug    [0m] [1mRasterizing SVG               [0m [[0m[1m[34mengine.tileset_loader[0m][0m [36mheight[0m=[35m16[0m [36mpath[0m=[35m/home/earnest/code_projects/basicrl/fonts/classic_roguelike_sliced_svgs/classic_roguelike_174.svg[0m [36mwidth[0m=[35m16[0m
STREAM b'IHDR' 16 13
STREAM b'bKGD' 41 6
b'bKGD' 41 6 (unknown)
STREAM b'IDAT' 59 63
[2m2025-05-14T23:07:35.902060[0m [[32m[1mdebug    [0m] [1mRasterizing SVG               [0m [[0m[1m[34mengine.tileset_loader[0m][0m [36mheight[0m=[35m16[0m [36mpath[0m=[35m/home/earnest/code_projects/basicrl/fonts/classic_roguelike_sliced_svgs/classic_roguelike_23.svg[0m [36mwidth[0m=[35m16[0m
STREAM b'IHDR' 16 13
STREAM b'bKGD' 41 6
b'bKGD' 41 6 (unknown)
STREAM b'IDAT' 59 65
[2m2025-05-14T23:07:35.903147[0m [[32m[1mdebug    [0m] [1mRasterizing SVG               [0m [[0m[1m[34mengine.tileset_loader[0m][0m [36mheight[0m=[35m16[0m [36mpath[0m=[35m/home/earnest/code_projects/basicrl/fonts/classic_roguelike_sliced_svgs/classic_roguelike_130.svg[0m [36mwidth[0m=[35m16[0m
STREAM b'IHDR' 16 13
STREAM b'bKGD' 41 6
b'bKGD' 41 6 (unknown)
STREAM b'IDAT' 59 53
[2m2025-05-14T23:07:35.923310[0m [[32m[1mdebug    [0m] [1mRasterizing SVG               [0m [[0m[1m[34mengine.tileset_loader[0m][0m [36mheight[0m=[35m16[0m [36mpath[0m=[35m/home/earnest/code_projects/basicrl/fonts/classic_roguelike_sliced_svgs/classic_roguelike_165.svg[0m [36mwidth[0m=[35m16[0m
STREAM b'IHDR' 16 13
STREAM b'bKGD' 41 6
b'bKGD' 41 6 (unknown)
STREAM b'IDAT' 59 64
[2m2025-05-14T23:07:35.924028[0m [[32m[1mdebug    [0m] [1mRasterizing SVG               [0m [[0m[1m[34mengine.tileset_loader[0m][0m [36mheight[0m=[35m16[0m [36mpath[0m=[35m/home/earnest/code_projects/basicrl/fonts/classic_roguelike_sliced_svgs/classic_roguelike_95.svg[0m [36mwidth[0m=[35m16[0m
STREAM b'IHDR' 16 13
STREAM b'bKGD' 41 6
b'bKGD' 41 6 (unknown)
STREAM b'IDAT' 59 70
[2m2025-05-14T23:07:35.924787[0m [[32m[1mdebug    [0m] [1mRasterizing SVG               [0m [[0m[1m[34mengine.tileset_loader[0m][0m [36mheight[0m=[35m16[0m [36mpath[0m=[35m/home/earnest/code_projects/basicrl/fonts/classic_roguelike_sliced_svgs/classic_roguelike_50.svg[0m [36mwidth[0m=[35m16[0m
STREAM b'IHDR' 16 13
STREAM b'bKGD' 41 6
b'bKGD' 41 6 (unknown)
STREAM b'IDAT' 59 50
[2m2025-05-14T23:07:35.925686[0m [[32m[1mdebug    [0m] [1mRasterizing SVG               [0m [[0m[1m[34mengine.tileset_loader[0m][0m [36mheight[0m=[35m16[0m [36mpath[0m=[35m/home/earnest/code_projects/basicrl/fonts/classic_roguelike_sliced_svgs/classic_roguelike_29.svg[0m [36mwidth[0m=[35m16[0m
STREAM b'IHDR' 16 13
STREAM b'bKGD' 41 6
b'bKGD' 41 6 (unknown)
STREAM b'IDAT' 59 55
[2m2025-05-14T23:07:35.927052[0m [[32m[1mdebug    [0m] [1mRasterizing SVG               [0m [[0m[1m[34mengine.tileset_loader[0m][0m [36mheight[0m=[35m16[0m [36mpath[0m=[35m/home/earnest/code_projects/basicrl/fonts/classic_roguelike_sliced_svgs/classic_roguelike_98.svg[0m [36mwidth[0m=[35m16[0m
STREAM b'IHDR' 16 13
STREAM b'bKGD' 41 6
b'bKGD' 41 6 (unknown)
STREAM b'IDAT' 59 61
[2m2025-05-14T23:07:35.927808[0m [[32m[1mdebug    [0m] [1mRasterizing SVG               [0m [[0m[1m[34mengine.tileset_loader[0m][0m [36mheight[0m=[35m16[0m [36mpath[0m=[35m/home/earnest/code_projects/basicrl/fonts/classic_roguelike_sliced_svgs/classic_roguelike_151.svg[0m [36mwidth[0m=[35m16[0m
STREAM b'IHDR' 16 13
STREAM b'bKGD' 41 6
b'bKGD' 41 6 (unknown)
STREAM b'IDAT' 59 50
[2m2025-05-14T23:07:35.928414[0m [[32m[1mdebug    [0m] [1mRasterizing SVG               [0m [[0m[1m[34mengine.tileset_loader[0m][0m [36mheight[0m=[35m16[0m [36mpath[0m=[35m/home/earnest/code_projects/basicrl/fonts/classic_roguelike_sliced_svgs/classic_roguelike_67.svg[0m [36mwidth[0m=[35m16[0m
STREAM b'IHDR' 16 13
STREAM b'bKGD' 41 6
b'bKGD' 41 6 (unknown)
STREAM b'IDAT' 59 67
[2m2025-05-14T23:07:35.929968[0m [[32m[1mdebug    [0m] [1mRasterizing SVG               [0m [[0m[1m[34mengine.tileset_loader[0m][0m [36mheight[0m=[35m16[0m [36mpath[0m=[35m/home/earnest/code_projects/basicrl/fonts/classic_roguelike_sliced_svgs/classic_roguelike_76.svg[0m [36mwidth[0m=[35m16[0m
STREAM b'IHDR' 16 13
STREAM b'bKGD' 41 6
b'bKGD' 41 6 (unknown)
STREAM b'IDAT' 59 69
[2m2025-05-14T23:07:35.930825[0m [[32m[1mdebug    [0m] [1mRasterizing SVG               [0m [[0m[1m[34mengine.tileset_loader[0m][0m [36mheight[0m=[35m16[0m [36mpath[0m=[35m/home/earnest/code_projects/basicrl/fonts/classic_roguelike_sliced_svgs/classic_roguelike_171.svg[0m [36mwidth[0m=[35m16[0m
STREAM b'IHDR' 16 13
STREAM b'bKGD' 41 6
b'bKGD' 41 6 (unknown)
STREAM b'IDAT' 59 71
[2m2025-05-14T23:07:35.931471[0m [[32m[1mdebug    [0m] [1mRasterizing SVG               [0m [[0m[1m[34mengine.tileset_loader[0m][0m [36mheight[0m=[35m16[0m [36mpath[0m=[35m/home/earnest/code_projects/basicrl/fonts/classic_roguelike_sliced_svgs/classic_roguelike_53.svg[0m [36mwidth[0m=[35m16[0m
STREAM b'IHDR' 16 13
STREAM b'bKGD' 41 6
b'bKGD' 41 6 (unknown)
STREAM b'IDAT' 59 57
[2m2025-05-14T23:07:35.932116[0m [[32m[1mdebug    [0m] [1mRasterizing SVG               [0m [[0m[1m[34mengine.tileset_loader[0m][0m [36mheight[0m=[35m16[0m [36mpath[0m=[35m/home/earnest/code_projects/basicrl/fonts/classic_roguelike_sliced_svgs/classic_roguelike_100.svg[0m [36mwidth[0m=[35m16[0m
STREAM b'IHDR' 16 13
STREAM b'bKGD' 41 6
b'bKGD' 41 6 (unknown)
STREAM b'IDAT' 59 65
[2m2025-05-14T23:07:35.933478[0m [[32m[1mdebug    [0m] [1mRasterizing SVG               [0m [[0m[1m[34mengine.tileset_loader[0m][0m [36mheight[0m=[35m16[0m [36mpath[0m=[35m/home/earnest/code_projects/basicrl/fonts/classic_roguelike_sliced_svgs/classic_roguelike_54.svg[0m [36mwidth[0m=[35m16[0m
STREAM b'IHDR' 16 13
STREAM b'bKGD' 41 6
b'bKGD' 41 6 (unknown)
STREAM b'IDAT' 59 50
[2m2025-05-14T23:07:35.934278[0m [[32m[1mdebug    [0m] [1mRasterizing SVG               [0m [[0m[1m[34mengine.tileset_loader[0m][0m [36mheight[0m=[35m16[0m [36mpath[0m=[35m/home/earnest/code_projects/basicrl/fonts/classic_roguelike_sliced_svgs/classic_roguelike_176.svg[0m [36mwidth[0m=[35m16[0m
STREAM b'IHDR' 16 13
STREAM b'bKGD' 41 6
b'bKGD' 41 6 (unknown)
STREAM b'IDAT' 59 59
[2m2025-05-14T23:07:35.934952[0m [[32m[1mdebug    [0m] [1mRasterizing SVG               [0m [[0m[1m[34mengine.tileset_loader[0m][0m [36mheight[0m=[35m16[0m [36mpath[0m=[35m/home/earnest/code_projects/basicrl/fonts/classic_roguelike_sliced_svgs/classic_roguelike_69.svg[0m [36mwidth[0m=[35m16[0m
STREAM b'IHDR' 16 13
STREAM b'bKGD' 41 6
b'bKGD' 41 6 (unknown)
STREAM b'IDAT' 59 60
[2m2025-05-14T23:07:35.936113[0m [[32m[1mdebug    [0m] [1mRasterizing SVG               [0m [[0m[1m[34mengine.tileset_loader[0m][0m [36mheight[0m=[35m16[0m [36mpath[0m=[35m/home/earnest/code_projects/basicrl/fonts/classic_roguelike_sliced_svgs/classic_roguelike_173.svg[0m [36mwidth[0m=[35m16[0m
STREAM b'IHDR' 16 13
STREAM b'bKGD' 41 6
b'bKGD' 41 6 (unknown)
STREAM b'IDAT' 59 56
[2m2025-05-14T23:07:35.936771[0m [[32m[1mdebug    [0m] [1mRasterizing SVG               [0m [[0m[1m[34mengine.tileset_loader[0m][0m [36mheight[0m=[35m16[0m [36mpath[0m=[35m/home/earnest/code_projects/basicrl/fonts/classic_roguelike_sliced_svgs/classic_roguelike_159.svg[0m [36mwidth[0m=[35m16[0m
STREAM b'IHDR' 16 13
STREAM b'bKGD' 41 6
b'bKGD' 41 6 (unknown)
STREAM b'IDAT' 59 49
[2m2025-05-14T23:07:35.937385[0m [[32m[1mdebug    [0m] [1mRasterizing SVG               [0m [[0m[1m[34mengine.tileset_loader[0m][0m [36mheight[0m=[35m16[0m [36mpath[0m=[35m/home/earnest/code_projects/basicrl/fonts/classic_roguelike_sliced_svgs/classic_roguelike_161.svg[0m [36mwidth[0m=[35m16[0m
STREAM b'IHDR' 16 13
STREAM b'bKGD' 41 6
b'bKGD' 41 6 (unknown)
STREAM b'IDAT' 59 60
[2m2025-05-14T23:07:35.938059[0m [[32m[1mdebug    [0m] [1mRasterizing SVG               [0m [[0m[1m[34mengine.tileset_loader[0m][0m [36mheight[0m=[35m16[0m [36mpath[0m=[35m/home/earnest/code_projects/basicrl/fonts/classic_roguelike_sliced_svgs/classic_roguelike_55.svg[0m [36mwidth[0m=[35m16[0m
STREAM b'IHDR' 16 13
STREAM b'bKGD' 41 6
b'bKGD' 41 6 (unknown)
STREAM b'IDAT' 59 54
[2m2025-05-14T23:07:35.938854[0m [[32m[1mdebug    [0m] [1mRasterizing SVG               [0m [[0m[1m[34mengine.tileset_loader[0m][0m [36mheight[0m=[35m16[0m [36mpath[0m=[35m/home/earnest/code_projects/basicrl/fonts/classic_roguelike_sliced_svgs/classic_roguelike_139.svg[0m [36mwidth[0m=[35m16[0m
STREAM b'IHDR' 16 13
STREAM b'bKGD' 41 6
b'bKGD' 41 6 (unknown)
STREAM b'IDAT' 59 61
[2m2025-05-14T23:07:35.939596[0m [[32m[1mdebug    [0m] [1mRasterizing SVG               [0m [[0m[1m[34mengine.tileset_loader[0m][0m [36mheight[0m=[35m16[0m [36mpath[0m=[35m/home/earnest/code_projects/basicrl/fonts/classic_roguelike_sliced_svgs/classic_roguelike_44.svg[0m [36mwidth[0m=[35m16[0m
STREAM b'IHDR' 16 13
STREAM b'bKGD' 41 6
b'bKGD' 41 6 (unknown)
STREAM b'IDAT' 59 48
[2m2025-05-14T23:07:35.941280[0m [[32m[1mdebug    [0m] [1mRasterizing SVG               [0m [[0m[1m[34mengine.tileset_loader[0m][0m [36mheight[0m=[35m16[0m [36mpath[0m=[35m/home/earnest/code_projects/basicrl/fonts/classic_roguelike_sliced_svgs/classic_roguelike_91.svg[0m [36mwidth[0m=[35m16[0m
STREAM b'IHDR' 16 13
STREAM b'bKGD' 41 6
b'bKGD' 41 6 (unknown)
STREAM b'IDAT' 59 73
[2m2025-05-14T23:07:35.942301[0m [[32m[1mdebug    [0m] [1mRasterizing SVG               [0m [[0m[1m[34mengine.tileset_loader[0m][0m [36mheight[0m=[35m16[0m [36mpath[0m=[35m/home/earnest/code_projects/basicrl/fonts/classic_roguelike_sliced_svgs/classic_roguelike_106.svg[0m [36mwidth[0m=[35m16[0m
STREAM b'IHDR' 16 13
STREAM b'bKGD' 41 6
b'bKGD' 41 6 (unknown)
STREAM b'IDAT' 59 59
[2m2025-05-14T23:07:35.943044[0m [[32m[1mdebug    [0m] [1mRasterizing SVG               [0m [[0m[1m[34mengine.tileset_loader[0m][0m [36mheight[0m=[35m16[0m [36mpath[0m=[35m/home/earnest/code_projects/basicrl/fonts/classic_roguelike_sliced_svgs/classic_roguelike_175.svg[0m [36mwidth[0m=[35m16[0m
STREAM b'IHDR' 16 13
STREAM b'bKGD' 41 6
b'bKGD' 41 6 (unknown)
STREAM b'IDAT' 59 54
[2m2025-05-14T23:07:35.943727[0m [[32m[1mdebug    [0m] [1mRasterizing SVG               [0m [[0m[1m[34mengine.tileset_loader[0m][0m [36mheight[0m=[35m16[0m [36mpath[0m=[35m/home/earnest/code_projects/basicrl/fonts/classic_roguelike_sliced_svgs/classic_roguelike_78.svg[0m [36mwidth[0m=[35m16[0m
STREAM b'IHDR' 16 13
STREAM b'bKGD' 41 6
b'bKGD' 41 6 (unknown)
STREAM b'IDAT' 59 70
[2m2025-05-14T23:07:35.945110[0m [[32m[1mdebug    [0m] [1mRasterizing SVG               [0m [[0m[1m[34mengine.tileset_loader[0m][0m [36mheight[0m=[35m16[0m [36mpath[0m=[35m/home/earnest/code_projects/basicrl/fonts/classic_roguelike_sliced_svgs/classic_roguelike_77.svg[0m [36mwidth[0m=[35m16[0m
STREAM b'IHDR' 16 13
STREAM b'bKGD' 41 6
b'bKGD' 41 6 (unknown)
STREAM b'IDAT' 59 63
[2m2025-05-14T23:07:35.945774[0m [[32m[1minfo     [0m] [1mSVG rasterization complete    [0m [[0m[1m[34mengine.tileset_loader[0m][0m [36mcount[0m=[35m195[0m
[2m2025-05-14T23:07:35.945812[0m [[32m[1minfo     [0m] [1mTileset loading finished      [0m [[0m[1m[34mengine.tileset_loader[0m][0m [36mpath[0m=[35m/home/earnest/code_projects/basicrl/fonts/classic_roguelike_sliced_svgs[0m [36mpng_count[0m=[35m0[0m [36msvg_count[0m=[35m195[0m [36mtotal_tiles[0m=[35m195[0m
[2m2025-05-14T23:07:35.945867[0m [[32m[1mdebug    [0m] [1mUpdating tile array cache (Numba typed.Dict & render data)...[0m [[0m[1m[34mengine.window_manager_modules.tileset_manager[0m][0m
[2m2025-05-14T23:07:35.946025[0m [[32m[1mdebug    [0m] [1mTile render cache populated   [0m [[0m[1m[34mengine.window_manager_modules.tileset_manager[0m][0m [36marray_size[0m=[35m2[0m [36mbg_shape[0m=[35m(2, 3)[0m [36mfg_shape[0m=[35m(2, 3)[0m [36midx_shape[0m=[35m(2,)[0m [36mloaded_ids[0m=[35m2[0m [36mmax_id[0m=[35m1[0m
bytecode dump:
>          0	NOP(arg=None, lineno=32)
           2	RESUME(arg=0, lineno=32)
           4	LOAD_FAST(arg=2, lineno=34)
           6	LOAD_FAST(arg=0, lineno=34)
           8	LOAD_FAST(arg=1, lineno=34)
          10	STORE_SUBSCR(arg=None, lineno=34)
          14	LOAD_CONST(arg=0, lineno=34)
          16	RETURN_VALUE(arg=None, lineno=34)
pending: deque([State(pc_initial=0 nstack_initial=0)])
stack: []
state.pc_initial: State(pc_initial=0 nstack_initial=0)
dispatch pc=0, inst=NOP(arg=None, lineno=32)
stack []
dispatch pc=2, inst=RESUME(arg=0, lineno=32)
stack []
dispatch pc=4, inst=LOAD_FAST(arg=2, lineno=34)
stack []
dispatch pc=6, inst=LOAD_FAST(arg=0, lineno=34)
stack ['$value4.0']
dispatch pc=8, inst=LOAD_FAST(arg=1, lineno=34)
stack ['$value4.0', '$d6.1']
dispatch pc=10, inst=STORE_SUBSCR(arg=None, lineno=34)
stack ['$value4.0', '$d6.1', '$key8.2']
dispatch pc=14, inst=LOAD_CONST(arg=0, lineno=34)
stack []
dispatch pc=16, inst=RETURN_VALUE(arg=None, lineno=34)
stack ['$const14.3.0']
end state. edges=[]
-------------------------Prune PHIs-------------------------
Used_phis: defaultdict(<class 'set'>, {State(pc_initial=0 nstack_initial=0): set()})
defmap: {}
phismap: defaultdict(<class 'set'>, {})
changing phismap: defaultdict(<class 'set'>, {})
keep phismap: {}
new_out: defaultdict(<class 'dict'>, {})
----------------------DONE Prune PHIs-----------------------
block_infos State(pc_initial=0 nstack_initial=0):
AdaptBlockInfo(insts=((0, {}), (2, {}), (4, {'res': '$value4.0'}), (6, {'res': '$d6.1'}), (8, {'res': '$key8.2'}), (10, {'target': '$d6.1', 'index': '$key8.2', 'value': '$value4.0'}), (12, {}), (14, {'res': '$const14.3.0'}), (16, {'retval': '$const14.3.0', 'castval': '$16return_value.4'})), outgoing_phis={}, blockstack=(), active_try_block=None, outgoing_edgepushed={})
label 0:
    d = arg(0, name=d)                       ['d']
    key = arg(1, name=key)                   ['key']
    value = arg(2, name=value)               ['value']
    d[key] = value                           ['d', 'key', 'value']
    $const14.3.0 = const(NoneType, None)     ['$const14.3.0']
    $16return_value.4 = cast(value=$const14.3.0) ['$16return_value.4', '$const14.3.0']
    return $16return_value.4                 ['$16return_value.4']

==== SSA block analysis pass on 0
Running <numba.core.ssa._GatherDefsHandler object at 0x7f61a6d180d0>
on stmt: d = arg(0, name=d)
on stmt: key = arg(1, name=key)
on stmt: value = arg(2, name=value)
on stmt: d[key] = value
on stmt: $const14.3.0 = const(NoneType, None)
on stmt: $16return_value.4 = cast(value=$const14.3.0)
on stmt: return $16return_value.4
defs defaultdict(<class 'list'>,
            {'$16return_value.4': [(<numba.core.ir.Assign object at 0x7f61c00caa10>,
                                    0)],
             '$const14.3.0': [(<numba.core.ir.Assign object at 0x7f61c00ca9d0>,
                               0)],
             'd': [(<numba.core.ir.Assign object at 0x7f61c00e3150>, 0)],
             'key': [(<numba.core.ir.Assign object at 0x7f61c00e2710>, 0)],
             'value': [(<numba.core.ir.Assign object at 0x7f61c00e28d0>, 0)]})
SSA violators <numba.core.utils.OrderedSet object at 0x7f61a6d180d0>
bytecode dump:
>          0	NOP(arg=None, lineno=714)
           2	COPY_FREE_VARS(arg=2, lineno=714)
           4	RESUME(arg=0, lineno=714)
           6	LOAD_GLOBAL(arg=1, lineno=715)
          18	LOAD_FAST(arg=1, lineno=715)
          20	LOAD_DEREF(arg=6, lineno=715)
          22	PRECALL(arg=2, lineno=715)
          26	CALL(arg=2, lineno=715)
          36	STORE_FAST(arg=3, lineno=715)
          38	LOAD_GLOBAL(arg=1, lineno=716)
          50	LOAD_FAST(arg=2, lineno=716)
          52	LOAD_DEREF(arg=7, lineno=716)
          54	PRECALL(arg=2, lineno=716)
          58	CALL(arg=2, lineno=716)
          68	STORE_FAST(arg=4, lineno=716)
          70	LOAD_GLOBAL(arg=3, lineno=717)
          82	LOAD_FAST(arg=0, lineno=717)
          84	LOAD_FAST(arg=3, lineno=717)
          86	LOAD_GLOBAL(arg=5, lineno=717)
          98	LOAD_FAST(arg=3, lineno=717)
         100	PRECALL(arg=1, lineno=717)
         104	CALL(arg=1, lineno=717)
         114	LOAD_FAST(arg=4, lineno=717)
         116	PRECALL(arg=4, lineno=717)
         120	CALL(arg=4, lineno=717)
         130	STORE_FAST(arg=5, lineno=717)
         132	LOAD_FAST(arg=5, lineno=718)
         134	LOAD_GLOBAL(arg=6, lineno=718)
         146	LOAD_ATTR(arg=4, lineno=718)
         156	COMPARE_OP(arg=2, lineno=718)
         162	POP_JUMP_FORWARD_IF_FALSE(arg=2, lineno=718)
         164	LOAD_CONST(arg=0, lineno=719)
         166	RETURN_VALUE(arg=None, lineno=719)
>        168	LOAD_FAST(arg=5, lineno=720)
         170	LOAD_GLOBAL(arg=6, lineno=720)
         182	LOAD_ATTR(arg=5, lineno=720)
         192	COMPARE_OP(arg=2, lineno=720)
         198	POP_JUMP_FORWARD_IF_FALSE(arg=2, lineno=720)
         200	LOAD_CONST(arg=0, lineno=723)
         202	RETURN_VALUE(arg=None, lineno=723)
>        204	LOAD_FAST(arg=5, lineno=724)
         206	LOAD_GLOBAL(arg=6, lineno=724)
         218	LOAD_ATTR(arg=6, lineno=724)
         228	COMPARE_OP(arg=2, lineno=724)
         234	POP_JUMP_FORWARD_IF_FALSE(arg=15, lineno=724)
         236	LOAD_GLOBAL(arg=15, lineno=725)
         248	LOAD_CONST(arg=1, lineno=725)
         250	PRECALL(arg=1, lineno=725)
         254	CALL(arg=1, lineno=725)
         264	RAISE_VARARGS(arg=1, lineno=725)
>        266	LOAD_GLOBAL(arg=17, lineno=727)
         278	LOAD_CONST(arg=2, lineno=727)
         280	PRECALL(arg=1, lineno=727)
         284	CALL(arg=1, lineno=727)
         294	RAISE_VARARGS(arg=1, lineno=727)
pending: deque([State(pc_initial=0 nstack_initial=0)])
stack: []
state.pc_initial: State(pc_initial=0 nstack_initial=0)
dispatch pc=0, inst=NOP(arg=None, lineno=714)
stack []
dispatch pc=2, inst=COPY_FREE_VARS(arg=2, lineno=714)
stack []
dispatch pc=4, inst=RESUME(arg=0, lineno=714)
stack []
dispatch pc=6, inst=LOAD_GLOBAL(arg=1, lineno=715)
stack []
dispatch pc=18, inst=LOAD_FAST(arg=1, lineno=715)
stack ['$null$6.1', '$6load_global.0']
dispatch pc=20, inst=LOAD_DEREF(arg=6, lineno=715)
stack ['$null$6.1', '$6load_global.0', '$key18.2']
dispatch pc=22, inst=PRECALL(arg=2, lineno=715)
stack ['$null$6.1', '$6load_global.0', '$key18.2', '$20load_deref.3']
dispatch pc=26, inst=CALL(arg=2, lineno=715)
stack ['$null$6.1', '$6load_global.0', '$key18.2', '$20load_deref.3']
dispatch pc=36, inst=STORE_FAST(arg=3, lineno=715)
stack ['$26call.4']
dispatch pc=38, inst=LOAD_GLOBAL(arg=1, lineno=716)
stack []
dispatch pc=50, inst=LOAD_FAST(arg=2, lineno=716)
stack ['$null$38.6', '$38load_global.5']
dispatch pc=52, inst=LOAD_DEREF(arg=7, lineno=716)
stack ['$null$38.6', '$38load_global.5', '$value50.7']
dispatch pc=54, inst=PRECALL(arg=2, lineno=716)
stack ['$null$38.6', '$38load_global.5', '$value50.7', '$52load_deref.8']
dispatch pc=58, inst=CALL(arg=2, lineno=716)
stack ['$null$38.6', '$38load_global.5', '$value50.7', '$52load_deref.8']
dispatch pc=68, inst=STORE_FAST(arg=4, lineno=716)
stack ['$58call.9']
dispatch pc=70, inst=LOAD_GLOBAL(arg=3, lineno=717)
stack []
dispatch pc=82, inst=LOAD_FAST(arg=0, lineno=717)
stack ['$null$70.11', '$70load_global.10']
dispatch pc=84, inst=LOAD_FAST(arg=3, lineno=717)
stack ['$null$70.11', '$70load_global.10', '$d82.12']
dispatch pc=86, inst=LOAD_GLOBAL(arg=5, lineno=717)
stack ['$null$70.11', '$70load_global.10', '$d82.12', '$castedkey84.13']
dispatch pc=98, inst=LOAD_FAST(arg=3, lineno=717)
stack ['$null$70.11', '$70load_global.10', '$d82.12', '$castedkey84.13', '$null$86.15', '$86load_global.14']
dispatch pc=100, inst=PRECALL(arg=1, lineno=717)
stack ['$null$70.11', '$70load_global.10', '$d82.12', '$castedkey84.13', '$null$86.15', '$86load_global.14', '$castedkey98.16']
dispatch pc=104, inst=CALL(arg=1, lineno=717)
stack ['$null$70.11', '$70load_global.10', '$d82.12', '$castedkey84.13', '$null$86.15', '$86load_global.14', '$castedkey98.16']
dispatch pc=114, inst=LOAD_FAST(arg=4, lineno=717)
stack ['$null$70.11', '$70load_global.10', '$d82.12', '$castedkey84.13', '$104call.17']
dispatch pc=116, inst=PRECALL(arg=4, lineno=717)
stack ['$null$70.11', '$70load_global.10', '$d82.12', '$castedkey84.13', '$104call.17', '$castedval114.18']
dispatch pc=120, inst=CALL(arg=4, lineno=717)
stack ['$null$70.11', '$70load_global.10', '$d82.12', '$castedkey84.13', '$104call.17', '$castedval114.18']
dispatch pc=130, inst=STORE_FAST(arg=5, lineno=717)
stack ['$120call.19']
dispatch pc=132, inst=LOAD_FAST(arg=5, lineno=718)
stack []
dispatch pc=134, inst=LOAD_GLOBAL(arg=6, lineno=718)
stack ['$status132.20']
dispatch pc=146, inst=LOAD_ATTR(arg=4, lineno=718)
stack ['$status132.20', '$134load_global.21']
dispatch pc=156, inst=COMPARE_OP(arg=2, lineno=718)
stack ['$status132.20', '$146load_attr.22']
dispatch pc=162, inst=POP_JUMP_FORWARD_IF_FALSE(arg=2, lineno=718)
stack ['$156compare_op.23']
end state. edges=[Edge(pc=164, stack=(), blockstack=(), npush=0), Edge(pc=168, stack=(), blockstack=(), npush=0)]
pending: deque([State(pc_initial=164 nstack_initial=0), State(pc_initial=168 nstack_initial=0)])
stack: []
state.pc_initial: State(pc_initial=164 nstack_initial=0)
dispatch pc=164, inst=LOAD_CONST(arg=0, lineno=719)
stack []
dispatch pc=166, inst=RETURN_VALUE(arg=None, lineno=719)
stack ['$const164.0.0']
end state. edges=[]
pending: deque([State(pc_initial=168 nstack_initial=0)])
stack: []
state.pc_initial: State(pc_initial=168 nstack_initial=0)
dispatch pc=168, inst=LOAD_FAST(arg=5, lineno=720)
stack []
dispatch pc=170, inst=LOAD_GLOBAL(arg=6, lineno=720)
stack ['$status168.0']
dispatch pc=182, inst=LOAD_ATTR(arg=5, lineno=720)
stack ['$status168.0', '$170load_global.1']
dispatch pc=192, inst=COMPARE_OP(arg=2, lineno=720)
stack ['$status168.0', '$182load_attr.2']
dispatch pc=198, inst=POP_JUMP_FORWARD_IF_FALSE(arg=2, lineno=720)
stack ['$192compare_op.3']
end state. edges=[Edge(pc=200, stack=(), blockstack=(), npush=0), Edge(pc=204, stack=(), blockstack=(), npush=0)]
pending: deque([State(pc_initial=200 nstack_initial=0), State(pc_initial=204 nstack_initial=0)])
stack: []
state.pc_initial: State(pc_initial=200 nstack_initial=0)
dispatch pc=200, inst=LOAD_CONST(arg=0, lineno=723)
stack []
dispatch pc=202, inst=RETURN_VALUE(arg=None, lineno=723)
stack ['$const200.0.0']
end state. edges=[]
pending: deque([State(pc_initial=204 nstack_initial=0)])
stack: []
state.pc_initial: State(pc_initial=204 nstack_initial=0)
dispatch pc=204, inst=LOAD_FAST(arg=5, lineno=724)
stack []
dispatch pc=206, inst=LOAD_GLOBAL(arg=6, lineno=724)
stack ['$status204.0']
dispatch pc=218, inst=LOAD_ATTR(arg=6, lineno=724)
stack ['$status204.0', '$206load_global.1']
dispatch pc=228, inst=COMPARE_OP(arg=2, lineno=724)
stack ['$status204.0', '$218load_attr.2']
dispatch pc=234, inst=POP_JUMP_FORWARD_IF_FALSE(arg=15, lineno=724)
stack ['$228compare_op.3']
end state. edges=[Edge(pc=236, stack=(), blockstack=(), npush=0), Edge(pc=266, stack=(), blockstack=(), npush=0)]
pending: deque([State(pc_initial=236 nstack_initial=0), State(pc_initial=266 nstack_initial=0)])
stack: []
state.pc_initial: State(pc_initial=236 nstack_initial=0)
dispatch pc=236, inst=LOAD_GLOBAL(arg=15, lineno=725)
stack []
dispatch pc=248, inst=LOAD_CONST(arg=1, lineno=725)
stack ['$null$236.1', '$236load_global.0']
dispatch pc=250, inst=PRECALL(arg=1, lineno=725)
stack ['$null$236.1', '$236load_global.0', '$const248.2.1']
dispatch pc=254, inst=CALL(arg=1, lineno=725)
stack ['$null$236.1', '$236load_global.0', '$const248.2.1']
dispatch pc=264, inst=RAISE_VARARGS(arg=1, lineno=725)
stack ['$254call.3']
end state. edges=[]
pending: deque([State(pc_initial=266 nstack_initial=0)])
stack: []
state.pc_initial: State(pc_initial=266 nstack_initial=0)
dispatch pc=266, inst=LOAD_GLOBAL(arg=17, lineno=727)
stack []
dispatch pc=278, inst=LOAD_CONST(arg=2, lineno=727)
stack ['$null$266.1', '$266load_global.0']
dispatch pc=280, inst=PRECALL(arg=1, lineno=727)
stack ['$null$266.1', '$266load_global.0', '$const278.2.2']
dispatch pc=284, inst=CALL(arg=1, lineno=727)
stack ['$null$266.1', '$266load_global.0', '$const278.2.2']
dispatch pc=294, inst=RAISE_VARARGS(arg=1, lineno=727)
stack ['$284call.3']
end state. edges=[]
-------------------------Prune PHIs-------------------------
Used_phis: defaultdict(<class 'set'>,
            {State(pc_initial=0 nstack_initial=0): set(),
             State(pc_initial=164 nstack_initial=0): set(),
             State(pc_initial=168 nstack_initial=0): set(),
             State(pc_initial=200 nstack_initial=0): set(),
             State(pc_initial=204 nstack_initial=0): set(),
             State(pc_initial=236 nstack_initial=0): set(),
             State(pc_initial=266 nstack_initial=0): set()})
defmap: {}
phismap: defaultdict(<class 'set'>, {})
changing phismap: defaultdict(<class 'set'>, {})
keep phismap: {}
new_out: defaultdict(<class 'dict'>, {})
----------------------DONE Prune PHIs-----------------------
block_infos State(pc_initial=0 nstack_initial=0):
AdaptBlockInfo(insts=((0, {}), (2, {}), (4, {}), (6, {'idx': 0, 'res': '$6load_global.0'}), (8, {}), (10, {}), (12, {}), (14, {}), (16, {}), (18, {'res': '$key18.2'}), (20, {'res': '$20load_deref.3'}), (22, {}), (24, {}), (26, {'func': '$6load_global.0', 'args': ['$key18.2', '$20load_deref.3'], 'kw_names': None, 'res': '$26call.4'}), (28, {}), (30, {}), (32, {}), (34, {}), (36, {'value': '$26call.4'}), (38, {'idx': 0, 'res': '$38load_global.5'}), (40, {}), (42, {}), (44, {}), (46, {}), (48, {}), (50, {'res': '$value50.7'}), (52, {'res': '$52load_deref.8'}), (54, {}), (56, {}), (58, {'func': '$38load_global.5', 'args': ['$value50.7', '$52load_deref.8'], 'kw_names': None, 'res': '$58call.9'}), (60, {}), (62, {}), (64, {}), (66, {}), (68, {'value': '$58call.9'}), (70, {'idx': 1, 'res': '$70load_global.10'}), (72, {}), (74, {}), (76, {}), (78, {}), (80, {}), (82, {'res': '$d82.12'}), (84, {'res': '$castedkey84.13'}), (86, {'idx': 2, 'res': '$86load_global.14'}), (88, {}), (90, {}), (92, {}), (94, {}), (96, {}), (98, {'res': '$castedkey98.16'}), (100, {}), (102, {}), (104, {'func': '$86load_global.14', 'args': ['$castedkey98.16'], 'kw_names': None, 'res': '$104call.17'}), (106, {}), (108, {}), (110, {}), (112, {}), (114, {'res': '$castedval114.18'}), (116, {}), (118, {}), (120, {'func': '$70load_global.10', 'args': ['$d82.12', '$castedkey84.13', '$104call.17', '$castedval114.18'], 'kw_names': None, 'res': '$120call.19'}), (122, {}), (124, {}), (126, {}), (128, {}), (130, {'value': '$120call.19'}), (132, {'res': '$status132.20'}), (134, {'idx': 3, 'res': '$134load_global.21'}), (136, {}), (138, {}), (140, {}), (142, {}), (144, {}), (146, {'item': '$134load_global.21', 'res': '$146load_attr.22'}), (148, {}), (150, {}), (152, {}), (154, {}), (156, {'lhs': '$status132.20', 'rhs': '$146load_attr.22', 'res': '$156compare_op.23'}), (158, {}), (160, {}), (162, {'pred': '$156compare_op.23'})), outgoing_phis={}, blockstack=(), active_try_block=None, outgoing_edgepushed={164: (), 168: ()})
block_infos State(pc_initial=164 nstack_initial=0):
AdaptBlockInfo(insts=((164, {'res': '$const164.0.0'}), (166, {'retval': '$const164.0.0', 'castval': '$166return_value.1'})), outgoing_phis={}, blockstack=(), active_try_block=None, outgoing_edgepushed={})
block_infos State(pc_initial=168 nstack_initial=0):
AdaptBlockInfo(insts=((168, {'res': '$status168.0'}), (170, {'idx': 3, 'res': '$170load_global.1'}), (172, {}), (174, {}), (176, {}), (178, {}), (180, {}), (182, {'item': '$170load_global.1', 'res': '$182load_attr.2'}), (184, {}), (186, {}), (188, {}), (190, {}), (192, {'lhs': '$status168.0', 'rhs': '$182load_attr.2', 'res': '$192compare_op.3'}), (194, {}), (196, {}), (198, {'pred': '$192compare_op.3'})), outgoing_phis={}, blockstack=(), active_try_block=None, outgoing_edgepushed={200: (), 204: ()})
block_infos State(pc_initial=200 nstack_initial=0):
AdaptBlockInfo(insts=((200, {'res': '$const200.0.0'}), (202, {'retval': '$const200.0.0', 'castval': '$202return_value.1'})), outgoing_phis={}, blockstack=(), active_try_block=None, outgoing_edgepushed={})
block_infos State(pc_initial=204 nstack_initial=0):
AdaptBlockInfo(insts=((204, {'res': '$status204.0'}), (206, {'idx': 3, 'res': '$206load_global.1'}), (208, {}), (210, {}), (212, {}), (214, {}), (216, {}), (218, {'item': '$206load_global.1', 'res': '$218load_attr.2'}), (220, {}), (222, {}), (224, {}), (226, {}), (228, {'lhs': '$status204.0', 'rhs': '$218load_attr.2', 'res': '$228compare_op.3'}), (230, {}), (232, {}), (234, {'pred': '$228compare_op.3'})), outgoing_phis={}, blockstack=(), active_try_block=None, outgoing_edgepushed={236: (), 266: ()})
block_infos State(pc_initial=236 nstack_initial=0):
AdaptBlockInfo(insts=((236, {'idx': 7, 'res': '$236load_global.0'}), (238, {}), (240, {}), (242, {}), (244, {}), (246, {}), (248, {'res': '$const248.2.1'}), (250, {}), (252, {}), (254, {'func': '$236load_global.0', 'args': ['$const248.2.1'], 'kw_names': None, 'res': '$254call.3'}), (256, {}), (258, {}), (260, {}), (262, {}), (264, {'exc': '$254call.3'})), outgoing_phis={}, blockstack=(), active_try_block=None, outgoing_edgepushed={})
block_infos State(pc_initial=266 nstack_initial=0):
AdaptBlockInfo(insts=((266, {'idx': 8, 'res': '$266load_global.0'}), (268, {}), (270, {}), (272, {}), (274, {}), (276, {}), (278, {'res': '$const278.2.2'}), (280, {}), (282, {}), (284, {'func': '$266load_global.0', 'args': ['$const278.2.2'], 'kw_names': None, 'res': '$284call.3'}), (286, {}), (288, {}), (290, {}), (292, {}), (294, {'exc': '$284call.3'})), outgoing_phis={}, blockstack=(), active_try_block=None, outgoing_edgepushed={})
label 0:
    d = arg(0, name=d)                       ['d']
    key = arg(1, name=key)                   ['key']
    value = arg(2, name=value)               ['value']
    $6load_global.0 = global(_cast: <intrinsic _cast>) ['$6load_global.0']
    $20load_deref.3 = freevar(keyty: int64)  ['$20load_deref.3']
    castedkey = call $6load_global.0(key, $20load_deref.3, func=$6load_global.0, args=[Var(key, dictobject.py:714), Var($20load_deref.3, dictobject.py:715)], kws=(), vararg=None, varkwarg=None, target=None) ['$20load_deref.3', '$6load_global.0', 'castedkey', 'key']
    $38load_global.5 = global(_cast: <intrinsic _cast>) ['$38load_global.5']
    $52load_deref.8 = freevar(valty: array(uint8, 3d, C)) ['$52load_deref.8']
    castedval = call $38load_global.5(value, $52load_deref.8, func=$38load_global.5, args=[Var(value, dictobject.py:714), Var($52load_deref.8, dictobject.py:716)], kws=(), vararg=None, varkwarg=None, target=None) ['$38load_global.5', '$52load_deref.8', 'castedval', 'value']
    $70load_global.10 = global(_dict_insert: <intrinsic _dict_insert>) ['$70load_global.10']
    $86load_global.14 = global(hash: <built-in function hash>) ['$86load_global.14']
    $104call.17 = call $86load_global.14(castedkey, func=$86load_global.14, args=[Var(castedkey, dictobject.py:715)], kws=(), vararg=None, varkwarg=None, target=None) ['$104call.17', '$86load_global.14', 'castedkey']
    status = call $70load_global.10(d, castedkey, $104call.17, castedval, func=$70load_global.10, args=[Var(d, dictobject.py:714), Var(castedkey, dictobject.py:715), Var($104call.17, dictobject.py:717), Var(castedval, dictobject.py:716)], kws=(), vararg=None, varkwarg=None, target=None) ['$104call.17', '$70load_global.10', 'castedkey', 'castedval', 'd', 'status']
    $134load_global.21 = global(Status: <enum 'Status'>) ['$134load_global.21']
    $146load_attr.22 = getattr(value=$134load_global.21, attr=OK) ['$134load_global.21', '$146load_attr.22']
    $156compare_op.23 = status == $146load_attr.22 ['$146load_attr.22', '$156compare_op.23', 'status']
    bool162 = global(bool: <class 'bool'>)   ['bool162']
    $162pred = call bool162($156compare_op.23, func=bool162, args=(Var($156compare_op.23, dictobject.py:718),), kws=(), vararg=None, varkwarg=None, target=None) ['$156compare_op.23', '$162pred', 'bool162']
    branch $162pred, 164, 168                ['$162pred']
label 164:
    $const164.0.0 = const(NoneType, None)    ['$const164.0.0']
    $166return_value.1 = cast(value=$const164.0.0) ['$166return_value.1', '$const164.0.0']
    return $166return_value.1                ['$166return_value.1']
label 168:
    $170load_global.1 = global(Status: <enum 'Status'>) ['$170load_global.1']
    $182load_attr.2 = getattr(value=$170load_global.1, attr=OK_REPLACED) ['$170load_global.1', '$182load_attr.2']
    $192compare_op.3 = status == $182load_attr.2 ['$182load_attr.2', '$192compare_op.3', 'status']
    bool198 = global(bool: <class 'bool'>)   ['bool198']
    $198pred = call bool198($192compare_op.3, func=bool198, args=(Var($192compare_op.3, dictobject.py:720),), kws=(), vararg=None, varkwarg=None, target=None) ['$192compare_op.3', '$198pred', 'bool198']
    branch $198pred, 200, 204                ['$198pred']
label 200:
    $const200.0.0 = const(NoneType, None)    ['$const200.0.0']
    $202return_value.1 = cast(value=$const200.0.0) ['$202return_value.1', '$const200.0.0']
    return $202return_value.1                ['$202return_value.1']
label 204:
    $206load_global.1 = global(Status: <enum 'Status'>) ['$206load_global.1']
    $218load_attr.2 = getattr(value=$206load_global.1, attr=ERR_CMP_FAILED) ['$206load_global.1', '$218load_attr.2']
    $228compare_op.3 = status == $218load_attr.2 ['$218load_attr.2', '$228compare_op.3', 'status']
    bool234 = global(bool: <class 'bool'>)   ['bool234']
    $234pred = call bool234($228compare_op.3, func=bool234, args=(Var($228compare_op.3, dictobject.py:724),), kws=(), vararg=None, varkwarg=None, target=None) ['$228compare_op.3', '$234pred', 'bool234']
    branch $234pred, 236, 266                ['$234pred']
label 236:
    $236load_global.0 = global(ValueError: <class 'ValueError'>) ['$236load_global.0']
    $const248.2.1 = const(str, key comparison failed) ['$const248.2.1']
    $254call.3 = call $236load_global.0($const248.2.1, func=$236load_global.0, args=[Var($const248.2.1, dictobject.py:725)], kws=(), vararg=None, varkwarg=None, target=None) ['$236load_global.0', '$254call.3', '$const248.2.1']
    raise $254call.3                         ['$254call.3']
label 266:
    $266load_global.0 = global(RuntimeError: <class 'RuntimeError'>) ['$266load_global.0']
    $const278.2.2 = const(str, dict.__setitem__ failed unexpectedly) ['$const278.2.2']
    $284call.3 = call $266load_global.0($const278.2.2, func=$266load_global.0, args=[Var($const278.2.2, dictobject.py:727)], kws=(), vararg=None, varkwarg=None, target=None) ['$266load_global.0', '$284call.3', '$const278.2.2']
    raise $284call.3                         ['$284call.3']

==== SSA block analysis pass on 0
Running <numba.core.ssa._GatherDefsHandler object at 0x7f61a5dc2490>
on stmt: d = arg(0, name=d)
on stmt: key = arg(1, name=key)
on stmt: value = arg(2, name=value)
on stmt: $6load_global.0 = global(_cast: <intrinsic _cast>)
on stmt: $20load_deref.3 = freevar(keyty: int64)
on stmt: castedkey = call $6load_global.0(key, $20load_deref.3, func=$6load_global.0, args=[Var(key, dictobject.py:714), Var($20load_deref.3, dictobject.py:715)], kws=(), vararg=None, varkwarg=None, target=None)
on stmt: $38load_global.5 = global(_cast: <intrinsic _cast>)
on stmt: $52load_deref.8 = freevar(valty: array(uint8, 3d, C))
on stmt: castedval = call $38load_global.5(value, $52load_deref.8, func=$38load_global.5, args=[Var(value, dictobject.py:714), Var($52load_deref.8, dictobject.py:716)], kws=(), vararg=None, varkwarg=None, target=None)
on stmt: $70load_global.10 = global(_dict_insert: <intrinsic _dict_insert>)
on stmt: $86load_global.14 = global(hash: <built-in function hash>)
on stmt: $104call.17 = call $86load_global.14(castedkey, func=$86load_global.14, args=[Var(castedkey, dictobject.py:715)], kws=(), vararg=None, varkwarg=None, target=None)
on stmt: status = call $70load_global.10(d, castedkey, $104call.17, castedval, func=$70load_global.10, args=[Var(d, dictobject.py:714), Var(castedkey, dictobject.py:715), Var($104call.17, dictobject.py:717), Var(castedval, dictobject.py:716)], kws=(), vararg=None, varkwarg=None, target=None)
on stmt: $134load_global.21 = global(Status: <enum 'Status'>)
on stmt: $146load_attr.22 = getattr(value=$134load_global.21, attr=OK)
on stmt: $156compare_op.23 = status == $146load_attr.22
on stmt: bool162 = global(bool: <class 'bool'>)
on stmt: $162pred = call bool162($156compare_op.23, func=bool162, args=(Var($156compare_op.23, dictobject.py:718),), kws=(), vararg=None, varkwarg=None, target=None)
on stmt: branch $162pred, 164, 168
==== SSA block analysis pass on 164
Running <numba.core.ssa._GatherDefsHandler object at 0x7f61a5dc2490>
on stmt: $const164.0.0 = const(NoneType, None)
on stmt: $166return_value.1 = cast(value=$const164.0.0)
on stmt: return $166return_value.1
==== SSA block analysis pass on 168
Running <numba.core.ssa._GatherDefsHandler object at 0x7f61a5dc2490>
on stmt: $170load_global.1 = global(Status: <enum 'Status'>)
on stmt: $182load_attr.2 = getattr(value=$170load_global.1, attr=OK_REPLACED)
on stmt: $192compare_op.3 = status == $182load_attr.2
on stmt: bool198 = global(bool: <class 'bool'>)
on stmt: $198pred = call bool198($192compare_op.3, func=bool198, args=(Var($192compare_op.3, dictobject.py:720),), kws=(), vararg=None, varkwarg=None, target=None)
on stmt: branch $198pred, 200, 204
==== SSA block analysis pass on 200
Running <numba.core.ssa._GatherDefsHandler object at 0x7f61a5dc2490>
on stmt: $const200.0.0 = const(NoneType, None)
on stmt: $202return_value.1 = cast(value=$const200.0.0)
on stmt: return $202return_value.1
==== SSA block analysis pass on 204
Running <numba.core.ssa._GatherDefsHandler object at 0x7f61a5dc2490>
on stmt: $206load_global.1 = global(Status: <enum 'Status'>)
on stmt: $218load_attr.2 = getattr(value=$206load_global.1, attr=ERR_CMP_FAILED)
on stmt: $228compare_op.3 = status == $218load_attr.2
on stmt: bool234 = global(bool: <class 'bool'>)
on stmt: $234pred = call bool234($228compare_op.3, func=bool234, args=(Var($228compare_op.3, dictobject.py:724),), kws=(), vararg=None, varkwarg=None, target=None)
on stmt: branch $234pred, 236, 266
==== SSA block analysis pass on 236
Running <numba.core.ssa._GatherDefsHandler object at 0x7f61a5dc2490>
on stmt: $236load_global.0 = global(ValueError: <class 'ValueError'>)
on stmt: $const248.2.1 = const(str, key comparison failed)
on stmt: $254call.3 = call $236load_global.0($const248.2.1, func=$236load_global.0, args=[Var($const248.2.1, dictobject.py:725)], kws=(), vararg=None, varkwarg=None, target=None)
on stmt: <static> raise <class 'ValueError'>('key comparison failed')
==== SSA block analysis pass on 266
Running <numba.core.ssa._GatherDefsHandler object at 0x7f61a5dc2490>
on stmt: $266load_global.0 = global(RuntimeError: <class 'RuntimeError'>)
on stmt: $const278.2.2 = const(str, dict.__setitem__ failed unexpectedly)
on stmt: $284call.3 = call $266load_global.0($const278.2.2, func=$266load_global.0, args=[Var($const278.2.2, dictobject.py:727)], kws=(), vararg=None, varkwarg=None, target=None)
on stmt: <static> raise <class 'RuntimeError'>('dict.__setitem__ failed unexpectedly')
defs defaultdict(<class 'list'>,
            {'$104call.17': [(<numba.core.ir.Assign object at 0x7f61a6cb9590>,
                              0)],
             '$134load_global.21': [(<numba.core.ir.Assign object at 0x7f61a6cba6d0>,
                                     0)],
             '$146load_attr.22': [(<numba.core.ir.Assign object at 0x7f61a6cb96d0>,
                                   0)],
             '$156compare_op.23': [(<numba.core.ir.Assign object at 0x7f61a6cb9610>,
                                    0)],
             '$162pred': [(<numba.core.ir.Assign object at 0x7f61a6cbac10>, 0)],
             '$166return_value.1': [(<numba.core.ir.Assign object at 0x7f61a6cbbed0>,
                                     164)],
             '$170load_global.1': [(<numba.core.ir.Assign object at 0x7f61c004db10>,
                                    168)],
             '$182load_attr.2': [(<numba.core.ir.Assign object at 0x7f61c004c510>,
                                  168)],
             '$192compare_op.3': [(<numba.core.ir.Assign object at 0x7f61c004ee10>,
                                   168)],
             '$198pred': [(<numba.core.ir.Assign object at 0x7f61c004e7d0>,
                           168)],
             '$202return_value.1': [(<numba.core.ir.Assign object at 0x7f61c004f790>,
                                     200)],
             '$206load_global.1': [(<numba.core.ir.Assign object at 0x7f61c004d9d0>,
                                    204)],
             '$20load_deref.3': [(<numba.core.ir.Assign object at 0x7f61a5db4c50>,
                                  0)],
             '$218load_attr.2': [(<numba.core.ir.Assign object at 0x7f61c004ec50>,
                                  204)],
             '$228compare_op.3': [(<numba.core.ir.Assign object at 0x7f61a6c8a290>,
                                   204)],
             '$234pred': [(<numba.core.ir.Assign object at 0x7f61a6c89550>,
                           204)],
             '$236load_global.0': [(<numba.core.ir.Assign object at 0x7f61a6c8a090>,
                                    236)],
             '$254call.3': [(<numba.core.ir.Assign object at 0x7f61a6c8a5d0>,
                             236)],
             '$266load_global.0': [(<numba.core.ir.Assign object at 0x7f61a6c89a90>,
                                    266)],
             '$284call.3': [(<numba.core.ir.Assign object at 0x7f61a6c8ba50>,
                             266)],
             '$38load_global.5': [(<numba.core.ir.Assign object at 0x7f61a5db7c10>,
                                   0)],
             '$52load_deref.8': [(<numba.core.ir.Assign object at 0x7f61a5dabe10>,
                                  0)],
             '$6load_global.0': [(<numba.core.ir.Assign object at 0x7f61a5db6110>,
                                  0)],
             '$70load_global.10': [(<numba.core.ir.Assign object at 0x7f61a5da8750>,
                                    0)],
             '$86load_global.14': [(<numba.core.ir.Assign object at 0x7f61a5da8610>,
                                    0)],
             '$const164.0.0': [(<numba.core.ir.Assign object at 0x7f61a6cbbe50>,
                                164)],
             '$const200.0.0': [(<numba.core.ir.Assign object at 0x7f61c004cb50>,
                                200)],
             '$const248.2.1': [(<numba.core.ir.Assign object at 0x7f61a6c8a890>,
                                236)],
             '$const278.2.2': [(<numba.core.ir.Assign object at 0x7f61a6c88b90>,
                                266)],
             'bool162': [(<numba.core.ir.Assign object at 0x7f61a6cb90d0>, 0)],
             'bool198': [(<numba.core.ir.Assign object at 0x7f61c004fe10>,
                          168)],
             'bool234': [(<numba.core.ir.Assign object at 0x7f61a6c8a110>,
                          204)],
             'castedkey': [(<numba.core.ir.Assign object at 0x7f61a5db7450>,
                            0)],
             'castedval': [(<numba.core.ir.Assign object at 0x7f61a5da9f10>,
                            0)],
             'd': [(<numba.core.ir.Assign object at 0x7f61a6c9b850>, 0)],
             'key': [(<numba.core.ir.Assign object at 0x7f61a5db5c50>, 0)],
             'status': [(<numba.core.ir.Assign object at 0x7f61a6cb9310>, 0)],
             'value': [(<numba.core.ir.Assign object at 0x7f61a5db4cd0>, 0)]})
SSA violators <numba.core.utils.OrderedSet object at 0x7f61a5dc2490>
bytecode dump:
>          0	NOP(arg=None, lineno=71)
           2	COPY_FREE_VARS(arg=1, lineno=71)
           4	RESUME(arg=0, lineno=71)
           6	LOAD_GLOBAL(arg=1, lineno=72)
          18	LOAD_FAST(arg=0, lineno=72)
          20	LOAD_CONST(arg=1, lineno=72)
          22	PRECALL(arg=2, lineno=72)
          26	CALL(arg=2, lineno=72)
          36	POP_JUMP_FORWARD_IF_FALSE(arg=30, lineno=72)
          38	LOAD_GLOBAL(arg=3, lineno=73)
          50	LOAD_FAST(arg=0, lineno=73)
          52	LOAD_GLOBAL(arg=5, lineno=73)
          64	LOAD_FAST(arg=0, lineno=73)
          66	LOAD_CONST(arg=1, lineno=73)
          68	PRECALL(arg=2, lineno=73)
          72	CALL(arg=2, lineno=73)
          82	PRECALL(arg=2, lineno=73)
          86	CALL(arg=2, lineno=73)
          96	RETURN_VALUE(arg=None, lineno=73)
>         98	LOAD_GLOBAL(arg=7, lineno=75)
         110	LOAD_DEREF(arg=1, lineno=75)
         112	PRECALL(arg=1, lineno=75)
         116	CALL(arg=1, lineno=75)
         126	RAISE_VARARGS(arg=1, lineno=75)
pending: deque([State(pc_initial=0 nstack_initial=0)])
stack: []
state.pc_initial: State(pc_initial=0 nstack_initial=0)
dispatch pc=0, inst=NOP(arg=None, lineno=71)
stack []
dispatch pc=2, inst=COPY_FREE_VARS(arg=1, lineno=71)
stack []
dispatch pc=4, inst=RESUME(arg=0, lineno=71)
stack []
dispatch pc=6, inst=LOAD_GLOBAL(arg=1, lineno=72)
stack []
dispatch pc=18, inst=LOAD_FAST(arg=0, lineno=72)
stack ['$null$6.1', '$6load_global.0']
dispatch pc=20, inst=LOAD_CONST(arg=1, lineno=72)
stack ['$null$6.1', '$6load_global.0', '$obj18.2']
dispatch pc=22, inst=PRECALL(arg=2, lineno=72)
stack ['$null$6.1', '$6load_global.0', '$obj18.2', '$const20.3.1']
dispatch pc=26, inst=CALL(arg=2, lineno=72)
stack ['$null$6.1', '$6load_global.0', '$obj18.2', '$const20.3.1']
dispatch pc=36, inst=POP_JUMP_FORWARD_IF_FALSE(arg=30, lineno=72)
stack ['$26call.4']
end state. edges=[Edge(pc=38, stack=(), blockstack=(), npush=0), Edge(pc=98, stack=(), blockstack=(), npush=0)]
pending: deque([State(pc_initial=38 nstack_initial=0), State(pc_initial=98 nstack_initial=0)])
stack: []
state.pc_initial: State(pc_initial=38 nstack_initial=0)
dispatch pc=38, inst=LOAD_GLOBAL(arg=3, lineno=73)
stack []
dispatch pc=50, inst=LOAD_FAST(arg=0, lineno=73)
stack ['$null$38.1', '$38load_global.0']
dispatch pc=52, inst=LOAD_GLOBAL(arg=5, lineno=73)
stack ['$null$38.1', '$38load_global.0', '$obj50.2']
dispatch pc=64, inst=LOAD_FAST(arg=0, lineno=73)
stack ['$null$38.1', '$38load_global.0', '$obj50.2', '$null$52.4', '$52load_global.3']
dispatch pc=66, inst=LOAD_CONST(arg=1, lineno=73)
stack ['$null$38.1', '$38load_global.0', '$obj50.2', '$null$52.4', '$52load_global.3', '$obj64.5']
dispatch pc=68, inst=PRECALL(arg=2, lineno=73)
stack ['$null$38.1', '$38load_global.0', '$obj50.2', '$null$52.4', '$52load_global.3', '$obj64.5', '$const66.6.1']
dispatch pc=72, inst=CALL(arg=2, lineno=73)
stack ['$null$38.1', '$38load_global.0', '$obj50.2', '$null$52.4', '$52load_global.3', '$obj64.5', '$const66.6.1']
dispatch pc=82, inst=PRECALL(arg=2, lineno=73)
stack ['$null$38.1', '$38load_global.0', '$obj50.2', '$72call.7']
dispatch pc=86, inst=CALL(arg=2, lineno=73)
stack ['$null$38.1', '$38load_global.0', '$obj50.2', '$72call.7']
dispatch pc=96, inst=RETURN_VALUE(arg=None, lineno=73)
stack ['$86call.8']
end state. edges=[]
pending: deque([State(pc_initial=98 nstack_initial=0)])
stack: []
state.pc_initial: State(pc_initial=98 nstack_initial=0)
dispatch pc=98, inst=LOAD_GLOBAL(arg=7, lineno=75)
stack []
dispatch pc=110, inst=LOAD_DEREF(arg=1, lineno=75)
stack ['$null$98.1', '$98load_global.0']
dispatch pc=112, inst=PRECALL(arg=1, lineno=75)
stack ['$null$98.1', '$98load_global.0', '$110load_deref.2']
dispatch pc=116, inst=CALL(arg=1, lineno=75)
stack ['$null$98.1', '$98load_global.0', '$110load_deref.2']
dispatch pc=126, inst=RAISE_VARARGS(arg=1, lineno=75)
stack ['$116call.3']
end state. edges=[]
-------------------------Prune PHIs-------------------------
Used_phis: defaultdict(<class 'set'>,
            {State(pc_initial=0 nstack_initial=0): set(),
             State(pc_initial=38 nstack_initial=0): set(),
             State(pc_initial=98 nstack_initial=0): set()})
defmap: {}
phismap: defaultdict(<class 'set'>, {})
changing phismap: defaultdict(<class 'set'>, {})
keep phismap: {}
new_out: defaultdict(<class 'dict'>, {})
----------------------DONE Prune PHIs-----------------------
block_infos State(pc_initial=0 nstack_initial=0):
AdaptBlockInfo(insts=((0, {}), (2, {}), (4, {}), (6, {'idx': 0, 'res': '$6load_global.0'}), (8, {}), (10, {}), (12, {}), (14, {}), (16, {}), (18, {'res': '$obj18.2'}), (20, {'res': '$const20.3.1'}), (22, {}), (24, {}), (26, {'func': '$6load_global.0', 'args': ['$obj18.2', '$const20.3.1'], 'kw_names': None, 'res': '$26call.4'}), (28, {}), (30, {}), (32, {}), (34, {}), (36, {'pred': '$26call.4'})), outgoing_phis={}, blockstack=(), active_try_block=None, outgoing_edgepushed={38: (), 98: ()})
block_infos State(pc_initial=38 nstack_initial=0):
AdaptBlockInfo(insts=((38, {'idx': 1, 'res': '$38load_global.0'}), (40, {}), (42, {}), (44, {}), (46, {}), (48, {}), (50, {'res': '$obj50.2'}), (52, {'idx': 2, 'res': '$52load_global.3'}), (54, {}), (56, {}), (58, {}), (60, {}), (62, {}), (64, {'res': '$obj64.5'}), (66, {'res': '$const66.6.1'}), (68, {}), (70, {}), (72, {'func': '$52load_global.3', 'args': ['$obj64.5', '$const66.6.1'], 'kw_names': None, 'res': '$72call.7'}), (74, {}), (76, {}), (78, {}), (80, {}), (82, {}), (84, {}), (86, {'func': '$38load_global.0', 'args': ['$obj50.2', '$72call.7'], 'kw_names': None, 'res': '$86call.8'}), (88, {}), (90, {}), (92, {}), (94, {}), (96, {'retval': '$86call.8', 'castval': '$96return_value.9'})), outgoing_phis={}, blockstack=(), active_try_block=None, outgoing_edgepushed={})
block_infos State(pc_initial=98 nstack_initial=0):
AdaptBlockInfo(insts=((98, {'idx': 3, 'res': '$98load_global.0'}), (100, {}), (102, {}), (104, {}), (106, {}), (108, {}), (110, {'res': '$110load_deref.2'}), (112, {}), (114, {}), (116, {'func': '$98load_global.0', 'args': ['$110load_deref.2'], 'kw_names': None, 'res': '$116call.3'}), (118, {}), (120, {}), (122, {}), (124, {}), (126, {'exc': '$116call.3'})), outgoing_phis={}, blockstack=(), active_try_block=None, outgoing_edgepushed={})
label 0:
    obj = arg(0, name=obj)                   ['obj']
    $6load_global.0 = global(hasattr: <built-in function hasattr>) ['$6load_global.0']
    $const20.3.1 = const(str, __hash__)      ['$const20.3.1']
    $26call.4 = call $6load_global.0(obj, $const20.3.1, func=$6load_global.0, args=[Var(obj, old_hashing.py:71), Var($const20.3.1, old_hashing.py:72)], kws=(), vararg=None, varkwarg=None, target=None) ['$26call.4', '$6load_global.0', '$const20.3.1', 'obj']
    bool36 = global(bool: <class 'bool'>)    ['bool36']
    $36pred = call bool36($26call.4, func=bool36, args=(Var($26call.4, old_hashing.py:72),), kws=(), vararg=None, varkwarg=None, target=None) ['$26call.4', '$36pred', 'bool36']
    branch $36pred, 38, 98                   ['$36pred']
label 38:
    $38load_global.0 = global(_defer_hash: <function _defer_hash at 0x7f61cb0c6d40>) ['$38load_global.0']
    $52load_global.3 = global(getattr: <built-in function getattr>) ['$52load_global.3']
    $const66.6.1 = const(str, __hash__)      ['$const66.6.1']
    $72call.7 = call $52load_global.3(obj, $const66.6.1, func=$52load_global.3, args=[Var(obj, old_hashing.py:71), Var($const66.6.1, old_hashing.py:73)], kws=(), vararg=None, varkwarg=None, target=None) ['$52load_global.3', '$72call.7', '$const66.6.1', 'obj']
    $86call.8 = call $38load_global.0(obj, $72call.7, func=$38load_global.0, args=[Var(obj, old_hashing.py:71), Var($72call.7, old_hashing.py:73)], kws=(), vararg=None, varkwarg=None, target=None) ['$38load_global.0', '$72call.7', '$86call.8', 'obj']
    $96return_value.9 = cast(value=$86call.8) ['$86call.8', '$96return_value.9']
    return $96return_value.9                 ['$96return_value.9']
label 98:
    $98load_global.0 = global(TypeError: <class 'TypeError'>) ['$98load_global.0']
    $110load_deref.2 = freevar(attempt_generic_msg: No __hash__ is defined for object of type 'int64' and a generic hash() cannot be performed as there is no suitable object represention in Numba compiled code!) ['$110load_deref.2']
    $116call.3 = call $98load_global.0($110load_deref.2, func=$98load_global.0, args=[Var($110load_deref.2, old_hashing.py:75)], kws=(), vararg=None, varkwarg=None, target=None) ['$110load_deref.2', '$116call.3', '$98load_global.0']
    raise $116call.3                         ['$116call.3']

==== SSA block analysis pass on 0
Running <numba.core.ssa._GatherDefsHandler object at 0x7f61a5dc6410>
on stmt: obj = arg(0, name=obj)
on stmt: $6load_global.0 = global(hasattr: <built-in function hasattr>)
on stmt: $const20.3.1 = const(str, __hash__)
on stmt: $26call.4 = call $6load_global.0(obj, $const20.3.1, func=$6load_global.0, args=[Var(obj, old_hashing.py:71), Var($const20.3.1, old_hashing.py:72)], kws=(), vararg=None, varkwarg=None, target=None)
on stmt: bool36 = global(bool: <class 'bool'>)
on stmt: $36pred = call bool36($26call.4, func=bool36, args=(Var($26call.4, old_hashing.py:72),), kws=(), vararg=None, varkwarg=None, target=None)
on stmt: branch $36pred, 38, 98
==== SSA block analysis pass on 38
Running <numba.core.ssa._GatherDefsHandler object at 0x7f61a5dc6410>
on stmt: $38load_global.0 = global(_defer_hash: <function _defer_hash at 0x7f61cb0c6d40>)
on stmt: $52load_global.3 = global(getattr: <built-in function getattr>)
on stmt: $const66.6.1 = const(str, __hash__)
on stmt: $72call.7 = call $52load_global.3(obj, $const66.6.1, func=$52load_global.3, args=[Var(obj, old_hashing.py:71), Var($const66.6.1, old_hashing.py:73)], kws=(), vararg=None, varkwarg=None, target=None)
on stmt: $86call.8 = call $38load_global.0(obj, $72call.7, func=$38load_global.0, args=[Var(obj, old_hashing.py:71), Var($72call.7, old_hashing.py:73)], kws=(), vararg=None, varkwarg=None, target=None)
on stmt: $96return_value.9 = cast(value=$86call.8)
on stmt: return $96return_value.9
==== SSA block analysis pass on 98
Running <numba.core.ssa._GatherDefsHandler object at 0x7f61a5dc6410>
on stmt: $98load_global.0 = global(TypeError: <class 'TypeError'>)
on stmt: $110load_deref.2 = freevar(attempt_generic_msg: No __hash__ is defined for object of type 'int64' and a generic hash() cannot be performed as there is no suitable object represention in Numba compiled code!)
on stmt: $116call.3 = call $98load_global.0($110load_deref.2, func=$98load_global.0, args=[Var($110load_deref.2, old_hashing.py:75)], kws=(), vararg=None, varkwarg=None, target=None)
on stmt: <static> raise <class 'TypeError'>("No __hash__ is defined for object of type 'int64' and a generic hash() cannot be performed as there is no suitable object represention in Numba compiled code!")
defs defaultdict(<class 'list'>,
            {'$110load_deref.2': [(<numba.core.ir.Assign object at 0x7f61a6ce1190>,
                                   98)],
             '$116call.3': [(<numba.core.ir.Assign object at 0x7f61a6ce3c50>,
                             98)],
             '$26call.4': [(<numba.core.ir.Assign object at 0x7f61a5dc7950>,
                            0)],
             '$36pred': [(<numba.core.ir.Assign object at 0x7f61a5dc79d0>, 0)],
             '$38load_global.0': [(<numba.core.ir.Assign object at 0x7f61a5dc6310>,
                                   38)],
             '$52load_global.3': [(<numba.core.ir.Assign object at 0x7f61ca311c50>,
                                   38)],
             '$6load_global.0': [(<numba.core.ir.Assign object at 0x7f61a5dc42d0>,
                                  0)],
             '$72call.7': [(<numba.core.ir.Assign object at 0x7f61ca310410>,
                            38)],
             '$86call.8': [(<numba.core.ir.Assign object at 0x7f61ca313b10>,
                            38)],
             '$96return_value.9': [(<numba.core.ir.Assign object at 0x7f61ca312290>,
                                    38)],
             '$98load_global.0': [(<numba.core.ir.Assign object at 0x7f61ca3119d0>,
                                   98)],
             '$const20.3.1': [(<numba.core.ir.Assign object at 0x7f61a5dc4d50>,
                               0)],
             '$const66.6.1': [(<numba.core.ir.Assign object at 0x7f61ca310a50>,
                               38)],
             'bool36': [(<numba.core.ir.Assign object at 0x7f61a5dc45d0>, 0)],
             'obj': [(<numba.core.ir.Assign object at 0x7f61a5dc5b90>, 0)]})
SSA violators <numba.core.utils.OrderedSet object at 0x7f61a5dc6410>
bytecode dump:
>          0	NOP(arg=None, lineno=998)
           2	RESUME(arg=0, lineno=998)
           4	LOAD_GLOBAL(arg=1, lineno=999)
          16	LOAD_FAST(arg=0, lineno=999)
          18	LOAD_FAST(arg=1, lineno=999)
          20	PRECALL(arg=2, lineno=999)
          24	CALL(arg=2, lineno=999)
          34	RETURN_VALUE(arg=None, lineno=999)
pending: deque([State(pc_initial=0 nstack_initial=0)])
stack: []
state.pc_initial: State(pc_initial=0 nstack_initial=0)
dispatch pc=0, inst=NOP(arg=None, lineno=998)
stack []
dispatch pc=2, inst=RESUME(arg=0, lineno=998)
stack []
dispatch pc=4, inst=LOAD_GLOBAL(arg=1, lineno=999)
stack []
dispatch pc=16, inst=LOAD_FAST(arg=0, lineno=999)
stack ['$null$4.1', '$4load_global.0']
dispatch pc=18, inst=LOAD_FAST(arg=1, lineno=999)
stack ['$null$4.1', '$4load_global.0', '$obj16.2']
dispatch pc=20, inst=PRECALL(arg=2, lineno=999)
stack ['$null$4.1', '$4load_global.0', '$obj16.2', '$name18.3']
dispatch pc=24, inst=CALL(arg=2, lineno=999)
stack ['$null$4.1', '$4load_global.0', '$obj16.2', '$name18.3']
dispatch pc=34, inst=RETURN_VALUE(arg=None, lineno=999)
stack ['$24call.4']
end state. edges=[]
-------------------------Prune PHIs-------------------------
Used_phis: defaultdict(<class 'set'>, {State(pc_initial=0 nstack_initial=0): set()})
defmap: {}
phismap: defaultdict(<class 'set'>, {})
changing phismap: defaultdict(<class 'set'>, {})
keep phismap: {}
new_out: defaultdict(<class 'dict'>, {})
----------------------DONE Prune PHIs-----------------------
block_infos State(pc_initial=0 nstack_initial=0):
AdaptBlockInfo(insts=((0, {}), (2, {}), (4, {'idx': 0, 'res': '$4load_global.0'}), (6, {}), (8, {}), (10, {}), (12, {}), (14, {}), (16, {'res': '$obj16.2'}), (18, {'res': '$name18.3'}), (20, {}), (22, {}), (24, {'func': '$4load_global.0', 'args': ['$obj16.2', '$name18.3'], 'kw_names': None, 'res': '$24call.4'}), (26, {}), (28, {}), (30, {}), (32, {}), (34, {'retval': '$24call.4', 'castval': '$34return_value.5'})), outgoing_phis={}, blockstack=(), active_try_block=None, outgoing_edgepushed={})
label 0:
    obj = arg(0, name=obj)                   ['obj']
    name = arg(1, name=name)                 ['name']
    $4load_global.0 = global(resolve_hasattr: <intrinsic resolve_hasattr>) ['$4load_global.0']
    $24call.4 = call $4load_global.0(obj, name, func=$4load_global.0, args=[Var(obj, old_builtins.py:998), Var(name, old_builtins.py:998)], kws=(), vararg=None, varkwarg=None, target=None) ['$24call.4', '$4load_global.0', 'name', 'obj']
    $34return_value.5 = cast(value=$24call.4) ['$24call.4', '$34return_value.5']
    return $34return_value.5                 ['$34return_value.5']

==== SSA block analysis pass on 0
Running <numba.core.ssa._GatherDefsHandler object at 0x7f61a6d0bad0>
on stmt: obj = arg(0, name=obj)
on stmt: name = arg(1, name=name)
on stmt: $4load_global.0 = global(resolve_hasattr: <intrinsic resolve_hasattr>)
on stmt: $24call.4 = call $4load_global.0(obj, name, func=$4load_global.0, args=[Var(obj, old_builtins.py:998), Var(name, old_builtins.py:998)], kws=(), vararg=None, varkwarg=None, target=None)
on stmt: $34return_value.5 = cast(value=$24call.4)
on stmt: return $34return_value.5
defs defaultdict(<class 'list'>,
            {'$24call.4': [(<numba.core.ir.Assign object at 0x7f61a6d09e90>,
                            0)],
             '$34return_value.5': [(<numba.core.ir.Assign object at 0x7f61a6d09dd0>,
                                    0)],
             '$4load_global.0': [(<numba.core.ir.Assign object at 0x7f61a6cfc890>,
                                  0)],
             'name': [(<numba.core.ir.Assign object at 0x7f61a6cfe190>, 0)],
             'obj': [(<numba.core.ir.Assign object at 0x7f61a6cfe050>, 0)]})
SSA violators <numba.core.utils.OrderedSet object at 0x7f61a6cfe3d0>
captured error
Traceback (most recent call last):
  File "/home/earnest/.local/share/mamba/envs/basicrl/lib/python3.11/site-packages/numba/core/typeinfer.py", line 160, in propagate
    constraint(typeinfer)
  File "/home/earnest/.local/share/mamba/envs/basicrl/lib/python3.11/site-packages/numba/core/typeinfer.py", line 566, in __call__
    self.resolve(typeinfer, typevars, fnty)
  File "/home/earnest/.local/share/mamba/envs/basicrl/lib/python3.11/site-packages/numba/core/typeinfer.py", line 589, in resolve
    sig = typeinfer.resolve_call(fnty, pos_args, kw_args)
          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/home/earnest/.local/share/mamba/envs/basicrl/lib/python3.11/site-packages/numba/core/typeinfer.py", line 1560, in resolve_call
    return self.context.resolve_function_type(fnty, pos_args, kw_args)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/home/earnest/.local/share/mamba/envs/basicrl/lib/python3.11/site-packages/numba/core/typing/context.py", line 212, in resolve_function_type
    raise last_exception
  File "/home/earnest/.local/share/mamba/envs/basicrl/lib/python3.11/site-packages/numba/core/typing/context.py", line 195, in resolve_function_type
    res = self._resolve_user_function_type(func, args, kws)
          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/home/earnest/.local/share/mamba/envs/basicrl/lib/python3.11/site-packages/numba/core/typing/context.py", line 247, in _resolve_user_function_type
    return func.get_call_type(self, args, kws)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/home/earnest/.local/share/mamba/envs/basicrl/lib/python3.11/site-packages/numba/core/types/functions.py", line 329, in get_call_type
    failures.raise_error()
  File "/home/earnest/.local/share/mamba/envs/basicrl/lib/python3.11/site-packages/numba/core/types/functions.py", line 227, in raise_error
    raise errors.TypingError(self.format())
numba.core.errors.TypingError: No implementation of function Function(<intrinsic resolve_hasattr>) found for signature:
 
 >>> resolve_hasattr(int64, unicode_type)
 
There are 2 candidate implementations:
 - Of which 2 did not match due to:
 Intrinsic in function 'resolve_hasattr': File: numba/cpython/old_builtins.py: Line 970.
   With argument(s): '(int64, unicode_type)':
  Rejected as the implementation raised a specific error:
    RequireLiteralValue: argument 'name' must be a literal string
  raised from /home/earnest/.local/share/mamba/envs/basicrl/lib/python3.11/site-packages/numba/cpython/old_builtins.py:973

During: resolving callee type: Function(<intrinsic resolve_hasattr>)
During: typing of call at /home/earnest/.local/share/mamba/envs/basicrl/lib/python3.11/site-packages/numba/cpython/old_builtins.py (999)

captured error
Traceback (most recent call last):
  File "/home/earnest/.local/share/mamba/envs/basicrl/lib/python3.11/site-packages/numba/core/typeinfer.py", line 160, in propagate
    constraint(typeinfer)
  File "/home/earnest/.local/share/mamba/envs/basicrl/lib/python3.11/site-packages/numba/core/typeinfer.py", line 566, in __call__
    self.resolve(typeinfer, typevars, fnty)
  File "/home/earnest/.local/share/mamba/envs/basicrl/lib/python3.11/site-packages/numba/core/typeinfer.py", line 589, in resolve
    sig = typeinfer.resolve_call(fnty, pos_args, kw_args)
          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/home/earnest/.local/share/mamba/envs/basicrl/lib/python3.11/site-packages/numba/core/typeinfer.py", line 1560, in resolve_call
    return self.context.resolve_function_type(fnty, pos_args, kw_args)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/home/earnest/.local/share/mamba/envs/basicrl/lib/python3.11/site-packages/numba/core/typing/context.py", line 212, in resolve_function_type
    raise last_exception
  File "/home/earnest/.local/share/mamba/envs/basicrl/lib/python3.11/site-packages/numba/core/typing/context.py", line 195, in resolve_function_type
    res = self._resolve_user_function_type(func, args, kws)
          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/home/earnest/.local/share/mamba/envs/basicrl/lib/python3.11/site-packages/numba/core/typing/context.py", line 247, in _resolve_user_function_type
    return func.get_call_type(self, args, kws)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/home/earnest/.local/share/mamba/envs/basicrl/lib/python3.11/site-packages/numba/core/types/functions.py", line 329, in get_call_type
    failures.raise_error()
  File "/home/earnest/.local/share/mamba/envs/basicrl/lib/python3.11/site-packages/numba/core/types/functions.py", line 227, in raise_error
    raise errors.TypingError(self.format())
numba.core.errors.TypingError: No implementation of function Function(<intrinsic resolve_hasattr>) found for signature:
 
 >>> resolve_hasattr(int64, unicode_type)
 
There are 2 candidate implementations:
  - Of which 2 did not match due to:
  Intrinsic in function 'resolve_hasattr': File: numba/cpython/old_builtins.py: Line 970.
    With argument(s): '(int64, unicode_type)':
   Rejected as the implementation raised a specific error:
     RequireLiteralValue: argument 'name' must be a literal string
  raised from /home/earnest/.local/share/mamba/envs/basicrl/lib/python3.11/site-packages/numba/cpython/old_builtins.py:973

During: resolving callee type: Function(<intrinsic resolve_hasattr>)
During: typing of call at /home/earnest/.local/share/mamba/envs/basicrl/lib/python3.11/site-packages/numba/cpython/old_builtins.py (999)

bytecode dump:
>          0	NOP(arg=None, lineno=998)
           2	RESUME(arg=0, lineno=998)
           4	LOAD_GLOBAL(arg=1, lineno=999)
          16	LOAD_FAST(arg=0, lineno=999)
          18	LOAD_FAST(arg=1, lineno=999)
          20	PRECALL(arg=2, lineno=999)
          24	CALL(arg=2, lineno=999)
          34	RETURN_VALUE(arg=None, lineno=999)
pending: deque([State(pc_initial=0 nstack_initial=0)])
stack: []
state.pc_initial: State(pc_initial=0 nstack_initial=0)
dispatch pc=0, inst=NOP(arg=None, lineno=998)
stack []
dispatch pc=2, inst=RESUME(arg=0, lineno=998)
stack []
dispatch pc=4, inst=LOAD_GLOBAL(arg=1, lineno=999)
stack []
dispatch pc=16, inst=LOAD_FAST(arg=0, lineno=999)
stack ['$null$4.1', '$4load_global.0']
dispatch pc=18, inst=LOAD_FAST(arg=1, lineno=999)
stack ['$null$4.1', '$4load_global.0', '$obj16.2']
dispatch pc=20, inst=PRECALL(arg=2, lineno=999)
stack ['$null$4.1', '$4load_global.0', '$obj16.2', '$name18.3']
dispatch pc=24, inst=CALL(arg=2, lineno=999)
stack ['$null$4.1', '$4load_global.0', '$obj16.2', '$name18.3']
dispatch pc=34, inst=RETURN_VALUE(arg=None, lineno=999)
stack ['$24call.4']
end state. edges=[]
-------------------------Prune PHIs-------------------------
Used_phis: defaultdict(<class 'set'>, {State(pc_initial=0 nstack_initial=0): set()})
defmap: {}
phismap: defaultdict(<class 'set'>, {})
changing phismap: defaultdict(<class 'set'>, {})
keep phismap: {}
new_out: defaultdict(<class 'dict'>, {})
----------------------DONE Prune PHIs-----------------------
block_infos State(pc_initial=0 nstack_initial=0):
AdaptBlockInfo(insts=((0, {}), (2, {}), (4, {'idx': 0, 'res': '$4load_global.0'}), (6, {}), (8, {}), (10, {}), (12, {}), (14, {}), (16, {'res': '$obj16.2'}), (18, {'res': '$name18.3'}), (20, {}), (22, {}), (24, {'func': '$4load_global.0', 'args': ['$obj16.2', '$name18.3'], 'kw_names': None, 'res': '$24call.4'}), (26, {}), (28, {}), (30, {}), (32, {}), (34, {'retval': '$24call.4', 'castval': '$34return_value.5'})), outgoing_phis={}, blockstack=(), active_try_block=None, outgoing_edgepushed={})
label 0:
    obj = arg(0, name=obj)                   ['obj']
    name = arg(1, name=name)                 ['name']
    $4load_global.0 = global(resolve_hasattr: <intrinsic resolve_hasattr>) ['$4load_global.0']
    $24call.4 = call $4load_global.0(obj, name, func=$4load_global.0, args=[Var(obj, old_builtins.py:998), Var(name, old_builtins.py:998)], kws=(), vararg=None, varkwarg=None, target=None) ['$24call.4', '$4load_global.0', 'name', 'obj']
    $34return_value.5 = cast(value=$24call.4) ['$24call.4', '$34return_value.5']
    return $34return_value.5                 ['$34return_value.5']

==== SSA block analysis pass on 0
Running <numba.core.ssa._GatherDefsHandler object at 0x7f61a55bca90>
on stmt: obj = arg(0, name=obj)
on stmt: name = arg(1, name=name)
on stmt: $4load_global.0 = global(resolve_hasattr: <intrinsic resolve_hasattr>)
on stmt: $24call.4 = call $4load_global.0(obj, name, func=$4load_global.0, args=[Var(obj, old_builtins.py:998), Var(name, old_builtins.py:998)], kws=(), vararg=None, varkwarg=None, target=None)
on stmt: $34return_value.5 = cast(value=$24call.4)
on stmt: return $34return_value.5
defs defaultdict(<class 'list'>,
            {'$24call.4': [(<numba.core.ir.Assign object at 0x7f61a55bc350>,
                            0)],
             '$34return_value.5': [(<numba.core.ir.Assign object at 0x7f61a55bc510>,
                                    0)],
             '$4load_global.0': [(<numba.core.ir.Assign object at 0x7f61a5523c50>,
                                  0)],
             'name': [(<numba.core.ir.Assign object at 0x7f61a5523a10>, 0)],
             'obj': [(<numba.core.ir.Assign object at 0x7f61a5523910>, 0)]})
SSA violators <numba.core.utils.OrderedSet object at 0x7f61a55bca90>
bytecode dump:
>          0	NOP(arg=None, lineno=954)
           2	RESUME(arg=0, lineno=954)
           4	LOAD_GLOBAL(arg=1, lineno=955)
          16	LOAD_FAST(arg=0, lineno=955)
          18	LOAD_FAST(arg=1, lineno=955)
          20	LOAD_GLOBAL(arg=2, lineno=955)
          32	PRECALL(arg=3, lineno=955)
          36	CALL(arg=3, lineno=955)
          46	RETURN_VALUE(arg=None, lineno=955)
pending: deque([State(pc_initial=0 nstack_initial=0)])
stack: []
state.pc_initial: State(pc_initial=0 nstack_initial=0)
dispatch pc=0, inst=NOP(arg=None, lineno=954)
stack []
dispatch pc=2, inst=RESUME(arg=0, lineno=954)
stack []
dispatch pc=4, inst=LOAD_GLOBAL(arg=1, lineno=955)
stack []
dispatch pc=16, inst=LOAD_FAST(arg=0, lineno=955)
stack ['$null$4.1', '$4load_global.0']
dispatch pc=18, inst=LOAD_FAST(arg=1, lineno=955)
stack ['$null$4.1', '$4load_global.0', '$obj16.2']
dispatch pc=20, inst=LOAD_GLOBAL(arg=2, lineno=955)
stack ['$null$4.1', '$4load_global.0', '$obj16.2', '$name18.3']
dispatch pc=32, inst=PRECALL(arg=3, lineno=955)
stack ['$null$4.1', '$4load_global.0', '$obj16.2', '$name18.3', '$20load_global.4']
dispatch pc=36, inst=CALL(arg=3, lineno=955)
stack ['$null$4.1', '$4load_global.0', '$obj16.2', '$name18.3', '$20load_global.4']
dispatch pc=46, inst=RETURN_VALUE(arg=None, lineno=955)
stack ['$36call.5']
end state. edges=[]
-------------------------Prune PHIs-------------------------
Used_phis: defaultdict(<class 'set'>, {State(pc_initial=0 nstack_initial=0): set()})
defmap: {}
phismap: defaultdict(<class 'set'>, {})
changing phismap: defaultdict(<class 'set'>, {})
keep phismap: {}
new_out: defaultdict(<class 'dict'>, {})
----------------------DONE Prune PHIs-----------------------
block_infos State(pc_initial=0 nstack_initial=0):
AdaptBlockInfo(insts=((0, {}), (2, {}), (4, {'idx': 0, 'res': '$4load_global.0'}), (6, {}), (8, {}), (10, {}), (12, {}), (14, {}), (16, {'res': '$obj16.2'}), (18, {'res': '$name18.3'}), (20, {'idx': 1, 'res': '$20load_global.4'}), (22, {}), (24, {}), (26, {}), (28, {}), (30, {}), (32, {}), (34, {}), (36, {'func': '$4load_global.0', 'args': ['$obj16.2', '$name18.3', '$20load_global.4'], 'kw_names': None, 'res': '$36call.5'}), (38, {}), (40, {}), (42, {}), (44, {}), (46, {'retval': '$36call.5', 'castval': '$46return_value.6'})), outgoing_phis={}, blockstack=(), active_try_block=None, outgoing_edgepushed={})
label 0:
    obj = arg(0, name=obj)                   ['obj']
    name = arg(1, name=name)                 ['name']
    $4load_global.0 = global(resolve_getattr: <intrinsic resolve_getattr>) ['$4load_global.0']
    $20load_global.4 = global(_getattr_default: _getattr_default_type()) ['$20load_global.4']
    $36call.5 = call $4load_global.0(obj, name, $20load_global.4, func=$4load_global.0, args=[Var(obj, old_builtins.py:954), Var(name, old_builtins.py:954), Var($20load_global.4, old_builtins.py:955)], kws=(), vararg=None, varkwarg=None, target=None) ['$20load_global.4', '$36call.5', '$4load_global.0', 'name', 'obj']
    $46return_value.6 = cast(value=$36call.5) ['$36call.5', '$46return_value.6']
    return $46return_value.6                 ['$46return_value.6']

==== SSA block analysis pass on 0
Running <numba.core.ssa._GatherDefsHandler object at 0x7f61a55e0410>
on stmt: obj = arg(0, name=obj)
on stmt: name = arg(1, name=name)
on stmt: $4load_global.0 = global(resolve_getattr: <intrinsic resolve_getattr>)
on stmt: $20load_global.4 = global(_getattr_default: _getattr_default_type())
on stmt: $36call.5 = call $4load_global.0(obj, name, $20load_global.4, func=$4load_global.0, args=[Var(obj, old_builtins.py:954), Var(name, old_builtins.py:954), Var($20load_global.4, old_builtins.py:955)], kws=(), vararg=None, varkwarg=None, target=None)
on stmt: $46return_value.6 = cast(value=$36call.5)
on stmt: return $46return_value.6
defs defaultdict(<class 'list'>,
            {'$20load_global.4': [(<numba.core.ir.Assign object at 0x7f61a55d2f50>,
                                   0)],
             '$36call.5': [(<numba.core.ir.Assign object at 0x7f61a55d3190>,
                            0)],
             '$46return_value.6': [(<numba.core.ir.Assign object at 0x7f61a55d3450>,
                                    0)],
             '$4load_global.0': [(<numba.core.ir.Assign object at 0x7f61a55d28d0>,
                                  0)],
             'name': [(<numba.core.ir.Assign object at 0x7f61a55d2650>, 0)],
             'obj': [(<numba.core.ir.Assign object at 0x7f61a55d2550>, 0)]})
SSA violators <numba.core.utils.OrderedSet object at 0x7f61a55e0410>
bytecode dump:
>          0	NOP(arg=None, lineno=55)
           2	COPY_FREE_VARS(arg=1, lineno=55)
           4	RESUME(arg=0, lineno=55)
           6	LOAD_FAST(arg=1, lineno=56)
           8	POP_JUMP_FORWARD_IF_NOT_NONE(arg=15, lineno=56)
          10	LOAD_GLOBAL(arg=1, lineno=57)
          22	LOAD_DEREF(arg=2, lineno=57)
          24	PRECALL(arg=1, lineno=57)
          28	CALL(arg=1, lineno=57)
          38	RAISE_VARARGS(arg=1, lineno=57)
>         40	PUSH_NULL(arg=None, lineno=59)
          42	LOAD_FAST(arg=1, lineno=59)
          44	PRECALL(arg=0, lineno=59)
          48	CALL(arg=0, lineno=59)
          58	RETURN_VALUE(arg=None, lineno=59)
pending: deque([State(pc_initial=0 nstack_initial=0)])
stack: []
state.pc_initial: State(pc_initial=0 nstack_initial=0)
dispatch pc=0, inst=NOP(arg=None, lineno=55)
stack []
dispatch pc=2, inst=COPY_FREE_VARS(arg=1, lineno=55)
stack []
dispatch pc=4, inst=RESUME(arg=0, lineno=55)
stack []
dispatch pc=6, inst=LOAD_FAST(arg=1, lineno=56)
stack []
dispatch pc=8, inst=POP_JUMP_FORWARD_IF_NOT_NONE(arg=15, lineno=56)
stack ['$hash_func6.0']
end state. edges=[Edge(pc=10, stack=(), blockstack=(), npush=0), Edge(pc=40, stack=(), blockstack=(), npush=0)]
pending: deque([State(pc_initial=10 nstack_initial=0), State(pc_initial=40 nstack_initial=0)])
stack: []
state.pc_initial: State(pc_initial=10 nstack_initial=0)
dispatch pc=10, inst=LOAD_GLOBAL(arg=1, lineno=57)
stack []
dispatch pc=22, inst=LOAD_DEREF(arg=2, lineno=57)
stack ['$null$10.1', '$10load_global.0']
dispatch pc=24, inst=PRECALL(arg=1, lineno=57)
stack ['$null$10.1', '$10load_global.0', '$22load_deref.2']
dispatch pc=28, inst=CALL(arg=1, lineno=57)
stack ['$null$10.1', '$10load_global.0', '$22load_deref.2']
dispatch pc=38, inst=RAISE_VARARGS(arg=1, lineno=57)
stack ['$28call.3']
end state. edges=[]
pending: deque([State(pc_initial=40 nstack_initial=0)])
stack: []
state.pc_initial: State(pc_initial=40 nstack_initial=0)
dispatch pc=40, inst=PUSH_NULL(arg=None, lineno=59)
stack []
dispatch pc=42, inst=LOAD_FAST(arg=1, lineno=59)
stack ['$null$40.0']
dispatch pc=44, inst=PRECALL(arg=0, lineno=59)
stack ['$null$40.0', '$hash_func42.1']
dispatch pc=48, inst=CALL(arg=0, lineno=59)
stack ['$null$40.0', '$hash_func42.1']
dispatch pc=58, inst=RETURN_VALUE(arg=None, lineno=59)
stack ['$48call.2']
end state. edges=[]
-------------------------Prune PHIs-------------------------
Used_phis: defaultdict(<class 'set'>,
            {State(pc_initial=0 nstack_initial=0): set(),
             State(pc_initial=10 nstack_initial=0): set(),
             State(pc_initial=40 nstack_initial=0): set()})
defmap: {}
phismap: defaultdict(<class 'set'>, {})
changing phismap: defaultdict(<class 'set'>, {})
keep phismap: {}
new_out: defaultdict(<class 'dict'>, {})
----------------------DONE Prune PHIs-----------------------
block_infos State(pc_initial=0 nstack_initial=0):
AdaptBlockInfo(insts=((0, {}), (2, {}), (4, {}), (6, {'res': '$hash_func6.0'}), (8, {'pred': '$hash_func6.0'})), outgoing_phis={}, blockstack=(), active_try_block=None, outgoing_edgepushed={10: (), 40: ()})
block_infos State(pc_initial=10 nstack_initial=0):
AdaptBlockInfo(insts=((10, {'idx': 0, 'res': '$10load_global.0'}), (12, {}), (14, {}), (16, {}), (18, {}), (20, {}), (22, {'res': '$22load_deref.2'}), (24, {}), (26, {}), (28, {'func': '$10load_global.0', 'args': ['$22load_deref.2'], 'kw_names': None, 'res': '$28call.3'}), (30, {}), (32, {}), (34, {}), (36, {}), (38, {'exc': '$28call.3'})), outgoing_phis={}, blockstack=(), active_try_block=None, outgoing_edgepushed={})
block_infos State(pc_initial=40 nstack_initial=0):
AdaptBlockInfo(insts=((40, {}), (42, {'res': '$hash_func42.1'}), (44, {}), (46, {}), (48, {'func': '$hash_func42.1', 'args': [], 'kw_names': None, 'res': '$48call.2'}), (50, {}), (52, {}), (54, {}), (56, {}), (58, {'retval': '$48call.2', 'castval': '$58return_value.3'})), outgoing_phis={}, blockstack=(), active_try_block=None, outgoing_edgepushed={})
label 0:
    obj = arg(0, name=obj)                   ['obj']
    hash_func = arg(1, name=hash_func)       ['hash_func']
    $constNone8 = const(NoneType, None)      ['$constNone8']
    $maybeNone8 = hash_func is $constNone8   ['$constNone8', '$maybeNone8', 'hash_func']
    $bool8 = global(bool: <class 'bool'>)    ['$bool8']
    $pred8 = call $bool8($maybeNone8, func=$bool8, args=(Var($maybeNone8, old_hashing.py:56),), kws=(), vararg=None, varkwarg=None, target=None) ['$bool8', '$maybeNone8', '$pred8']
    branch $pred8, 10, 40                    ['$pred8']
label 10:
    $10load_global.0 = global(TypeError: <class 'TypeError'>) ['$10load_global.0']
    $22load_deref.2 = freevar(err_msg: unhashable type: 'int64') ['$22load_deref.2']
    $28call.3 = call $10load_global.0($22load_deref.2, func=$10load_global.0, args=[Var($22load_deref.2, old_hashing.py:57)], kws=(), vararg=None, varkwarg=None, target=None) ['$10load_global.0', '$22load_deref.2', '$28call.3']
    raise $28call.3                          ['$28call.3']
label 40:
    $48call.2 = call hash_func(func=hash_func, args=[], kws=(), vararg=None, varkwarg=None, target=None) ['$48call.2', 'hash_func']
    $58return_value.3 = cast(value=$48call.2) ['$48call.2', '$58return_value.3']
    return $58return_value.3                 ['$58return_value.3']

==== SSA block analysis pass on 0
Running <numba.core.ssa._GatherDefsHandler object at 0x7f61a5520c90>
on stmt: obj = arg(0, name=obj)
on stmt: hash_func = arg(1, name=hash_func)
on stmt: $constNone8 = const(NoneType, None)
on stmt: $maybeNone8 = hash_func is $constNone8
on stmt: $bool8 = global(bool: <class 'bool'>)
on stmt: $pred8 = call $bool8($maybeNone8, func=$bool8, args=(Var($maybeNone8, old_hashing.py:56),), kws=(), vararg=None, varkwarg=None, target=None)
on stmt: branch $pred8, 10, 40
==== SSA block analysis pass on 10
Running <numba.core.ssa._GatherDefsHandler object at 0x7f61a5520c90>
on stmt: $10load_global.0 = global(TypeError: <class 'TypeError'>)
on stmt: $22load_deref.2 = freevar(err_msg: unhashable type: 'int64')
on stmt: $28call.3 = call $10load_global.0($22load_deref.2, func=$10load_global.0, args=[Var($22load_deref.2, old_hashing.py:57)], kws=(), vararg=None, varkwarg=None, target=None)
on stmt: <static> raise <class 'TypeError'>("unhashable type: 'int64'")
==== SSA block analysis pass on 40
Running <numba.core.ssa._GatherDefsHandler object at 0x7f61a5520c90>
on stmt: $48call.2 = call hash_func(func=hash_func, args=[], kws=(), vararg=None, varkwarg=None, target=None)
on stmt: $58return_value.3 = cast(value=$48call.2)
on stmt: return $58return_value.3
defs defaultdict(<class 'list'>,
            {'$10load_global.0': [(<numba.core.ir.Assign object at 0x7f61a6d08910>,
                                   10)],
             '$22load_deref.2': [(<numba.core.ir.Assign object at 0x7f61a6d0bb10>,
                                  10)],
             '$28call.3': [(<numba.core.ir.Assign object at 0x7f61a6d0bfd0>,
                            10)],
             '$48call.2': [(<numba.core.ir.Assign object at 0x7f61a6d0aad0>,
                            40)],
             '$58return_value.3': [(<numba.core.ir.Assign object at 0x7f61a6cdb8d0>,
                                    40)],
             '$bool8': [(<numba.core.ir.Assign object at 0x7f61a6d0bad0>, 0)],
             '$constNone8': [(<numba.core.ir.Assign object at 0x7f61a6d0a050>,
                              0)],
             '$maybeNone8': [(<numba.core.ir.Assign object at 0x7f61a6d0ac50>,
                              0)],
             '$pred8': [(<numba.core.ir.Assign object at 0x7f61a6d0b790>, 0)],
             'hash_func': [(<numba.core.ir.Assign object at 0x7f61a6d0b6d0>,
                            0)],
             'obj': [(<numba.core.ir.Assign object at 0x7f61a6d0bb50>, 0)]})
SSA violators <numba.core.utils.OrderedSet object at 0x7f61a5520c90>
bytecode dump:
>          0	NOP(arg=None, lineno=237)
           2	COPY_FREE_VARS(arg=3, lineno=237)
           4	RESUME(arg=0, lineno=237)
           6	PUSH_NULL(arg=None, lineno=247)
           8	LOAD_DEREF(arg=4, lineno=247)
          10	LOAD_FAST(arg=0, lineno=247)
          12	PRECALL(arg=1, lineno=247)
          16	CALL(arg=1, lineno=247)
          26	STORE_FAST(arg=0, lineno=247)
          28	LOAD_GLOBAL(arg=1, lineno=248)
          40	LOAD_FAST(arg=0, lineno=248)
          42	PRECALL(arg=1, lineno=248)
          46	CALL(arg=1, lineno=248)
          56	STORE_FAST(arg=1, lineno=248)
          58	LOAD_FAST(arg=1, lineno=249)
          60	LOAD_GLOBAL(arg=2, lineno=249)
          72	COMPARE_OP(arg=0, lineno=249)
          78	POP_JUMP_FORWARD_IF_FALSE(arg=47, lineno=249)
          80	LOAD_FAST(arg=0, lineno=250)
          82	LOAD_CONST(arg=1, lineno=250)
          84	COMPARE_OP(arg=2, lineno=250)
          90	POP_JUMP_FORWARD_IF_FALSE(arg=3, lineno=250)
          92	LOAD_CONST(arg=1, lineno=251)
          94	STORE_FAST(arg=2, lineno=251)
          96	JUMP_FORWARD(arg=71, lineno=251)
>         98	LOAD_FAST(arg=0, lineno=252)
         100	LOAD_DEREF(arg=6, lineno=252)
         102	COMPARE_OP(arg=2, lineno=252)
         108	POP_JUMP_FORWARD_IF_FALSE(arg=16, lineno=252)
         110	LOAD_GLOBAL(arg=5, lineno=253)
         122	LOAD_DEREF(arg=5, lineno=253)
         124	PRECALL(arg=1, lineno=253)
         128	CALL(arg=1, lineno=253)
         138	STORE_FAST(arg=2, lineno=253)
         140	JUMP_FORWARD(arg=49, lineno=253)
>        142	LOAD_GLOBAL(arg=5, lineno=255)
         154	LOAD_FAST(arg=0, lineno=255)
         156	PRECALL(arg=1, lineno=255)
         160	CALL(arg=1, lineno=255)
         170	STORE_FAST(arg=2, lineno=255)
         172	JUMP_FORWARD(arg=33, lineno=255)
>        174	LOAD_CONST(arg=2, lineno=257)
         176	STORE_FAST(arg=3, lineno=257)
         178	LOAD_FAST(arg=0, lineno=258)
         180	LOAD_CONST(arg=1, lineno=258)
         182	COMPARE_OP(arg=0, lineno=258)
         188	POP_JUMP_FORWARD_IF_FALSE(arg=5, lineno=258)
         190	LOAD_FAST(arg=0, lineno=259)
         192	UNARY_NEGATIVE(arg=None, lineno=259)
         194	STORE_FAST(arg=0, lineno=259)
         196	LOAD_CONST(arg=3, lineno=260)
         198	STORE_FAST(arg=3, lineno=260)
>        200	LOAD_GLOBAL(arg=7, lineno=261)
         212	LOAD_FAST(arg=0, lineno=261)
         214	PRECALL(arg=1, lineno=261)
         218	CALL(arg=1, lineno=261)
         228	STORE_FAST(arg=2, lineno=261)
         230	LOAD_FAST(arg=3, lineno=262)
         232	POP_JUMP_FORWARD_IF_FALSE(arg=3, lineno=262)
         234	LOAD_FAST(arg=2, lineno=263)
         236	UNARY_NEGATIVE(arg=None, lineno=263)
         238	STORE_FAST(arg=2, lineno=263)
>        240	LOAD_GLOBAL(arg=9, lineno=264)
         252	LOAD_FAST(arg=2, lineno=264)
         254	PRECALL(arg=1, lineno=264)
         258	CALL(arg=1, lineno=264)
         268	RETURN_VALUE(arg=None, lineno=264)
pending: deque([State(pc_initial=0 nstack_initial=0)])
stack: []
state.pc_initial: State(pc_initial=0 nstack_initial=0)
dispatch pc=0, inst=NOP(arg=None, lineno=237)
stack []
dispatch pc=2, inst=COPY_FREE_VARS(arg=3, lineno=237)
stack []
dispatch pc=4, inst=RESUME(arg=0, lineno=237)
stack []
dispatch pc=6, inst=PUSH_NULL(arg=None, lineno=247)
stack []
dispatch pc=8, inst=LOAD_DEREF(arg=4, lineno=247)
stack ['$null$6.0']
dispatch pc=10, inst=LOAD_FAST(arg=0, lineno=247)
stack ['$null$6.0', '$8load_deref.1']
dispatch pc=12, inst=PRECALL(arg=1, lineno=247)
stack ['$null$6.0', '$8load_deref.1', '$val10.2']
dispatch pc=16, inst=CALL(arg=1, lineno=247)
stack ['$null$6.0', '$8load_deref.1', '$val10.2']
dispatch pc=26, inst=STORE_FAST(arg=0, lineno=247)
stack ['$16call.3']
dispatch pc=28, inst=LOAD_GLOBAL(arg=1, lineno=248)
stack []
dispatch pc=40, inst=LOAD_FAST(arg=0, lineno=248)
stack ['$null$28.5', '$28load_global.4']
dispatch pc=42, inst=PRECALL(arg=1, lineno=248)
stack ['$null$28.5', '$28load_global.4', '$val40.6']
dispatch pc=46, inst=CALL(arg=1, lineno=248)
stack ['$null$28.5', '$28load_global.4', '$val40.6']
dispatch pc=56, inst=STORE_FAST(arg=1, lineno=248)
stack ['$46call.7']
dispatch pc=58, inst=LOAD_FAST(arg=1, lineno=249)
stack []
dispatch pc=60, inst=LOAD_GLOBAL(arg=2, lineno=249)
stack ['$mag58.8']
dispatch pc=72, inst=COMPARE_OP(arg=0, lineno=249)
stack ['$mag58.8', '$60load_global.9']
dispatch pc=78, inst=POP_JUMP_FORWARD_IF_FALSE(arg=47, lineno=249)
stack ['$72compare_op.10']
end state. edges=[Edge(pc=80, stack=(), blockstack=(), npush=0), Edge(pc=174, stack=(), blockstack=(), npush=0)]
pending: deque([State(pc_initial=80 nstack_initial=0), State(pc_initial=174 nstack_initial=0)])
stack: []
state.pc_initial: State(pc_initial=80 nstack_initial=0)
dispatch pc=80, inst=LOAD_FAST(arg=0, lineno=250)
stack []
dispatch pc=82, inst=LOAD_CONST(arg=1, lineno=250)
stack ['$val80.0']
dispatch pc=84, inst=COMPARE_OP(arg=2, lineno=250)
stack ['$val80.0', '$const82.1.1']
dispatch pc=90, inst=POP_JUMP_FORWARD_IF_FALSE(arg=3, lineno=250)
stack ['$84compare_op.2']
end state. edges=[Edge(pc=92, stack=(), blockstack=(), npush=0), Edge(pc=98, stack=(), blockstack=(), npush=0)]
pending: deque([State(pc_initial=174 nstack_initial=0), State(pc_initial=92 nstack_initial=0), State(pc_initial=98 nstack_initial=0)])
stack: []
state.pc_initial: State(pc_initial=174 nstack_initial=0)
dispatch pc=174, inst=LOAD_CONST(arg=2, lineno=257)
stack []
dispatch pc=176, inst=STORE_FAST(arg=3, lineno=257)
stack ['$const174.0.2']
dispatch pc=178, inst=LOAD_FAST(arg=0, lineno=258)
stack []
dispatch pc=180, inst=LOAD_CONST(arg=1, lineno=258)
stack ['$val178.1']
dispatch pc=182, inst=COMPARE_OP(arg=0, lineno=258)
stack ['$val178.1', '$const180.2.1']
dispatch pc=188, inst=POP_JUMP_FORWARD_IF_FALSE(arg=5, lineno=258)
stack ['$182compare_op.3']
end state. edges=[Edge(pc=190, stack=(), blockstack=(), npush=0), Edge(pc=200, stack=(), blockstack=(), npush=0)]
pending: deque([State(pc_initial=92 nstack_initial=0), State(pc_initial=98 nstack_initial=0), State(pc_initial=190 nstack_initial=0), State(pc_initial=200 nstack_initial=0)])
stack: []
state.pc_initial: State(pc_initial=92 nstack_initial=0)
dispatch pc=92, inst=LOAD_CONST(arg=1, lineno=251)
stack []
dispatch pc=94, inst=STORE_FAST(arg=2, lineno=251)
stack ['$const92.0.1']
dispatch pc=96, inst=JUMP_FORWARD(arg=71, lineno=251)
stack []
end state. edges=[Edge(pc=240, stack=(), blockstack=(), npush=0)]
pending: deque([State(pc_initial=98 nstack_initial=0), State(pc_initial=190 nstack_initial=0), State(pc_initial=200 nstack_initial=0), State(pc_initial=240 nstack_initial=0)])
stack: []
state.pc_initial: State(pc_initial=98 nstack_initial=0)
dispatch pc=98, inst=LOAD_FAST(arg=0, lineno=252)
stack []
dispatch pc=100, inst=LOAD_DEREF(arg=6, lineno=252)
stack ['$val98.0']
dispatch pc=102, inst=COMPARE_OP(arg=2, lineno=252)
stack ['$val98.0', '$100load_deref.1']
dispatch pc=108, inst=POP_JUMP_FORWARD_IF_FALSE(arg=16, lineno=252)
stack ['$102compare_op.2']
end state. edges=[Edge(pc=110, stack=(), blockstack=(), npush=0), Edge(pc=142, stack=(), blockstack=(), npush=0)]
pending: deque([State(pc_initial=190 nstack_initial=0), State(pc_initial=200 nstack_initial=0), State(pc_initial=240 nstack_initial=0), State(pc_initial=110 nstack_initial=0), State(pc_initial=142 nstack_initial=0)])
stack: []
state.pc_initial: State(pc_initial=190 nstack_initial=0)
dispatch pc=190, inst=LOAD_FAST(arg=0, lineno=259)
stack []
dispatch pc=192, inst=UNARY_NEGATIVE(arg=None, lineno=259)
stack ['$val190.0']
dispatch pc=194, inst=STORE_FAST(arg=0, lineno=259)
stack ['$192unary_negative.1']
dispatch pc=196, inst=LOAD_CONST(arg=3, lineno=260)
stack []
dispatch pc=198, inst=STORE_FAST(arg=3, lineno=260)
stack ['$const196.2.3']
end state. edges=[Edge(pc=200, stack=(), blockstack=(), npush=0)]
pending: deque([State(pc_initial=200 nstack_initial=0), State(pc_initial=240 nstack_initial=0), State(pc_initial=110 nstack_initial=0), State(pc_initial=142 nstack_initial=0), State(pc_initial=200 nstack_initial=0)])
stack: []
state.pc_initial: State(pc_initial=200 nstack_initial=0)
dispatch pc=200, inst=LOAD_GLOBAL(arg=7, lineno=261)
stack []
dispatch pc=212, inst=LOAD_FAST(arg=0, lineno=261)
stack ['$null$200.1', '$200load_global.0']
dispatch pc=214, inst=PRECALL(arg=1, lineno=261)
stack ['$null$200.1', '$200load_global.0', '$val212.2']
dispatch pc=218, inst=CALL(arg=1, lineno=261)
stack ['$null$200.1', '$200load_global.0', '$val212.2']
dispatch pc=228, inst=STORE_FAST(arg=2, lineno=261)
stack ['$218call.3']
dispatch pc=230, inst=LOAD_FAST(arg=3, lineno=262)
stack []
dispatch pc=232, inst=POP_JUMP_FORWARD_IF_FALSE(arg=3, lineno=262)
stack ['$needs_negate230.4']
end state. edges=[Edge(pc=234, stack=(), blockstack=(), npush=0), Edge(pc=240, stack=(), blockstack=(), npush=0)]
pending: deque([State(pc_initial=240 nstack_initial=0), State(pc_initial=110 nstack_initial=0), State(pc_initial=142 nstack_initial=0), State(pc_initial=200 nstack_initial=0), State(pc_initial=234 nstack_initial=0), State(pc_initial=240 nstack_initial=0)])
stack: []
state.pc_initial: State(pc_initial=240 nstack_initial=0)
dispatch pc=240, inst=LOAD_GLOBAL(arg=9, lineno=264)
stack []
dispatch pc=252, inst=LOAD_FAST(arg=2, lineno=264)
stack ['$null$240.1', '$240load_global.0']
dispatch pc=254, inst=PRECALL(arg=1, lineno=264)
stack ['$null$240.1', '$240load_global.0', '$ret252.2']
dispatch pc=258, inst=CALL(arg=1, lineno=264)
stack ['$null$240.1', '$240load_global.0', '$ret252.2']
dispatch pc=268, inst=RETURN_VALUE(arg=None, lineno=264)
stack ['$258call.3']
end state. edges=[]
pending: deque([State(pc_initial=110 nstack_initial=0), State(pc_initial=142 nstack_initial=0), State(pc_initial=200 nstack_initial=0), State(pc_initial=234 nstack_initial=0), State(pc_initial=240 nstack_initial=0)])
stack: []
state.pc_initial: State(pc_initial=110 nstack_initial=0)
dispatch pc=110, inst=LOAD_GLOBAL(arg=5, lineno=253)
stack []
dispatch pc=122, inst=LOAD_DEREF(arg=5, lineno=253)
stack ['$null$110.1', '$110load_global.0']
dispatch pc=124, inst=PRECALL(arg=1, lineno=253)
stack ['$null$110.1', '$110load_global.0', '$122load_deref.2']
dispatch pc=128, inst=CALL(arg=1, lineno=253)
stack ['$null$110.1', '$110load_global.0', '$122load_deref.2']
dispatch pc=138, inst=STORE_FAST(arg=2, lineno=253)
stack ['$128call.3']
dispatch pc=140, inst=JUMP_FORWARD(arg=49, lineno=253)
stack []
end state. edges=[Edge(pc=240, stack=(), blockstack=(), npush=0)]
pending: deque([State(pc_initial=142 nstack_initial=0), State(pc_initial=200 nstack_initial=0), State(pc_initial=234 nstack_initial=0), State(pc_initial=240 nstack_initial=0), State(pc_initial=240 nstack_initial=0)])
stack: []
state.pc_initial: State(pc_initial=142 nstack_initial=0)
dispatch pc=142, inst=LOAD_GLOBAL(arg=5, lineno=255)
stack []
dispatch pc=154, inst=LOAD_FAST(arg=0, lineno=255)
stack ['$null$142.1', '$142load_global.0']
dispatch pc=156, inst=PRECALL(arg=1, lineno=255)
stack ['$null$142.1', '$142load_global.0', '$val154.2']
dispatch pc=160, inst=CALL(arg=1, lineno=255)
stack ['$null$142.1', '$142load_global.0', '$val154.2']
dispatch pc=170, inst=STORE_FAST(arg=2, lineno=255)
stack ['$160call.3']
dispatch pc=172, inst=JUMP_FORWARD(arg=33, lineno=255)
stack []
end state. edges=[Edge(pc=240, stack=(), blockstack=(), npush=0)]
pending: deque([State(pc_initial=200 nstack_initial=0), State(pc_initial=234 nstack_initial=0), State(pc_initial=240 nstack_initial=0), State(pc_initial=240 nstack_initial=0), State(pc_initial=240 nstack_initial=0)])
pending: deque([State(pc_initial=234 nstack_initial=0), State(pc_initial=240 nstack_initial=0), State(pc_initial=240 nstack_initial=0), State(pc_initial=240 nstack_initial=0)])
stack: []
state.pc_initial: State(pc_initial=234 nstack_initial=0)
dispatch pc=234, inst=LOAD_FAST(arg=2, lineno=263)
stack []
dispatch pc=236, inst=UNARY_NEGATIVE(arg=None, lineno=263)
stack ['$ret234.0']
dispatch pc=238, inst=STORE_FAST(arg=2, lineno=263)
stack ['$236unary_negative.1']
end state. edges=[Edge(pc=240, stack=(), blockstack=(), npush=0)]
pending: deque([State(pc_initial=240 nstack_initial=0), State(pc_initial=240 nstack_initial=0), State(pc_initial=240 nstack_initial=0), State(pc_initial=240 nstack_initial=0)])
pending: deque([State(pc_initial=240 nstack_initial=0), State(pc_initial=240 nstack_initial=0), State(pc_initial=240 nstack_initial=0)])
pending: deque([State(pc_initial=240 nstack_initial=0), State(pc_initial=240 nstack_initial=0)])
pending: deque([State(pc_initial=240 nstack_initial=0)])
-------------------------Prune PHIs-------------------------
Used_phis: defaultdict(<class 'set'>,
            {State(pc_initial=0 nstack_initial=0): set(),
             State(pc_initial=80 nstack_initial=0): set(),
             State(pc_initial=92 nstack_initial=0): set(),
             State(pc_initial=98 nstack_initial=0): set(),
             State(pc_initial=110 nstack_initial=0): set(),
             State(pc_initial=142 nstack_initial=0): set(),
             State(pc_initial=174 nstack_initial=0): set(),
             State(pc_initial=190 nstack_initial=0): set(),
             State(pc_initial=200 nstack_initial=0): set(),
             State(pc_initial=234 nstack_initial=0): set(),
             State(pc_initial=240 nstack_initial=0): set()})
defmap: {}
phismap: defaultdict(<class 'set'>, {})
changing phismap: defaultdict(<class 'set'>, {})
keep phismap: {}
new_out: defaultdict(<class 'dict'>, {})
----------------------DONE Prune PHIs-----------------------
block_infos State(pc_initial=0 nstack_initial=0):
AdaptBlockInfo(insts=((0, {}), (2, {}), (4, {}), (6, {}), (8, {'res': '$8load_deref.1'}), (10, {'res': '$val10.2'}), (12, {}), (14, {}), (16, {'func': '$8load_deref.1', 'args': ['$val10.2'], 'kw_names': None, 'res': '$16call.3'}), (18, {}), (20, {}), (22, {}), (24, {}), (26, {'value': '$16call.3'}), (28, {'idx': 0, 'res': '$28load_global.4'}), (30, {}), (32, {}), (34, {}), (36, {}), (38, {}), (40, {'res': '$val40.6'}), (42, {}), (44, {}), (46, {'func': '$28load_global.4', 'args': ['$val40.6'], 'kw_names': None, 'res': '$46call.7'}), (48, {}), (50, {}), (52, {}), (54, {}), (56, {'value': '$46call.7'}), (58, {'res': '$mag58.8'}), (60, {'idx': 1, 'res': '$60load_global.9'}), (62, {}), (64, {}), (66, {}), (68, {}), (70, {}), (72, {'lhs': '$mag58.8', 'rhs': '$60load_global.9', 'res': '$72compare_op.10'}), (74, {}), (76, {}), (78, {'pred': '$72compare_op.10'})), outgoing_phis={}, blockstack=(), active_try_block=None, outgoing_edgepushed={80: (), 174: ()})
block_infos State(pc_initial=80 nstack_initial=0):
AdaptBlockInfo(insts=((80, {'res': '$val80.0'}), (82, {'res': '$const82.1.1'}), (84, {'lhs': '$val80.0', 'rhs': '$const82.1.1', 'res': '$84compare_op.2'}), (86, {}), (88, {}), (90, {'pred': '$84compare_op.2'})), outgoing_phis={}, blockstack=(), active_try_block=None, outgoing_edgepushed={92: (), 98: ()})
block_infos State(pc_initial=92 nstack_initial=0):
AdaptBlockInfo(insts=((92, {'res': '$const92.0.1'}), (94, {'value': '$const92.0.1'}), (96, {})), outgoing_phis={}, blockstack=(), active_try_block=None, outgoing_edgepushed={240: ()})
block_infos State(pc_initial=98 nstack_initial=0):
AdaptBlockInfo(insts=((98, {'res': '$val98.0'}), (100, {'res': '$100load_deref.1'}), (102, {'lhs': '$val98.0', 'rhs': '$100load_deref.1', 'res': '$102compare_op.2'}), (104, {}), (106, {}), (108, {'pred': '$102compare_op.2'})), outgoing_phis={}, blockstack=(), active_try_block=None, outgoing_edgepushed={110: (), 142: ()})
block_infos State(pc_initial=110 nstack_initial=0):
AdaptBlockInfo(insts=((110, {'idx': 2, 'res': '$110load_global.0'}), (112, {}), (114, {}), (116, {}), (118, {}), (120, {}), (122, {'res': '$122load_deref.2'}), (124, {}), (126, {}), (128, {'func': '$110load_global.0', 'args': ['$122load_deref.2'], 'kw_names': None, 'res': '$128call.3'}), (130, {}), (132, {}), (134, {}), (136, {}), (138, {'value': '$128call.3'}), (140, {})), outgoing_phis={}, blockstack=(), active_try_block=None, outgoing_edgepushed={240: ()})
block_infos State(pc_initial=142 nstack_initial=0):
AdaptBlockInfo(insts=((142, {'idx': 2, 'res': '$142load_global.0'}), (144, {}), (146, {}), (148, {}), (150, {}), (152, {}), (154, {'res': '$val154.2'}), (156, {}), (158, {}), (160, {'func': '$142load_global.0', 'args': ['$val154.2'], 'kw_names': None, 'res': '$160call.3'}), (162, {}), (164, {}), (166, {}), (168, {}), (170, {'value': '$160call.3'}), (172, {})), outgoing_phis={}, blockstack=(), active_try_block=None, outgoing_edgepushed={240: ()})
block_infos State(pc_initial=174 nstack_initial=0):
AdaptBlockInfo(insts=((174, {'res': '$const174.0.2'}), (176, {'value': '$const174.0.2'}), (178, {'res': '$val178.1'}), (180, {'res': '$const180.2.1'}), (182, {'lhs': '$val178.1', 'rhs': '$const180.2.1', 'res': '$182compare_op.3'}), (184, {}), (186, {}), (188, {'pred': '$182compare_op.3'})), outgoing_phis={}, blockstack=(), active_try_block=None, outgoing_edgepushed={190: (), 200: ()})
block_infos State(pc_initial=190 nstack_initial=0):
AdaptBlockInfo(insts=((190, {'res': '$val190.0'}), (192, {'value': '$val190.0', 'res': '$192unary_negative.1'}), (194, {'value': '$192unary_negative.1'}), (196, {'res': '$const196.2.3'}), (198, {'value': '$const196.2.3'})), outgoing_phis={}, blockstack=(), active_try_block=None, outgoing_edgepushed={200: ()})
block_infos State(pc_initial=200 nstack_initial=0):
AdaptBlockInfo(insts=((200, {'idx': 3, 'res': '$200load_global.0'}), (202, {}), (204, {}), (206, {}), (208, {}), (210, {}), (212, {'res': '$val212.2'}), (214, {}), (216, {}), (218, {'func': '$200load_global.0', 'args': ['$val212.2'], 'kw_names': None, 'res': '$218call.3'}), (220, {}), (222, {}), (224, {}), (226, {}), (228, {'value': '$218call.3'}), (230, {'res': '$needs_negate230.4'}), (232, {'pred': '$needs_negate230.4'})), outgoing_phis={}, blockstack=(), active_try_block=None, outgoing_edgepushed={234: (), 240: ()})
block_infos State(pc_initial=234 nstack_initial=0):
AdaptBlockInfo(insts=((234, {'res': '$ret234.0'}), (236, {'value': '$ret234.0', 'res': '$236unary_negative.1'}), (238, {'value': '$236unary_negative.1'})), outgoing_phis={}, blockstack=(), active_try_block=None, outgoing_edgepushed={240: ()})
block_infos State(pc_initial=240 nstack_initial=0):
AdaptBlockInfo(insts=((240, {'idx': 4, 'res': '$240load_global.0'}), (242, {}), (244, {}), (246, {}), (248, {}), (250, {}), (252, {'res': '$ret252.2'}), (254, {}), (256, {}), (258, {'func': '$240load_global.0', 'args': ['$ret252.2'], 'kw_names': None, 'res': '$258call.3'}), (260, {}), (262, {}), (264, {}), (266, {}), (268, {'retval': '$258call.3', 'castval': '$268return_value.4'})), outgoing_phis={}, blockstack=(), active_try_block=None, outgoing_edgepushed={})
label 0:
    val = arg(0, name=val)                   ['val']
    $8load_deref.1 = freevar(_BIG: int64)    ['$8load_deref.1']
    val.1 = call $8load_deref.1(val, func=$8load_deref.1, args=[Var(val, old_hashing.py:237)], kws=(), vararg=None, varkwarg=None, target=None) ['$8load_deref.1', 'val', 'val.1']
    $28load_global.4 = global(abs: <built-in function abs>) ['$28load_global.4']
    mag = call $28load_global.4(val.1, func=$28load_global.4, args=[Var(val.1, old_hashing.py:247)], kws=(), vararg=None, varkwarg=None, target=None) ['$28load_global.4', 'mag', 'val.1']
    $60load_global.9 = global(_PyHASH_MODULUS: 2305843009213693951) ['$60load_global.9']
    $72compare_op.10 = mag < $60load_global.9 ['$60load_global.9', '$72compare_op.10', 'mag']
    bool78 = global(bool: <class 'bool'>)    ['bool78']
    $78pred = call bool78($72compare_op.10, func=bool78, args=(Var($72compare_op.10, old_hashing.py:249),), kws=(), vararg=None, varkwarg=None, target=None) ['$72compare_op.10', '$78pred', 'bool78']
    branch $78pred, 80, 174                  ['$78pred']
label 80:
    $const82.1.1 = const(int, 0)             ['$const82.1.1']
    $84compare_op.2 = val.1 == $const82.1.1  ['$84compare_op.2', '$const82.1.1', 'val.1']
    bool90 = global(bool: <class 'bool'>)    ['bool90']
    $90pred = call bool90($84compare_op.2, func=bool90, args=(Var($84compare_op.2, old_hashing.py:250),), kws=(), vararg=None, varkwarg=None, target=None) ['$84compare_op.2', '$90pred', 'bool90']
    branch $90pred, 92, 98                   ['$90pred']
label 92:
    ret = const(int, 0)                      ['ret']
    jump 240                                 []
label 98:
    $100load_deref.1 = freevar(_SIGNED_MIN: -9223372036854775808) ['$100load_deref.1']
    $102compare_op.2 = val.1 == $100load_deref.1 ['$100load_deref.1', '$102compare_op.2', 'val.1']
    bool108 = global(bool: <class 'bool'>)   ['bool108']
    $108pred = call bool108($102compare_op.2, func=bool108, args=(Var($102compare_op.2, old_hashing.py:252),), kws=(), vararg=None, varkwarg=None, target=None) ['$102compare_op.2', '$108pred', 'bool108']
    branch $108pred, 110, 142                ['$108pred']
label 110:
    $110load_global.0 = global(_Py_hash_t: int64) ['$110load_global.0']
    $122load_deref.2 = freevar(_HASH_I64_MIN: -4) ['$122load_deref.2']
    ret = call $110load_global.0($122load_deref.2, func=$110load_global.0, args=[Var($122load_deref.2, old_hashing.py:253)], kws=(), vararg=None, varkwarg=None, target=None) ['$110load_global.0', '$122load_deref.2', 'ret']
    jump 240                                 []
label 142:
    $142load_global.0 = global(_Py_hash_t: int64) ['$142load_global.0']
    ret = call $142load_global.0(val.1, func=$142load_global.0, args=[Var(val.1, old_hashing.py:247)], kws=(), vararg=None, varkwarg=None, target=None) ['$142load_global.0', 'ret', 'val.1']
    jump 240                                 []
label 174:
    needs_negate = const(bool, False)        ['needs_negate']
    $const180.2.1 = const(int, 0)            ['$const180.2.1']
    $182compare_op.3 = val.1 < $const180.2.1 ['$182compare_op.3', '$const180.2.1', 'val.1']
    bool188 = global(bool: <class 'bool'>)   ['bool188']
    $188pred = call bool188($182compare_op.3, func=bool188, args=(Var($182compare_op.3, old_hashing.py:258),), kws=(), vararg=None, varkwarg=None, target=None) ['$182compare_op.3', '$188pred', 'bool188']
    branch $188pred, 190, 200                ['$188pred']
label 190:
    val.1 = unary(fn=<built-in function neg>, value=val.1) ['val.1', 'val.1']
    needs_negate = const(bool, True)         ['needs_negate']
    jump 200                                 []
label 200:
    $200load_global.0 = global(_long_impl: <function _long_impl at 0x7f61cafc94e0>) ['$200load_global.0']
    ret = call $200load_global.0(val.1, func=$200load_global.0, args=[Var(val.1, old_hashing.py:247)], kws=(), vararg=None, varkwarg=None, target=None) ['$200load_global.0', 'ret', 'val.1']
    bool232 = global(bool: <class 'bool'>)   ['bool232']
    $232pred = call bool232(needs_negate, func=bool232, args=(Var(needs_negate, old_hashing.py:257),), kws=(), vararg=None, varkwarg=None, target=None) ['$232pred', 'bool232', 'needs_negate']
    branch $232pred, 234, 240                ['$232pred']
label 234:
    ret = unary(fn=<built-in function neg>, value=ret) ['ret', 'ret']
    jump 240                                 []
label 240:
    $240load_global.0 = global(process_return: <function process_return at 0x7f61cb0c7560>) ['$240load_global.0']
    $258call.3 = call $240load_global.0(ret, func=$240load_global.0, args=[Var(ret, old_hashing.py:251)], kws=(), vararg=None, varkwarg=None, target=None) ['$240load_global.0', '$258call.3', 'ret']
    $268return_value.4 = cast(value=$258call.3) ['$258call.3', '$268return_value.4']
    return $268return_value.4                ['$268return_value.4']

==== SSA block analysis pass on 0
Running <numba.core.ssa._GatherDefsHandler object at 0x7f61a5da99d0>
on stmt: val = arg(0, name=val)
on stmt: $8load_deref.1 = freevar(_BIG: int64)
on stmt: val.1 = call $8load_deref.1(val, func=$8load_deref.1, args=[Var(val, old_hashing.py:237)], kws=(), vararg=None, varkwarg=None, target=None)
on stmt: $28load_global.4 = global(abs: <built-in function abs>)
on stmt: mag = call $28load_global.4(val.1, func=$28load_global.4, args=[Var(val.1, old_hashing.py:247)], kws=(), vararg=None, varkwarg=None, target=None)
on stmt: $60load_global.9 = global(_PyHASH_MODULUS: 2305843009213693951)
on stmt: $72compare_op.10 = mag < $60load_global.9
on stmt: bool78 = global(bool: <class 'bool'>)
on stmt: $78pred = call bool78($72compare_op.10, func=bool78, args=(Var($72compare_op.10, old_hashing.py:249),), kws=(), vararg=None, varkwarg=None, target=None)
on stmt: branch $78pred, 80, 174
==== SSA block analysis pass on 80
Running <numba.core.ssa._GatherDefsHandler object at 0x7f61a5da99d0>
on stmt: $const82.1.1 = const(int, 0)
on stmt: $84compare_op.2 = val.1 == $const82.1.1
on stmt: bool90 = global(bool: <class 'bool'>)
on stmt: $90pred = call bool90($84compare_op.2, func=bool90, args=(Var($84compare_op.2, old_hashing.py:250),), kws=(), vararg=None, varkwarg=None, target=None)
on stmt: branch $90pred, 92, 98
==== SSA block analysis pass on 92
Running <numba.core.ssa._GatherDefsHandler object at 0x7f61a5da99d0>
on stmt: ret = const(int, 0)
on stmt: jump 240
==== SSA block analysis pass on 98
Running <numba.core.ssa._GatherDefsHandler object at 0x7f61a5da99d0>
on stmt: $100load_deref.1 = freevar(_SIGNED_MIN: -9223372036854775808)
on stmt: $102compare_op.2 = val.1 == $100load_deref.1
on stmt: bool108 = global(bool: <class 'bool'>)
on stmt: $108pred = call bool108($102compare_op.2, func=bool108, args=(Var($102compare_op.2, old_hashing.py:252),), kws=(), vararg=None, varkwarg=None, target=None)
on stmt: branch $108pred, 110, 142
==== SSA block analysis pass on 110
Running <numba.core.ssa._GatherDefsHandler object at 0x7f61a5da99d0>
on stmt: $110load_global.0 = global(_Py_hash_t: int64)
on stmt: $122load_deref.2 = freevar(_HASH_I64_MIN: -4)
on stmt: ret = call $110load_global.0($122load_deref.2, func=$110load_global.0, args=[Var($122load_deref.2, old_hashing.py:253)], kws=(), vararg=None, varkwarg=None, target=None)
on stmt: jump 240
==== SSA block analysis pass on 142
Running <numba.core.ssa._GatherDefsHandler object at 0x7f61a5da99d0>
on stmt: $142load_global.0 = global(_Py_hash_t: int64)
on stmt: ret = call $142load_global.0(val.1, func=$142load_global.0, args=[Var(val.1, old_hashing.py:247)], kws=(), vararg=None, varkwarg=None, target=None)
on stmt: jump 240
==== SSA block analysis pass on 174
Running <numba.core.ssa._GatherDefsHandler object at 0x7f61a5da99d0>
on stmt: needs_negate = const(bool, False)
on stmt: $const180.2.1 = const(int, 0)
on stmt: $182compare_op.3 = val.1 < $const180.2.1
on stmt: bool188 = global(bool: <class 'bool'>)
on stmt: $188pred = call bool188($182compare_op.3, func=bool188, args=(Var($182compare_op.3, old_hashing.py:258),), kws=(), vararg=None, varkwarg=None, target=None)
on stmt: branch $188pred, 190, 200
==== SSA block analysis pass on 190
Running <numba.core.ssa._GatherDefsHandler object at 0x7f61a5da99d0>
on stmt: val.1 = unary(fn=<built-in function neg>, value=val.1)
on stmt: needs_negate = const(bool, True)
on stmt: jump 200
==== SSA block analysis pass on 200
Running <numba.core.ssa._GatherDefsHandler object at 0x7f61a5da99d0>
on stmt: $200load_global.0 = global(_long_impl: <function _long_impl at 0x7f61cafc94e0>)
on stmt: ret = call $200load_global.0(val.1, func=$200load_global.0, args=[Var(val.1, old_hashing.py:247)], kws=(), vararg=None, varkwarg=None, target=None)
on stmt: bool232 = global(bool: <class 'bool'>)
on stmt: $232pred = call bool232(needs_negate, func=bool232, args=(Var(needs_negate, old_hashing.py:257),), kws=(), vararg=None, varkwarg=None, target=None)
on stmt: branch $232pred, 234, 240
==== SSA block analysis pass on 234
Running <numba.core.ssa._GatherDefsHandler object at 0x7f61a5da99d0>
on stmt: ret = unary(fn=<built-in function neg>, value=ret)
on stmt: jump 240
==== SSA block analysis pass on 240
Running <numba.core.ssa._GatherDefsHandler object at 0x7f61a5da99d0>
on stmt: $240load_global.0 = global(process_return: <function process_return at 0x7f61cb0c7560>)
on stmt: $258call.3 = call $240load_global.0(ret, func=$240load_global.0, args=[Var(ret, old_hashing.py:251)], kws=(), vararg=None, varkwarg=None, target=None)
on stmt: $268return_value.4 = cast(value=$258call.3)
on stmt: return $268return_value.4
defs defaultdict(<class 'list'>,
            {'$100load_deref.1': [(<numba.core.ir.Assign object at 0x7f61a55d39d0>,
                                   98)],
             '$102compare_op.2': [(<numba.core.ir.Assign object at 0x7f61a55d1c50>,
                                   98)],
             '$108pred': [(<numba.core.ir.Assign object at 0x7f61a55d3290>,
                           98)],
             '$110load_global.0': [(<numba.core.ir.Assign object at 0x7f61a55d2bd0>,
                                    110)],
             '$122load_deref.2': [(<numba.core.ir.Assign object at 0x7f61a55d1c10>,
                                   110)],
             '$142load_global.0': [(<numba.core.ir.Assign object at 0x7f61a6ceedd0>,
                                    142)],
             '$182compare_op.3': [(<numba.core.ir.Assign object at 0x7f61a6cc0390>,
                                   174)],
             '$188pred': [(<numba.core.ir.Assign object at 0x7f61a6cc1590>,
                           174)],
             '$200load_global.0': [(<numba.core.ir.Assign object at 0x7f61a6cca090>,
                                    200)],
             '$232pred': [(<numba.core.ir.Assign object at 0x7f61c00e1650>,
                           200)],
             '$240load_global.0': [(<numba.core.ir.Assign object at 0x7f61ca2d5f50>,
                                    240)],
             '$258call.3': [(<numba.core.ir.Assign object at 0x7f61c01b52d0>,
                             240)],
             '$268return_value.4': [(<numba.core.ir.Assign object at 0x7f61c01b7110>,
                                     240)],
             '$28load_global.4': [(<numba.core.ir.Assign object at 0x7f61a6cfef10>,
                                   0)],
             '$60load_global.9': [(<numba.core.ir.Assign object at 0x7f61a55ce4d0>,
                                   0)],
             '$72compare_op.10': [(<numba.core.ir.Assign object at 0x7f61a55cc490>,
                                   0)],
             '$78pred': [(<numba.core.ir.Assign object at 0x7f61a55cd850>, 0)],
             '$84compare_op.2': [(<numba.core.ir.Assign object at 0x7f61a55cef10>,
                                  80)],
             '$8load_deref.1': [(<numba.core.ir.Assign object at 0x7f61a55bd750>,
                                 0)],
             '$90pred': [(<numba.core.ir.Assign object at 0x7f61a551fc90>, 80)],
             '$const180.2.1': [(<numba.core.ir.Assign object at 0x7f61a6cc3e90>,
                                174)],
             '$const82.1.1': [(<numba.core.ir.Assign object at 0x7f61a55ce810>,
                               80)],
             'bool108': [(<numba.core.ir.Assign object at 0x7f61a55d2d10>, 98)],
             'bool188': [(<numba.core.ir.Assign object at 0x7f61a6cc3690>,
                          174)],
             'bool232': [(<numba.core.ir.Assign object at 0x7f61c00e2910>,
                          200)],
             'bool78': [(<numba.core.ir.Assign object at 0x7f61a55cffd0>, 0)],
             'bool90': [(<numba.core.ir.Assign object at 0x7f61a551fb90>, 80)],
             'mag': [(<numba.core.ir.Assign object at 0x7f61a55cf210>, 0)],
             'needs_negate': [(<numba.core.ir.Assign object at 0x7f61a5db73d0>,
                               174),
                              (<numba.core.ir.Assign object at 0x7f61ca305090>,
                               190)],
             'ret': [(<numba.core.ir.Assign object at 0x7f61a551fa50>, 92),
                     (<numba.core.ir.Assign object at 0x7f61a6cae710>, 110),
                     (<numba.core.ir.Assign object at 0x7f61a6cee8d0>, 142),
                     (<numba.core.ir.Assign object at 0x7f61a6cc8050>, 200),
                     (<numba.core.ir.Assign object at 0x7f61ca2d6590>, 234)],
             'val': [(<numba.core.ir.Assign object at 0x7f61a55bf210>, 0)],
             'val.1': [(<numba.core.ir.Assign object at 0x7f61a55bea10>, 0),
                       (<numba.core.ir.Assign object at 0x7f61a6cc1a90>, 190)]})
SSA violators <numba.core.utils.OrderedSet object at 0x7f61a5da99d0>
Fix SSA violator on var val.1
==== SSA block rewrite pass on 0
Running <numba.core.ssa._FreshVarHandler object at 0x7f61a6cfd390>
on stmt: val = arg(0, name=val)
on stmt: $8load_deref.1 = freevar(_BIG: int64)
on stmt: val.1 = call $8load_deref.1(val, func=$8load_deref.1, args=[Var(val, old_hashing.py:237)], kws=(), vararg=None, varkwarg=None, target=None)
first assign: val.1
replaced with: val.1 = call $8load_deref.1(val, func=$8load_deref.1, args=[Var(val, old_hashing.py:237)], kws=(), vararg=None, varkwarg=None, target=None)
on stmt: $28load_global.4 = global(abs: <built-in function abs>)
on stmt: mag = call $28load_global.4(val.1, func=$28load_global.4, args=[Var(val.1, old_hashing.py:247)], kws=(), vararg=None, varkwarg=None, target=None)
on stmt: $60load_global.9 = global(_PyHASH_MODULUS: 2305843009213693951)
on stmt: $72compare_op.10 = mag < $60load_global.9
on stmt: bool78 = global(bool: <class 'bool'>)
on stmt: $78pred = call bool78($72compare_op.10, func=bool78, args=(Var($72compare_op.10, old_hashing.py:249),), kws=(), vararg=None, varkwarg=None, target=None)
on stmt: branch $78pred, 80, 174
==== SSA block rewrite pass on 80
Running <numba.core.ssa._FreshVarHandler object at 0x7f61a6cfd390>
on stmt: $const82.1.1 = const(int, 0)
on stmt: $84compare_op.2 = val.1 == $const82.1.1
on stmt: bool90 = global(bool: <class 'bool'>)
on stmt: $90pred = call bool90($84compare_op.2, func=bool90, args=(Var($84compare_op.2, old_hashing.py:250),), kws=(), vararg=None, varkwarg=None, target=None)
on stmt: branch $90pred, 92, 98
==== SSA block rewrite pass on 92
Running <numba.core.ssa._FreshVarHandler object at 0x7f61a6cfd390>
on stmt: ret = const(int, 0)
on stmt: jump 240
==== SSA block rewrite pass on 98
Running <numba.core.ssa._FreshVarHandler object at 0x7f61a6cfd390>
on stmt: $100load_deref.1 = freevar(_SIGNED_MIN: -9223372036854775808)
on stmt: $102compare_op.2 = val.1 == $100load_deref.1
on stmt: bool108 = global(bool: <class 'bool'>)
on stmt: $108pred = call bool108($102compare_op.2, func=bool108, args=(Var($102compare_op.2, old_hashing.py:252),), kws=(), vararg=None, varkwarg=None, target=None)
on stmt: branch $108pred, 110, 142
==== SSA block rewrite pass on 110
Running <numba.core.ssa._FreshVarHandler object at 0x7f61a6cfd390>
on stmt: $110load_global.0 = global(_Py_hash_t: int64)
on stmt: $122load_deref.2 = freevar(_HASH_I64_MIN: -4)
on stmt: ret = call $110load_global.0($122load_deref.2, func=$110load_global.0, args=[Var($122load_deref.2, old_hashing.py:253)], kws=(), vararg=None, varkwarg=None, target=None)
on stmt: jump 240
==== SSA block rewrite pass on 142
Running <numba.core.ssa._FreshVarHandler object at 0x7f61a6cfd390>
on stmt: $142load_global.0 = global(_Py_hash_t: int64)
on stmt: ret = call $142load_global.0(val.1, func=$142load_global.0, args=[Var(val.1, old_hashing.py:247)], kws=(), vararg=None, varkwarg=None, target=None)
on stmt: jump 240
==== SSA block rewrite pass on 174
Running <numba.core.ssa._FreshVarHandler object at 0x7f61a6cfd390>
on stmt: needs_negate = const(bool, False)
on stmt: $const180.2.1 = const(int, 0)
on stmt: $182compare_op.3 = val.1 < $const180.2.1
on stmt: bool188 = global(bool: <class 'bool'>)
on stmt: $188pred = call bool188($182compare_op.3, func=bool188, args=(Var($182compare_op.3, old_hashing.py:258),), kws=(), vararg=None, varkwarg=None, target=None)
on stmt: branch $188pred, 190, 200
==== SSA block rewrite pass on 190
Running <numba.core.ssa._FreshVarHandler object at 0x7f61a6cfd390>
on stmt: val.1 = unary(fn=<built-in function neg>, value=val.1)
replaced with: val.1.1 = unary(fn=<built-in function neg>, value=val.1)
on stmt: needs_negate = const(bool, True)
on stmt: jump 200
==== SSA block rewrite pass on 200
Running <numba.core.ssa._FreshVarHandler object at 0x7f61a6cfd390>
on stmt: $200load_global.0 = global(_long_impl: <function _long_impl at 0x7f61cafc94e0>)
on stmt: ret = call $200load_global.0(val.1, func=$200load_global.0, args=[Var(val.1, old_hashing.py:247)], kws=(), vararg=None, varkwarg=None, target=None)
on stmt: bool232 = global(bool: <class 'bool'>)
on stmt: $232pred = call bool232(needs_negate, func=bool232, args=(Var(needs_negate, old_hashing.py:257),), kws=(), vararg=None, varkwarg=None, target=None)
on stmt: branch $232pred, 234, 240
==== SSA block rewrite pass on 234
Running <numba.core.ssa._FreshVarHandler object at 0x7f61a6cfd390>
on stmt: ret = unary(fn=<built-in function neg>, value=ret)
on stmt: jump 240
==== SSA block rewrite pass on 240
Running <numba.core.ssa._FreshVarHandler object at 0x7f61a6cfd390>
on stmt: $240load_global.0 = global(process_return: <function process_return at 0x7f61cb0c7560>)
on stmt: $258call.3 = call $240load_global.0(ret, func=$240load_global.0, args=[Var(ret, old_hashing.py:251)], kws=(), vararg=None, varkwarg=None, target=None)
on stmt: $268return_value.4 = cast(value=$258call.3)
on stmt: return $268return_value.4
Replaced assignments: defaultdict(<class 'list'>,
            {0: [<numba.core.ir.Assign object at 0x7f61a6c8a050>],
             190: [<numba.core.ir.Assign object at 0x7f61a55bef90>]})
==== SSA block rewrite pass on 0
Running <numba.core.ssa._FixSSAVars object at 0x7f61a55bee50>
on stmt: val = arg(0, name=val)
on stmt: $8load_deref.1 = freevar(_BIG: int64)
on stmt: val.1 = call $8load_deref.1(val, func=$8load_deref.1, args=[Var(val, old_hashing.py:237)], kws=(), vararg=None, varkwarg=None, target=None)
on stmt: $28load_global.4 = global(abs: <built-in function abs>)
on stmt: mag = call $28load_global.4(val.1, func=$28load_global.4, args=[Var(val.1, old_hashing.py:247)], kws=(), vararg=None, varkwarg=None, target=None)
find_def var='val.1' stmt=mag = call $28load_global.4(val.1, func=$28load_global.4, args=[Var(val.1, old_hashing.py:247)], kws=(), vararg=None, varkwarg=None, target=None)
on stmt: $60load_global.9 = global(_PyHASH_MODULUS: 2305843009213693951)
on stmt: $72compare_op.10 = mag < $60load_global.9
on stmt: bool78 = global(bool: <class 'bool'>)
on stmt: $78pred = call bool78($72compare_op.10, func=bool78, args=(Var($72compare_op.10, old_hashing.py:249),), kws=(), vararg=None, varkwarg=None, target=None)
on stmt: branch $78pred, 80, 174
==== SSA block rewrite pass on 80
Running <numba.core.ssa._FixSSAVars object at 0x7f61a55bee50>
on stmt: $const82.1.1 = const(int, 0)
on stmt: $84compare_op.2 = val.1 == $const82.1.1
find_def var='val.1' stmt=$84compare_op.2 = val.1 == $const82.1.1
find_def_from_top label 80
idom 0 from label 80
find_def_from_bottom label 0
on stmt: bool90 = global(bool: <class 'bool'>)
on stmt: $90pred = call bool90($84compare_op.2, func=bool90, args=(Var($84compare_op.2, old_hashing.py:250),), kws=(), vararg=None, varkwarg=None, target=None)
on stmt: branch $90pred, 92, 98
==== SSA block rewrite pass on 92
Running <numba.core.ssa._FixSSAVars object at 0x7f61a55bee50>
on stmt: ret = const(int, 0)
on stmt: jump 240
==== SSA block rewrite pass on 98
Running <numba.core.ssa._FixSSAVars object at 0x7f61a55bee50>
on stmt: $100load_deref.1 = freevar(_SIGNED_MIN: -9223372036854775808)
on stmt: $102compare_op.2 = val.1 == $100load_deref.1
find_def var='val.1' stmt=$102compare_op.2 = val.1 == $100load_deref.1
find_def_from_top label 98
idom 80 from label 98
find_def_from_bottom label 80
find_def_from_top label 80
idom 0 from label 80
find_def_from_bottom label 0
on stmt: bool108 = global(bool: <class 'bool'>)
on stmt: $108pred = call bool108($102compare_op.2, func=bool108, args=(Var($102compare_op.2, old_hashing.py:252),), kws=(), vararg=None, varkwarg=None, target=None)
on stmt: branch $108pred, 110, 142
==== SSA block rewrite pass on 110
Running <numba.core.ssa._FixSSAVars object at 0x7f61a55bee50>
on stmt: $110load_global.0 = global(_Py_hash_t: int64)
on stmt: $122load_deref.2 = freevar(_HASH_I64_MIN: -4)
on stmt: ret = call $110load_global.0($122load_deref.2, func=$110load_global.0, args=[Var($122load_deref.2, old_hashing.py:253)], kws=(), vararg=None, varkwarg=None, target=None)
on stmt: jump 240
==== SSA block rewrite pass on 142
Running <numba.core.ssa._FixSSAVars object at 0x7f61a55bee50>
on stmt: $142load_global.0 = global(_Py_hash_t: int64)
on stmt: ret = call $142load_global.0(val.1, func=$142load_global.0, args=[Var(val.1, old_hashing.py:247)], kws=(), vararg=None, varkwarg=None, target=None)
find_def var='val.1' stmt=ret = call $142load_global.0(val.1, func=$142load_global.0, args=[Var(val.1, old_hashing.py:247)], kws=(), vararg=None, varkwarg=None, target=None)
find_def_from_top label 142
idom 98 from label 142
find_def_from_bottom label 98
find_def_from_top label 98
idom 80 from label 98
find_def_from_bottom label 80
find_def_from_top label 80
idom 0 from label 80
find_def_from_bottom label 0
on stmt: jump 240
==== SSA block rewrite pass on 174
Running <numba.core.ssa._FixSSAVars object at 0x7f61a55bee50>
on stmt: needs_negate = const(bool, False)
on stmt: $const180.2.1 = const(int, 0)
on stmt: $182compare_op.3 = val.1 < $const180.2.1
find_def var='val.1' stmt=$182compare_op.3 = val.1 < $const180.2.1
find_def_from_top label 174
idom 0 from label 174
find_def_from_bottom label 0
on stmt: bool188 = global(bool: <class 'bool'>)
on stmt: $188pred = call bool188($182compare_op.3, func=bool188, args=(Var($182compare_op.3, old_hashing.py:258),), kws=(), vararg=None, varkwarg=None, target=None)
on stmt: branch $188pred, 190, 200
==== SSA block rewrite pass on 190
Running <numba.core.ssa._FixSSAVars object at 0x7f61a55bee50>
on stmt: val.1.1 = unary(fn=<built-in function neg>, value=val.1)
find_def var='val.1' stmt=val.1.1 = unary(fn=<built-in function neg>, value=val.1)
find_def_from_top label 190
idom 174 from label 190
find_def_from_bottom label 174
find_def_from_top label 174
idom 0 from label 174
find_def_from_bottom label 0
on stmt: needs_negate = const(bool, True)
on stmt: jump 200
==== SSA block rewrite pass on 200
Running <numba.core.ssa._FixSSAVars object at 0x7f61a55bee50>
on stmt: $200load_global.0 = global(_long_impl: <function _long_impl at 0x7f61cafc94e0>)
on stmt: ret = call $200load_global.0(val.1, func=$200load_global.0, args=[Var(val.1, old_hashing.py:247)], kws=(), vararg=None, varkwarg=None, target=None)
find_def var='val.1' stmt=ret = call $200load_global.0(val.1, func=$200load_global.0, args=[Var(val.1, old_hashing.py:247)], kws=(), vararg=None, varkwarg=None, target=None)
find_def_from_top label 200
insert phi node val.1.2 = phi(incoming_values=[], incoming_blocks=[]) at 200
find_def_from_bottom label 190
incoming_def val.1.1 = unary(fn=<built-in function neg>, value=val.1)
find_def_from_bottom label 174
find_def_from_top label 174
idom 0 from label 174
find_def_from_bottom label 0
incoming_def val.1 = call $8load_deref.1(val, func=$8load_deref.1, args=[Var(val, old_hashing.py:237)], kws=(), vararg=None, varkwarg=None, target=None)
replaced with: ret = call $200load_global.0(val.1.2, func=$200load_global.0, args=[Var(val.1.2, old_hashing.py:261)], kws=(), vararg=None, varkwarg=None, target=None)
on stmt: bool232 = global(bool: <class 'bool'>)
on stmt: $232pred = call bool232(needs_negate, func=bool232, args=(Var(needs_negate, old_hashing.py:257),), kws=(), vararg=None, varkwarg=None, target=None)
on stmt: branch $232pred, 234, 240
==== SSA block rewrite pass on 234
Running <numba.core.ssa._FixSSAVars object at 0x7f61a55bee50>
on stmt: ret = unary(fn=<built-in function neg>, value=ret)
on stmt: jump 240
==== SSA block rewrite pass on 240
Running <numba.core.ssa._FixSSAVars object at 0x7f61a55bee50>
on stmt: $240load_global.0 = global(process_return: <function process_return at 0x7f61cb0c7560>)
on stmt: $258call.3 = call $240load_global.0(ret, func=$240load_global.0, args=[Var(ret, old_hashing.py:251)], kws=(), vararg=None, varkwarg=None, target=None)
on stmt: $268return_value.4 = cast(value=$258call.3)
on stmt: return $268return_value.4
Fix SSA violator on var ret
==== SSA block rewrite pass on 0
Running <numba.core.ssa._FreshVarHandler object at 0x7f61a6cfe0d0>
on stmt: val = arg(0, name=val)
on stmt: $8load_deref.1 = freevar(_BIG: int64)
on stmt: val.1 = call $8load_deref.1(val, func=$8load_deref.1, args=[Var(val, old_hashing.py:237)], kws=(), vararg=None, varkwarg=None, target=None)
on stmt: $28load_global.4 = global(abs: <built-in function abs>)
on stmt: mag = call $28load_global.4(val.1, func=$28load_global.4, args=[Var(val.1, old_hashing.py:247)], kws=(), vararg=None, varkwarg=None, target=None)
on stmt: $60load_global.9 = global(_PyHASH_MODULUS: 2305843009213693951)
on stmt: $72compare_op.10 = mag < $60load_global.9
on stmt: bool78 = global(bool: <class 'bool'>)
on stmt: $78pred = call bool78($72compare_op.10, func=bool78, args=(Var($72compare_op.10, old_hashing.py:249),), kws=(), vararg=None, varkwarg=None, target=None)
on stmt: branch $78pred, 80, 174
==== SSA block rewrite pass on 80
Running <numba.core.ssa._FreshVarHandler object at 0x7f61a6cfe0d0>
on stmt: $const82.1.1 = const(int, 0)
on stmt: $84compare_op.2 = val.1 == $const82.1.1
on stmt: bool90 = global(bool: <class 'bool'>)
on stmt: $90pred = call bool90($84compare_op.2, func=bool90, args=(Var($84compare_op.2, old_hashing.py:250),), kws=(), vararg=None, varkwarg=None, target=None)
on stmt: branch $90pred, 92, 98
==== SSA block rewrite pass on 92
Running <numba.core.ssa._FreshVarHandler object at 0x7f61a6cfe0d0>
on stmt: ret = const(int, 0)
first assign: ret
replaced with: ret = const(int, 0)
on stmt: jump 240
==== SSA block rewrite pass on 98
Running <numba.core.ssa._FreshVarHandler object at 0x7f61a6cfe0d0>
on stmt: $100load_deref.1 = freevar(_SIGNED_MIN: -9223372036854775808)
on stmt: $102compare_op.2 = val.1 == $100load_deref.1
on stmt: bool108 = global(bool: <class 'bool'>)
on stmt: $108pred = call bool108($102compare_op.2, func=bool108, args=(Var($102compare_op.2, old_hashing.py:252),), kws=(), vararg=None, varkwarg=None, target=None)
on stmt: branch $108pred, 110, 142
==== SSA block rewrite pass on 110
Running <numba.core.ssa._FreshVarHandler object at 0x7f61a6cfe0d0>
on stmt: $110load_global.0 = global(_Py_hash_t: int64)
on stmt: $122load_deref.2 = freevar(_HASH_I64_MIN: -4)
on stmt: ret = call $110load_global.0($122load_deref.2, func=$110load_global.0, args=[Var($122load_deref.2, old_hashing.py:253)], kws=(), vararg=None, varkwarg=None, target=None)
replaced with: ret.1 = call $110load_global.0($122load_deref.2, func=$110load_global.0, args=[Var($122load_deref.2, old_hashing.py:253)], kws=(), vararg=None, varkwarg=None, target=None)
on stmt: jump 240
==== SSA block rewrite pass on 142
Running <numba.core.ssa._FreshVarHandler object at 0x7f61a6cfe0d0>
on stmt: $142load_global.0 = global(_Py_hash_t: int64)
on stmt: ret = call $142load_global.0(val.1, func=$142load_global.0, args=[Var(val.1, old_hashing.py:247)], kws=(), vararg=None, varkwarg=None, target=None)
replaced with: ret.2 = call $142load_global.0(val.1, func=$142load_global.0, args=[Var(val.1, old_hashing.py:247)], kws=(), vararg=None, varkwarg=None, target=None)
on stmt: jump 240
==== SSA block rewrite pass on 174
Running <numba.core.ssa._FreshVarHandler object at 0x7f61a6cfe0d0>
on stmt: needs_negate = const(bool, False)
on stmt: $const180.2.1 = const(int, 0)
on stmt: $182compare_op.3 = val.1 < $const180.2.1
on stmt: bool188 = global(bool: <class 'bool'>)
on stmt: $188pred = call bool188($182compare_op.3, func=bool188, args=(Var($182compare_op.3, old_hashing.py:258),), kws=(), vararg=None, varkwarg=None, target=None)
on stmt: branch $188pred, 190, 200
==== SSA block rewrite pass on 190
Running <numba.core.ssa._FreshVarHandler object at 0x7f61a6cfe0d0>
on stmt: val.1.1 = unary(fn=<built-in function neg>, value=val.1)
on stmt: needs_negate = const(bool, True)
on stmt: jump 200
==== SSA block rewrite pass on 200
Running <numba.core.ssa._FreshVarHandler object at 0x7f61a6cfe0d0>
on stmt: val.1.2 = phi(incoming_values=[Var(val.1.1, old_hashing.py:259), Var(val.1, old_hashing.py:247)], incoming_blocks=[190, 174])
on stmt: $200load_global.0 = global(_long_impl: <function _long_impl at 0x7f61cafc94e0>)
on stmt: ret = call $200load_global.0(val.1.2, func=$200load_global.0, args=[Var(val.1.2, old_hashing.py:261)], kws=(), vararg=None, varkwarg=None, target=None)
replaced with: ret.3 = call $200load_global.0(val.1.2, func=$200load_global.0, args=[Var(val.1.2, old_hashing.py:261)], kws=(), vararg=None, varkwarg=None, target=None)
on stmt: bool232 = global(bool: <class 'bool'>)
on stmt: $232pred = call bool232(needs_negate, func=bool232, args=(Var(needs_negate, old_hashing.py:257),), kws=(), vararg=None, varkwarg=None, target=None)
on stmt: branch $232pred, 234, 240
==== SSA block rewrite pass on 234
Running <numba.core.ssa._FreshVarHandler object at 0x7f61a6cfe0d0>
on stmt: ret = unary(fn=<built-in function neg>, value=ret)
replaced with: ret.4 = unary(fn=<built-in function neg>, value=ret)
on stmt: jump 240
==== SSA block rewrite pass on 240
Running <numba.core.ssa._FreshVarHandler object at 0x7f61a6cfe0d0>
on stmt: $240load_global.0 = global(process_return: <function process_return at 0x7f61cb0c7560>)
on stmt: $258call.3 = call $240load_global.0(ret, func=$240load_global.0, args=[Var(ret, old_hashing.py:251)], kws=(), vararg=None, varkwarg=None, target=None)
on stmt: $268return_value.4 = cast(value=$258call.3)
on stmt: return $268return_value.4
Replaced assignments: defaultdict(<class 'list'>,
            {92: [<numba.core.ir.Assign object at 0x7f61a55bded0>],
             110: [<numba.core.ir.Assign object at 0x7f61a55be810>],
             142: [<numba.core.ir.Assign object at 0x7f61a55bcf90>],
             200: [<numba.core.ir.Assign object at 0x7f61a55cfb10>],
             234: [<numba.core.ir.Assign object at 0x7f61a55d2590>]})
==== SSA block rewrite pass on 0
Running <numba.core.ssa._FixSSAVars object at 0x7f61a5db72d0>
on stmt: val = arg(0, name=val)
on stmt: $8load_deref.1 = freevar(_BIG: int64)
on stmt: val.1 = call $8load_deref.1(val, func=$8load_deref.1, args=[Var(val, old_hashing.py:237)], kws=(), vararg=None, varkwarg=None, target=None)
on stmt: $28load_global.4 = global(abs: <built-in function abs>)
on stmt: mag = call $28load_global.4(val.1, func=$28load_global.4, args=[Var(val.1, old_hashing.py:247)], kws=(), vararg=None, varkwarg=None, target=None)
on stmt: $60load_global.9 = global(_PyHASH_MODULUS: 2305843009213693951)
on stmt: $72compare_op.10 = mag < $60load_global.9
on stmt: bool78 = global(bool: <class 'bool'>)
on stmt: $78pred = call bool78($72compare_op.10, func=bool78, args=(Var($72compare_op.10, old_hashing.py:249),), kws=(), vararg=None, varkwarg=None, target=None)
on stmt: branch $78pred, 80, 174
==== SSA block rewrite pass on 80
Running <numba.core.ssa._FixSSAVars object at 0x7f61a5db72d0>
on stmt: $const82.1.1 = const(int, 0)
on stmt: $84compare_op.2 = val.1 == $const82.1.1
on stmt: bool90 = global(bool: <class 'bool'>)
on stmt: $90pred = call bool90($84compare_op.2, func=bool90, args=(Var($84compare_op.2, old_hashing.py:250),), kws=(), vararg=None, varkwarg=None, target=None)
on stmt: branch $90pred, 92, 98
==== SSA block rewrite pass on 92
Running <numba.core.ssa._FixSSAVars object at 0x7f61a5db72d0>
on stmt: ret = const(int, 0)
on stmt: jump 240
==== SSA block rewrite pass on 98
Running <numba.core.ssa._FixSSAVars object at 0x7f61a5db72d0>
on stmt: $100load_deref.1 = freevar(_SIGNED_MIN: -9223372036854775808)
on stmt: $102compare_op.2 = val.1 == $100load_deref.1
on stmt: bool108 = global(bool: <class 'bool'>)
on stmt: $108pred = call bool108($102compare_op.2, func=bool108, args=(Var($102compare_op.2, old_hashing.py:252),), kws=(), vararg=None, varkwarg=None, target=None)
on stmt: branch $108pred, 110, 142
==== SSA block rewrite pass on 110
Running <numba.core.ssa._FixSSAVars object at 0x7f61a5db72d0>
on stmt: $110load_global.0 = global(_Py_hash_t: int64)
on stmt: $122load_deref.2 = freevar(_HASH_I64_MIN: -4)
on stmt: ret.1 = call $110load_global.0($122load_deref.2, func=$110load_global.0, args=[Var($122load_deref.2, old_hashing.py:253)], kws=(), vararg=None, varkwarg=None, target=None)
on stmt: jump 240
==== SSA block rewrite pass on 142
Running <numba.core.ssa._FixSSAVars object at 0x7f61a5db72d0>
on stmt: $142load_global.0 = global(_Py_hash_t: int64)
on stmt: ret.2 = call $142load_global.0(val.1, func=$142load_global.0, args=[Var(val.1, old_hashing.py:247)], kws=(), vararg=None, varkwarg=None, target=None)
on stmt: jump 240
==== SSA block rewrite pass on 174
Running <numba.core.ssa._FixSSAVars object at 0x7f61a5db72d0>
on stmt: needs_negate = const(bool, False)
on stmt: $const180.2.1 = const(int, 0)
on stmt: $182compare_op.3 = val.1 < $const180.2.1
on stmt: bool188 = global(bool: <class 'bool'>)
on stmt: $188pred = call bool188($182compare_op.3, func=bool188, args=(Var($182compare_op.3, old_hashing.py:258),), kws=(), vararg=None, varkwarg=None, target=None)
on stmt: branch $188pred, 190, 200
==== SSA block rewrite pass on 190
Running <numba.core.ssa._FixSSAVars object at 0x7f61a5db72d0>
on stmt: val.1.1 = unary(fn=<built-in function neg>, value=val.1)
on stmt: needs_negate = const(bool, True)
on stmt: jump 200
==== SSA block rewrite pass on 200
Running <numba.core.ssa._FixSSAVars object at 0x7f61a5db72d0>
on stmt: val.1.2 = phi(incoming_values=[Var(val.1.1, old_hashing.py:259), Var(val.1, old_hashing.py:247)], incoming_blocks=[190, 174])
on stmt: $200load_global.0 = global(_long_impl: <function _long_impl at 0x7f61cafc94e0>)
on stmt: ret.3 = call $200load_global.0(val.1.2, func=$200load_global.0, args=[Var(val.1.2, old_hashing.py:261)], kws=(), vararg=None, varkwarg=None, target=None)
on stmt: bool232 = global(bool: <class 'bool'>)
on stmt: $232pred = call bool232(needs_negate, func=bool232, args=(Var(needs_negate, old_hashing.py:257),), kws=(), vararg=None, varkwarg=None, target=None)
on stmt: branch $232pred, 234, 240
==== SSA block rewrite pass on 234
Running <numba.core.ssa._FixSSAVars object at 0x7f61a5db72d0>
on stmt: ret.4 = unary(fn=<built-in function neg>, value=ret)
find_def var='ret' stmt=ret.4 = unary(fn=<built-in function neg>, value=ret)
find_def_from_top label 234
idom 200 from label 234
find_def_from_bottom label 200
replaced with: ret.4 = unary(fn=<built-in function neg>, value=ret.3)
on stmt: jump 240
==== SSA block rewrite pass on 240
Running <numba.core.ssa._FixSSAVars object at 0x7f61a5db72d0>
on stmt: $240load_global.0 = global(process_return: <function process_return at 0x7f61cb0c7560>)
on stmt: $258call.3 = call $240load_global.0(ret, func=$240load_global.0, args=[Var(ret, old_hashing.py:251)], kws=(), vararg=None, varkwarg=None, target=None)
find_def var='ret' stmt=$258call.3 = call $240load_global.0(ret, func=$240load_global.0, args=[Var(ret, old_hashing.py:251)], kws=(), vararg=None, varkwarg=None, target=None)
find_def_from_top label 240
insert phi node ret.5 = phi(incoming_values=[], incoming_blocks=[]) at 240
find_def_from_bottom label 200
incoming_def ret.3 = call $200load_global.0(val.1.2, func=$200load_global.0, args=[Var(val.1.2, old_hashing.py:261)], kws=(), vararg=None, varkwarg=None, target=None)
find_def_from_bottom label 234
incoming_def ret.4 = unary(fn=<built-in function neg>, value=ret.3)
find_def_from_bottom label 142
incoming_def ret.2 = call $142load_global.0(val.1, func=$142load_global.0, args=[Var(val.1, old_hashing.py:247)], kws=(), vararg=None, varkwarg=None, target=None)
find_def_from_bottom label 110
incoming_def ret.1 = call $110load_global.0($122load_deref.2, func=$110load_global.0, args=[Var($122load_deref.2, old_hashing.py:253)], kws=(), vararg=None, varkwarg=None, target=None)
find_def_from_bottom label 92
incoming_def ret = const(int, 0)
replaced with: $258call.3 = call $240load_global.0(ret.5, func=$240load_global.0, args=[Var(ret.5, old_hashing.py:264)], kws=(), vararg=None, varkwarg=None, target=None)
on stmt: $268return_value.4 = cast(value=$258call.3)
on stmt: return $268return_value.4
Fix SSA violator on var needs_negate
==== SSA block rewrite pass on 0
Running <numba.core.ssa._FreshVarHandler object at 0x7f61a5dc3150>
on stmt: val = arg(0, name=val)
on stmt: $8load_deref.1 = freevar(_BIG: int64)
on stmt: val.1 = call $8load_deref.1(val, func=$8load_deref.1, args=[Var(val, old_hashing.py:237)], kws=(), vararg=None, varkwarg=None, target=None)
on stmt: $28load_global.4 = global(abs: <built-in function abs>)
on stmt: mag = call $28load_global.4(val.1, func=$28load_global.4, args=[Var(val.1, old_hashing.py:247)], kws=(), vararg=None, varkwarg=None, target=None)
on stmt: $60load_global.9 = global(_PyHASH_MODULUS: 2305843009213693951)
on stmt: $72compare_op.10 = mag < $60load_global.9
on stmt: bool78 = global(bool: <class 'bool'>)
on stmt: $78pred = call bool78($72compare_op.10, func=bool78, args=(Var($72compare_op.10, old_hashing.py:249),), kws=(), vararg=None, varkwarg=None, target=None)
on stmt: branch $78pred, 80, 174
==== SSA block rewrite pass on 80
Running <numba.core.ssa._FreshVarHandler object at 0x7f61a5dc3150>
on stmt: $const82.1.1 = const(int, 0)
on stmt: $84compare_op.2 = val.1 == $const82.1.1
on stmt: bool90 = global(bool: <class 'bool'>)
on stmt: $90pred = call bool90($84compare_op.2, func=bool90, args=(Var($84compare_op.2, old_hashing.py:250),), kws=(), vararg=None, varkwarg=None, target=None)
on stmt: branch $90pred, 92, 98
==== SSA block rewrite pass on 92
Running <numba.core.ssa._FreshVarHandler object at 0x7f61a5dc3150>
on stmt: ret = const(int, 0)
on stmt: jump 240
==== SSA block rewrite pass on 98
Running <numba.core.ssa._FreshVarHandler object at 0x7f61a5dc3150>
on stmt: $100load_deref.1 = freevar(_SIGNED_MIN: -9223372036854775808)
on stmt: $102compare_op.2 = val.1 == $100load_deref.1
on stmt: bool108 = global(bool: <class 'bool'>)
on stmt: $108pred = call bool108($102compare_op.2, func=bool108, args=(Var($102compare_op.2, old_hashing.py:252),), kws=(), vararg=None, varkwarg=None, target=None)
on stmt: branch $108pred, 110, 142
==== SSA block rewrite pass on 110
Running <numba.core.ssa._FreshVarHandler object at 0x7f61a5dc3150>
on stmt: $110load_global.0 = global(_Py_hash_t: int64)
on stmt: $122load_deref.2 = freevar(_HASH_I64_MIN: -4)
on stmt: ret.1 = call $110load_global.0($122load_deref.2, func=$110load_global.0, args=[Var($122load_deref.2, old_hashing.py:253)], kws=(), vararg=None, varkwarg=None, target=None)
on stmt: jump 240
==== SSA block rewrite pass on 142
Running <numba.core.ssa._FreshVarHandler object at 0x7f61a5dc3150>
on stmt: $142load_global.0 = global(_Py_hash_t: int64)
on stmt: ret.2 = call $142load_global.0(val.1, func=$142load_global.0, args=[Var(val.1, old_hashing.py:247)], kws=(), vararg=None, varkwarg=None, target=None)
on stmt: jump 240
==== SSA block rewrite pass on 174
Running <numba.core.ssa._FreshVarHandler object at 0x7f61a5dc3150>
on stmt: needs_negate = const(bool, False)
first assign: needs_negate
replaced with: needs_negate = const(bool, False)
on stmt: $const180.2.1 = const(int, 0)
on stmt: $182compare_op.3 = val.1 < $const180.2.1
on stmt: bool188 = global(bool: <class 'bool'>)
on stmt: $188pred = call bool188($182compare_op.3, func=bool188, args=(Var($182compare_op.3, old_hashing.py:258),), kws=(), vararg=None, varkwarg=None, target=None)
on stmt: branch $188pred, 190, 200
==== SSA block rewrite pass on 190
Running <numba.core.ssa._FreshVarHandler object at 0x7f61a5dc3150>
on stmt: val.1.1 = unary(fn=<built-in function neg>, value=val.1)
on stmt: needs_negate = const(bool, True)
replaced with: needs_negate.1 = const(bool, True)
on stmt: jump 200
==== SSA block rewrite pass on 200
Running <numba.core.ssa._FreshVarHandler object at 0x7f61a5dc3150>
on stmt: val.1.2 = phi(incoming_values=[Var(val.1.1, old_hashing.py:259), Var(val.1, old_hashing.py:247)], incoming_blocks=[190, 174])
on stmt: $200load_global.0 = global(_long_impl: <function _long_impl at 0x7f61cafc94e0>)
on stmt: ret.3 = call $200load_global.0(val.1.2, func=$200load_global.0, args=[Var(val.1.2, old_hashing.py:261)], kws=(), vararg=None, varkwarg=None, target=None)
on stmt: bool232 = global(bool: <class 'bool'>)
on stmt: $232pred = call bool232(needs_negate, func=bool232, args=(Var(needs_negate, old_hashing.py:257),), kws=(), vararg=None, varkwarg=None, target=None)
on stmt: branch $232pred, 234, 240
==== SSA block rewrite pass on 234
Running <numba.core.ssa._FreshVarHandler object at 0x7f61a5dc3150>
on stmt: ret.4 = unary(fn=<built-in function neg>, value=ret.3)
on stmt: jump 240
==== SSA block rewrite pass on 240
Running <numba.core.ssa._FreshVarHandler object at 0x7f61a5dc3150>
on stmt: ret.5 = phi(incoming_values=[Var(ret.3, old_hashing.py:261), Var(ret.4, old_hashing.py:263), Var(ret.2, old_hashing.py:255), Var(ret.1, old_hashing.py:253), Var(ret, old_hashing.py:251)], incoming_blocks=[200, 234, 142, 110, 92])
on stmt: $240load_global.0 = global(process_return: <function process_return at 0x7f61cb0c7560>)
on stmt: $258call.3 = call $240load_global.0(ret.5, func=$240load_global.0, args=[Var(ret.5, old_hashing.py:264)], kws=(), vararg=None, varkwarg=None, target=None)
on stmt: $268return_value.4 = cast(value=$258call.3)
on stmt: return $268return_value.4
Replaced assignments: defaultdict(<class 'list'>,
            {174: [<numba.core.ir.Assign object at 0x7f61a55bcdd0>],
             190: [<numba.core.ir.Assign object at 0x7f61a55e0b50>]})
==== SSA block rewrite pass on 0
Running <numba.core.ssa._FixSSAVars object at 0x7f61a6d19c10>
on stmt: val = arg(0, name=val)
on stmt: $8load_deref.1 = freevar(_BIG: int64)
on stmt: val.1 = call $8load_deref.1(val, func=$8load_deref.1, args=[Var(val, old_hashing.py:237)], kws=(), vararg=None, varkwarg=None, target=None)
on stmt: $28load_global.4 = global(abs: <built-in function abs>)
on stmt: mag = call $28load_global.4(val.1, func=$28load_global.4, args=[Var(val.1, old_hashing.py:247)], kws=(), vararg=None, varkwarg=None, target=None)
on stmt: $60load_global.9 = global(_PyHASH_MODULUS: 2305843009213693951)
on stmt: $72compare_op.10 = mag < $60load_global.9
on stmt: bool78 = global(bool: <class 'bool'>)
on stmt: $78pred = call bool78($72compare_op.10, func=bool78, args=(Var($72compare_op.10, old_hashing.py:249),), kws=(), vararg=None, varkwarg=None, target=None)
on stmt: branch $78pred, 80, 174
==== SSA block rewrite pass on 80
Running <numba.core.ssa._FixSSAVars object at 0x7f61a6d19c10>
on stmt: $const82.1.1 = const(int, 0)
on stmt: $84compare_op.2 = val.1 == $const82.1.1
on stmt: bool90 = global(bool: <class 'bool'>)
on stmt: $90pred = call bool90($84compare_op.2, func=bool90, args=(Var($84compare_op.2, old_hashing.py:250),), kws=(), vararg=None, varkwarg=None, target=None)
on stmt: branch $90pred, 92, 98
==== SSA block rewrite pass on 92
Running <numba.core.ssa._FixSSAVars object at 0x7f61a6d19c10>
on stmt: ret = const(int, 0)
on stmt: jump 240
==== SSA block rewrite pass on 98
Running <numba.core.ssa._FixSSAVars object at 0x7f61a6d19c10>
on stmt: $100load_deref.1 = freevar(_SIGNED_MIN: -9223372036854775808)
on stmt: $102compare_op.2 = val.1 == $100load_deref.1
on stmt: bool108 = global(bool: <class 'bool'>)
on stmt: $108pred = call bool108($102compare_op.2, func=bool108, args=(Var($102compare_op.2, old_hashing.py:252),), kws=(), vararg=None, varkwarg=None, target=None)
on stmt: branch $108pred, 110, 142
==== SSA block rewrite pass on 110
Running <numba.core.ssa._FixSSAVars object at 0x7f61a6d19c10>
on stmt: $110load_global.0 = global(_Py_hash_t: int64)
on stmt: $122load_deref.2 = freevar(_HASH_I64_MIN: -4)
on stmt: ret.1 = call $110load_global.0($122load_deref.2, func=$110load_global.0, args=[Var($122load_deref.2, old_hashing.py:253)], kws=(), vararg=None, varkwarg=None, target=None)
on stmt: jump 240
==== SSA block rewrite pass on 142
Running <numba.core.ssa._FixSSAVars object at 0x7f61a6d19c10>
on stmt: $142load_global.0 = global(_Py_hash_t: int64)
on stmt: ret.2 = call $142load_global.0(val.1, func=$142load_global.0, args=[Var(val.1, old_hashing.py:247)], kws=(), vararg=None, varkwarg=None, target=None)
on stmt: jump 240
==== SSA block rewrite pass on 174
Running <numba.core.ssa._FixSSAVars object at 0x7f61a6d19c10>
on stmt: needs_negate = const(bool, False)
on stmt: $const180.2.1 = const(int, 0)
on stmt: $182compare_op.3 = val.1 < $const180.2.1
on stmt: bool188 = global(bool: <class 'bool'>)
on stmt: $188pred = call bool188($182compare_op.3, func=bool188, args=(Var($182compare_op.3, old_hashing.py:258),), kws=(), vararg=None, varkwarg=None, target=None)
on stmt: branch $188pred, 190, 200
==== SSA block rewrite pass on 190
Running <numba.core.ssa._FixSSAVars object at 0x7f61a6d19c10>
on stmt: val.1.1 = unary(fn=<built-in function neg>, value=val.1)
on stmt: needs_negate.1 = const(bool, True)
on stmt: jump 200
==== SSA block rewrite pass on 200
Running <numba.core.ssa._FixSSAVars object at 0x7f61a6d19c10>
on stmt: val.1.2 = phi(incoming_values=[Var(val.1.1, old_hashing.py:259), Var(val.1, old_hashing.py:247)], incoming_blocks=[190, 174])
on stmt: $200load_global.0 = global(_long_impl: <function _long_impl at 0x7f61cafc94e0>)
on stmt: ret.3 = call $200load_global.0(val.1.2, func=$200load_global.0, args=[Var(val.1.2, old_hashing.py:261)], kws=(), vararg=None, varkwarg=None, target=None)
on stmt: bool232 = global(bool: <class 'bool'>)
on stmt: $232pred = call bool232(needs_negate, func=bool232, args=(Var(needs_negate, old_hashing.py:257),), kws=(), vararg=None, varkwarg=None, target=None)
find_def var='needs_negate' stmt=$232pred = call bool232(needs_negate, func=bool232, args=(Var(needs_negate, old_hashing.py:257),), kws=(), vararg=None, varkwarg=None, target=None)
find_def_from_top label 200
insert phi node needs_negate.2 = phi(incoming_values=[], incoming_blocks=[]) at 200
find_def_from_bottom label 190
incoming_def needs_negate.1 = const(bool, True)
find_def_from_bottom label 174
incoming_def needs_negate = const(bool, False)
replaced with: $232pred = call bool232(needs_negate.2, func=bool232, args=(Var(needs_negate.2, old_hashing.py:261),), kws=(), vararg=None, varkwarg=None, target=None)
on stmt: branch $232pred, 234, 240
==== SSA block rewrite pass on 234
Running <numba.core.ssa._FixSSAVars object at 0x7f61a6d19c10>
on stmt: ret.4 = unary(fn=<built-in function neg>, value=ret.3)
on stmt: jump 240
==== SSA block rewrite pass on 240
Running <numba.core.ssa._FixSSAVars object at 0x7f61a6d19c10>
on stmt: ret.5 = phi(incoming_values=[Var(ret.3, old_hashing.py:261), Var(ret.4, old_hashing.py:263), Var(ret.2, old_hashing.py:255), Var(ret.1, old_hashing.py:253), Var(ret, old_hashing.py:251)], incoming_blocks=[200, 234, 142, 110, 92])
on stmt: $240load_global.0 = global(process_return: <function process_return at 0x7f61cb0c7560>)
on stmt: $258call.3 = call $240load_global.0(ret.5, func=$240load_global.0, args=[Var(ret.5, old_hashing.py:264)], kws=(), vararg=None, varkwarg=None, target=None)
on stmt: $268return_value.4 = cast(value=$258call.3)
on stmt: return $268return_value.4
bytecode dump:
>          0	NOP(arg=None, lineno=188)
           2	RESUME(arg=0, lineno=188)
           4	LOAD_CONST(arg=1, lineno=202)
           6	LOAD_GLOBAL(arg=0, lineno=202)
          18	BINARY_OP(arg=10, lineno=202)
          22	STORE_FAST(arg=1, lineno=202)
          24	LOAD_GLOBAL(arg=3, lineno=203)
          36	LOAD_ATTR(arg=2, lineno=203)
          46	LOAD_CONST(arg=2, lineno=203)
          48	PRECALL(arg=1, lineno=203)
          52	CALL(arg=1, lineno=203)
          62	UNARY_INVERT(arg=None, lineno=203)
          64	LOAD_FAST(arg=1, lineno=203)
          66	BINARY_OP(arg=9, lineno=203)
          70	STORE_FAST(arg=2, lineno=203)
          72	LOAD_CONST(arg=3, lineno=207)
          74	LOAD_GLOBAL(arg=0, lineno=207)
          86	BINARY_OP(arg=2, lineno=207)
          90	LOAD_CONST(arg=4, lineno=207)
          92	BINARY_OP(arg=0, lineno=207)
          96	STORE_FAST(arg=3, lineno=207)
          98	LOAD_CONST(arg=2, lineno=210)
         100	STORE_FAST(arg=4, lineno=210)
         102	LOAD_GLOBAL(arg=6, lineno=211)
         114	LOAD_GLOBAL(arg=0, lineno=211)
         126	BINARY_OP(arg=10, lineno=211)
         130	STORE_FAST(arg=5, lineno=211)
         132	LOAD_GLOBAL(arg=9, lineno=212)
         144	LOAD_FAST(arg=3, lineno=212)
         146	LOAD_CONST(arg=4, lineno=212)
         148	BINARY_OP(arg=10, lineno=212)
         152	LOAD_CONST(arg=5, lineno=212)
         154	LOAD_CONST(arg=5, lineno=212)
         156	PRECALL(arg=3, lineno=212)
         160	CALL(arg=3, lineno=212)
         170	GET_ITER(arg=None, lineno=212)
>        172	FOR_ITER(arg=90, lineno=212)
         174	STORE_FAST(arg=6, lineno=212)
         176	LOAD_FAST(arg=4, lineno=213)
         178	LOAD_GLOBAL(arg=0, lineno=213)
         190	BINARY_OP(arg=3, lineno=213)
         194	STORE_FAST(arg=7, lineno=213)
         196	LOAD_FAST(arg=7, lineno=214)
         198	LOAD_GLOBAL(arg=10, lineno=214)
         210	BINARY_OP(arg=1, lineno=214)
         214	STORE_FAST(arg=8, lineno=214)
         216	LOAD_FAST(arg=4, lineno=215)
         218	LOAD_FAST(arg=5, lineno=215)
         220	BINARY_OP(arg=9, lineno=215)
         224	STORE_FAST(arg=9, lineno=215)
         226	LOAD_FAST(arg=8, lineno=216)
         228	LOAD_FAST(arg=9, lineno=216)
         230	BINARY_OP(arg=7, lineno=216)
         234	STORE_FAST(arg=4, lineno=216)
         236	LOAD_FAST(arg=4, lineno=218)
         238	LOAD_GLOBAL(arg=3, lineno=218)
         250	LOAD_ATTR(arg=2, lineno=218)
         260	LOAD_FAST(arg=0, lineno=218)
         262	LOAD_FAST(arg=6, lineno=218)
         264	LOAD_GLOBAL(arg=0, lineno=218)
         276	BINARY_OP(arg=5, lineno=218)
         280	BINARY_OP(arg=9, lineno=218)
         284	LOAD_FAST(arg=2, lineno=218)
         286	BINARY_OP(arg=1, lineno=218)
         290	PRECALL(arg=1, lineno=218)
         294	CALL(arg=1, lineno=218)
         304	BINARY_OP(arg=13, lineno=218)
         308	STORE_FAST(arg=4, lineno=218)
         310	LOAD_FAST(arg=4, lineno=219)
         312	LOAD_GLOBAL(arg=10, lineno=219)
         324	COMPARE_OP(arg=5, lineno=219)
         330	POP_JUMP_FORWARD_IF_FALSE(arg=10, lineno=219)
         332	LOAD_FAST(arg=4, lineno=220)
         334	LOAD_GLOBAL(arg=10, lineno=220)
         346	BINARY_OP(arg=23, lineno=220)
         350	STORE_FAST(arg=4, lineno=220)
>        352	JUMP_BACKWARD(arg=91, lineno=220)
>        354	LOAD_GLOBAL(arg=13, lineno=221)
         366	LOAD_FAST(arg=4, lineno=221)
         368	PRECALL(arg=1, lineno=221)
         372	CALL(arg=1, lineno=221)
         382	RETURN_VALUE(arg=None, lineno=221)
pending: deque([State(pc_initial=0 nstack_initial=0)])
stack: []
state.pc_initial: State(pc_initial=0 nstack_initial=0)
dispatch pc=0, inst=NOP(arg=None, lineno=188)
stack []
dispatch pc=2, inst=RESUME(arg=0, lineno=188)
stack []
dispatch pc=4, inst=LOAD_CONST(arg=1, lineno=202)
stack []
dispatch pc=6, inst=LOAD_GLOBAL(arg=0, lineno=202)
stack ['$const4.0.1']
dispatch pc=18, inst=BINARY_OP(arg=10, lineno=202)
stack ['$const4.0.1', '$6load_global.1']
dispatch pc=22, inst=STORE_FAST(arg=1, lineno=202)
stack ['$binop_sub18.2']
dispatch pc=24, inst=LOAD_GLOBAL(arg=3, lineno=203)
stack []
dispatch pc=36, inst=LOAD_ATTR(arg=2, lineno=203)
stack ['$null$24.4', '$24load_global.3']
dispatch pc=46, inst=LOAD_CONST(arg=2, lineno=203)
stack ['$null$24.4', '$36load_attr.5']
dispatch pc=48, inst=PRECALL(arg=1, lineno=203)
stack ['$null$24.4', '$36load_attr.5', '$const46.6.2']
dispatch pc=52, inst=CALL(arg=1, lineno=203)
stack ['$null$24.4', '$36load_attr.5', '$const46.6.2']
dispatch pc=62, inst=UNARY_INVERT(arg=None, lineno=203)
stack ['$52call.7']
dispatch pc=64, inst=LOAD_FAST(arg=1, lineno=203)
stack ['$62unary_invert.8']
dispatch pc=66, inst=BINARY_OP(arg=9, lineno=203)
stack ['$62unary_invert.8', '$_tmp_shift64.9']
dispatch pc=70, inst=STORE_FAST(arg=2, lineno=203)
stack ['$binop_rshift66.10']
dispatch pc=72, inst=LOAD_CONST(arg=3, lineno=207)
stack []
dispatch pc=74, inst=LOAD_GLOBAL(arg=0, lineno=207)
stack ['$const72.11.3']
dispatch pc=86, inst=BINARY_OP(arg=2, lineno=207)
stack ['$const72.11.3', '$74load_global.12']
dispatch pc=90, inst=LOAD_CONST(arg=4, lineno=207)
stack ['$binop_floordiv86.13']
dispatch pc=92, inst=BINARY_OP(arg=0, lineno=207)
stack ['$binop_floordiv86.13', '$const90.14.4']
dispatch pc=96, inst=STORE_FAST(arg=3, lineno=207)
stack ['$binop_add92.15']
dispatch pc=98, inst=LOAD_CONST(arg=2, lineno=210)
stack []
dispatch pc=100, inst=STORE_FAST(arg=4, lineno=210)
stack ['$const98.16.2']
dispatch pc=102, inst=LOAD_GLOBAL(arg=6, lineno=211)
stack []
dispatch pc=114, inst=LOAD_GLOBAL(arg=0, lineno=211)
stack ['$102load_global.17']
dispatch pc=126, inst=BINARY_OP(arg=10, lineno=211)
stack ['$102load_global.17', '$114load_global.18']
dispatch pc=130, inst=STORE_FAST(arg=5, lineno=211)
stack ['$binop_sub126.19']
dispatch pc=132, inst=LOAD_GLOBAL(arg=9, lineno=212)
stack []
dispatch pc=144, inst=LOAD_FAST(arg=3, lineno=212)
stack ['$null$132.21', '$132load_global.20']
dispatch pc=146, inst=LOAD_CONST(arg=4, lineno=212)
stack ['$null$132.21', '$132load_global.20', '$i144.22']
dispatch pc=148, inst=BINARY_OP(arg=10, lineno=212)
stack ['$null$132.21', '$132load_global.20', '$i144.22', '$const146.23.4']
dispatch pc=152, inst=LOAD_CONST(arg=5, lineno=212)
stack ['$null$132.21', '$132load_global.20', '$binop_sub148.24']
dispatch pc=154, inst=LOAD_CONST(arg=5, lineno=212)
stack ['$null$132.21', '$132load_global.20', '$binop_sub148.24', '$const152.25.5']
dispatch pc=156, inst=PRECALL(arg=3, lineno=212)
stack ['$null$132.21', '$132load_global.20', '$binop_sub148.24', '$const152.25.5', '$const154.26.5']
dispatch pc=160, inst=CALL(arg=3, lineno=212)
stack ['$null$132.21', '$132load_global.20', '$binop_sub148.24', '$const152.25.5', '$const154.26.5']
dispatch pc=170, inst=GET_ITER(arg=None, lineno=212)
stack ['$160call.27']
end state. edges=[Edge(pc=172, stack=('$170get_iter.28',), blockstack=(), npush=0)]
pending: deque([State(pc_initial=172 nstack_initial=1)])
stack: ['$phi172.0']
state.pc_initial: State(pc_initial=172 nstack_initial=1)
dispatch pc=172, inst=FOR_ITER(arg=90, lineno=212)
stack ['$phi172.0']
end state. edges=[Edge(pc=354, stack=(), blockstack=(), npush=0), Edge(pc=174, stack=('$phi172.0', '$172for_iter.2'), blockstack=(), npush=0)]
pending: deque([State(pc_initial=354 nstack_initial=0), State(pc_initial=174 nstack_initial=2)])
stack: []
state.pc_initial: State(pc_initial=354 nstack_initial=0)
dispatch pc=354, inst=LOAD_GLOBAL(arg=13, lineno=221)
stack []
dispatch pc=366, inst=LOAD_FAST(arg=4, lineno=221)
stack ['$null$354.1', '$354load_global.0']
dispatch pc=368, inst=PRECALL(arg=1, lineno=221)
stack ['$null$354.1', '$354load_global.0', '$x366.2']
dispatch pc=372, inst=CALL(arg=1, lineno=221)
stack ['$null$354.1', '$354load_global.0', '$x366.2']
dispatch pc=382, inst=RETURN_VALUE(arg=None, lineno=221)
stack ['$372call.3']
end state. edges=[]
pending: deque([State(pc_initial=174 nstack_initial=2)])
stack: ['$phi174.0', '$phi174.1']
state.pc_initial: State(pc_initial=174 nstack_initial=2)
dispatch pc=174, inst=STORE_FAST(arg=6, lineno=212)
stack ['$phi174.0', '$phi174.1']
dispatch pc=176, inst=LOAD_FAST(arg=4, lineno=213)
stack ['$phi174.0']
dispatch pc=178, inst=LOAD_GLOBAL(arg=0, lineno=213)
stack ['$phi174.0', '$x176.2']
dispatch pc=190, inst=BINARY_OP(arg=3, lineno=213)
stack ['$phi174.0', '$x176.2', '$178load_global.3']
dispatch pc=194, inst=STORE_FAST(arg=7, lineno=213)
stack ['$phi174.0', '$binop_lshift190.4']
dispatch pc=196, inst=LOAD_FAST(arg=7, lineno=214)
stack ['$phi174.0']
dispatch pc=198, inst=LOAD_GLOBAL(arg=10, lineno=214)
stack ['$phi174.0', '$p1196.5']
dispatch pc=210, inst=BINARY_OP(arg=1, lineno=214)
stack ['$phi174.0', '$p1196.5', '$198load_global.6']
dispatch pc=214, inst=STORE_FAST(arg=8, lineno=214)
stack ['$phi174.0', '$binop_and_210.7']
dispatch pc=216, inst=LOAD_FAST(arg=4, lineno=215)
stack ['$phi174.0']
dispatch pc=218, inst=LOAD_FAST(arg=5, lineno=215)
stack ['$phi174.0', '$x216.8']
dispatch pc=220, inst=BINARY_OP(arg=9, lineno=215)
stack ['$phi174.0', '$x216.8', '$p3218.9']
dispatch pc=224, inst=STORE_FAST(arg=9, lineno=215)
stack ['$phi174.0', '$binop_rshift220.10']
dispatch pc=226, inst=LOAD_FAST(arg=8, lineno=216)
stack ['$phi174.0']
dispatch pc=228, inst=LOAD_FAST(arg=9, lineno=216)
stack ['$phi174.0', '$p2226.11']
dispatch pc=230, inst=BINARY_OP(arg=7, lineno=216)
stack ['$phi174.0', '$p2226.11', '$p4228.12']
dispatch pc=234, inst=STORE_FAST(arg=4, lineno=216)
stack ['$phi174.0', '$binop_or_230.13']
dispatch pc=236, inst=LOAD_FAST(arg=4, lineno=218)
stack ['$phi174.0']
dispatch pc=238, inst=LOAD_GLOBAL(arg=3, lineno=218)
stack ['$phi174.0', '$x236.14']
dispatch pc=250, inst=LOAD_ATTR(arg=2, lineno=218)
stack ['$phi174.0', '$x236.14', '$null$238.16', '$238load_global.15']
dispatch pc=260, inst=LOAD_FAST(arg=0, lineno=218)
stack ['$phi174.0', '$x236.14', '$null$238.16', '$250load_attr.17']
dispatch pc=262, inst=LOAD_FAST(arg=6, lineno=218)
stack ['$phi174.0', '$x236.14', '$null$238.16', '$250load_attr.17', '$val260.18']
dispatch pc=264, inst=LOAD_GLOBAL(arg=0, lineno=218)
stack ['$phi174.0', '$x236.14', '$null$238.16', '$250load_attr.17', '$val260.18', '$idx262.19']
dispatch pc=276, inst=BINARY_OP(arg=5, lineno=218)
stack ['$phi174.0', '$x236.14', '$null$238.16', '$250load_attr.17', '$val260.18', '$idx262.19', '$264load_global.20']
dispatch pc=280, inst=BINARY_OP(arg=9, lineno=218)
stack ['$phi174.0', '$x236.14', '$null$238.16', '$250load_attr.17', '$val260.18', '$binop_mul276.21']
dispatch pc=284, inst=LOAD_FAST(arg=2, lineno=218)
stack ['$phi174.0', '$x236.14', '$null$238.16', '$250load_attr.17', '$binop_rshift280.22']
dispatch pc=286, inst=BINARY_OP(arg=1, lineno=218)
stack ['$phi174.0', '$x236.14', '$null$238.16', '$250load_attr.17', '$binop_rshift280.22', '$mask_shift284.23']
dispatch pc=290, inst=PRECALL(arg=1, lineno=218)
stack ['$phi174.0', '$x236.14', '$null$238.16', '$250load_attr.17', '$binop_and_286.24']
dispatch pc=294, inst=CALL(arg=1, lineno=218)
stack ['$phi174.0', '$x236.14', '$null$238.16', '$250load_attr.17', '$binop_and_286.24']
dispatch pc=304, inst=BINARY_OP(arg=13, lineno=218)
stack ['$phi174.0', '$x236.14', '$294call.25']
dispatch pc=308, inst=STORE_FAST(arg=4, lineno=218)
stack ['$phi174.0', '$binop_iadd304.26']
dispatch pc=310, inst=LOAD_FAST(arg=4, lineno=219)
stack ['$phi174.0']
dispatch pc=312, inst=LOAD_GLOBAL(arg=10, lineno=219)
stack ['$phi174.0', '$x310.27']
dispatch pc=324, inst=COMPARE_OP(arg=5, lineno=219)
stack ['$phi174.0', '$x310.27', '$312load_global.28']
dispatch pc=330, inst=POP_JUMP_FORWARD_IF_FALSE(arg=10, lineno=219)
stack ['$phi174.0', '$324compare_op.29']
end state. edges=[Edge(pc=332, stack=('$phi174.0',), blockstack=(), npush=0), Edge(pc=352, stack=('$phi174.0',), blockstack=(), npush=0)]
pending: deque([State(pc_initial=332 nstack_initial=1), State(pc_initial=352 nstack_initial=1)])
stack: ['$phi332.0']
state.pc_initial: State(pc_initial=332 nstack_initial=1)
dispatch pc=332, inst=LOAD_FAST(arg=4, lineno=220)
stack ['$phi332.0']
dispatch pc=334, inst=LOAD_GLOBAL(arg=10, lineno=220)
stack ['$phi332.0', '$x332.1']
dispatch pc=346, inst=BINARY_OP(arg=23, lineno=220)
stack ['$phi332.0', '$x332.1', '$334load_global.2']
dispatch pc=350, inst=STORE_FAST(arg=4, lineno=220)
stack ['$phi332.0', '$binop_isub346.3']
end state. edges=[Edge(pc=352, stack=('$phi332.0',), blockstack=(), npush=0)]
pending: deque([State(pc_initial=352 nstack_initial=1), State(pc_initial=352 nstack_initial=1)])
stack: ['$phi352.0']
state.pc_initial: State(pc_initial=352 nstack_initial=1)
dispatch pc=352, inst=JUMP_BACKWARD(arg=91, lineno=220)
stack ['$phi352.0']
end state. edges=[Edge(pc=172, stack=('$phi352.0',), blockstack=(), npush=0)]
pending: deque([State(pc_initial=352 nstack_initial=1), State(pc_initial=172 nstack_initial=1)])
pending: deque([State(pc_initial=172 nstack_initial=1)])
-------------------------Prune PHIs-------------------------
Used_phis: defaultdict(<class 'set'>,
            {State(pc_initial=0 nstack_initial=0): set(),
             State(pc_initial=172 nstack_initial=1): {'$phi172.0'},
             State(pc_initial=174 nstack_initial=2): {'$phi174.1'},
             State(pc_initial=332 nstack_initial=1): set(),
             State(pc_initial=352 nstack_initial=1): set(),
             State(pc_initial=354 nstack_initial=0): set()})
defmap: {'$phi172.0': State(pc_initial=0 nstack_initial=0),
 '$phi174.1': State(pc_initial=172 nstack_initial=1)}
phismap: defaultdict(<class 'set'>,
            {'$phi172.0': {('$170get_iter.28',
                            State(pc_initial=0 nstack_initial=0)),
                           ('$phi352.0',
                            State(pc_initial=352 nstack_initial=1))},
             '$phi174.0': {('$phi172.0',
                            State(pc_initial=172 nstack_initial=1))},
             '$phi174.1': {('$172for_iter.2',
                            State(pc_initial=172 nstack_initial=1))},
             '$phi332.0': {('$phi174.0',
                            State(pc_initial=174 nstack_initial=2))},
             '$phi352.0': {('$phi174.0',
                            State(pc_initial=174 nstack_initial=2)),
                           ('$phi332.0',
                            State(pc_initial=332 nstack_initial=1))}})
changing phismap: defaultdict(<class 'set'>,
            {'$phi172.0': {('$170get_iter.28',
                            State(pc_initial=0 nstack_initial=0)),
                           ('$phi174.0',
                            State(pc_initial=174 nstack_initial=2)),
                           ('$phi332.0',
                            State(pc_initial=332 nstack_initial=1))},
             '$phi174.0': {('$170get_iter.28',
                            State(pc_initial=0 nstack_initial=0)),
                           ('$phi174.0',
                            State(pc_initial=174 nstack_initial=2)),
                           ('$phi332.0',
                            State(pc_initial=332 nstack_initial=1))},
             '$phi174.1': {('$172for_iter.2',
                            State(pc_initial=172 nstack_initial=1))},
             '$phi332.0': {('$170get_iter.28',
                            State(pc_initial=0 nstack_initial=0)),
                           ('$phi332.0',
                            State(pc_initial=332 nstack_initial=1))},
             '$phi352.0': {('$170get_iter.28',
                            State(pc_initial=0 nstack_initial=0))}})
changing phismap: defaultdict(<class 'set'>,
            {'$phi172.0': {('$170get_iter.28',
                            State(pc_initial=0 nstack_initial=0))},
             '$phi174.0': {('$170get_iter.28',
                            State(pc_initial=0 nstack_initial=0))},
             '$phi174.1': {('$172for_iter.2',
                            State(pc_initial=172 nstack_initial=1))},
             '$phi332.0': {('$170get_iter.28',
                            State(pc_initial=0 nstack_initial=0))},
             '$phi352.0': {('$170get_iter.28',
                            State(pc_initial=0 nstack_initial=0))}})
changing phismap: defaultdict(<class 'set'>,
            {'$phi172.0': {('$170get_iter.28',
                            State(pc_initial=0 nstack_initial=0))},
             '$phi174.0': {('$170get_iter.28',
                            State(pc_initial=0 nstack_initial=0))},
             '$phi174.1': {('$172for_iter.2',
                            State(pc_initial=172 nstack_initial=1))},
             '$phi332.0': {('$170get_iter.28',
                            State(pc_initial=0 nstack_initial=0))},
             '$phi352.0': {('$170get_iter.28',
                            State(pc_initial=0 nstack_initial=0))}})
keep phismap: {'$phi172.0': {('$170get_iter.28', State(pc_initial=0 nstack_initial=0))},
 '$phi174.1': {('$172for_iter.2', State(pc_initial=172 nstack_initial=1))}}
new_out: defaultdict(<class 'dict'>,
            {State(pc_initial=0 nstack_initial=0): {'$phi172.0': '$170get_iter.28'},
             State(pc_initial=172 nstack_initial=1): {'$phi174.1': '$172for_iter.2'}})
----------------------DONE Prune PHIs-----------------------
block_infos State(pc_initial=0 nstack_initial=0):
AdaptBlockInfo(insts=((0, {}), (2, {}), (4, {'res': '$const4.0.1'}), (6, {'idx': 0, 'res': '$6load_global.1'}), (8, {}), (10, {}), (12, {}), (14, {}), (16, {}), (18, {'op': '-', 'lhs': '$const4.0.1', 'rhs': '$6load_global.1', 'res': '$binop_sub18.2'}), (20, {}), (22, {'value': '$binop_sub18.2'}), (24, {'idx': 1, 'res': '$24load_global.3'}), (26, {}), (28, {}), (30, {}), (32, {}), (34, {}), (36, {'item': '$24load_global.3', 'res': '$36load_attr.5'}), (38, {}), (40, {}), (42, {}), (44, {}), (46, {'res': '$const46.6.2'}), (48, {}), (50, {}), (52, {'func': '$36load_attr.5', 'args': ['$const46.6.2'], 'kw_names': None, 'res': '$52call.7'}), (54, {}), (56, {}), (58, {}), (60, {}), (62, {'value': '$52call.7', 'res': '$62unary_invert.8'}), (64, {'res': '$_tmp_shift64.9'}), (66, {'op': '>>', 'lhs': '$62unary_invert.8', 'rhs': '$_tmp_shift64.9', 'res': '$binop_rshift66.10'}), (68, {}), (70, {'value': '$binop_rshift66.10'}), (72, {'res': '$const72.11.3'}), (74, {'idx': 0, 'res': '$74load_global.12'}), (76, {}), (78, {}), (80, {}), (82, {}), (84, {}), (86, {'op': '//', 'lhs': '$const72.11.3', 'rhs': '$74load_global.12', 'res': '$binop_floordiv86.13'}), (88, {}), (90, {'res': '$const90.14.4'}), (92, {'op': '+', 'lhs': '$binop_floordiv86.13', 'rhs': '$const90.14.4', 'res': '$binop_add92.15'}), (94, {}), (96, {'value': '$binop_add92.15'}), (98, {'res': '$const98.16.2'}), (100, {'value': '$const98.16.2'}), (102, {'idx': 3, 'res': '$102load_global.17'}), (104, {}), (106, {}), (108, {}), (110, {}), (112, {}), (114, {'idx': 0, 'res': '$114load_global.18'}), (116, {}), (118, {}), (120, {}), (122, {}), (124, {}), (126, {'op': '-', 'lhs': '$102load_global.17', 'rhs': '$114load_global.18', 'res': '$binop_sub126.19'}), (128, {}), (130, {'value': '$binop_sub126.19'}), (132, {'idx': 4, 'res': '$132load_global.20'}), (134, {}), (136, {}), (138, {}), (140, {}), (142, {}), (144, {'res': '$i144.22'}), (146, {'res': '$const146.23.4'}), (148, {'op': '-', 'lhs': '$i144.22', 'rhs': '$const146.23.4', 'res': '$binop_sub148.24'}), (150, {}), (152, {'res': '$const152.25.5'}), (154, {'res': '$const154.26.5'}), (156, {}), (158, {}), (160, {'func': '$132load_global.20', 'args': ['$binop_sub148.24', '$const152.25.5', '$const154.26.5'], 'kw_names': None, 'res': '$160call.27'}), (162, {}), (164, {}), (166, {}), (168, {}), (170, {'value': '$160call.27', 'res': '$170get_iter.28'})), outgoing_phis={'$phi172.0': '$170get_iter.28'}, blockstack=(), active_try_block=None, outgoing_edgepushed={172: ('$170get_iter.28',)})
block_infos State(pc_initial=172 nstack_initial=1):
AdaptBlockInfo(insts=((172, {'iterator': '$phi172.0', 'pair': '$172for_iter.1', 'indval': '$172for_iter.2', 'pred': '$172for_iter.3'}),), outgoing_phis={'$phi174.1': '$172for_iter.2'}, blockstack=(), active_try_block=None, outgoing_edgepushed={354: (), 174: ('$phi172.0', '$172for_iter.2')})
block_infos State(pc_initial=174 nstack_initial=2):
AdaptBlockInfo(insts=((174, {'value': '$phi174.1'}), (176, {'res': '$x176.2'}), (178, {'idx': 0, 'res': '$178load_global.3'}), (180, {}), (182, {}), (184, {}), (186, {}), (188, {}), (190, {'op': '<<', 'lhs': '$x176.2', 'rhs': '$178load_global.3', 'res': '$binop_lshift190.4'}), (192, {}), (194, {'value': '$binop_lshift190.4'}), (196, {'res': '$p1196.5'}), (198, {'idx': 5, 'res': '$198load_global.6'}), (200, {}), (202, {}), (204, {}), (206, {}), (208, {}), (210, {'op': '&', 'lhs': '$p1196.5', 'rhs': '$198load_global.6', 'res': '$binop_and_210.7'}), (212, {}), (214, {'value': '$binop_and_210.7'}), (216, {'res': '$x216.8'}), (218, {'res': '$p3218.9'}), (220, {'op': '>>', 'lhs': '$x216.8', 'rhs': '$p3218.9', 'res': '$binop_rshift220.10'}), (222, {}), (224, {'value': '$binop_rshift220.10'}), (226, {'res': '$p2226.11'}), (228, {'res': '$p4228.12'}), (230, {'op': '|', 'lhs': '$p2226.11', 'rhs': '$p4228.12', 'res': '$binop_or_230.13'}), (232, {}), (234, {'value': '$binop_or_230.13'}), (236, {'res': '$x236.14'}), (238, {'idx': 1, 'res': '$238load_global.15'}), (240, {}), (242, {}), (244, {}), (246, {}), (248, {}), (250, {'item': '$238load_global.15', 'res': '$250load_attr.17'}), (252, {}), (254, {}), (256, {}), (258, {}), (260, {'res': '$val260.18'}), (262, {'res': '$idx262.19'}), (264, {'idx': 0, 'res': '$264load_global.20'}), (266, {}), (268, {}), (270, {}), (272, {}), (274, {}), (276, {'op': '*', 'lhs': '$idx262.19', 'rhs': '$264load_global.20', 'res': '$binop_mul276.21'}), (278, {}), (280, {'op': '>>', 'lhs': '$val260.18', 'rhs': '$binop_mul276.21', 'res': '$binop_rshift280.22'}), (282, {}), (284, {'res': '$mask_shift284.23'}), (286, {'op': '&', 'lhs': '$binop_rshift280.22', 'rhs': '$mask_shift284.23', 'res': '$binop_and_286.24'}), (288, {}), (290, {}), (292, {}), (294, {'func': '$250load_attr.17', 'args': ['$binop_and_286.24'], 'kw_names': None, 'res': '$294call.25'}), (296, {}), (298, {}), (300, {}), (302, {}), (304, {'op': '+=', 'lhs': '$x236.14', 'rhs': '$294call.25', 'res': '$binop_iadd304.26'}), (306, {}), (308, {'value': '$binop_iadd304.26'}), (310, {'res': '$x310.27'}), (312, {'idx': 5, 'res': '$312load_global.28'}), (314, {}), (316, {}), (318, {}), (320, {}), (322, {}), (324, {'lhs': '$x310.27', 'rhs': '$312load_global.28', 'res': '$324compare_op.29'}), (326, {}), (328, {}), (330, {'pred': '$324compare_op.29'})), outgoing_phis={}, blockstack=(), active_try_block=None, outgoing_edgepushed={332: ('$phi174.0',), 352: ('$phi174.0',)})
block_infos State(pc_initial=332 nstack_initial=1):
AdaptBlockInfo(insts=((332, {'res': '$x332.1'}), (334, {'idx': 5, 'res': '$334load_global.2'}), (336, {}), (338, {}), (340, {}), (342, {}), (344, {}), (346, {'op': '-=', 'lhs': '$x332.1', 'rhs': '$334load_global.2', 'res': '$binop_isub346.3'}), (348, {}), (350, {'value': '$binop_isub346.3'})), outgoing_phis={}, blockstack=(), active_try_block=None, outgoing_edgepushed={352: ('$phi332.0',)})
block_infos State(pc_initial=352 nstack_initial=1):
AdaptBlockInfo(insts=((352, {}),), outgoing_phis={}, blockstack=(), active_try_block=None, outgoing_edgepushed={172: ('$phi352.0',)})
block_infos State(pc_initial=354 nstack_initial=0):
AdaptBlockInfo(insts=((354, {'idx': 6, 'res': '$354load_global.0'}), (356, {}), (358, {}), (360, {}), (362, {}), (364, {}), (366, {'res': '$x366.2'}), (368, {}), (370, {}), (372, {'func': '$354load_global.0', 'args': ['$x366.2'], 'kw_names': None, 'res': '$372call.3'}), (374, {}), (376, {}), (378, {}), (380, {}), (382, {'retval': '$372call.3', 'castval': '$382return_value.4'})), outgoing_phis={}, blockstack=(), active_try_block=None, outgoing_edgepushed={})
label 0:
    val = arg(0, name=val)                   ['val']
    $const4.0.1 = const(int, 32)             ['$const4.0.1']
    $6load_global.1 = global(_PyLong_SHIFT: 30) ['$6load_global.1']
    _tmp_shift = $const4.0.1 - $6load_global.1 ['$6load_global.1', '$const4.0.1', '_tmp_shift']
    $24load_global.3 = global(types: <module 'numba.core.types' from '/home/earnest/.local/share/mamba/envs/basicrl/lib/python3.11/site-packages/numba/core/types/__init__.py'>) ['$24load_global.3']
    $36load_attr.5 = getattr(value=$24load_global.3, attr=uint32) ['$24load_global.3', '$36load_attr.5']
    $const46.6.2 = const(int, 0)             ['$const46.6.2']
    $52call.7 = call $36load_attr.5($const46.6.2, func=$36load_attr.5, args=[Var($const46.6.2, old_hashing.py:203)], kws=(), vararg=None, varkwarg=None, target=None) ['$36load_attr.5', '$52call.7', '$const46.6.2']
    $62unary_invert.8 = unary(fn=<built-in function invert>, value=$52call.7) ['$52call.7', '$62unary_invert.8']
    mask_shift = $62unary_invert.8 >> _tmp_shift ['$62unary_invert.8', '_tmp_shift', 'mask_shift']
    $const72.11.3 = const(int, 64)           ['$const72.11.3']
    $74load_global.12 = global(_PyLong_SHIFT: 30) ['$74load_global.12']
    $binop_floordiv86.13 = $const72.11.3 // $74load_global.12 ['$74load_global.12', '$binop_floordiv86.13', '$const72.11.3']
    $const90.14.4 = const(int, 1)            ['$const90.14.4']
    i = $binop_floordiv86.13 + $const90.14.4 ['$binop_floordiv86.13', '$const90.14.4', 'i']
    x = const(int, 0)                        ['x']
    $102load_global.17 = global(_PyHASH_BITS: 61) ['$102load_global.17']
    $114load_global.18 = global(_PyLong_SHIFT: 30) ['$114load_global.18']
    p3 = $102load_global.17 - $114load_global.18 ['$102load_global.17', '$114load_global.18', 'p3']
    $132load_global.20 = global(range: <class 'range'>) ['$132load_global.20']
    $const146.23.4 = const(int, 1)           ['$const146.23.4']
    $binop_sub148.24 = i - $const146.23.4    ['$binop_sub148.24', '$const146.23.4', 'i']
    $const152.25.5 = const(int, -1)          ['$const152.25.5']
    $const154.26.5 = const(int, -1)          ['$const154.26.5']
    $160call.27 = call $132load_global.20($binop_sub148.24, $const152.25.5, $const154.26.5, func=$132load_global.20, args=[Var($binop_sub148.24, old_hashing.py:212), Var($const152.25.5, old_hashing.py:212), Var($const154.26.5, old_hashing.py:212)], kws=(), vararg=None, varkwarg=None, target=None) ['$132load_global.20', '$160call.27', '$binop_sub148.24', '$const152.25.5', '$const154.26.5']
    $170get_iter.28 = getiter(value=$160call.27) ['$160call.27', '$170get_iter.28']
    $phi172.0 = $170get_iter.28              ['$170get_iter.28', '$phi172.0']
    jump 172                                 []
label 172:
    $172for_iter.1 = iternext(value=$phi172.0) ['$172for_iter.1', '$phi172.0']
    $172for_iter.2 = pair_first(value=$172for_iter.1) ['$172for_iter.1', '$172for_iter.2']
    $172for_iter.3 = pair_second(value=$172for_iter.1) ['$172for_iter.1', '$172for_iter.3']
    $phi174.1 = $172for_iter.2               ['$172for_iter.2', '$phi174.1']
    branch $172for_iter.3, 174, 354          ['$172for_iter.3']
label 174:
    idx = $phi174.1                          ['$phi174.1', 'idx']
    $178load_global.3 = global(_PyLong_SHIFT: 30) ['$178load_global.3']
    p1 = x << $178load_global.3              ['$178load_global.3', 'p1', 'x']
    $198load_global.6 = global(_PyHASH_MODULUS: 2305843009213693951) ['$198load_global.6']
    p2 = p1 & $198load_global.6              ['$198load_global.6', 'p1', 'p2']
    p4 = x >> p3                             ['p3', 'p4', 'x']
    x = p2 | p4                              ['p2', 'p4', 'x']
    $238load_global.15 = global(types: <module 'numba.core.types' from '/home/earnest/.local/share/mamba/envs/basicrl/lib/python3.11/site-packages/numba/core/types/__init__.py'>) ['$238load_global.15']
    $250load_attr.17 = getattr(value=$238load_global.15, attr=uint32) ['$238load_global.15', '$250load_attr.17']
    $264load_global.20 = global(_PyLong_SHIFT: 30) ['$264load_global.20']
    $binop_mul276.21 = idx * $264load_global.20 ['$264load_global.20', '$binop_mul276.21', 'idx']
    $binop_rshift280.22 = val >> $binop_mul276.21 ['$binop_mul276.21', '$binop_rshift280.22', 'val']
    $binop_and_286.24 = $binop_rshift280.22 & mask_shift ['$binop_and_286.24', '$binop_rshift280.22', 'mask_shift']
    $294call.25 = call $250load_attr.17($binop_and_286.24, func=$250load_attr.17, args=[Var($binop_and_286.24, old_hashing.py:218)], kws=(), vararg=None, varkwarg=None, target=None) ['$250load_attr.17', '$294call.25', '$binop_and_286.24']
    $binop_iadd304.26 = inplace_binop(fn=<built-in function iadd>, immutable_fn=<built-in function add>, lhs=x, rhs=$294call.25, static_lhs=Undefined, static_rhs=Undefined) ['$294call.25', '$binop_iadd304.26', 'x']
    x = $binop_iadd304.26                    ['$binop_iadd304.26', 'x']
    $312load_global.28 = global(_PyHASH_MODULUS: 2305843009213693951) ['$312load_global.28']
    $324compare_op.29 = x >= $312load_global.28 ['$312load_global.28', '$324compare_op.29', 'x']
    bool330 = global(bool: <class 'bool'>)   ['bool330']
    $330pred = call bool330($324compare_op.29, func=bool330, args=(Var($324compare_op.29, old_hashing.py:219),), kws=(), vararg=None, varkwarg=None, target=None) ['$324compare_op.29', '$330pred', 'bool330']
    branch $330pred, 332, 352                ['$330pred']
label 332:
    $334load_global.2 = global(_PyHASH_MODULUS: 2305843009213693951) ['$334load_global.2']
    $binop_isub346.3 = inplace_binop(fn=<built-in function isub>, immutable_fn=<built-in function sub>, lhs=x, rhs=$334load_global.2, static_lhs=Undefined, static_rhs=Undefined) ['$334load_global.2', '$binop_isub346.3', 'x']
    x = $binop_isub346.3                     ['$binop_isub346.3', 'x']
    jump 352                                 []
label 352:
    jump 172                                 []
label 354:
    $354load_global.0 = global(_Py_hash_t: int64) ['$354load_global.0']
    $372call.3 = call $354load_global.0(x, func=$354load_global.0, args=[Var(x, old_hashing.py:210)], kws=(), vararg=None, varkwarg=None, target=None) ['$354load_global.0', '$372call.3', 'x']
    $382return_value.4 = cast(value=$372call.3) ['$372call.3', '$382return_value.4']
    return $382return_value.4                ['$382return_value.4']

==== SSA block analysis pass on 0
Running <numba.core.ssa._GatherDefsHandler object at 0x7f61a55e3f50>
on stmt: val = arg(0, name=val)
on stmt: $const4.0.1 = const(int, 32)
on stmt: $6load_global.1 = global(_PyLong_SHIFT: 30)
on stmt: _tmp_shift = $const4.0.1 - $6load_global.1
on stmt: $24load_global.3 = global(types: <module 'numba.core.types' from '/home/earnest/.local/share/mamba/envs/basicrl/lib/python3.11/site-packages/numba/core/types/__init__.py'>)
on stmt: $36load_attr.5 = getattr(value=$24load_global.3, attr=uint32)
on stmt: $const46.6.2 = const(int, 0)
on stmt: $52call.7 = call $36load_attr.5($const46.6.2, func=$36load_attr.5, args=[Var($const46.6.2, old_hashing.py:203)], kws=(), vararg=None, varkwarg=None, target=None)
on stmt: $62unary_invert.8 = unary(fn=<built-in function invert>, value=$52call.7)
on stmt: mask_shift = $62unary_invert.8 >> _tmp_shift
on stmt: $const72.11.3 = const(int, 64)
on stmt: $74load_global.12 = global(_PyLong_SHIFT: 30)
on stmt: $binop_floordiv86.13 = $const72.11.3 // $74load_global.12
on stmt: $const90.14.4 = const(int, 1)
on stmt: i = $binop_floordiv86.13 + $const90.14.4
on stmt: x = const(int, 0)
on stmt: $102load_global.17 = global(_PyHASH_BITS: 61)
on stmt: $114load_global.18 = global(_PyLong_SHIFT: 30)
on stmt: p3 = $102load_global.17 - $114load_global.18
on stmt: $132load_global.20 = global(range: <class 'range'>)
on stmt: $const146.23.4 = const(int, 1)
on stmt: $binop_sub148.24 = i - $const146.23.4
on stmt: $const152.25.5 = const(int, -1)
on stmt: $const154.26.5 = const(int, -1)
on stmt: $160call.27 = call $132load_global.20($binop_sub148.24, $const152.25.5, $const154.26.5, func=$132load_global.20, args=[Var($binop_sub148.24, old_hashing.py:212), Var($const152.25.5, old_hashing.py:212), Var($const154.26.5, old_hashing.py:212)], kws=(), vararg=None, varkwarg=None, target=None)
on stmt: $170get_iter.28 = getiter(value=$160call.27)
on stmt: $phi172.0 = $170get_iter.28
on stmt: jump 172
==== SSA block analysis pass on 172
Running <numba.core.ssa._GatherDefsHandler object at 0x7f61a55e3f50>
on stmt: $172for_iter.1 = iternext(value=$phi172.0)
on stmt: $172for_iter.2 = pair_first(value=$172for_iter.1)
on stmt: $172for_iter.3 = pair_second(value=$172for_iter.1)
on stmt: $phi174.1 = $172for_iter.2
on stmt: branch $172for_iter.3, 174, 354
==== SSA block analysis pass on 174
Running <numba.core.ssa._GatherDefsHandler object at 0x7f61a55e3f50>
on stmt: idx = $phi174.1
on stmt: $178load_global.3 = global(_PyLong_SHIFT: 30)
on stmt: p1 = x << $178load_global.3
on stmt: $198load_global.6 = global(_PyHASH_MODULUS: 2305843009213693951)
on stmt: p2 = p1 & $198load_global.6
on stmt: p4 = x >> p3
on stmt: x = p2 | p4
on stmt: $238load_global.15 = global(types: <module 'numba.core.types' from '/home/earnest/.local/share/mamba/envs/basicrl/lib/python3.11/site-packages/numba/core/types/__init__.py'>)
on stmt: $250load_attr.17 = getattr(value=$238load_global.15, attr=uint32)
on stmt: $264load_global.20 = global(_PyLong_SHIFT: 30)
on stmt: $binop_mul276.21 = idx * $264load_global.20
on stmt: $binop_rshift280.22 = val >> $binop_mul276.21
on stmt: $binop_and_286.24 = $binop_rshift280.22 & mask_shift
on stmt: $294call.25 = call $250load_attr.17($binop_and_286.24, func=$250load_attr.17, args=[Var($binop_and_286.24, old_hashing.py:218)], kws=(), vararg=None, varkwarg=None, target=None)
on stmt: $binop_iadd304.26 = inplace_binop(fn=<built-in function iadd>, immutable_fn=<built-in function add>, lhs=x, rhs=$294call.25, static_lhs=Undefined, static_rhs=Undefined)
on stmt: x = $binop_iadd304.26
on stmt: $312load_global.28 = global(_PyHASH_MODULUS: 2305843009213693951)
on stmt: $324compare_op.29 = x >= $312load_global.28
on stmt: bool330 = global(bool: <class 'bool'>)
on stmt: $330pred = call bool330($324compare_op.29, func=bool330, args=(Var($324compare_op.29, old_hashing.py:219),), kws=(), vararg=None, varkwarg=None, target=None)
on stmt: branch $330pred, 332, 352
==== SSA block analysis pass on 332
Running <numba.core.ssa._GatherDefsHandler object at 0x7f61a55e3f50>
on stmt: $334load_global.2 = global(_PyHASH_MODULUS: 2305843009213693951)
on stmt: $binop_isub346.3 = inplace_binop(fn=<built-in function isub>, immutable_fn=<built-in function sub>, lhs=x, rhs=$334load_global.2, static_lhs=Undefined, static_rhs=Undefined)
on stmt: x = $binop_isub346.3
on stmt: jump 352
==== SSA block analysis pass on 352
Running <numba.core.ssa._GatherDefsHandler object at 0x7f61a55e3f50>
on stmt: jump 172
==== SSA block analysis pass on 354
Running <numba.core.ssa._GatherDefsHandler object at 0x7f61a55e3f50>
on stmt: $354load_global.0 = global(_Py_hash_t: int64)
on stmt: $372call.3 = call $354load_global.0(x, func=$354load_global.0, args=[Var(x, old_hashing.py:210)], kws=(), vararg=None, varkwarg=None, target=None)
on stmt: $382return_value.4 = cast(value=$372call.3)
on stmt: return $382return_value.4
defs defaultdict(<class 'list'>,
            {'$102load_global.17': [(<numba.core.ir.Assign object at 0x7f61a491ec90>,
                                     0)],
             '$114load_global.18': [(<numba.core.ir.Assign object at 0x7f61a491ef50>,
                                     0)],
             '$132load_global.20': [(<numba.core.ir.Assign object at 0x7f61a491f590>,
                                     0)],
             '$160call.27': [(<numba.core.ir.Assign object at 0x7f61a4928210>,
                              0)],
             '$170get_iter.28': [(<numba.core.ir.Assign object at 0x7f61a49284d0>,
                                  0)],
             '$172for_iter.1': [(<numba.core.ir.Assign object at 0x7f61a4928650>,
                                 172)],
             '$172for_iter.2': [(<numba.core.ir.Assign object at 0x7f61a4928790>,
                                 172)],
             '$172for_iter.3': [(<numba.core.ir.Assign object at 0x7f61a49288d0>,
                                 172)],
             '$178load_global.3': [(<numba.core.ir.Assign object at 0x7f61a4928f90>,
                                    174)],
             '$198load_global.6': [(<numba.core.ir.Assign object at 0x7f61a4929710>,
                                    174)],
             '$238load_global.15': [(<numba.core.ir.Assign object at 0x7f61a492ab50>,
                                     174)],
             '$24load_global.3': [(<numba.core.ir.Assign object at 0x7f61a491cd50>,
                                   0)],
             '$250load_attr.17': [(<numba.core.ir.Assign object at 0x7f61a492ad90>,
                                   174)],
             '$264load_global.20': [(<numba.core.ir.Assign object at 0x7f61a492b310>,
                                     174)],
             '$294call.25': [(<numba.core.ir.Assign object at 0x7f61a492be10>,
                              174)],
             '$312load_global.28': [(<numba.core.ir.Assign object at 0x7f61a492c550>,
                                     174)],
             '$324compare_op.29': [(<numba.core.ir.Assign object at 0x7f61a492c890>,
                                    174)],
             '$330pred': [(<numba.core.ir.Assign object at 0x7f61a492cc90>,
                           174)],
             '$334load_global.2': [(<numba.core.ir.Assign object at 0x7f61a492a850>,
                                    332)],
             '$354load_global.0': [(<numba.core.ir.Assign object at 0x7f61a492d2d0>,
                                    354)],
             '$36load_attr.5': [(<numba.core.ir.Assign object at 0x7f61a491d110>,
                                 0)],
             '$372call.3': [(<numba.core.ir.Assign object at 0x7f61a492d6d0>,
                             354)],
             '$382return_value.4': [(<numba.core.ir.Assign object at 0x7f61a492d990>,
                                     354)],
             '$52call.7': [(<numba.core.ir.Assign object at 0x7f61a491d510>,
                            0)],
             '$62unary_invert.8': [(<numba.core.ir.Assign object at 0x7f61a491d690>,
                                    0)],
             '$6load_global.1': [(<numba.core.ir.Assign object at 0x7f61a4912d50>,
                                  0)],
             '$74load_global.12': [(<numba.core.ir.Assign object at 0x7f61a491df50>,
                                    0)],
             '$binop_and_286.24': [(<numba.core.ir.Assign object at 0x7f61a492bb10>,
                                    174)],
             '$binop_floordiv86.13': [(<numba.core.ir.Assign object at 0x7f61a491e250>,
                                       0)],
             '$binop_iadd304.26': [(<numba.core.ir.Assign object at 0x7f61a492c090>,
                                    174)],
             '$binop_isub346.3': [(<numba.core.ir.Assign object at 0x7f61a492ce50>,
                                   332)],
             '$binop_mul276.21': [(<numba.core.ir.Assign object at 0x7f61a492b550>,
                                   174)],
             '$binop_rshift280.22': [(<numba.core.ir.Assign object at 0x7f61a492b750>,
                                      174)],
             '$binop_sub148.24': [(<numba.core.ir.Assign object at 0x7f61a491fb90>,
                                   0)],
             '$const146.23.4': [(<numba.core.ir.Assign object at 0x7f61a491f950>,
                                 0)],
             '$const152.25.5': [(<numba.core.ir.Assign object at 0x7f61a491fd50>,
                                 0)],
             '$const154.26.5': [(<numba.core.ir.Assign object at 0x7f61a491ff10>,
                                 0)],
             '$const4.0.1': [(<numba.core.ir.Assign object at 0x7f61a4913cd0>,
                              0)],
             '$const46.6.2': [(<numba.core.ir.Assign object at 0x7f61a491d310>,
                               0)],
             '$const72.11.3': [(<numba.core.ir.Assign object at 0x7f61a491dd90>,
                                0)],
             '$const90.14.4': [(<numba.core.ir.Assign object at 0x7f61a491e450>,
                                0)],
             '$phi172.0': [(<numba.core.ir.Assign object at 0x7f61a491d850>,
                            0)],
             '$phi174.1': [(<numba.core.ir.Assign object at 0x7f61a4928990>,
                            172)],
             '_tmp_shift': [(<numba.core.ir.Assign object at 0x7f61a4910810>,
                             0)],
             'bool330': [(<numba.core.ir.Assign object at 0x7f61a492cad0>,
                          174)],
             'i': [(<numba.core.ir.Assign object at 0x7f61a491e690>, 0)],
             'idx': [(<numba.core.ir.Assign object at 0x7f61a4928c10>, 174)],
             'mask_shift': [(<numba.core.ir.Assign object at 0x7f61a491da50>,
                             0)],
             'p1': [(<numba.core.ir.Assign object at 0x7f61a4929210>, 174)],
             'p2': [(<numba.core.ir.Assign object at 0x7f61a4929910>, 174)],
             'p3': [(<numba.core.ir.Assign object at 0x7f61a491f250>, 0)],
             'p4': [(<numba.core.ir.Assign object at 0x7f61a4929f90>, 174)],
             'val': [(<numba.core.ir.Assign object at 0x7f61a6c8b310>, 0)],
             'x': [(<numba.core.ir.Assign object at 0x7f61a491e990>, 0),
                   (<numba.core.ir.Assign object at 0x7f61a492a710>, 174),
                   (<numba.core.ir.Assign object at 0x7f61a492c110>, 174),
                   (<numba.core.ir.Assign object at 0x7f61a492a2d0>, 332)]})
SSA violators <numba.core.utils.OrderedSet object at 0x7f61a55e3f50>
Fix SSA violator on var x
==== SSA block rewrite pass on 0
Running <numba.core.ssa._FreshVarHandler object at 0x7f61a6cfc210>
on stmt: val = arg(0, name=val)
on stmt: $const4.0.1 = const(int, 32)
on stmt: $6load_global.1 = global(_PyLong_SHIFT: 30)
on stmt: _tmp_shift = $const4.0.1 - $6load_global.1
on stmt: $24load_global.3 = global(types: <module 'numba.core.types' from '/home/earnest/.local/share/mamba/envs/basicrl/lib/python3.11/site-packages/numba/core/types/__init__.py'>)
on stmt: $36load_attr.5 = getattr(value=$24load_global.3, attr=uint32)
on stmt: $const46.6.2 = const(int, 0)
on stmt: $52call.7 = call $36load_attr.5($const46.6.2, func=$36load_attr.5, args=[Var($const46.6.2, old_hashing.py:203)], kws=(), vararg=None, varkwarg=None, target=None)
on stmt: $62unary_invert.8 = unary(fn=<built-in function invert>, value=$52call.7)
on stmt: mask_shift = $62unary_invert.8 >> _tmp_shift
on stmt: $const72.11.3 = const(int, 64)
on stmt: $74load_global.12 = global(_PyLong_SHIFT: 30)
on stmt: $binop_floordiv86.13 = $const72.11.3 // $74load_global.12
on stmt: $const90.14.4 = const(int, 1)
on stmt: i = $binop_floordiv86.13 + $const90.14.4
on stmt: x = const(int, 0)
first assign: x
replaced with: x = const(int, 0)
on stmt: $102load_global.17 = global(_PyHASH_BITS: 61)
on stmt: $114load_global.18 = global(_PyLong_SHIFT: 30)
on stmt: p3 = $102load_global.17 - $114load_global.18
on stmt: $132load_global.20 = global(range: <class 'range'>)
on stmt: $const146.23.4 = const(int, 1)
on stmt: $binop_sub148.24 = i - $const146.23.4
on stmt: $const152.25.5 = const(int, -1)
on stmt: $const154.26.5 = const(int, -1)
on stmt: $160call.27 = call $132load_global.20($binop_sub148.24, $const152.25.5, $const154.26.5, func=$132load_global.20, args=[Var($binop_sub148.24, old_hashing.py:212), Var($const152.25.5, old_hashing.py:212), Var($const154.26.5, old_hashing.py:212)], kws=(), vararg=None, varkwarg=None, target=None)
on stmt: $170get_iter.28 = getiter(value=$160call.27)
on stmt: $phi172.0 = $170get_iter.28
on stmt: jump 172
==== SSA block rewrite pass on 172
Running <numba.core.ssa._FreshVarHandler object at 0x7f61a6cfc210>
on stmt: $172for_iter.1 = iternext(value=$phi172.0)
on stmt: $172for_iter.2 = pair_first(value=$172for_iter.1)
on stmt: $172for_iter.3 = pair_second(value=$172for_iter.1)
on stmt: $phi174.1 = $172for_iter.2
on stmt: branch $172for_iter.3, 174, 354
==== SSA block rewrite pass on 174
Running <numba.core.ssa._FreshVarHandler object at 0x7f61a6cfc210>
on stmt: idx = $phi174.1
on stmt: $178load_global.3 = global(_PyLong_SHIFT: 30)
on stmt: p1 = x << $178load_global.3
on stmt: $198load_global.6 = global(_PyHASH_MODULUS: 2305843009213693951)
on stmt: p2 = p1 & $198load_global.6
on stmt: p4 = x >> p3
on stmt: x = p2 | p4
replaced with: x.1 = p2 | p4
on stmt: $238load_global.15 = global(types: <module 'numba.core.types' from '/home/earnest/.local/share/mamba/envs/basicrl/lib/python3.11/site-packages/numba/core/types/__init__.py'>)
on stmt: $250load_attr.17 = getattr(value=$238load_global.15, attr=uint32)
on stmt: $264load_global.20 = global(_PyLong_SHIFT: 30)
on stmt: $binop_mul276.21 = idx * $264load_global.20
on stmt: $binop_rshift280.22 = val >> $binop_mul276.21
on stmt: $binop_and_286.24 = $binop_rshift280.22 & mask_shift
on stmt: $294call.25 = call $250load_attr.17($binop_and_286.24, func=$250load_attr.17, args=[Var($binop_and_286.24, old_hashing.py:218)], kws=(), vararg=None, varkwarg=None, target=None)
on stmt: $binop_iadd304.26 = inplace_binop(fn=<built-in function iadd>, immutable_fn=<built-in function add>, lhs=x, rhs=$294call.25, static_lhs=Undefined, static_rhs=Undefined)
on stmt: x = $binop_iadd304.26
replaced with: x.2 = $binop_iadd304.26
on stmt: $312load_global.28 = global(_PyHASH_MODULUS: 2305843009213693951)
on stmt: $324compare_op.29 = x >= $312load_global.28
on stmt: bool330 = global(bool: <class 'bool'>)
on stmt: $330pred = call bool330($324compare_op.29, func=bool330, args=(Var($324compare_op.29, old_hashing.py:219),), kws=(), vararg=None, varkwarg=None, target=None)
on stmt: branch $330pred, 332, 352
==== SSA block rewrite pass on 332
Running <numba.core.ssa._FreshVarHandler object at 0x7f61a6cfc210>
on stmt: $334load_global.2 = global(_PyHASH_MODULUS: 2305843009213693951)
on stmt: $binop_isub346.3 = inplace_binop(fn=<built-in function isub>, immutable_fn=<built-in function sub>, lhs=x, rhs=$334load_global.2, static_lhs=Undefined, static_rhs=Undefined)
on stmt: x = $binop_isub346.3
replaced with: x.3 = $binop_isub346.3
on stmt: jump 352
==== SSA block rewrite pass on 352
Running <numba.core.ssa._FreshVarHandler object at 0x7f61a6cfc210>
on stmt: jump 172
==== SSA block rewrite pass on 354
Running <numba.core.ssa._FreshVarHandler object at 0x7f61a6cfc210>
on stmt: $354load_global.0 = global(_Py_hash_t: int64)
on stmt: $372call.3 = call $354load_global.0(x, func=$354load_global.0, args=[Var(x, old_hashing.py:210)], kws=(), vararg=None, varkwarg=None, target=None)
on stmt: $382return_value.4 = cast(value=$372call.3)
on stmt: return $382return_value.4
Replaced assignments: defaultdict(<class 'list'>,
            {0: [<numba.core.ir.Assign object at 0x7f61ca2d7d10>],
             174: [<numba.core.ir.Assign object at 0x7f61a6ccb0d0>,
                   <numba.core.ir.Assign object at 0x7f61a4911150>],
             332: [<numba.core.ir.Assign object at 0x7f61a4911290>]})
==== SSA block rewrite pass on 0
Running <numba.core.ssa._FixSSAVars object at 0x7f61a4913b50>
on stmt: val = arg(0, name=val)
on stmt: $const4.0.1 = const(int, 32)
on stmt: $6load_global.1 = global(_PyLong_SHIFT: 30)
on stmt: _tmp_shift = $const4.0.1 - $6load_global.1
on stmt: $24load_global.3 = global(types: <module 'numba.core.types' from '/home/earnest/.local/share/mamba/envs/basicrl/lib/python3.11/site-packages/numba/core/types/__init__.py'>)
on stmt: $36load_attr.5 = getattr(value=$24load_global.3, attr=uint32)
on stmt: $const46.6.2 = const(int, 0)
on stmt: $52call.7 = call $36load_attr.5($const46.6.2, func=$36load_attr.5, args=[Var($const46.6.2, old_hashing.py:203)], kws=(), vararg=None, varkwarg=None, target=None)
on stmt: $62unary_invert.8 = unary(fn=<built-in function invert>, value=$52call.7)
on stmt: mask_shift = $62unary_invert.8 >> _tmp_shift
on stmt: $const72.11.3 = const(int, 64)
on stmt: $74load_global.12 = global(_PyLong_SHIFT: 30)
on stmt: $binop_floordiv86.13 = $const72.11.3 // $74load_global.12
on stmt: $const90.14.4 = const(int, 1)
on stmt: i = $binop_floordiv86.13 + $const90.14.4
on stmt: x = const(int, 0)
on stmt: $102load_global.17 = global(_PyHASH_BITS: 61)
on stmt: $114load_global.18 = global(_PyLong_SHIFT: 30)
on stmt: p3 = $102load_global.17 - $114load_global.18
on stmt: $132load_global.20 = global(range: <class 'range'>)
on stmt: $const146.23.4 = const(int, 1)
on stmt: $binop_sub148.24 = i - $const146.23.4
on stmt: $const152.25.5 = const(int, -1)
on stmt: $const154.26.5 = const(int, -1)
on stmt: $160call.27 = call $132load_global.20($binop_sub148.24, $const152.25.5, $const154.26.5, func=$132load_global.20, args=[Var($binop_sub148.24, old_hashing.py:212), Var($const152.25.5, old_hashing.py:212), Var($const154.26.5, old_hashing.py:212)], kws=(), vararg=None, varkwarg=None, target=None)
on stmt: $170get_iter.28 = getiter(value=$160call.27)
on stmt: $phi172.0 = $170get_iter.28
on stmt: jump 172
==== SSA block rewrite pass on 172
Running <numba.core.ssa._FixSSAVars object at 0x7f61a4913b50>
on stmt: $172for_iter.1 = iternext(value=$phi172.0)
on stmt: $172for_iter.2 = pair_first(value=$172for_iter.1)
on stmt: $172for_iter.3 = pair_second(value=$172for_iter.1)
on stmt: $phi174.1 = $172for_iter.2
on stmt: branch $172for_iter.3, 174, 354
==== SSA block rewrite pass on 174
Running <numba.core.ssa._FixSSAVars object at 0x7f61a4913b50>
on stmt: idx = $phi174.1
on stmt: $178load_global.3 = global(_PyLong_SHIFT: 30)
on stmt: p1 = x << $178load_global.3
find_def var='x' stmt=p1 = x << $178load_global.3
find_def_from_top label 174
idom 172 from label 174
find_def_from_bottom label 172
find_def_from_top label 172
insert phi node x.4 = phi(incoming_values=[], incoming_blocks=[]) at 172
find_def_from_bottom label 0
incoming_def x = const(int, 0)
find_def_from_bottom label 352
find_def_from_top label 352
insert phi node x.5 = phi(incoming_values=[], incoming_blocks=[]) at 352
find_def_from_bottom label 332
incoming_def x.3 = $binop_isub346.3
find_def_from_bottom label 174
incoming_def x.2 = $binop_iadd304.26
incoming_def x.5 = phi(incoming_values=[Var(x.3, old_hashing.py:220), Var(x.2, old_hashing.py:218)], incoming_blocks=[332, 174])
replaced with: p1 = x.4 << $178load_global.3
on stmt: $198load_global.6 = global(_PyHASH_MODULUS: 2305843009213693951)
on stmt: p2 = p1 & $198load_global.6
on stmt: p4 = x >> p3
find_def var='x' stmt=p4 = x >> p3
find_def_from_top label 174
idom 172 from label 174
find_def_from_bottom label 172
replaced with: p4 = x.4 >> p3
on stmt: x.1 = p2 | p4
on stmt: $238load_global.15 = global(types: <module 'numba.core.types' from '/home/earnest/.local/share/mamba/envs/basicrl/lib/python3.11/site-packages/numba/core/types/__init__.py'>)
on stmt: $250load_attr.17 = getattr(value=$238load_global.15, attr=uint32)
on stmt: $264load_global.20 = global(_PyLong_SHIFT: 30)
on stmt: $binop_mul276.21 = idx * $264load_global.20
on stmt: $binop_rshift280.22 = val >> $binop_mul276.21
on stmt: $binop_and_286.24 = $binop_rshift280.22 & mask_shift
on stmt: $294call.25 = call $250load_attr.17($binop_and_286.24, func=$250load_attr.17, args=[Var($binop_and_286.24, old_hashing.py:218)], kws=(), vararg=None, varkwarg=None, target=None)
on stmt: $binop_iadd304.26 = inplace_binop(fn=<built-in function iadd>, immutable_fn=<built-in function add>, lhs=x, rhs=$294call.25, static_lhs=Undefined, static_rhs=Undefined)
find_def var='x' stmt=$binop_iadd304.26 = inplace_binop(fn=<built-in function iadd>, immutable_fn=<built-in function add>, lhs=x, rhs=$294call.25, static_lhs=Undefined, static_rhs=Undefined)
replaced with: $binop_iadd304.26 = inplace_binop(fn=<built-in function iadd>, immutable_fn=<built-in function add>, lhs=x.1, rhs=$294call.25, static_lhs=Undefined, static_rhs=Undefined)
on stmt: x.2 = $binop_iadd304.26
on stmt: $312load_global.28 = global(_PyHASH_MODULUS: 2305843009213693951)
on stmt: $324compare_op.29 = x >= $312load_global.28
find_def var='x' stmt=$324compare_op.29 = x >= $312load_global.28
replaced with: $324compare_op.29 = x.2 >= $312load_global.28
on stmt: bool330 = global(bool: <class 'bool'>)
on stmt: $330pred = call bool330($324compare_op.29, func=bool330, args=(Var($324compare_op.29, old_hashing.py:219),), kws=(), vararg=None, varkwarg=None, target=None)
on stmt: branch $330pred, 332, 352
==== SSA block rewrite pass on 332
Running <numba.core.ssa._FixSSAVars object at 0x7f61a4913b50>
on stmt: $334load_global.2 = global(_PyHASH_MODULUS: 2305843009213693951)
on stmt: $binop_isub346.3 = inplace_binop(fn=<built-in function isub>, immutable_fn=<built-in function sub>, lhs=x, rhs=$334load_global.2, static_lhs=Undefined, static_rhs=Undefined)
find_def var='x' stmt=$binop_isub346.3 = inplace_binop(fn=<built-in function isub>, immutable_fn=<built-in function sub>, lhs=x, rhs=$334load_global.2, static_lhs=Undefined, static_rhs=Undefined)
find_def_from_top label 332
idom 174 from label 332
find_def_from_bottom label 174
replaced with: $binop_isub346.3 = inplace_binop(fn=<built-in function isub>, immutable_fn=<built-in function sub>, lhs=x.2, rhs=$334load_global.2, static_lhs=Undefined, static_rhs=Undefined)
on stmt: x.3 = $binop_isub346.3
on stmt: jump 352
==== SSA block rewrite pass on 352
Running <numba.core.ssa._FixSSAVars object at 0x7f61a4913b50>
on stmt: jump 172
==== SSA block rewrite pass on 354
Running <numba.core.ssa._FixSSAVars object at 0x7f61a4913b50>
on stmt: $354load_global.0 = global(_Py_hash_t: int64)
on stmt: $372call.3 = call $354load_global.0(x, func=$354load_global.0, args=[Var(x, old_hashing.py:210)], kws=(), vararg=None, varkwarg=None, target=None)
find_def var='x' stmt=$372call.3 = call $354load_global.0(x, func=$354load_global.0, args=[Var(x, old_hashing.py:210)], kws=(), vararg=None, varkwarg=None, target=None)
find_def_from_top label 354
idom 172 from label 354
find_def_from_bottom label 172
replaced with: $372call.3 = call $354load_global.0(x.4, func=$354load_global.0, args=[Var(x.4, old_hashing.py:212)], kws=(), vararg=None, varkwarg=None, target=None)
on stmt: $382return_value.4 = cast(value=$372call.3)
on stmt: return $382return_value.4
bytecode dump:
>          0	NOP(arg=None, lineno=79)
           2	RESUME(arg=0, lineno=79)
           4	LOAD_GLOBAL(arg=1, lineno=81)
          16	LOAD_FAST(arg=0, lineno=81)
          18	PRECALL(arg=1, lineno=81)
          22	CALL(arg=1, lineno=81)
          32	STORE_FAST(arg=1, lineno=81)
          34	LOAD_FAST(arg=1, lineno=82)
          36	LOAD_GLOBAL(arg=3, lineno=82)
          48	LOAD_CONST(arg=1, lineno=82)
          50	PRECALL(arg=1, lineno=82)
          54	CALL(arg=1, lineno=82)
          64	COMPARE_OP(arg=2, lineno=82)
          70	POP_JUMP_FORWARD_IF_FALSE(arg=15, lineno=82)
          72	LOAD_GLOBAL(arg=3, lineno=83)
          84	LOAD_CONST(arg=2, lineno=83)
          86	PRECALL(arg=1, lineno=83)
          90	CALL(arg=1, lineno=83)
         100	STORE_FAST(arg=1, lineno=83)
>        102	LOAD_FAST(arg=1, lineno=84)
         104	RETURN_VALUE(arg=None, lineno=84)
pending: deque([State(pc_initial=0 nstack_initial=0)])
stack: []
state.pc_initial: State(pc_initial=0 nstack_initial=0)
dispatch pc=0, inst=NOP(arg=None, lineno=79)
stack []
dispatch pc=2, inst=RESUME(arg=0, lineno=79)
stack []
dispatch pc=4, inst=LOAD_GLOBAL(arg=1, lineno=81)
stack []
dispatch pc=16, inst=LOAD_FAST(arg=0, lineno=81)
stack ['$null$4.1', '$4load_global.0']
dispatch pc=18, inst=PRECALL(arg=1, lineno=81)
stack ['$null$4.1', '$4load_global.0', '$val16.2']
dispatch pc=22, inst=CALL(arg=1, lineno=81)
stack ['$null$4.1', '$4load_global.0', '$val16.2']
dispatch pc=32, inst=STORE_FAST(arg=1, lineno=81)
stack ['$22call.3']
dispatch pc=34, inst=LOAD_FAST(arg=1, lineno=82)
stack []
dispatch pc=36, inst=LOAD_GLOBAL(arg=3, lineno=82)
stack ['$asint34.4']
dispatch pc=48, inst=LOAD_CONST(arg=1, lineno=82)
stack ['$asint34.4', '$null$36.6', '$36load_global.5']
dispatch pc=50, inst=PRECALL(arg=1, lineno=82)
stack ['$asint34.4', '$null$36.6', '$36load_global.5', '$const48.7.1']
dispatch pc=54, inst=CALL(arg=1, lineno=82)
stack ['$asint34.4', '$null$36.6', '$36load_global.5', '$const48.7.1']
dispatch pc=64, inst=COMPARE_OP(arg=2, lineno=82)
stack ['$asint34.4', '$54call.8']
dispatch pc=70, inst=POP_JUMP_FORWARD_IF_FALSE(arg=15, lineno=82)
stack ['$64compare_op.9']
end state. edges=[Edge(pc=72, stack=(), blockstack=(), npush=0), Edge(pc=102, stack=(), blockstack=(), npush=0)]
pending: deque([State(pc_initial=72 nstack_initial=0), State(pc_initial=102 nstack_initial=0)])
stack: []
state.pc_initial: State(pc_initial=72 nstack_initial=0)
dispatch pc=72, inst=LOAD_GLOBAL(arg=3, lineno=83)
stack []
dispatch pc=84, inst=LOAD_CONST(arg=2, lineno=83)
stack ['$null$72.1', '$72load_global.0']
dispatch pc=86, inst=PRECALL(arg=1, lineno=83)
stack ['$null$72.1', '$72load_global.0', '$const84.2.2']
dispatch pc=90, inst=CALL(arg=1, lineno=83)
stack ['$null$72.1', '$72load_global.0', '$const84.2.2']
dispatch pc=100, inst=STORE_FAST(arg=1, lineno=83)
stack ['$90call.3']
end state. edges=[Edge(pc=102, stack=(), blockstack=(), npush=0)]
pending: deque([State(pc_initial=102 nstack_initial=0), State(pc_initial=102 nstack_initial=0)])
stack: []
state.pc_initial: State(pc_initial=102 nstack_initial=0)
dispatch pc=102, inst=LOAD_FAST(arg=1, lineno=84)
stack []
dispatch pc=104, inst=RETURN_VALUE(arg=None, lineno=84)
stack ['$asint102.0']
end state. edges=[]
pending: deque([State(pc_initial=102 nstack_initial=0)])
-------------------------Prune PHIs-------------------------
Used_phis: defaultdict(<class 'set'>,
            {State(pc_initial=0 nstack_initial=0): set(),
             State(pc_initial=72 nstack_initial=0): set(),
             State(pc_initial=102 nstack_initial=0): set()})
defmap: {}
phismap: defaultdict(<class 'set'>, {})
changing phismap: defaultdict(<class 'set'>, {})
keep phismap: {}
new_out: defaultdict(<class 'dict'>, {})
----------------------DONE Prune PHIs-----------------------
block_infos State(pc_initial=0 nstack_initial=0):
AdaptBlockInfo(insts=((0, {}), (2, {}), (4, {'idx': 0, 'res': '$4load_global.0'}), (6, {}), (8, {}), (10, {}), (12, {}), (14, {}), (16, {'res': '$val16.2'}), (18, {}), (20, {}), (22, {'func': '$4load_global.0', 'args': ['$val16.2'], 'kw_names': None, 'res': '$22call.3'}), (24, {}), (26, {}), (28, {}), (30, {}), (32, {'value': '$22call.3'}), (34, {'res': '$asint34.4'}), (36, {'idx': 1, 'res': '$36load_global.5'}), (38, {}), (40, {}), (42, {}), (44, {}), (46, {}), (48, {'res': '$const48.7.1'}), (50, {}), (52, {}), (54, {'func': '$36load_global.5', 'args': ['$const48.7.1'], 'kw_names': None, 'res': '$54call.8'}), (56, {}), (58, {}), (60, {}), (62, {}), (64, {'lhs': '$asint34.4', 'rhs': '$54call.8', 'res': '$64compare_op.9'}), (66, {}), (68, {}), (70, {'pred': '$64compare_op.9'})), outgoing_phis={}, blockstack=(), active_try_block=None, outgoing_edgepushed={72: (), 102: ()})
block_infos State(pc_initial=72 nstack_initial=0):
AdaptBlockInfo(insts=((72, {'idx': 1, 'res': '$72load_global.0'}), (74, {}), (76, {}), (78, {}), (80, {}), (82, {}), (84, {'res': '$const84.2.2'}), (86, {}), (88, {}), (90, {'func': '$72load_global.0', 'args': ['$const84.2.2'], 'kw_names': None, 'res': '$90call.3'}), (92, {}), (94, {}), (96, {}), (98, {}), (100, {'value': '$90call.3'})), outgoing_phis={}, blockstack=(), active_try_block=None, outgoing_edgepushed={102: ()})
block_infos State(pc_initial=102 nstack_initial=0):
AdaptBlockInfo(insts=((102, {'res': '$asint102.0'}), (104, {'retval': '$asint102.0', 'castval': '$104return_value.1'})), outgoing_phis={}, blockstack=(), active_try_block=None, outgoing_edgepushed={})
label 0:
    val = arg(0, name=val)                   ['val']
    $4load_global.0 = global(_Py_hash_t: int64) ['$4load_global.0']
    asint = call $4load_global.0(val, func=$4load_global.0, args=[Var(val, old_hashing.py:79)], kws=(), vararg=None, varkwarg=None, target=None) ['$4load_global.0', 'asint', 'val']
    $36load_global.5 = global(int: <class 'int'>) ['$36load_global.5']
    $const48.7.1 = const(int, -1)            ['$const48.7.1']
    $54call.8 = call $36load_global.5($const48.7.1, func=$36load_global.5, args=[Var($const48.7.1, old_hashing.py:82)], kws=(), vararg=None, varkwarg=None, target=None) ['$36load_global.5', '$54call.8', '$const48.7.1']
    $64compare_op.9 = asint == $54call.8     ['$54call.8', '$64compare_op.9', 'asint']
    bool70 = global(bool: <class 'bool'>)    ['bool70']
    $70pred = call bool70($64compare_op.9, func=bool70, args=(Var($64compare_op.9, old_hashing.py:82),), kws=(), vararg=None, varkwarg=None, target=None) ['$64compare_op.9', '$70pred', 'bool70']
    branch $70pred, 72, 102                  ['$70pred']
label 72:
    $72load_global.0 = global(int: <class 'int'>) ['$72load_global.0']
    $const84.2.2 = const(int, -2)            ['$const84.2.2']
    asint = call $72load_global.0($const84.2.2, func=$72load_global.0, args=[Var($const84.2.2, old_hashing.py:83)], kws=(), vararg=None, varkwarg=None, target=None) ['$72load_global.0', '$const84.2.2', 'asint']
    jump 102                                 []
label 102:
    $104return_value.1 = cast(value=asint)   ['$104return_value.1', 'asint']
    return $104return_value.1                ['$104return_value.1']

==== SSA block analysis pass on 0
Running <numba.core.ssa._GatherDefsHandler object at 0x7f61a492bbd0>
on stmt: val = arg(0, name=val)
on stmt: $4load_global.0 = global(_Py_hash_t: int64)
on stmt: asint = call $4load_global.0(val, func=$4load_global.0, args=[Var(val, old_hashing.py:79)], kws=(), vararg=None, varkwarg=None, target=None)
on stmt: $36load_global.5 = global(int: <class 'int'>)
on stmt: $const48.7.1 = const(int, -1)
on stmt: $54call.8 = call $36load_global.5($const48.7.1, func=$36load_global.5, args=[Var($const48.7.1, old_hashing.py:82)], kws=(), vararg=None, varkwarg=None, target=None)
on stmt: $64compare_op.9 = asint == $54call.8
on stmt: bool70 = global(bool: <class 'bool'>)
on stmt: $70pred = call bool70($64compare_op.9, func=bool70, args=(Var($64compare_op.9, old_hashing.py:82),), kws=(), vararg=None, varkwarg=None, target=None)
on stmt: branch $70pred, 72, 102
==== SSA block analysis pass on 72
Running <numba.core.ssa._GatherDefsHandler object at 0x7f61a492bbd0>
on stmt: $72load_global.0 = global(int: <class 'int'>)
on stmt: $const84.2.2 = const(int, -2)
on stmt: asint = call $72load_global.0($const84.2.2, func=$72load_global.0, args=[Var($const84.2.2, old_hashing.py:83)], kws=(), vararg=None, varkwarg=None, target=None)
on stmt: jump 102
==== SSA block analysis pass on 102
Running <numba.core.ssa._GatherDefsHandler object at 0x7f61a492bbd0>
on stmt: $104return_value.1 = cast(value=asint)
on stmt: return $104return_value.1
defs defaultdict(<class 'list'>,
            {'$104return_value.1': [(<numba.core.ir.Assign object at 0x7f61a4990d50>,
                                     102)],
             '$36load_global.5': [(<numba.core.ir.Assign object at 0x7f61a4983810>,
                                   0)],
             '$4load_global.0': [(<numba.core.ir.Assign object at 0x7f61a55e3310>,
                                  0)],
             '$54call.8': [(<numba.core.ir.Assign object at 0x7f61a4983c90>,
                            0)],
             '$64compare_op.9': [(<numba.core.ir.Assign object at 0x7f61a4983e90>,
                                  0)],
             '$70pred': [(<numba.core.ir.Assign object at 0x7f61a49902d0>, 0)],
             '$72load_global.0': [(<numba.core.ir.Assign object at 0x7f61a4990490>,
                                   72)],
             '$const48.7.1': [(<numba.core.ir.Assign object at 0x7f61a4983a50>,
                               0)],
             '$const84.2.2': [(<numba.core.ir.Assign object at 0x7f61a4990650>,
                               72)],
             'asint': [(<numba.core.ir.Assign object at 0x7f61a6c9a150>, 0),
                       (<numba.core.ir.Assign object at 0x7f61a4990850>, 72)],
             'bool70': [(<numba.core.ir.Assign object at 0x7f61a4990110>, 0)],
             'val': [(<numba.core.ir.Assign object at 0x7f61a55e3990>, 0)]})
SSA violators <numba.core.utils.OrderedSet object at 0x7f61a492bbd0>
Fix SSA violator on var asint
==== SSA block rewrite pass on 0
Running <numba.core.ssa._FreshVarHandler object at 0x7f61a491eb90>
on stmt: val = arg(0, name=val)
on stmt: $4load_global.0 = global(_Py_hash_t: int64)
on stmt: asint = call $4load_global.0(val, func=$4load_global.0, args=[Var(val, old_hashing.py:79)], kws=(), vararg=None, varkwarg=None, target=None)
first assign: asint
replaced with: asint = call $4load_global.0(val, func=$4load_global.0, args=[Var(val, old_hashing.py:79)], kws=(), vararg=None, varkwarg=None, target=None)
on stmt: $36load_global.5 = global(int: <class 'int'>)
on stmt: $const48.7.1 = const(int, -1)
on stmt: $54call.8 = call $36load_global.5($const48.7.1, func=$36load_global.5, args=[Var($const48.7.1, old_hashing.py:82)], kws=(), vararg=None, varkwarg=None, target=None)
on stmt: $64compare_op.9 = asint == $54call.8
on stmt: bool70 = global(bool: <class 'bool'>)
on stmt: $70pred = call bool70($64compare_op.9, func=bool70, args=(Var($64compare_op.9, old_hashing.py:82),), kws=(), vararg=None, varkwarg=None, target=None)
on stmt: branch $70pred, 72, 102
==== SSA block rewrite pass on 72
Running <numba.core.ssa._FreshVarHandler object at 0x7f61a491eb90>
on stmt: $72load_global.0 = global(int: <class 'int'>)
on stmt: $const84.2.2 = const(int, -2)
on stmt: asint = call $72load_global.0($const84.2.2, func=$72load_global.0, args=[Var($const84.2.2, old_hashing.py:83)], kws=(), vararg=None, varkwarg=None, target=None)
replaced with: asint.1 = call $72load_global.0($const84.2.2, func=$72load_global.0, args=[Var($const84.2.2, old_hashing.py:83)], kws=(), vararg=None, varkwarg=None, target=None)
on stmt: jump 102
==== SSA block rewrite pass on 102
Running <numba.core.ssa._FreshVarHandler object at 0x7f61a491eb90>
on stmt: $104return_value.1 = cast(value=asint)
on stmt: return $104return_value.1
Replaced assignments: defaultdict(<class 'list'>,
            {0: [<numba.core.ir.Assign object at 0x7f61a49919d0>],
             72: [<numba.core.ir.Assign object at 0x7f61a4991ad0>]})
==== SSA block rewrite pass on 0
Running <numba.core.ssa._FixSSAVars object at 0x7f61a4991d10>
on stmt: val = arg(0, name=val)
on stmt: $4load_global.0 = global(_Py_hash_t: int64)
on stmt: asint = call $4load_global.0(val, func=$4load_global.0, args=[Var(val, old_hashing.py:79)], kws=(), vararg=None, varkwarg=None, target=None)
on stmt: $36load_global.5 = global(int: <class 'int'>)
on stmt: $const48.7.1 = const(int, -1)
on stmt: $54call.8 = call $36load_global.5($const48.7.1, func=$36load_global.5, args=[Var($const48.7.1, old_hashing.py:82)], kws=(), vararg=None, varkwarg=None, target=None)
on stmt: $64compare_op.9 = asint == $54call.8
find_def var='asint' stmt=$64compare_op.9 = asint == $54call.8
on stmt: bool70 = global(bool: <class 'bool'>)
on stmt: $70pred = call bool70($64compare_op.9, func=bool70, args=(Var($64compare_op.9, old_hashing.py:82),), kws=(), vararg=None, varkwarg=None, target=None)
on stmt: branch $70pred, 72, 102
==== SSA block rewrite pass on 72
Running <numba.core.ssa._FixSSAVars object at 0x7f61a4991d10>
on stmt: $72load_global.0 = global(int: <class 'int'>)
on stmt: $const84.2.2 = const(int, -2)
on stmt: asint.1 = call $72load_global.0($const84.2.2, func=$72load_global.0, args=[Var($const84.2.2, old_hashing.py:83)], kws=(), vararg=None, varkwarg=None, target=None)
on stmt: jump 102
==== SSA block rewrite pass on 102
Running <numba.core.ssa._FixSSAVars object at 0x7f61a4991d10>
on stmt: $104return_value.1 = cast(value=asint)
find_def var='asint' stmt=$104return_value.1 = cast(value=asint)
find_def_from_top label 102
insert phi node asint.2 = phi(incoming_values=[], incoming_blocks=[]) at 102
find_def_from_bottom label 0
incoming_def asint = call $4load_global.0(val, func=$4load_global.0, args=[Var(val, old_hashing.py:79)], kws=(), vararg=None, varkwarg=None, target=None)
find_def_from_bottom label 72
incoming_def asint.1 = call $72load_global.0($const84.2.2, func=$72load_global.0, args=[Var($const84.2.2, old_hashing.py:83)], kws=(), vararg=None, varkwarg=None, target=None)
replaced with: $104return_value.1 = cast(value=asint.2)
on stmt: return $104return_value.1
bytecode dump:
>          0	NOP(arg=None, lineno=998)
           2	RESUME(arg=0, lineno=998)
           4	LOAD_GLOBAL(arg=1, lineno=999)
          16	LOAD_FAST(arg=0, lineno=999)
          18	LOAD_FAST(arg=1, lineno=999)
          20	PRECALL(arg=2, lineno=999)
          24	CALL(arg=2, lineno=999)
          34	RETURN_VALUE(arg=None, lineno=999)
pending: deque([State(pc_initial=0 nstack_initial=0)])
stack: []
state.pc_initial: State(pc_initial=0 nstack_initial=0)
dispatch pc=0, inst=NOP(arg=None, lineno=998)
stack []
dispatch pc=2, inst=RESUME(arg=0, lineno=998)
stack []
dispatch pc=4, inst=LOAD_GLOBAL(arg=1, lineno=999)
stack []
dispatch pc=16, inst=LOAD_FAST(arg=0, lineno=999)
stack ['$null$4.1', '$4load_global.0']
dispatch pc=18, inst=LOAD_FAST(arg=1, lineno=999)
stack ['$null$4.1', '$4load_global.0', '$obj16.2']
dispatch pc=20, inst=PRECALL(arg=2, lineno=999)
stack ['$null$4.1', '$4load_global.0', '$obj16.2', '$name18.3']
dispatch pc=24, inst=CALL(arg=2, lineno=999)
stack ['$null$4.1', '$4load_global.0', '$obj16.2', '$name18.3']
dispatch pc=34, inst=RETURN_VALUE(arg=None, lineno=999)
stack ['$24call.4']
end state. edges=[]
-------------------------Prune PHIs-------------------------
Used_phis: defaultdict(<class 'set'>, {State(pc_initial=0 nstack_initial=0): set()})
defmap: {}
phismap: defaultdict(<class 'set'>, {})
changing phismap: defaultdict(<class 'set'>, {})
keep phismap: {}
new_out: defaultdict(<class 'dict'>, {})
----------------------DONE Prune PHIs-----------------------
block_infos State(pc_initial=0 nstack_initial=0):
AdaptBlockInfo(insts=((0, {}), (2, {}), (4, {'idx': 0, 'res': '$4load_global.0'}), (6, {}), (8, {}), (10, {}), (12, {}), (14, {}), (16, {'res': '$obj16.2'}), (18, {'res': '$name18.3'}), (20, {}), (22, {}), (24, {'func': '$4load_global.0', 'args': ['$obj16.2', '$name18.3'], 'kw_names': None, 'res': '$24call.4'}), (26, {}), (28, {}), (30, {}), (32, {}), (34, {'retval': '$24call.4', 'castval': '$34return_value.5'})), outgoing_phis={}, blockstack=(), active_try_block=None, outgoing_edgepushed={})
label 0:
    obj = arg(0, name=obj)                   ['obj']
    name = arg(1, name=name)                 ['name']
    $4load_global.0 = global(resolve_hasattr: <intrinsic resolve_hasattr>) ['$4load_global.0']
    $24call.4 = call $4load_global.0(obj, name, func=$4load_global.0, args=[Var(obj, old_builtins.py:998), Var(name, old_builtins.py:998)], kws=(), vararg=None, varkwarg=None, target=None) ['$24call.4', '$4load_global.0', 'name', 'obj']
    $34return_value.5 = cast(value=$24call.4) ['$24call.4', '$34return_value.5']
    return $34return_value.5                 ['$34return_value.5']

==== SSA block analysis pass on 0
Running <numba.core.ssa._GatherDefsHandler object at 0x7f61a411e4d0>
on stmt: obj = arg(0, name=obj)
on stmt: name = arg(1, name=name)
on stmt: $4load_global.0 = global(resolve_hasattr: <intrinsic resolve_hasattr>)
on stmt: $24call.4 = call $4load_global.0(obj, name, func=$4load_global.0, args=[Var(obj, old_builtins.py:998), Var(name, old_builtins.py:998)], kws=(), vararg=None, varkwarg=None, target=None)
on stmt: $34return_value.5 = cast(value=$24call.4)
on stmt: return $34return_value.5
defs defaultdict(<class 'list'>,
            {'$24call.4': [(<numba.core.ir.Assign object at 0x7f61a411d5d0>,
                            0)],
             '$34return_value.5': [(<numba.core.ir.Assign object at 0x7f61a411d890>,
                                    0)],
             '$4load_global.0': [(<numba.core.ir.Assign object at 0x7f61a411cf90>,
                                  0)],
             'name': [(<numba.core.ir.Assign object at 0x7f61a411cd10>, 0)],
             'obj': [(<numba.core.ir.Assign object at 0x7f61a411cc10>, 0)]})
SSA violators <numba.core.utils.OrderedSet object at 0x7f61a411e4d0>
captured error
Traceback (most recent call last):
  File "/home/earnest/.local/share/mamba/envs/basicrl/lib/python3.11/site-packages/numba/core/typeinfer.py", line 160, in propagate
    constraint(typeinfer)
  File "/home/earnest/.local/share/mamba/envs/basicrl/lib/python3.11/site-packages/numba/core/typeinfer.py", line 566, in __call__
    self.resolve(typeinfer, typevars, fnty)
  File "/home/earnest/.local/share/mamba/envs/basicrl/lib/python3.11/site-packages/numba/core/typeinfer.py", line 589, in resolve
    sig = typeinfer.resolve_call(fnty, pos_args, kw_args)
          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/home/earnest/.local/share/mamba/envs/basicrl/lib/python3.11/site-packages/numba/core/typeinfer.py", line 1560, in resolve_call
    return self.context.resolve_function_type(fnty, pos_args, kw_args)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/home/earnest/.local/share/mamba/envs/basicrl/lib/python3.11/site-packages/numba/core/typing/context.py", line 212, in resolve_function_type
    raise last_exception
  File "/home/earnest/.local/share/mamba/envs/basicrl/lib/python3.11/site-packages/numba/core/typing/context.py", line 195, in resolve_function_type
    res = self._resolve_user_function_type(func, args, kws)
          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/home/earnest/.local/share/mamba/envs/basicrl/lib/python3.11/site-packages/numba/core/typing/context.py", line 247, in _resolve_user_function_type
    return func.get_call_type(self, args, kws)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/home/earnest/.local/share/mamba/envs/basicrl/lib/python3.11/site-packages/numba/core/types/functions.py", line 329, in get_call_type
    failures.raise_error()
  File "/home/earnest/.local/share/mamba/envs/basicrl/lib/python3.11/site-packages/numba/core/types/functions.py", line 227, in raise_error
    raise errors.TypingError(self.format())
numba.core.errors.TypingError: No implementation of function Function(<intrinsic resolve_hasattr>) found for signature:
 
 >>> resolve_hasattr(int64, unicode_type)
 
There are 2 candidate implementations:
   - Of which 2 did not match due to:
   Intrinsic in function 'resolve_hasattr': File: numba/cpython/old_builtins.py: Line 970.
     With argument(s): '(int64, unicode_type)':
    Rejected as the implementation raised a specific error:
      RequireLiteralValue: argument 'name' must be a literal string
  raised from /home/earnest/.local/share/mamba/envs/basicrl/lib/python3.11/site-packages/numba/cpython/old_builtins.py:973

During: resolving callee type: Function(<intrinsic resolve_hasattr>)
During: typing of call at /home/earnest/.local/share/mamba/envs/basicrl/lib/python3.11/site-packages/numba/cpython/old_builtins.py (999)

captured error
Traceback (most recent call last):
  File "/home/earnest/.local/share/mamba/envs/basicrl/lib/python3.11/site-packages/numba/core/typeinfer.py", line 160, in propagate
    constraint(typeinfer)
  File "/home/earnest/.local/share/mamba/envs/basicrl/lib/python3.11/site-packages/numba/core/typeinfer.py", line 566, in __call__
    self.resolve(typeinfer, typevars, fnty)
  File "/home/earnest/.local/share/mamba/envs/basicrl/lib/python3.11/site-packages/numba/core/typeinfer.py", line 589, in resolve
    sig = typeinfer.resolve_call(fnty, pos_args, kw_args)
          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/home/earnest/.local/share/mamba/envs/basicrl/lib/python3.11/site-packages/numba/core/typeinfer.py", line 1560, in resolve_call
    return self.context.resolve_function_type(fnty, pos_args, kw_args)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/home/earnest/.local/share/mamba/envs/basicrl/lib/python3.11/site-packages/numba/core/typing/context.py", line 212, in resolve_function_type
    raise last_exception
  File "/home/earnest/.local/share/mamba/envs/basicrl/lib/python3.11/site-packages/numba/core/typing/context.py", line 195, in resolve_function_type
    res = self._resolve_user_function_type(func, args, kws)
          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/home/earnest/.local/share/mamba/envs/basicrl/lib/python3.11/site-packages/numba/core/typing/context.py", line 247, in _resolve_user_function_type
    return func.get_call_type(self, args, kws)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/home/earnest/.local/share/mamba/envs/basicrl/lib/python3.11/site-packages/numba/core/types/functions.py", line 329, in get_call_type
    failures.raise_error()
  File "/home/earnest/.local/share/mamba/envs/basicrl/lib/python3.11/site-packages/numba/core/types/functions.py", line 227, in raise_error
    raise errors.TypingError(self.format())
numba.core.errors.TypingError: No implementation of function Function(<intrinsic resolve_hasattr>) found for signature:
 
 >>> resolve_hasattr(int64, unicode_type)
 
There are 2 candidate implementations:
    - Of which 2 did not match due to:
    Intrinsic in function 'resolve_hasattr': File: numba/cpython/old_builtins.py: Line 970.
      With argument(s): '(int64, unicode_type)':
     Rejected as the implementation raised a specific error:
       RequireLiteralValue: argument 'name' must be a literal string
  raised from /home/earnest/.local/share/mamba/envs/basicrl/lib/python3.11/site-packages/numba/cpython/old_builtins.py:973

During: resolving callee type: Function(<intrinsic resolve_hasattr>)
During: typing of call at /home/earnest/.local/share/mamba/envs/basicrl/lib/python3.11/site-packages/numba/cpython/old_builtins.py (999)

bytecode dump:
>          0	NOP(arg=None, lineno=307)
           2	RESUME(arg=0, lineno=307)
           4	LOAD_GLOBAL(arg=1, lineno=308)
          16	LOAD_ATTR(arg=1, lineno=308)
          26	LOAD_FAST(arg=0, lineno=308)
          28	LOAD_FAST(arg=1, lineno=308)
          30	PRECALL(arg=2, lineno=308)
          34	CALL(arg=2, lineno=308)
          44	RETURN_VALUE(arg=None, lineno=308)
pending: deque([State(pc_initial=0 nstack_initial=0)])
stack: []
state.pc_initial: State(pc_initial=0 nstack_initial=0)
dispatch pc=0, inst=NOP(arg=None, lineno=307)
stack []
dispatch pc=2, inst=RESUME(arg=0, lineno=307)
stack []
dispatch pc=4, inst=LOAD_GLOBAL(arg=1, lineno=308)
stack []
dispatch pc=16, inst=LOAD_ATTR(arg=1, lineno=308)
stack ['$null$4.1', '$4load_global.0']
dispatch pc=26, inst=LOAD_FAST(arg=0, lineno=308)
stack ['$null$4.1', '$16load_attr.2']
dispatch pc=28, inst=LOAD_FAST(arg=1, lineno=308)
stack ['$null$4.1', '$16load_attr.2', '$mi26.3']
dispatch pc=30, inst=PRECALL(arg=2, lineno=308)
stack ['$null$4.1', '$16load_attr.2', '$mi26.3', '$typ28.4']
dispatch pc=34, inst=CALL(arg=2, lineno=308)
stack ['$null$4.1', '$16load_attr.2', '$mi26.3', '$typ28.4']
dispatch pc=44, inst=RETURN_VALUE(arg=None, lineno=308)
stack ['$34call.5']
end state. edges=[]
-------------------------Prune PHIs-------------------------
Used_phis: defaultdict(<class 'set'>, {State(pc_initial=0 nstack_initial=0): set()})
defmap: {}
phismap: defaultdict(<class 'set'>, {})
changing phismap: defaultdict(<class 'set'>, {})
keep phismap: {}
new_out: defaultdict(<class 'dict'>, {})
----------------------DONE Prune PHIs-----------------------
block_infos State(pc_initial=0 nstack_initial=0):
AdaptBlockInfo(insts=((0, {}), (2, {}), (4, {'idx': 0, 'res': '$4load_global.0'}), (6, {}), (8, {}), (10, {}), (12, {}), (14, {}), (16, {'item': '$4load_global.0', 'res': '$16load_attr.2'}), (18, {}), (20, {}), (22, {}), (24, {}), (26, {'res': '$mi26.3'}), (28, {'res': '$typ28.4'}), (30, {}), (32, {}), (34, {'func': '$16load_attr.2', 'args': ['$mi26.3', '$typ28.4'], 'kw_names': None, 'res': '$34call.5'}), (36, {}), (38, {}), (40, {}), (42, {}), (44, {'retval': '$34call.5', 'castval': '$44return_value.6'})), outgoing_phis={}, blockstack=(), active_try_block=None, outgoing_edgepushed={})
label 0:
    mi = arg(0, name=mi)                     ['mi']
    typ = arg(1, name=typ)                   ['typ']
    $4load_global.0 = global(dictobject: <module 'numba.typed.dictobject' from '/home/earnest/.local/share/mamba/envs/basicrl/lib/python3.11/site-packages/numba/typed/dictobject.py'>) ['$4load_global.0']
    $16load_attr.2 = getattr(value=$4load_global.0, attr=_from_meminfo) ['$16load_attr.2', '$4load_global.0']
    $34call.5 = call $16load_attr.2(mi, typ, func=$16load_attr.2, args=[Var(mi, typeddict.py:307), Var(typ, typeddict.py:307)], kws=(), vararg=None, varkwarg=None, target=None) ['$16load_attr.2', '$34call.5', 'mi', 'typ']
    $44return_value.6 = cast(value=$34call.5) ['$34call.5', '$44return_value.6']
    return $44return_value.6                 ['$44return_value.6']

==== SSA block analysis pass on 0
Running <numba.core.ssa._GatherDefsHandler object at 0x7f61a55d2490>
on stmt: mi = arg(0, name=mi)
on stmt: typ = arg(1, name=typ)
on stmt: $4load_global.0 = global(dictobject: <module 'numba.typed.dictobject' from '/home/earnest/.local/share/mamba/envs/basicrl/lib/python3.11/site-packages/numba/typed/dictobject.py'>)
on stmt: $16load_attr.2 = getattr(value=$4load_global.0, attr=_from_meminfo)
on stmt: $34call.5 = call $16load_attr.2(mi, typ, func=$16load_attr.2, args=[Var(mi, typeddict.py:307), Var(typ, typeddict.py:307)], kws=(), vararg=None, varkwarg=None, target=None)
on stmt: $44return_value.6 = cast(value=$34call.5)
on stmt: return $44return_value.6
defs defaultdict(<class 'list'>,
            {'$16load_attr.2': [(<numba.core.ir.Assign object at 0x7f61a5d9abd0>,
                                 0)],
             '$34call.5': [(<numba.core.ir.Assign object at 0x7f61a5da9450>,
                            0)],
             '$44return_value.6': [(<numba.core.ir.Assign object at 0x7f61a5daa750>,
                                    0)],
             '$4load_global.0': [(<numba.core.ir.Assign object at 0x7f61a49c3650>,
                                  0)],
             'mi': [(<numba.core.ir.Assign object at 0x7f61a49c1510>, 0)],
             'typ': [(<numba.core.ir.Assign object at 0x7f61a49c2490>, 0)]})
SSA violators <numba.core.utils.OrderedSet object at 0x7f61a55d2490>
[2m2025-05-14T23:07:36.210705[0m [[32m[1minfo     [0m] [1mTilesetManager cache updated  [0m [[0m[1m[34mengine.window_manager_modules.tileset_manager[0m][0m [36mnumba_count[0m=[35m195[0m [36mpil_count[0m=[35m195[0m
[2m2025-05-14T23:07:36.210778[0m [[32m[1minfo     [0m] [1mTileset loaded successfully   [0m [[0m[1m[34mengine.window_manager_modules.tileset_manager[0m][0m [36mcount[0m=[35m195[0m [36mfinal_h[0m=[35m16[0m [36mfinal_w[0m=[35m16[0m [36mpath[0m=[35m/home/earnest/code_projects/basicrl/fonts/classic_roguelike_sliced_svgs[0m
[2m2025-05-14T23:07:36.210820[0m [[32m[1mdebug    [0m] [1mTilesetManager initialized.   [0m [[0m[1m[34mengine.window_manager_modules.tileset_manager[0m][0m
[2m2025-05-14T23:07:36.212314[0m [[32m[1mdebug    [0m] [1mBuilding menus...             [0m [[0m[1m[34mengine.window_manager[0m][0m
[2m2025-05-14T23:07:36.213638[0m [[32m[1mdebug    [0m] [1mMenus built                   [0m [[0m[1m[34mengine.window_manager[0m][0m
[2m2025-05-14T23:07:36.217362[0m [[32m[1minfo     [0m] [1mActive keybinding sets        [0m [[0m[1m[34mengine.window_manager[0m][0m [36msets[0m=[35m['common', 'modern', 'numpad', 'arrows'][0m
[2m2025-05-14T23:07:36.217430[0m [[32m[1mdebug    [0m] [1mInputHandler initialized.     [0m [[0m[1m[34mengine.window_manager_modules.input_handler[0m][0m
[2m2025-05-14T23:07:36.217474[0m [[32m[1mdebug    [0m] [1mUIOverlayManager initialized. [0m [[0m[1m[34mengine.window_manager_modules.ui_overlay_manager[0m][0m
[2m2025-05-14T23:07:36.217501[0m [[32m[1mdebug    [0m] [1mWindowManager __init__ complete[0m [[0m[1m[34mengine.window_manager[0m][0m
[2m2025-05-14T23:07:36.217529[0m [[32m[1minfo     [0m] [1mInitializing main loop...     [0m [[0m[1m[34m__main__[0m][0m
[2m2025-05-14T23:07:36.217587[0m [[32m[1minfo     [0m] [1mMainLoop initialized successfully[0m [[0m[1m[34mengine.main_loop[0m][0m
[2m2025-05-14T23:07:36.217619[0m [[32m[1minfo     [0m] [1mMainLoop instance set in WindowManager[0m [[0m[1m[34mengine.window_manager[0m][0m
[2m2025-05-14T23:07:36.217648[0m [[32m[1minfo     [0m] [1mShowing window and starting application loop...[0m [[0m[1m[34m__main__[0m][0m
[2m2025-05-14T23:07:36.218444[0m [[32m[1mdebug    [0m] [1mResize event detected         [0m [[0m[1m[34mengine.window_manager[0m][0m [36mnew_size[0m=[35mPySide6.QtCore.QSize(1024, 768)[0m
[2m2025-05-14T23:07:36.229923[0m [[32m[1minfo     [0m] [1mUpdating render coordinate cache...[0m [[0m[1m[34mengine.window_manager[0m][0m [36mtile_h[0m=[35m16[0m [36mtile_w[0m=[35m16[0m [36mvp_pixel_h[0m=[35m736[0m [36mvp_pixel_w[0m=[35m1008[0m
[2m2025-05-14T23:07:36.233257[0m [[32m[1mdebug    [0m] [1mRender coordinate cache updated[0m [[0m[1m[34mengine.window_manager[0m][0m [36mcoord_x_shape[0m=[35m(736, 1008)[0m [36mcoord_y_shape[0m=[35m(736, 1008)[0m [36mduration_ms[0m=[35m3.268233995186165[0m [36mtile_h[0m=[35m16[0m [36mtile_w[0m=[35m16[0m [36mvp_pixel_h[0m=[35m736[0m [36mvp_pixel_w[0m=[35m1008[0m
bytecode dump:
>          0	NOP(arg=None, lineno=27)
           2	RESUME(arg=0, lineno=27)
           4	LOAD_GLOBAL(arg=1, lineno=29)
          16	LOAD_FAST(arg=0, lineno=29)
          18	PRECALL(arg=1, lineno=29)
          22	CALL(arg=1, lineno=29)
          32	RETURN_VALUE(arg=None, lineno=29)
pending: deque([State(pc_initial=0 nstack_initial=0)])
stack: []
state.pc_initial: State(pc_initial=0 nstack_initial=0)
dispatch pc=0, inst=NOP(arg=None, lineno=27)
stack []
dispatch pc=2, inst=RESUME(arg=0, lineno=27)
stack []
dispatch pc=4, inst=LOAD_GLOBAL(arg=1, lineno=29)
stack []
dispatch pc=16, inst=LOAD_FAST(arg=0, lineno=29)
stack ['$null$4.1', '$4load_global.0']
dispatch pc=18, inst=PRECALL(arg=1, lineno=29)
stack ['$null$4.1', '$4load_global.0', '$d16.2']
dispatch pc=22, inst=CALL(arg=1, lineno=29)
stack ['$null$4.1', '$4load_global.0', '$d16.2']
dispatch pc=32, inst=RETURN_VALUE(arg=None, lineno=29)
stack ['$22call.3']
end state. edges=[]
-------------------------Prune PHIs-------------------------
Used_phis: defaultdict(<class 'set'>, {State(pc_initial=0 nstack_initial=0): set()})
defmap: {}
phismap: defaultdict(<class 'set'>, {})
changing phismap: defaultdict(<class 'set'>, {})
keep phismap: {}
new_out: defaultdict(<class 'dict'>, {})
----------------------DONE Prune PHIs-----------------------
block_infos State(pc_initial=0 nstack_initial=0):
AdaptBlockInfo(insts=((0, {}), (2, {}), (4, {'idx': 0, 'res': '$4load_global.0'}), (6, {}), (8, {}), (10, {}), (12, {}), (14, {}), (16, {'res': '$d16.2'}), (18, {}), (20, {}), (22, {'func': '$4load_global.0', 'args': ['$d16.2'], 'kw_names': None, 'res': '$22call.3'}), (24, {}), (26, {}), (28, {}), (30, {}), (32, {'retval': '$22call.3', 'castval': '$32return_value.4'})), outgoing_phis={}, blockstack=(), active_try_block=None, outgoing_edgepushed={})
label 0:
    d = arg(0, name=d)                       ['d']
    $4load_global.0 = global(len: <built-in function len>) ['$4load_global.0']
    $22call.3 = call $4load_global.0(d, func=$4load_global.0, args=[Var(d, typeddict.py:27)], kws=(), vararg=None, varkwarg=None, target=None) ['$22call.3', '$4load_global.0', 'd']
    $32return_value.4 = cast(value=$22call.3) ['$22call.3', '$32return_value.4']
    return $32return_value.4                 ['$32return_value.4']

==== SSA block analysis pass on 0
Running <numba.core.ssa._GatherDefsHandler object at 0x7f61a416e690>
on stmt: d = arg(0, name=d)
on stmt: $4load_global.0 = global(len: <built-in function len>)
on stmt: $22call.3 = call $4load_global.0(d, func=$4load_global.0, args=[Var(d, typeddict.py:27)], kws=(), vararg=None, varkwarg=None, target=None)
on stmt: $32return_value.4 = cast(value=$22call.3)
on stmt: return $32return_value.4
defs defaultdict(<class 'list'>,
            {'$22call.3': [(<numba.core.ir.Assign object at 0x7f61a416f450>,
                            0)],
             '$32return_value.4': [(<numba.core.ir.Assign object at 0x7f61a416f050>,
                                    0)],
             '$4load_global.0': [(<numba.core.ir.Assign object at 0x7f61a416fb10>,
                                  0)],
             'd': [(<numba.core.ir.Assign object at 0x7f61a416fe10>, 0)]})
SSA violators <numba.core.utils.OrderedSet object at 0x7f61a416e690>
bytecode dump:
>          0	NOP(arg=None, lineno=686)
           2	RESUME(arg=0, lineno=686)
           4	LOAD_GLOBAL(arg=1, lineno=687)
          16	LOAD_FAST(arg=0, lineno=687)
          18	PRECALL(arg=1, lineno=687)
          22	CALL(arg=1, lineno=687)
          32	RETURN_VALUE(arg=None, lineno=687)
pending: deque([State(pc_initial=0 nstack_initial=0)])
stack: []
state.pc_initial: State(pc_initial=0 nstack_initial=0)
dispatch pc=0, inst=NOP(arg=None, lineno=686)
stack []
dispatch pc=2, inst=RESUME(arg=0, lineno=686)
stack []
dispatch pc=4, inst=LOAD_GLOBAL(arg=1, lineno=687)
stack []
dispatch pc=16, inst=LOAD_FAST(arg=0, lineno=687)
stack ['$null$4.1', '$4load_global.0']
dispatch pc=18, inst=PRECALL(arg=1, lineno=687)
stack ['$null$4.1', '$4load_global.0', '$d16.2']
dispatch pc=22, inst=CALL(arg=1, lineno=687)
stack ['$null$4.1', '$4load_global.0', '$d16.2']
dispatch pc=32, inst=RETURN_VALUE(arg=None, lineno=687)
stack ['$22call.3']
end state. edges=[]
-------------------------Prune PHIs-------------------------
Used_phis: defaultdict(<class 'set'>, {State(pc_initial=0 nstack_initial=0): set()})
defmap: {}
phismap: defaultdict(<class 'set'>, {})
changing phismap: defaultdict(<class 'set'>, {})
keep phismap: {}
new_out: defaultdict(<class 'dict'>, {})
----------------------DONE Prune PHIs-----------------------
block_infos State(pc_initial=0 nstack_initial=0):
AdaptBlockInfo(insts=((0, {}), (2, {}), (4, {'idx': 0, 'res': '$4load_global.0'}), (6, {}), (8, {}), (10, {}), (12, {}), (14, {}), (16, {'res': '$d16.2'}), (18, {}), (20, {}), (22, {'func': '$4load_global.0', 'args': ['$d16.2'], 'kw_names': None, 'res': '$22call.3'}), (24, {}), (26, {}), (28, {}), (30, {}), (32, {'retval': '$22call.3', 'castval': '$32return_value.4'})), outgoing_phis={}, blockstack=(), active_try_block=None, outgoing_edgepushed={})
label 0:
    d = arg(0, name=d)                       ['d']
    $4load_global.0 = global(_dict_length: <intrinsic _dict_length>) ['$4load_global.0']
    $22call.3 = call $4load_global.0(d, func=$4load_global.0, args=[Var(d, dictobject.py:686)], kws=(), vararg=None, varkwarg=None, target=None) ['$22call.3', '$4load_global.0', 'd']
    $32return_value.4 = cast(value=$22call.3) ['$22call.3', '$32return_value.4']
    return $32return_value.4                 ['$32return_value.4']

==== SSA block analysis pass on 0
Running <numba.core.ssa._GatherDefsHandler object at 0x7f61a49b9e50>
on stmt: d = arg(0, name=d)
on stmt: $4load_global.0 = global(_dict_length: <intrinsic _dict_length>)
on stmt: $22call.3 = call $4load_global.0(d, func=$4load_global.0, args=[Var(d, dictobject.py:686)], kws=(), vararg=None, varkwarg=None, target=None)
on stmt: $32return_value.4 = cast(value=$22call.3)
on stmt: return $32return_value.4
defs defaultdict(<class 'list'>,
            {'$22call.3': [(<numba.core.ir.Assign object at 0x7f61a49c3750>,
                            0)],
             '$32return_value.4': [(<numba.core.ir.Assign object at 0x7f61a49c2ad0>,
                                    0)],
             '$4load_global.0': [(<numba.core.ir.Assign object at 0x7f61a49c2950>,
                                  0)],
             'd': [(<numba.core.ir.Assign object at 0x7f61a49c1fd0>, 0)]})
SSA violators <numba.core.utils.OrderedSet object at 0x7f61a49b9e50>
[2m2025-05-14T23:07:36.265287[0m [[32m[1mdebug    [0m] [1mTilesetManager.get_render_data called.[0m [[0m[1m[34mengine.window_manager_modules.tileset_manager[0m][0m [36mbg_colors_valid[0m=[35mTrue[0m [36mcache_ready[0m=[35mTrue[0m [36mfg_colors_valid[0m=[35mTrue[0m [36mindices_valid[0m=[35mTrue[0m [36mmax_id[0m=[35m1[0m [36mtile_arrays_items[0m=[35m195[0m
[2m2025-05-14T23:07:36.265392[0m [[32m[1mdebug    [0m] [1mrender_viewport called        [0m [[0m[1m[34mengine.renderer[0m][0m [36mbg_colors_shape[0m=[35m(2, 3)[0m [36mcoord_keys[0m=[35m['tile_coord_y', 'tile_coord_x'][0m [36mfg_colors_shape[0m=[35m(2, 3)[0m [36mindices_shape[0m=[35m(2,)[0m [36mmax_tile_id[0m=[35m1[0m [36mtile_arrays_len[0m=[35m195[0m [36mtile_arrays_type[0m=[35m<class 'numba.typed.typeddict.Dict'>[0m [36mtile_dims[0m=[35m16x16[0m [36mvp_h[0m=[35m46[0m [36mvp_w[0m=[35m63[0m [36mvp_x[0m=[35m0[0m [36mvp_y[0m=[35m0[0m
bytecode dump:
>          0	NOP(arg=None, lineno=52)
           2	RESUME(arg=0, lineno=52)
           4	LOAD_FAST(arg=0, lineno=54)
           6	LOAD_METHOD(arg=0, lineno=54)
          28	LOAD_FAST(arg=1, lineno=54)
          30	LOAD_FAST(arg=2, lineno=54)
          32	PRECALL(arg=2, lineno=54)
          36	CALL(arg=2, lineno=54)
          46	RETURN_VALUE(arg=None, lineno=54)
pending: deque([State(pc_initial=0 nstack_initial=0)])
stack: []
state.pc_initial: State(pc_initial=0 nstack_initial=0)
dispatch pc=0, inst=NOP(arg=None, lineno=52)
stack []
dispatch pc=2, inst=RESUME(arg=0, lineno=52)
stack []
dispatch pc=4, inst=LOAD_FAST(arg=0, lineno=54)
stack []
dispatch pc=6, inst=LOAD_METHOD(arg=0, lineno=54)
stack ['$d4.0']
dispatch pc=28, inst=LOAD_FAST(arg=1, lineno=54)
stack ['$null$6.1', '$6load_method.2']
dispatch pc=30, inst=LOAD_FAST(arg=2, lineno=54)
stack ['$null$6.1', '$6load_method.2', '$key28.3']
dispatch pc=32, inst=PRECALL(arg=2, lineno=54)
stack ['$null$6.1', '$6load_method.2', '$key28.3', '$default30.4']
dispatch pc=36, inst=CALL(arg=2, lineno=54)
stack ['$null$6.1', '$6load_method.2', '$key28.3', '$default30.4']
dispatch pc=46, inst=RETURN_VALUE(arg=None, lineno=54)
stack ['$36call.5']
end state. edges=[]
-------------------------Prune PHIs-------------------------
Used_phis: defaultdict(<class 'set'>, {State(pc_initial=0 nstack_initial=0): set()})
defmap: {}
phismap: defaultdict(<class 'set'>, {})
changing phismap: defaultdict(<class 'set'>, {})
keep phismap: {}
new_out: defaultdict(<class 'dict'>, {})
----------------------DONE Prune PHIs-----------------------
block_infos State(pc_initial=0 nstack_initial=0):
AdaptBlockInfo(insts=((0, {}), (2, {}), (4, {'res': '$d4.0'}), (6, {'item': '$d4.0', 'res': '$6load_method.2'}), (8, {}), (10, {}), (12, {}), (14, {}), (16, {}), (18, {}), (20, {}), (22, {}), (24, {}), (26, {}), (28, {'res': '$key28.3'}), (30, {'res': '$default30.4'}), (32, {}), (34, {}), (36, {'func': '$6load_method.2', 'args': ['$key28.3', '$default30.4'], 'kw_names': None, 'res': '$36call.5'}), (38, {}), (40, {}), (42, {}), (44, {}), (46, {'retval': '$36call.5', 'castval': '$46return_value.6'})), outgoing_phis={}, blockstack=(), active_try_block=None, outgoing_edgepushed={})
label 0:
    d = arg(0, name=d)                       ['d']
    key = arg(1, name=key)                   ['key']
    default = arg(2, name=default)           ['default']
    $6load_method.2 = getattr(value=d, attr=get) ['$6load_method.2', 'd']
    $36call.5 = call $6load_method.2(key, default, func=$6load_method.2, args=[Var(key, typeddict.py:52), Var(default, typeddict.py:52)], kws=(), vararg=None, varkwarg=None, target=None) ['$36call.5', '$6load_method.2', 'default', 'key']
    $46return_value.6 = cast(value=$36call.5) ['$36call.5', '$46return_value.6']
    return $46return_value.6                 ['$46return_value.6']

==== SSA block analysis pass on 0
Running <numba.core.ssa._GatherDefsHandler object at 0x7f6187118410>
on stmt: d = arg(0, name=d)
on stmt: key = arg(1, name=key)
on stmt: default = arg(2, name=default)
on stmt: $6load_method.2 = getattr(value=d, attr=get)
on stmt: $36call.5 = call $6load_method.2(key, default, func=$6load_method.2, args=[Var(key, typeddict.py:52), Var(default, typeddict.py:52)], kws=(), vararg=None, varkwarg=None, target=None)
on stmt: $46return_value.6 = cast(value=$36call.5)
on stmt: return $46return_value.6
defs defaultdict(<class 'list'>,
            {'$36call.5': [(<numba.core.ir.Assign object at 0x7f61871077d0>,
                            0)],
             '$46return_value.6': [(<numba.core.ir.Assign object at 0x7f6187107a10>,
                                    0)],
             '$6load_method.2': [(<numba.core.ir.Assign object at 0x7f6187107210>,
                                  0)],
             'd': [(<numba.core.ir.Assign object at 0x7f6187106bd0>, 0)],
             'default': [(<numba.core.ir.Assign object at 0x7f6187106dd0>, 0)],
             'key': [(<numba.core.ir.Assign object at 0x7f6187106cd0>, 0)]})
SSA violators <numba.core.utils.OrderedSet object at 0x7f61a41f7350>
bytecode dump:
>          0	NOP(arg=None, lineno=750)
           2	COPY_FREE_VARS(arg=1, lineno=750)
           4	RESUME(arg=0, lineno=750)
           6	LOAD_GLOBAL(arg=1, lineno=751)
          18	LOAD_FAST(arg=1, lineno=751)
          20	LOAD_DEREF(arg=6, lineno=751)
          22	PRECALL(arg=2, lineno=751)
          26	CALL(arg=2, lineno=751)
          36	STORE_FAST(arg=3, lineno=751)
          38	LOAD_GLOBAL(arg=3, lineno=752)
          50	LOAD_FAST(arg=0, lineno=752)
          52	LOAD_FAST(arg=3, lineno=752)
          54	LOAD_GLOBAL(arg=5, lineno=752)
          66	LOAD_FAST(arg=3, lineno=752)
          68	PRECALL(arg=1, lineno=752)
          72	CALL(arg=1, lineno=752)
          82	PRECALL(arg=3, lineno=752)
          86	CALL(arg=3, lineno=752)
          96	UNPACK_SEQUENCE(arg=2, lineno=752)
         100	STORE_FAST(arg=4, lineno=752)
         102	STORE_FAST(arg=5, lineno=752)
         104	LOAD_FAST(arg=4, lineno=753)
         106	LOAD_GLOBAL(arg=6, lineno=753)
         118	LOAD_ATTR(arg=4, lineno=753)
         128	COMPARE_OP(arg=4, lineno=753)
         134	POP_JUMP_FORWARD_IF_FALSE(arg=2, lineno=753)
         136	LOAD_FAST(arg=5, lineno=754)
         138	RETURN_VALUE(arg=None, lineno=754)
>        140	LOAD_FAST(arg=2, lineno=755)
         142	RETURN_VALUE(arg=None, lineno=755)
pending: deque([State(pc_initial=0 nstack_initial=0)])
stack: []
state.pc_initial: State(pc_initial=0 nstack_initial=0)
dispatch pc=0, inst=NOP(arg=None, lineno=750)
stack []
dispatch pc=2, inst=COPY_FREE_VARS(arg=1, lineno=750)
stack []
dispatch pc=4, inst=RESUME(arg=0, lineno=750)
stack []
dispatch pc=6, inst=LOAD_GLOBAL(arg=1, lineno=751)
stack []
dispatch pc=18, inst=LOAD_FAST(arg=1, lineno=751)
stack ['$null$6.1', '$6load_global.0']
dispatch pc=20, inst=LOAD_DEREF(arg=6, lineno=751)
stack ['$null$6.1', '$6load_global.0', '$key18.2']
dispatch pc=22, inst=PRECALL(arg=2, lineno=751)
stack ['$null$6.1', '$6load_global.0', '$key18.2', '$20load_deref.3']
dispatch pc=26, inst=CALL(arg=2, lineno=751)
stack ['$null$6.1', '$6load_global.0', '$key18.2', '$20load_deref.3']
dispatch pc=36, inst=STORE_FAST(arg=3, lineno=751)
stack ['$26call.4']
dispatch pc=38, inst=LOAD_GLOBAL(arg=3, lineno=752)
stack []
dispatch pc=50, inst=LOAD_FAST(arg=0, lineno=752)
stack ['$null$38.6', '$38load_global.5']
dispatch pc=52, inst=LOAD_FAST(arg=3, lineno=752)
stack ['$null$38.6', '$38load_global.5', '$dct50.7']
dispatch pc=54, inst=LOAD_GLOBAL(arg=5, lineno=752)
stack ['$null$38.6', '$38load_global.5', '$dct50.7', '$castedkey52.8']
dispatch pc=66, inst=LOAD_FAST(arg=3, lineno=752)
stack ['$null$38.6', '$38load_global.5', '$dct50.7', '$castedkey52.8', '$null$54.10', '$54load_global.9']
dispatch pc=68, inst=PRECALL(arg=1, lineno=752)
stack ['$null$38.6', '$38load_global.5', '$dct50.7', '$castedkey52.8', '$null$54.10', '$54load_global.9', '$castedkey66.11']
dispatch pc=72, inst=CALL(arg=1, lineno=752)
stack ['$null$38.6', '$38load_global.5', '$dct50.7', '$castedkey52.8', '$null$54.10', '$54load_global.9', '$castedkey66.11']
dispatch pc=82, inst=PRECALL(arg=3, lineno=752)
stack ['$null$38.6', '$38load_global.5', '$dct50.7', '$castedkey52.8', '$72call.12']
dispatch pc=86, inst=CALL(arg=3, lineno=752)
stack ['$null$38.6', '$38load_global.5', '$dct50.7', '$castedkey52.8', '$72call.12']
dispatch pc=96, inst=UNPACK_SEQUENCE(arg=2, lineno=752)
stack ['$86call.13']
dispatch pc=100, inst=STORE_FAST(arg=4, lineno=752)
stack ['$96unpack_sequence.15', '$96unpack_sequence.14']
dispatch pc=102, inst=STORE_FAST(arg=5, lineno=752)
stack ['$96unpack_sequence.15']
dispatch pc=104, inst=LOAD_FAST(arg=4, lineno=753)
stack []
dispatch pc=106, inst=LOAD_GLOBAL(arg=6, lineno=753)
stack ['$ix104.17']
dispatch pc=118, inst=LOAD_ATTR(arg=4, lineno=753)
stack ['$ix104.17', '$106load_global.18']
dispatch pc=128, inst=COMPARE_OP(arg=4, lineno=753)
stack ['$ix104.17', '$118load_attr.19']
dispatch pc=134, inst=POP_JUMP_FORWARD_IF_FALSE(arg=2, lineno=753)
stack ['$128compare_op.20']
end state. edges=[Edge(pc=136, stack=(), blockstack=(), npush=0), Edge(pc=140, stack=(), blockstack=(), npush=0)]
pending: deque([State(pc_initial=136 nstack_initial=0), State(pc_initial=140 nstack_initial=0)])
stack: []
state.pc_initial: State(pc_initial=136 nstack_initial=0)
dispatch pc=136, inst=LOAD_FAST(arg=5, lineno=754)
stack []
dispatch pc=138, inst=RETURN_VALUE(arg=None, lineno=754)
stack ['$val136.0']
end state. edges=[]
pending: deque([State(pc_initial=140 nstack_initial=0)])
stack: []
state.pc_initial: State(pc_initial=140 nstack_initial=0)
dispatch pc=140, inst=LOAD_FAST(arg=2, lineno=755)
stack []
dispatch pc=142, inst=RETURN_VALUE(arg=None, lineno=755)
stack ['$default140.0']
end state. edges=[]
-------------------------Prune PHIs-------------------------
Used_phis: defaultdict(<class 'set'>,
            {State(pc_initial=0 nstack_initial=0): set(),
             State(pc_initial=136 nstack_initial=0): set(),
             State(pc_initial=140 nstack_initial=0): set()})
defmap: {}
phismap: defaultdict(<class 'set'>, {})
changing phismap: defaultdict(<class 'set'>, {})
keep phismap: {}
new_out: defaultdict(<class 'dict'>, {})
----------------------DONE Prune PHIs-----------------------
block_infos State(pc_initial=0 nstack_initial=0):
AdaptBlockInfo(insts=((0, {}), (2, {}), (4, {}), (6, {'idx': 0, 'res': '$6load_global.0'}), (8, {}), (10, {}), (12, {}), (14, {}), (16, {}), (18, {'res': '$key18.2'}), (20, {'res': '$20load_deref.3'}), (22, {}), (24, {}), (26, {'func': '$6load_global.0', 'args': ['$key18.2', '$20load_deref.3'], 'kw_names': None, 'res': '$26call.4'}), (28, {}), (30, {}), (32, {}), (34, {}), (36, {'value': '$26call.4'}), (38, {'idx': 1, 'res': '$38load_global.5'}), (40, {}), (42, {}), (44, {}), (46, {}), (48, {}), (50, {'res': '$dct50.7'}), (52, {'res': '$castedkey52.8'}), (54, {'idx': 2, 'res': '$54load_global.9'}), (56, {}), (58, {}), (60, {}), (62, {}), (64, {}), (66, {'res': '$castedkey66.11'}), (68, {}), (70, {}), (72, {'func': '$54load_global.9', 'args': ['$castedkey66.11'], 'kw_names': None, 'res': '$72call.12'}), (74, {}), (76, {}), (78, {}), (80, {}), (82, {}), (84, {}), (86, {'func': '$38load_global.5', 'args': ['$dct50.7', '$castedkey52.8', '$72call.12'], 'kw_names': None, 'res': '$86call.13'}), (88, {}), (90, {}), (92, {}), (94, {}), (96, {'iterable': '$86call.13', 'stores': ['$96unpack_sequence.14', '$96unpack_sequence.15'], 'tupleobj': '$96unpack_sequence.16'}), (98, {}), (100, {'value': '$96unpack_sequence.14'}), (102, {'value': '$96unpack_sequence.15'}), (104, {'res': '$ix104.17'}), (106, {'idx': 3, 'res': '$106load_global.18'}), (108, {}), (110, {}), (112, {}), (114, {}), (116, {}), (118, {'item': '$106load_global.18', 'res': '$118load_attr.19'}), (120, {}), (122, {}), (124, {}), (126, {}), (128, {'lhs': '$ix104.17', 'rhs': '$118load_attr.19', 'res': '$128compare_op.20'}), (130, {}), (132, {}), (134, {'pred': '$128compare_op.20'})), outgoing_phis={}, blockstack=(), active_try_block=None, outgoing_edgepushed={136: (), 140: ()})
block_infos State(pc_initial=136 nstack_initial=0):
AdaptBlockInfo(insts=((136, {'res': '$val136.0'}), (138, {'retval': '$val136.0', 'castval': '$138return_value.1'})), outgoing_phis={}, blockstack=(), active_try_block=None, outgoing_edgepushed={})
block_infos State(pc_initial=140 nstack_initial=0):
AdaptBlockInfo(insts=((140, {'res': '$default140.0'}), (142, {'retval': '$default140.0', 'castval': '$142return_value.1'})), outgoing_phis={}, blockstack=(), active_try_block=None, outgoing_edgepushed={})
label 0:
    dct = arg(0, name=dct)                   ['dct']
    key = arg(1, name=key)                   ['key']
    default = arg(2, name=default)           ['default']
    $6load_global.0 = global(_cast: <intrinsic _cast>) ['$6load_global.0']
    $20load_deref.3 = freevar(keyty: int64)  ['$20load_deref.3']
    castedkey = call $6load_global.0(key, $20load_deref.3, func=$6load_global.0, args=[Var(key, dictobject.py:750), Var($20load_deref.3, dictobject.py:751)], kws=(), vararg=None, varkwarg=None, target=None) ['$20load_deref.3', '$6load_global.0', 'castedkey', 'key']
    $38load_global.5 = global(_dict_lookup: <intrinsic _dict_lookup>) ['$38load_global.5']
    $54load_global.9 = global(hash: <built-in function hash>) ['$54load_global.9']
    $72call.12 = call $54load_global.9(castedkey, func=$54load_global.9, args=[Var(castedkey, dictobject.py:751)], kws=(), vararg=None, varkwarg=None, target=None) ['$54load_global.9', '$72call.12', 'castedkey']
    $86call.13 = call $38load_global.5(dct, castedkey, $72call.12, func=$38load_global.5, args=[Var(dct, dictobject.py:750), Var(castedkey, dictobject.py:751), Var($72call.12, dictobject.py:752)], kws=(), vararg=None, varkwarg=None, target=None) ['$38load_global.5', '$72call.12', '$86call.13', 'castedkey', 'dct']
    $96unpack_sequence.16 = exhaust_iter(value=$86call.13, count=2) ['$86call.13', '$96unpack_sequence.16']
    $96unpack_sequence.14 = static_getitem(value=$96unpack_sequence.16, index=0, index_var=None, fn=<built-in function getitem>) ['$96unpack_sequence.14', '$96unpack_sequence.16']
    $96unpack_sequence.15 = static_getitem(value=$96unpack_sequence.16, index=1, index_var=None, fn=<built-in function getitem>) ['$96unpack_sequence.15', '$96unpack_sequence.16']
    ix = $96unpack_sequence.14               ['$96unpack_sequence.14', 'ix']
    val = $96unpack_sequence.15              ['$96unpack_sequence.15', 'val']
    $106load_global.18 = global(DKIX: <enum 'DKIX'>) ['$106load_global.18']
    $118load_attr.19 = getattr(value=$106load_global.18, attr=EMPTY) ['$106load_global.18', '$118load_attr.19']
    $128compare_op.20 = ix > $118load_attr.19 ['$118load_attr.19', '$128compare_op.20', 'ix']
    bool134 = global(bool: <class 'bool'>)   ['bool134']
    $134pred = call bool134($128compare_op.20, func=bool134, args=(Var($128compare_op.20, dictobject.py:753),), kws=(), vararg=None, varkwarg=None, target=None) ['$128compare_op.20', '$134pred', 'bool134']
    branch $134pred, 136, 140                ['$134pred']
label 136:
    $138return_value.1 = cast(value=val)     ['$138return_value.1', 'val']
    return $138return_value.1                ['$138return_value.1']
label 140:
    $142return_value.1 = cast(value=default) ['$142return_value.1', 'default']
    return $142return_value.1                ['$142return_value.1']

==== SSA block analysis pass on 0
Running <numba.core.ssa._GatherDefsHandler object at 0x7f618711be50>
on stmt: dct = arg(0, name=dct)
on stmt: key = arg(1, name=key)
on stmt: default = arg(2, name=default)
on stmt: $6load_global.0 = global(_cast: <intrinsic _cast>)
on stmt: $20load_deref.3 = freevar(keyty: int64)
on stmt: castedkey = call $6load_global.0(key, $20load_deref.3, func=$6load_global.0, args=[Var(key, dictobject.py:750), Var($20load_deref.3, dictobject.py:751)], kws=(), vararg=None, varkwarg=None, target=None)
on stmt: $38load_global.5 = global(_dict_lookup: <intrinsic _dict_lookup>)
on stmt: $54load_global.9 = global(hash: <built-in function hash>)
on stmt: $72call.12 = call $54load_global.9(castedkey, func=$54load_global.9, args=[Var(castedkey, dictobject.py:751)], kws=(), vararg=None, varkwarg=None, target=None)
on stmt: $86call.13 = call $38load_global.5(dct, castedkey, $72call.12, func=$38load_global.5, args=[Var(dct, dictobject.py:750), Var(castedkey, dictobject.py:751), Var($72call.12, dictobject.py:752)], kws=(), vararg=None, varkwarg=None, target=None)
on stmt: $96unpack_sequence.16 = exhaust_iter(value=$86call.13, count=2)
on stmt: $96unpack_sequence.14 = static_getitem(value=$96unpack_sequence.16, index=0, index_var=None, fn=<built-in function getitem>)
on stmt: $96unpack_sequence.15 = static_getitem(value=$96unpack_sequence.16, index=1, index_var=None, fn=<built-in function getitem>)
on stmt: ix = $96unpack_sequence.14
on stmt: val = $96unpack_sequence.15
on stmt: $106load_global.18 = global(DKIX: <enum 'DKIX'>)
on stmt: $118load_attr.19 = getattr(value=$106load_global.18, attr=EMPTY)
on stmt: $128compare_op.20 = ix > $118load_attr.19
on stmt: bool134 = global(bool: <class 'bool'>)
on stmt: $134pred = call bool134($128compare_op.20, func=bool134, args=(Var($128compare_op.20, dictobject.py:753),), kws=(), vararg=None, varkwarg=None, target=None)
on stmt: branch $134pred, 136, 140
==== SSA block analysis pass on 136
Running <numba.core.ssa._GatherDefsHandler object at 0x7f618711be50>
on stmt: $138return_value.1 = cast(value=val)
on stmt: return $138return_value.1
==== SSA block analysis pass on 140
Running <numba.core.ssa._GatherDefsHandler object at 0x7f618711be50>
on stmt: $142return_value.1 = cast(value=default)
on stmt: return $142return_value.1
defs defaultdict(<class 'list'>,
            {'$106load_global.18': [(<numba.core.ir.Assign object at 0x7f618712b390>,
                                     0)],
             '$118load_attr.19': [(<numba.core.ir.Assign object at 0x7f618712b690>,
                                   0)],
             '$128compare_op.20': [(<numba.core.ir.Assign object at 0x7f618712b9d0>,
                                    0)],
             '$134pred': [(<numba.core.ir.Assign object at 0x7f618712bdd0>, 0)],
             '$138return_value.1': [(<numba.core.ir.Assign object at 0x7f618712c150>,
                                     136)],
             '$142return_value.1': [(<numba.core.ir.Assign object at 0x7f618712c610>,
                                     140)],
             '$20load_deref.3': [(<numba.core.ir.Assign object at 0x7f6187129150>,
                                  0)],
             '$38load_global.5': [(<numba.core.ir.Assign object at 0x7f61871297d0>,
                                   0)],
             '$54load_global.9': [(<numba.core.ir.Assign object at 0x7f6187129e10>,
                                   0)],
             '$6load_global.0': [(<numba.core.ir.Assign object at 0x7f6187128cd0>,
                                  0)],
             '$72call.12': [(<numba.core.ir.Assign object at 0x7f618712a350>,
                             0)],
             '$86call.13': [(<numba.core.ir.Assign object at 0x7f618712a710>,
                             0)],
             '$96unpack_sequence.14': [(<numba.core.ir.Assign object at 0x7f618712ab50>,
                                        0)],
             '$96unpack_sequence.15': [(<numba.core.ir.Assign object at 0x7f618712acd0>,
                                        0)],
             '$96unpack_sequence.16': [(<numba.core.ir.Assign object at 0x7f618712a9d0>,
                                        0)],
             'bool134': [(<numba.core.ir.Assign object at 0x7f618712bc10>, 0)],
             'castedkey': [(<numba.core.ir.Assign object at 0x7f6187129390>,
                            0)],
             'dct': [(<numba.core.ir.Assign object at 0x7f6187128850>, 0)],
             'default': [(<numba.core.ir.Assign object at 0x7f6187128a50>, 0)],
             'ix': [(<numba.core.ir.Assign object at 0x7f618712ae90>, 0)],
             'key': [(<numba.core.ir.Assign object at 0x7f6187128950>, 0)],
             'val': [(<numba.core.ir.Assign object at 0x7f618712b010>, 0)]})
SSA violators <numba.core.utils.OrderedSet object at 0x7f6187106750>
[2m2025-05-14T23:07:36.365487[0m [[32m[1mdebug    [0m] [1mFrame update finished         [0m [[0m[1m[34mengine.window_manager[0m][0m [36mduration_ms[0m=[35m144.59244199679233[0m
[2m2025-05-14T23:07:36.416495[0m [[32m[1mdebug    [0m] [1mTilesetManager.get_render_data called.[0m [[0m[1m[34mengine.window_manager_modules.tileset_manager[0m][0m [36mbg_colors_valid[0m=[35mTrue[0m [36mcache_ready[0m=[35mTrue[0m [36mfg_colors_valid[0m=[35mTrue[0m [36mindices_valid[0m=[35mTrue[0m [36mmax_id[0m=[35m1[0m [36mtile_arrays_items[0m=[35m195[0m
[2m2025-05-14T23:07:36.416631[0m [[32m[1mdebug    [0m] [1mrender_viewport called        [0m [[0m[1m[34mengine.renderer[0m][0m [36mbg_colors_shape[0m=[35m(2, 3)[0m [36mcoord_keys[0m=[35m['tile_coord_y', 'tile_coord_x'][0m [36mfg_colors_shape[0m=[35m(2, 3)[0m [36mindices_shape[0m=[35m(2,)[0m [36mmax_tile_id[0m=[35m1[0m [36mtile_arrays_len[0m=[35m195[0m [36mtile_arrays_type[0m=[35m<class 'numba.typed.typeddict.Dict'>[0m [36mtile_dims[0m=[35m16x16[0m [36mvp_h[0m=[35m46[0m [36mvp_w[0m=[35m63[0m [36mvp_x[0m=[35m0[0m [36mvp_y[0m=[35m0[0m
[2m2025-05-14T23:07:36.436714[0m [[32m[1mdebug    [0m] [1mFrame update finished         [0m [[0m[1m[34mengine.window_manager[0m][0m [36mduration_ms[0m=[35m21.2469199905172[0m
[2m2025-05-14T23:07:36.942314[0m [[32m[1mdebug    [0m] [1mProcessing key event          [0m [[0m[1m[34mengine.window_manager_modules.input_handler[0m][0m [36mkey_enum_val[0m=[35m65[0m [36mkey_text[0m=[35ma[0m [36mmods_val[0m=[35m<KeyboardModifier.NoModifier: 0>[0m [36mui_state[0m=[35mPLAYER_TURN[0m
[2m2025-05-14T23:07:36.942533[0m [[32m[1mdebug    [0m] [1mDispatching action to main loop[0m [[0m[1m[34mengine.window_manager_modules.input_handler[0m][0m [36maction[0m=[35m{'type': 'move', 'dx': -1, 'dy': 0}[0m
[2m2025-05-14T23:07:36.942621[0m [[32m[1mdebug    [0m] [1mActionHandler: Processing action type: move[0m [[0m[1m[34mengine.action_handler[0m][0m [36maction_details[0m=[35m{'type': 'move', 'dx': -1, 'dy': 0}[0m [36mplayer_id[0m=[35m0[0m
[2m2025-05-14T23:07:36.942672[0m [[32m[1mdebug    [0m] [1mAttempting _handle_player_move[0m [[0m[1m[34mengine.action_handler[0m][0m [36mdx[0m=[35m-1[0m [36mdy[0m=[35m0[0m
[2m2025-05-14T23:07:36.944807[0m [[32m[1mdebug    [0m] [1mPlayer moved successfully     [0m [[0m[1m[34mengine.action_handler[0m][0m [36mfrom_pos[0m=[35m(4, 3)[0m [36mplayer_id[0m=[35m0[0m [36mto_pos[0m=[35m(3, 3)[0m
[2m2025-05-14T23:07:36.944860[0m [[32m[1mdebug    [0m] [1mPlayer action resulted in turn[0m [[0m[1m[34mengine.action_handler[0m][0m [36maction_type[0m=[35mmove[0m
[2m2025-05-14T23:07:36.944898[0m [[32m[1mdebug    [0m] [1mPlayer action resulted in turn[0m [[0m[1m[34mengine.main_loop[0m][0m [36maction_type[0m=[35mmove[0m
[2m2025-05-14T23:07:36.944931[0m [[32m[1mdebug    [0m] [1mTurn advanced                 [0m [[0m[1m[34mgame.game_state[0m][0m [36mturn[0m=[35m1[0m
[2m2025-05-14T23:07:36.946278[0m [[32m[1mdebug    [0m] [1mCalling fov.compute_fov       [0m [[0m[1m[34mgame.world.game_map[0m][0m [36mexplored_in_sum[0m=[35mnp.int64(1)[0m [36mopaque_sum[0m=[35mnp.int64(2405)[0m [36morigin[0m=[35m(3, 3)[0m [36morigin_h[0m=[35m0[0m [36mradius[0m=[35m4[0m [36mvisible_in_sum[0m=[35mnp.int64(1)[0m
[2m2025-05-14T23:07:36.946345[0m [[32m[1minfo     [0m] [1mStarting FOV computation      [0m [[0m[1m[34mgame.world.fov[0m][0m [36mgrid_shape[0m=[35m(50, 80)[0m [36morigin[0m=[35m(3, 3)[0m [36mrange_limit[0m=[35m4[0m
[2m2025-05-14T23:07:36.946788[0m [[32m[1minfo     [0m] [1mFOV computation finished      [0m [[0m[1m[34mgame.world.fov[0m][0m [36mduration_ms[0m=[35m0.39[0m [36mgrid_shape[0m=[35m(50, 80)[0m [36morigin[0m=[35m(3, 3)[0m [36mrange_limit[0m=[35m4[0m [36mvisible_count[0m=[35mnp.int64(1)[0m
[2m2025-05-14T23:07:36.946867[0m [[32m[1mdebug    [0m] [1mfov.compute_fov call finished [0m [[0m[1m[34mgame.world.game_map[0m][0m [36mexplored_out_sum[0m=[35mnp.int64(2)[0m [36morigin[0m=[35m(3, 3)[0m [36mradius[0m=[35m4[0m [36mvisible_out_sum[0m=[35mnp.int64(1)[0m
[2m2025-05-14T23:07:36.947678[0m [[32m[1mdebug    [0m] [1mTilesetManager.get_render_data called.[0m [[0m[1m[34mengine.window_manager_modules.tileset_manager[0m][0m [36mbg_colors_valid[0m=[35mTrue[0m [36mcache_ready[0m=[35mTrue[0m [36mfg_colors_valid[0m=[35mTrue[0m [36mindices_valid[0m=[35mTrue[0m [36mmax_id[0m=[35m1[0m [36mtile_arrays_items[0m=[35m195[0m
[2m2025-05-14T23:07:36.947754[0m [[32m[1mdebug    [0m] [1mrender_viewport called        [0m [[0m[1m[34mengine.renderer[0m][0m [36mbg_colors_shape[0m=[35m(2, 3)[0m [36mcoord_keys[0m=[35m['tile_coord_y', 'tile_coord_x'][0m [36mfg_colors_shape[0m=[35m(2, 3)[0m [36mindices_shape[0m=[35m(2,)[0m [36mmax_tile_id[0m=[35m1[0m [36mtile_arrays_len[0m=[35m195[0m [36mtile_arrays_type[0m=[35m<class 'numba.typed.typeddict.Dict'>[0m [36mtile_dims[0m=[35m16x16[0m [36mvp_h[0m=[35m46[0m [36mvp_w[0m=[35m63[0m [36mvp_x[0m=[35m0[0m [36mvp_y[0m=[35m0[0m
[2m2025-05-14T23:07:36.966978[0m [[32m[1mdebug    [0m] [1mFrame update finished         [0m [[0m[1m[34mengine.window_manager[0m][0m [36mduration_ms[0m=[35m20.06001799600199[0m
[2m2025-05-14T23:07:38.612416[0m [[32m[1mdebug    [0m] [1mProcessing key event          [0m [[0m[1m[34mengine.window_manager_modules.input_handler[0m][0m [36mkey_enum_val[0m=[35m71[0m [36mkey_text[0m=[35mg[0m [36mmods_val[0m=[35m<KeyboardModifier.NoModifier: 0>[0m [36mui_state[0m=[35mPLAYER_TURN[0m
[2m2025-05-14T23:07:38.612603[0m [[32m[1mdebug    [0m] [1mDispatching action to main loop[0m [[0m[1m[34mengine.window_manager_modules.input_handler[0m][0m [36maction[0m=[35m{'type': 'pickup'}[0m
[2m2025-05-14T23:07:38.612661[0m [[32m[1mdebug    [0m] [1mActionHandler: Processing action type: pickup[0m [[0m[1m[34mengine.action_handler[0m][0m [36maction_details[0m=[35m{'type': 'pickup'}[0m [36mplayer_id[0m=[35m0[0m
[2m2025-05-14T23:07:38.613798[0m [[32m[1mdebug    [0m] [1mAttempting pickup             [0m [[0m[1m[34mengine.action_handler[0m][0m [36mitem_id[0m=[35m2[0m [36mname[0m=[35mTorch[0m
[2m2025-05-14T23:07:38.614490[0m [[32m[1minfo     [0m] [1mItem moved successfully       [0m [[0m[1m[34mgame.items.registry[0m][0m [36mitem_id[0m=[35m2[0m [36mnew_loc[0m=[35minventory[0m [36mowner[0m=[35m0[0m [36mparent[0m=[35mNone[0m [36mpos[0m=[35m(None, None)[0m [36mslot[0m=[35mNone[0m
[2m2025-05-14T23:07:38.614560[0m [[32m[1mdebug    [0m] [1mMessage added                 [0m [[0m[1m[34mgame.game_state[0m][0m [36mcolor[0m=[35m(200, 200, 200)[0m [36mmessage[0m=[35m'You pick up the Torch.'[0m
[2m2025-05-14T23:07:38.614622[0m [[32m[1mdebug    [0m] [1mPlayer action resulted in turn[0m [[0m[1m[34mengine.action_handler[0m][0m [36maction_type[0m=[35mpickup[0m
[2m2025-05-14T23:07:38.614658[0m [[32m[1mdebug    [0m] [1mPlayer action resulted in turn[0m [[0m[1m[34mengine.main_loop[0m][0m [36maction_type[0m=[35mpickup[0m
[2m2025-05-14T23:07:38.614685[0m [[32m[1mdebug    [0m] [1mTurn advanced                 [0m [[0m[1m[34mgame.game_state[0m][0m [36mturn[0m=[35m2[0m
[2m2025-05-14T23:07:38.616002[0m [[32m[1mdebug    [0m] [1mCalling fov.compute_fov       [0m [[0m[1m[34mgame.world.game_map[0m][0m [36mexplored_in_sum[0m=[35mnp.int64(2)[0m [36mopaque_sum[0m=[35mnp.int64(2405)[0m [36morigin[0m=[35m(3, 3)[0m [36morigin_h[0m=[35m0[0m [36mradius[0m=[35m4[0m [36mvisible_in_sum[0m=[35mnp.int64(1)[0m
[2m2025-05-14T23:07:38.616074[0m [[32m[1minfo     [0m] [1mStarting FOV computation      [0m [[0m[1m[34mgame.world.fov[0m][0m [36mgrid_shape[0m=[35m(50, 80)[0m [36morigin[0m=[35m(3, 3)[0m [36mrange_limit[0m=[35m4[0m
[2m2025-05-14T23:07:38.616477[0m [[32m[1minfo     [0m] [1mFOV computation finished      [0m [[0m[1m[34mgame.world.fov[0m][0m [36mduration_ms[0m=[35m0.35[0m [36mgrid_shape[0m=[35m(50, 80)[0m [36morigin[0m=[35m(3, 3)[0m [36mrange_limit[0m=[35m4[0m [36mvisible_count[0m=[35mnp.int64(1)[0m
[2m2025-05-14T23:07:38.616532[0m [[32m[1mdebug    [0m] [1mfov.compute_fov call finished [0m [[0m[1m[34mgame.world.game_map[0m][0m [36mexplored_out_sum[0m=[35mnp.int64(2)[0m [36morigin[0m=[35m(3, 3)[0m [36mradius[0m=[35m4[0m [36mvisible_out_sum[0m=[35mnp.int64(1)[0m
[2m2025-05-14T23:07:38.617185[0m [[32m[1mdebug    [0m] [1mTilesetManager.get_render_data called.[0m [[0m[1m[34mengine.window_manager_modules.tileset_manager[0m][0m [36mbg_colors_valid[0m=[35mTrue[0m [36mcache_ready[0m=[35mTrue[0m [36mfg_colors_valid[0m=[35mTrue[0m [36mindices_valid[0m=[35mTrue[0m [36mmax_id[0m=[35m1[0m [36mtile_arrays_items[0m=[35m195[0m
[2m2025-05-14T23:07:38.617258[0m [[32m[1mdebug    [0m] [1mrender_viewport called        [0m [[0m[1m[34mengine.renderer[0m][0m [36mbg_colors_shape[0m=[35m(2, 3)[0m [36mcoord_keys[0m=[35m['tile_coord_y', 'tile_coord_x'][0m [36mfg_colors_shape[0m=[35m(2, 3)[0m [36mindices_shape[0m=[35m(2,)[0m [36mmax_tile_id[0m=[35m1[0m [36mtile_arrays_len[0m=[35m195[0m [36mtile_arrays_type[0m=[35m<class 'numba.typed.typeddict.Dict'>[0m [36mtile_dims[0m=[35m16x16[0m [36mvp_h[0m=[35m46[0m [36mvp_w[0m=[35m63[0m [36mvp_x[0m=[35m0[0m [36mvp_y[0m=[35m0[0m
[2m2025-05-14T23:07:38.635533[0m [[32m[1mdebug    [0m] [1mFrame update finished         [0m [[0m[1m[34mengine.window_manager[0m][0m [36mduration_ms[0m=[35m18.942547001643106[0m
[2m2025-05-14T23:07:38.973142[0m [[32m[1mdebug    [0m] [1mProcessing key event          [0m [[0m[1m[34mengine.window_manager_modules.input_handler[0m][0m [36mkey_enum_val[0m=[35m65[0m [36mkey_text[0m=[35ma[0m [36mmods_val[0m=[35m<KeyboardModifier.NoModifier: 0>[0m [36mui_state[0m=[35mPLAYER_TURN[0m
[2m2025-05-14T23:07:38.973295[0m [[32m[1mdebug    [0m] [1mDispatching action to main loop[0m [[0m[1m[34mengine.window_manager_modules.input_handler[0m][0m [36maction[0m=[35m{'type': 'move', 'dx': -1, 'dy': 0}[0m
[2m2025-05-14T23:07:38.973347[0m [[32m[1mdebug    [0m] [1mActionHandler: Processing action type: move[0m [[0m[1m[34mengine.action_handler[0m][0m [36maction_details[0m=[35m{'type': 'move', 'dx': -1, 'dy': 0}[0m [36mplayer_id[0m=[35m0[0m
[2m2025-05-14T23:07:38.973385[0m [[32m[1mdebug    [0m] [1mAttempting _handle_player_move[0m [[0m[1m[34mengine.action_handler[0m][0m [36mdx[0m=[35m-1[0m [36mdy[0m=[35m0[0m
[2m2025-05-14T23:07:38.975477[0m [[32m[1mdebug    [0m] [1mPlayer moved successfully     [0m [[0m[1m[34mengine.action_handler[0m][0m [36mfrom_pos[0m=[35m(3, 3)[0m [36mplayer_id[0m=[35m0[0m [36mto_pos[0m=[35m(2, 3)[0m
[2m2025-05-14T23:07:38.975532[0m [[32m[1mdebug    [0m] [1mPlayer action resulted in turn[0m [[0m[1m[34mengine.action_handler[0m][0m [36maction_type[0m=[35mmove[0m
[2m2025-05-14T23:07:38.975590[0m [[32m[1mdebug    [0m] [1mPlayer action resulted in turn[0m [[0m[1m[34mengine.main_loop[0m][0m [36maction_type[0m=[35mmove[0m
[2m2025-05-14T23:07:38.975643[0m [[32m[1mdebug    [0m] [1mTurn advanced                 [0m [[0m[1m[34mgame.game_state[0m][0m [36mturn[0m=[35m3[0m
[2m2025-05-14T23:07:38.976928[0m [[32m[1mdebug    [0m] [1mCalling fov.compute_fov       [0m [[0m[1m[34mgame.world.game_map[0m][0m [36mexplored_in_sum[0m=[35mnp.int64(2)[0m [36mopaque_sum[0m=[35mnp.int64(2405)[0m [36morigin[0m=[35m(2, 3)[0m [36morigin_h[0m=[35m0[0m [36mradius[0m=[35m4[0m [36mvisible_in_sum[0m=[35mnp.int64(1)[0m
[2m2025-05-14T23:07:38.977001[0m [[32m[1minfo     [0m] [1mStarting FOV computation      [0m [[0m[1m[34mgame.world.fov[0m][0m [36mgrid_shape[0m=[35m(50, 80)[0m [36morigin[0m=[35m(2, 3)[0m [36mrange_limit[0m=[35m4[0m
[2m2025-05-14T23:07:38.977405[0m [[32m[1minfo     [0m] [1mFOV computation finished      [0m [[0m[1m[34mgame.world.fov[0m][0m [36mduration_ms[0m=[35m0.36[0m [36mgrid_shape[0m=[35m(50, 80)[0m [36morigin[0m=[35m(2, 3)[0m [36mrange_limit[0m=[35m4[0m [36mvisible_count[0m=[35mnp.int64(1)[0m
[2m2025-05-14T23:07:38.977459[0m [[32m[1mdebug    [0m] [1mfov.compute_fov call finished [0m [[0m[1m[34mgame.world.game_map[0m][0m [36mexplored_out_sum[0m=[35mnp.int64(3)[0m [36morigin[0m=[35m(2, 3)[0m [36mradius[0m=[35m4[0m [36mvisible_out_sum[0m=[35mnp.int64(1)[0m
[2m2025-05-14T23:07:38.978101[0m [[32m[1mdebug    [0m] [1mTilesetManager.get_render_data called.[0m [[0m[1m[34mengine.window_manager_modules.tileset_manager[0m][0m [36mbg_colors_valid[0m=[35mTrue[0m [36mcache_ready[0m=[35mTrue[0m [36mfg_colors_valid[0m=[35mTrue[0m [36mindices_valid[0m=[35mTrue[0m [36mmax_id[0m=[35m1[0m [36mtile_arrays_items[0m=[35m195[0m
[2m2025-05-14T23:07:38.978175[0m [[32m[1mdebug    [0m] [1mrender_viewport called        [0m [[0m[1m[34mengine.renderer[0m][0m [36mbg_colors_shape[0m=[35m(2, 3)[0m [36mcoord_keys[0m=[35m['tile_coord_y', 'tile_coord_x'][0m [36mfg_colors_shape[0m=[35m(2, 3)[0m [36mindices_shape[0m=[35m(2,)[0m [36mmax_tile_id[0m=[35m1[0m [36mtile_arrays_len[0m=[35m195[0m [36mtile_arrays_type[0m=[35m<class 'numba.typed.typeddict.Dict'>[0m [36mtile_dims[0m=[35m16x16[0m [36mvp_h[0m=[35m46[0m [36mvp_w[0m=[35m63[0m [36mvp_x[0m=[35m0[0m [36mvp_y[0m=[35m0[0m
[2m2025-05-14T23:07:38.995540[0m [[32m[1mdebug    [0m] [1mFrame update finished         [0m [[0m[1m[34mengine.window_manager[0m][0m [36mduration_ms[0m=[35m18.03811499848962[0m
[2m2025-05-14T23:07:39.269166[0m [[32m[1mdebug    [0m] [1mProcessing key event          [0m [[0m[1m[34mengine.window_manager_modules.input_handler[0m][0m [36mkey_enum_val[0m=[35m71[0m [36mkey_text[0m=[35mg[0m [36mmods_val[0m=[35m<KeyboardModifier.NoModifier: 0>[0m [36mui_state[0m=[35mPLAYER_TURN[0m
[2m2025-05-14T23:07:39.269300[0m [[32m[1mdebug    [0m] [1mDispatching action to main loop[0m [[0m[1m[34mengine.window_manager_modules.input_handler[0m][0m [36maction[0m=[35m{'type': 'pickup'}[0m
[2m2025-05-14T23:07:39.269351[0m [[32m[1mdebug    [0m] [1mActionHandler: Processing action type: pickup[0m [[0m[1m[34mengine.action_handler[0m][0m [36maction_details[0m=[35m{'type': 'pickup'}[0m [36mplayer_id[0m=[35m0[0m
[2m2025-05-14T23:07:39.270488[0m [[32m[1mdebug    [0m] [1mMessage added                 [0m [[0m[1m[34mgame.game_state[0m][0m [36mcolor[0m=[35m(150, 150, 150)[0m [36mmessage[0m=[35m'There is nothing here to pick up.'[0m
[2m2025-05-14T23:07:39.270552[0m [[32m[1mdebug    [0m] [1mPlayer action did not result in turn[0m [[0m[1m[34mengine.action_handler[0m][0m [36maction_type[0m=[35mpickup[0m
[2m2025-05-14T23:07:39.270600[0m [[32m[1mdebug    [0m] [1mPlayer action did not result in turn[0m [[0m[1m[34mengine.main_loop[0m][0m [36maction_type[0m=[35mpickup[0m
[2m2025-05-14T23:07:39.570168[0m [[32m[1mdebug    [0m] [1mProcessing key event          [0m [[0m[1m[34mengine.window_manager_modules.input_handler[0m][0m [36mkey_enum_val[0m=[35m65[0m [36mkey_text[0m=[35ma[0m [36mmods_val[0m=[35m<KeyboardModifier.NoModifier: 0>[0m [36mui_state[0m=[35mPLAYER_TURN[0m
[2m2025-05-14T23:07:39.570288[0m [[32m[1mdebug    [0m] [1mDispatching action to main loop[0m [[0m[1m[34mengine.window_manager_modules.input_handler[0m][0m [36maction[0m=[35m{'type': 'move', 'dx': -1, 'dy': 0}[0m
[2m2025-05-14T23:07:39.570347[0m [[32m[1mdebug    [0m] [1mActionHandler: Processing action type: move[0m [[0m[1m[34mengine.action_handler[0m][0m [36maction_details[0m=[35m{'type': 'move', 'dx': -1, 'dy': 0}[0m [36mplayer_id[0m=[35m0[0m
[2m2025-05-14T23:07:39.570387[0m [[32m[1mdebug    [0m] [1mAttempting _handle_player_move[0m [[0m[1m[34mengine.action_handler[0m][0m [36mdx[0m=[35m-1[0m [36mdy[0m=[35m0[0m
[2m2025-05-14T23:07:39.571480[0m [[32m[1mdebug    [0m] [1mWalkability check FAILED      [0m [[0m[1m[34mengine.action_handler[0m][0m
[2m2025-05-14T23:07:39.571527[0m [[32m[1mdebug    [0m] [1mMessage added                 [0m [[0m[1m[34mgame.game_state[0m][0m [36mcolor[0m=[35m(255, 127, 0)[0m [36mmessage[0m=[35m'That way is blocked by terrain.'[0m
[2m2025-05-14T23:07:39.571565[0m [[32m[1mdebug    [0m] [1mPlayer action did not result in turn[0m [[0m[1m[34mengine.action_handler[0m][0m [36maction_type[0m=[35mmove[0m
[2m2025-05-14T23:07:39.571639[0m [[32m[1mdebug    [0m] [1mPlayer action did not result in turn[0m [[0m[1m[34mengine.main_loop[0m][0m [36maction_type[0m=[35mmove[0m
[2m2025-05-14T23:07:40.380180[0m [[32m[1mdebug    [0m] [1mProcessing key event          [0m [[0m[1m[34mengine.window_manager_modules.input_handler[0m][0m [36mkey_enum_val[0m=[35m73[0m [36mkey_text[0m=[35mi[0m [36mmods_val[0m=[35m<KeyboardModifier.NoModifier: 0>[0m [36mui_state[0m=[35mPLAYER_TURN[0m
[2m2025-05-14T23:07:40.380374[0m [[32m[1mdebug    [0m] [1mChanging UI state from PLAYER_TURN to INVENTORY_VIEW[0m [[0m[1m[34mgame.game_state[0m][0m
[2m2025-05-14T23:07:40.380436[0m [[32m[1mdebug    [0m] [1mInventory UI state reset.     [0m [[0m[1m[34mengine.window_manager_modules.ui_overlay_manager[0m][0m
[2m2025-05-14T23:07:40.381506[0m [[32m[1mdebug    [0m] [1mTilesetManager.get_render_data called.[0m [[0m[1m[34mengine.window_manager_modules.tileset_manager[0m][0m [36mbg_colors_valid[0m=[35mTrue[0m [36mcache_ready[0m=[35mTrue[0m [36mfg_colors_valid[0m=[35mTrue[0m [36mindices_valid[0m=[35mTrue[0m [36mmax_id[0m=[35m1[0m [36mtile_arrays_items[0m=[35m195[0m
[2m2025-05-14T23:07:40.389423[0m [[32m[1mdebug    [0m] [1mrender_viewport called        [0m [[0m[1m[34mengine.renderer[0m][0m [36mbg_colors_shape[0m=[35m(2, 3)[0m [36mcoord_keys[0m=[35m['tile_coord_y', 'tile_coord_x'][0m [36mfg_colors_shape[0m=[35m(2, 3)[0m [36mindices_shape[0m=[35m(2,)[0m [36mmax_tile_id[0m=[35m1[0m [36mtile_arrays_len[0m=[35m195[0m [36mtile_arrays_type[0m=[35m<class 'numba.typed.typeddict.Dict'>[0m [36mtile_dims[0m=[35m16x16[0m [36mvp_h[0m=[35m46[0m [36mvp_w[0m=[35m63[0m [36mvp_x[0m=[35m0[0m [36mvp_y[0m=[35m0[0m
[2m2025-05-14T23:07:40.410351[0m [[32m[1mdebug    [0m] [1mFrame update finished         [0m [[0m[1m[34mengine.window_manager[0m][0m [36mduration_ms[0m=[35m29.86919200338889[0m
[2m2025-05-14T23:07:40.411108[0m [[32m[1mdebug    [0m] [1mTilesetManager.get_render_data called.[0m [[0m[1m[34mengine.window_manager_modules.tileset_manager[0m][0m [36mbg_colors_valid[0m=[35mTrue[0m [36mcache_ready[0m=[35mTrue[0m [36mfg_colors_valid[0m=[35mTrue[0m [36mindices_valid[0m=[35mTrue[0m [36mmax_id[0m=[35m1[0m [36mtile_arrays_items[0m=[35m195[0m
[2m2025-05-14T23:07:40.411181[0m [[32m[1mdebug    [0m] [1mrender_viewport called        [0m [[0m[1m[34mengine.renderer[0m][0m [36mbg_colors_shape[0m=[35m(2, 3)[0m [36mcoord_keys[0m=[35m['tile_coord_y', 'tile_coord_x'][0m [36mfg_colors_shape[0m=[35m(2, 3)[0m [36mindices_shape[0m=[35m(2,)[0m [36mmax_tile_id[0m=[35m1[0m [36mtile_arrays_len[0m=[35m195[0m [36mtile_arrays_type[0m=[35m<class 'numba.typed.typeddict.Dict'>[0m [36mtile_dims[0m=[35m16x16[0m [36mvp_h[0m=[35m46[0m [36mvp_w[0m=[35m63[0m [36mvp_x[0m=[35m0[0m [36mvp_y[0m=[35m0[0m
[2m2025-05-14T23:07:40.431672[0m [[32m[1mdebug    [0m] [1mFrame update finished         [0m [[0m[1m[34mengine.window_manager[0m][0m [36mduration_ms[0m=[35m21.231480001006275[0m
[2m2025-05-14T23:07:41.007177[0m [[32m[1mdebug    [0m] [1mProcessing key event          [0m [[0m[1m[34mengine.window_manager_modules.input_handler[0m][0m [36mkey_enum_val[0m=[35m16777216[0m [36mkey_text[0m=[35m[0m [36mmods_val[0m=[35m<KeyboardModifier.NoModifier: 0>[0m [36mui_state[0m=[35mINVENTORY_VIEW[0m
[2m2025-05-14T23:07:41.007317[0m [[32m[1minfo     [0m] [1mEscape pressed, returning to player turn.[0m [[0m[1m[34mengine.window_manager_modules.input_handler[0m][0m [36mfrom_state[0m=[35mINVENTORY_VIEW[0m
[2m2025-05-14T23:07:41.007370[0m [[32m[1mdebug    [0m] [1mChanging UI state from INVENTORY_VIEW to PLAYER_TURN[0m [[0m[1m[34mgame.game_state[0m][0m
[2m2025-05-14T23:07:41.007406[0m [[32m[1mdebug    [0m] [1mInventory UI state reset.     [0m [[0m[1m[34mengine.window_manager_modules.ui_overlay_manager[0m][0m
[2m2025-05-14T23:07:41.008538[0m [[32m[1mdebug    [0m] [1mTilesetManager.get_render_data called.[0m [[0m[1m[34mengine.window_manager_modules.tileset_manager[0m][0m [36mbg_colors_valid[0m=[35mTrue[0m [36mcache_ready[0m=[35mTrue[0m [36mfg_colors_valid[0m=[35mTrue[0m [36mindices_valid[0m=[35mTrue[0m [36mmax_id[0m=[35m1[0m [36mtile_arrays_items[0m=[35m195[0m
[2m2025-05-14T23:07:41.008689[0m [[32m[1mdebug    [0m] [1mrender_viewport called        [0m [[0m[1m[34mengine.renderer[0m][0m [36mbg_colors_shape[0m=[35m(2, 3)[0m [36mcoord_keys[0m=[35m['tile_coord_y', 'tile_coord_x'][0m [36mfg_colors_shape[0m=[35m(2, 3)[0m [36mindices_shape[0m=[35m(2,)[0m [36mmax_tile_id[0m=[35m1[0m [36mtile_arrays_len[0m=[35m195[0m [36mtile_arrays_type[0m=[35m<class 'numba.typed.typeddict.Dict'>[0m [36mtile_dims[0m=[35m16x16[0m [36mvp_h[0m=[35m46[0m [36mvp_w[0m=[35m63[0m [36mvp_x[0m=[35m0[0m [36mvp_y[0m=[35m0[0m
[2m2025-05-14T23:07:41.026760[0m [[32m[1mdebug    [0m] [1mFrame update finished         [0m [[0m[1m[34mengine.window_manager[0m][0m [36mduration_ms[0m=[35m19.31397701264359[0m
[2m2025-05-14T23:07:41.905299[0m [[32m[1mdebug    [0m] [1mProcessing key event          [0m [[0m[1m[34mengine.window_manager_modules.input_handler[0m][0m [36mkey_enum_val[0m=[35m16777264[0m [36mkey_text[0m=[35m[0m [36mmods_val[0m=[35m<KeyboardModifier.NoModifier: 0>[0m [36mui_state[0m=[35mPLAYER_TURN[0m
[2m2025-05-14T23:07:43.326169[0m [[32m[1mdebug    [0m] [1mProcessing key event          [0m [[0m[1m[34mengine.window_manager_modules.input_handler[0m][0m [36mkey_enum_val[0m=[35m86[0m [36mkey_text[0m=[35mv[0m [36mmods_val[0m=[35m<KeyboardModifier.NoModifier: 0>[0m [36mui_state[0m=[35mPLAYER_TURN[0m
[2m2025-05-14T23:07:43.326324[0m [[32m[1minfo     [0m] [1mHeight vis toggled            [0m [[0m[1m[34mengine.window_manager[0m][0m [36menabled[0m=[35mTrue[0m
[2m2025-05-14T23:07:43.327565[0m [[32m[1mdebug    [0m] [1mTilesetManager.get_render_data called.[0m [[0m[1m[34mengine.window_manager_modules.tileset_manager[0m][0m [36mbg_colors_valid[0m=[35mTrue[0m [36mcache_ready[0m=[35mTrue[0m [36mfg_colors_valid[0m=[35mTrue[0m [36mindices_valid[0m=[35mTrue[0m [36mmax_id[0m=[35m1[0m [36mtile_arrays_items[0m=[35m195[0m
[2m2025-05-14T23:07:43.327674[0m [[32m[1mdebug    [0m] [1mrender_viewport called        [0m [[0m[1m[34mengine.renderer[0m][0m [36mbg_colors_shape[0m=[35m(2, 3)[0m [36mcoord_keys[0m=[35m['tile_coord_y', 'tile_coord_x'][0m [36mfg_colors_shape[0m=[35m(2, 3)[0m [36mindices_shape[0m=[35m(2,)[0m [36mmax_tile_id[0m=[35m1[0m [36mtile_arrays_len[0m=[35m195[0m [36mtile_arrays_type[0m=[35m<class 'numba.typed.typeddict.Dict'>[0m [36mtile_dims[0m=[35m16x16[0m [36mvp_h[0m=[35m46[0m [36mvp_w[0m=[35m63[0m [36mvp_x[0m=[35m0[0m [36mvp_y[0m=[35m0[0m
[2m2025-05-14T23:07:43.344556[0m [[31m[1merror    [0m] [1mError drawing height key overlay[0m [[0m[1m[34mengine.window_manager_modules.ui_overlay_manager[0m][0m [36merror[0m=[35m"'WindowManager' object has no attribute 'lerp_color'"[0m
Traceback (most recent call last):
  File "/home/earnest/code_projects/basicrl/engine/window_manager_modules/ui_overlay_manager.py", line 209, in _render_height_key_overlay
    wm.lerp_color(cm, ch, t_norm)
    ^^^^^^^^^^^^^
AttributeError: 'WindowManager' object has no attribute 'lerp_color'
[2m2025-05-14T23:07:43.345512[0m [[32m[1mdebug    [0m] [1mFrame update finished         [0m [[0m[1m[34mengine.window_manager[0m][0m [36mduration_ms[0m=[35m19.140926000545733[0m
[2m2025-05-14T23:07:44.549274[0m [[32m[1mdebug    [0m] [1mProcessing key event          [0m [[0m[1m[34mengine.window_manager_modules.input_handler[0m][0m [36mkey_enum_val[0m=[35m86[0m [36mkey_text[0m=[35mv[0m [36mmods_val[0m=[35m<KeyboardModifier.NoModifier: 0>[0m [36mui_state[0m=[35mPLAYER_TURN[0m
[2m2025-05-14T23:07:44.549433[0m [[32m[1minfo     [0m] [1mHeight vis toggled            [0m [[0m[1m[34mengine.window_manager[0m][0m [36menabled[0m=[35mFalse[0m
[2m2025-05-14T23:07:44.550627[0m [[32m[1mdebug    [0m] [1mTilesetManager.get_render_data called.[0m [[0m[1m[34mengine.window_manager_modules.tileset_manager[0m][0m [36mbg_colors_valid[0m=[35mTrue[0m [36mcache_ready[0m=[35mTrue[0m [36mfg_colors_valid[0m=[35mTrue[0m [36mindices_valid[0m=[35mTrue[0m [36mmax_id[0m=[35m1[0m [36mtile_arrays_items[0m=[35m195[0m
[2m2025-05-14T23:07:44.550719[0m [[32m[1mdebug    [0m] [1mrender_viewport called        [0m [[0m[1m[34mengine.renderer[0m][0m [36mbg_colors_shape[0m=[35m(2, 3)[0m [36mcoord_keys[0m=[35m['tile_coord_y', 'tile_coord_x'][0m [36mfg_colors_shape[0m=[35m(2, 3)[0m [36mindices_shape[0m=[35m(2,)[0m [36mmax_tile_id[0m=[35m1[0m [36mtile_arrays_len[0m=[35m195[0m [36mtile_arrays_type[0m=[35m<class 'numba.typed.typeddict.Dict'>[0m [36mtile_dims[0m=[35m16x16[0m [36mvp_h[0m=[35m46[0m [36mvp_w[0m=[35m63[0m [36mvp_x[0m=[35m0[0m [36mvp_y[0m=[35m0[0m
[2m2025-05-14T23:07:44.568190[0m [[32m[1mdebug    [0m] [1mFrame update finished         [0m [[0m[1m[34mengine.window_manager[0m][0m [36mduration_ms[0m=[35m18.705645998124965[0m

--- Map Section around (4,3) ---
   0  1  2  3  4  5  6  7  8  9  10 11 12 13 14 
  ----------------------------------------------
0 | #  #  #  #  #  #  #  #  #  #  #  #  #  #  # 
1 | #  #  #  #  #  #  #  #  #  #  .  .  .  .  . 
2 | #  #  .  .  .  .  .  .  .  .  .  .  .  .  . 
3 | #  #  .  . [.] .  .  .  .  .  .  .  .  .  . 
4 | #  #  .  .  .  .  .  .  .  .  .  .  .  .  . 
5 | #  #  .  .  .  .  .  #  #  #  #  #  #  #  # 
6 | #  #  #  #  .  #  #  #  #  #  #  #  #  #  # 
7 | #  #  #  #  .  #  #  #  #  #  .  .  .  .  # 
8 | #  #  #  #  .  .  .  .  .  .  .  .  .  .  # 
9 | #  #  .  .  .  .  .  #  #  #  .  .  .  .  # 
10| #  #  .  .  .  .  .  #  #  #  .  .  .  .  # 
11| #  #  .  .  .  .  .  .  .  .  .  .  .  .  . 
12| #  #  .  .  .  .  .  #  #  #  #  #  #  #  # 
13| #  #  #  #  #  .  .  #  #  #  #  #  #  #  # 
------------------------------------


```

`basicrl/prototypes/roaming_entity_demo.py`:

```py
# === basicrl/prototypes/roaming_entity_demo.py ===
import sys
import time
from pathlib import Path

# Allow imports like 'from game.*' and 'from game_rng'
sys.path.append(str(Path(__file__).resolve().parent.parent))

from game.game_state import GameState
from game.world.game_map import GameMap


def create_roamer(entity_registry, x, y):
    return entity_registry.create_entity(
        x=x,
        y=y,
        glyph=ord("R"),
        color_fg=(255, 128, 0),
        name="Roamer",
        blocks_movement=True,
        hp=5,
        max_hp=5,
    )


def move_roamer(entity_registry, entity_id, game_map):
    dx, dy = 1, 0  # Move right each step
    x = entity_registry.get_entity_component(entity_id, "x")
    y = entity_registry.get_entity_component(entity_id, "y")
    new_x = x + dx
    new_y = y + dy

    if game_map.in_bounds(new_x, new_y) and game_map.is_walkable(new_x, new_y):
        entity_registry.set_entity_component(entity_id, "x", new_x)
        entity_registry.set_entity_component(entity_id, "y", new_y)
        return (new_x, new_y)
    return (x, y)


def main():
    width, height = 20, 10
    game_map = GameMap(width=width, height=height)
    game_map.create_test_room()

    game_state = GameState(
        existing_map=game_map,
        player_start_pos=(10, 5),
        player_glyph=ord("@"),
        player_start_hp=10,
        player_fov_radius=6,
        item_templates={},  # ✅ must be a dict
        effect_definitions={},
        rng_seed=42,
    )

    entity_registry = game_state.entity_registry
    game_map = game_state.game_map

    roamer_id = create_roamer(entity_registry, 2, 5)

    for tick in range(10):
        new_pos = move_roamer(entity_registry, roamer_id, game_map)
        game_state.turn_count += 1
        game_state.add_message(f"Roamer moved to {new_pos}", (200, 200, 0))
        print(f"[Tick {tick}] Roamer is now at {new_pos}")
        time.sleep(0.25)


if __name__ == "__main__":
    main()

```

`basicrl/run.sh`:

```sh
#!/bin/bash
set -euo pipefail

# Determine paths
PROJECT_ROOT="$(cd "$(dirname "${BASH_SOURCE[0]}")" &>/dev/null && pwd)"
PROJECT_NAME="$(basename "$PROJECT_ROOT")"
PARENT_DIR="$(dirname "$PROJECT_ROOT")"

# --- Check for active conda/mamba environment ---
if [ -z "${CONDA_PREFIX:-}" ]; then
  echo "WARNING: No Conda/Mamba environment appears to be active."
else
  ENV_NAME="$(basename "$CONDA_PREFIX")"
  if [ "$ENV_NAME" != "$PROJECT_NAME" ]; then
    echo "WARNING: Active environment '$ENV_NAME' != project '$PROJECT_NAME'"
  fi
fi

# --- Run main as a module, mimicking `python -m project.main` ---
echo "Running: python -m $PROJECT_NAME.main $@"
PYTHONPATH="$PARENT_DIR${PYTHONPATH:+:$PYTHONPATH}" \
  python -m "$PROJECT_NAME.main" "$@"

```

`basicrl/simulation_output.txt`:

```txt

--- Map Section around (2,3) ---
   0  1  2  3  4  5  6  7  8  9  10 11 12 
  ----------------------------------------
0 | #  #  #  #  #  #  #  #  #  #  #  #  # 
1 | #  .  .  .  .  .  .  .  .  .  .  .  . 
2 | #  .  .  .  .  #  #  #  #  #  .  .  . 
3 | #  . [.] .  .  #  #  #  #  #  .  .  . 
4 | #  .  .  .  .  #  #  #  #  #  .  .  . 
5 | #  .  .  .  .  .  .  .  .  .  .  .  . 
6 | #  #  #  .  .  #  #  #  #  #  #  #  # 
7 | #  #  #  .  .  #  #  #  #  #  #  #  # 
8 | #  #  #  .  .  .  .  .  .  .  .  .  . 
9 | #  #  #  .  .  #  #  .  .  .  .  #  # 
10| #  #  #  .  .  #  #  .  .  .  .  #  # 
11| #  #  #  .  .  #  #  .  .  .  .  #  # 
12| #  #  #  .  .  .  .  .  .  .  .  #  # 
13| #  #  #  .  .  .  .  .  .  .  .  #  # 
------------------------------------


```

`basicrl/tile_mapper/1.json`:

```json
{
  "format_version": 2,
  "maps": {
    "1": {
      "default_tile": ".",
      "grid_height": 32,
      "grid_width": 29,
      "rows": [
      	"#############################",
        "#...........................#",
        "#.########################..#",
        "#.#kkkkkkk#bbbbbb#bbbbbbb#..#",
        "#.#kkkkkkk#bbbbb###bbbbbb#..#",
        "#.#lllllll#bbbbb+l+bbbbbb#..#",
        "#.#lllllll#######l########..#",
        "#.#lllllll#sssss+l+wwwwww#..#",
        "#.+lllllll#sssss#l#wwwwww#..#",
        "#.#lllllll#######l########..#",
        "#.#llllllllllllllllllllll#..#",
        "#.####################+###..#",
        "#.#kkkk#bbbbb#bbbbb#l+ttt#..#",
        "#.#kkkk#bbbbb#bbbbb#l#ttt#..#",
        "#.#llll#bbbbb#bbbbb#l#ttt#..#",
        "#.#llll#+######+####l#ttt#..#",
        "#.#llllllllllllllllll#ttt#..#",
        "#.#llll#+######+######ttt#..#",
        "#.+llll#bbbbb#bbbbbbb#ttt#..#",
        "#.#llll#bbbbb#bbbbbbb#ttt#..#",
        "#.#llll#bbbbb#bbbbbbb#ttt#..#",
        "#.######################+#..#",
        "#.#wwwwwwww#sss#kkkllllll#..#",
        "#.#wwwwwwww#sss#kkkllllll#..#",
        "#.#wwwwwwww#sss#lllllllll#..#",
        "#.#wwwwwwww+sss#lll#######..#",
        "#.#wwwwwwww#sss#lll#bbbbb#..#",
        "#.#wwwwwwww#sss#lll+bbbbb#..#",
        "#.#wwwwwwww#####lll#bbbbb#..#",
        "#.#wwwwwwww+lllllll#bbbbb#..#",
        "#.###############+########..#",
        "#...........................#",
        "#############################"
      ]
    },
    "2": {
      "default_tile": ".",
      "grid_height": 33,
      "grid_width": 29,
      "rows": [
        "#############################",
        "#...........................#",
        "#.########################..#",
        "#.#wwwwwwwwwwwwwww#bbbbbb#..#",
        "#.#wwwwwwwwwwwwwww#bbbbbb#..#",
        "#.###+#############bbbbbb#..#",
        "#.#lllllllllllllll##+#####..#",
        "#.#llllllllllllllllllllll#..#",
        "#.+llllllkkkk#####+###lll#..#",
        "#.#llllllkkkk#bbbbbbb#lll#..#",
        "#.#llllllkkkk#bbbbbbb#lll#..#",
        "#.####################+###..#",
        "#.#kkllllllllllllllll+ttt#..#",
        "#.#kkll##########+####ttt#..#",
        "#.#kkll#bbbbbbb#bbbbb#ttt#..#",
        "#.#llll#bbbbbbb#bbbbb#ttt#..#",
        "#.#llll+bbbbbbb#bbbbb#ttt#..#",
        "#.#llll#########bbbbb#ttt#..#",
        "#.+llll+bbbbbbb#bbbbb#ttt#..#",
        "#.#llll#bbbbbbb#bbbbb#ttt#..#",
        "#.#llll#bbbbbbb#bbbbb#ttt#..#",
        "#.######################+#..#",
        "#.#bbbbbb+llllll#bbbb#lll#..#",
        "#.#bbbbbb######l#bbbb#lll#..#",
        "#.#bbbbbb#bbbb+l#bbbb#lll#..#",
        "#.#bbbbbb#bbbb#l#+####lll#..#",
        "#.#bbbbbb#bbbb#llllllllll#..#",
        "#.#bbbbbb#bbbb#llllllllll+..#",
        "#.#bbbbbb#bbbb#lllkkkkkll#..#",
        "#.#bbbbbb#bbbb#lllkkkkkll#..#",
        "#.########################..#",
        "#...........................#",
        "#############################"
      ]
    }
  }
}

```

`basicrl/tile_mapper/2.json`:

```json
{
  "grid_width": 29,
  "grid_height": 66,
  "default_tile": ".",
  "rows": [
    "#############################",
    "#...........................#",
    "#.########################..#",
    "#.#kkkkkkk#bbbbbb#bbbbbbb#..#",
    "#.#kkkkkkk#bbbbb###bbbbbb#..#",
    "#.#lllllll#bbbbb+l+bbbbbb#..#",
    "#.#lllllll#######l########..#",
    "#.#lllllll#sssss+l+wwwwww#..#",
    "#.+lllllll#sssss#l#wwwwww#..#",
    "#.#lllllll#######l########..#",
    "#.#llllllllllllllllllllll#..#",
    "#.####################+###..#",
    "#.#kkkk#bbbbb#bbbbb#l+ttt#..#",
    "#.#kkkk#bbbbb#bbbbb#l#ttt#..#",
    "#.#llll#bbbbb#bbbbb#l#ttt#..#",
    "#.#llll#+######+####l#ttt#..#",
    "#.#llllllllllllllllll#ttt#..#",
    "#.#llll#+######+######ttt#..#",
    "#.+llll#bbbbb#bbbbbbb#ttt#..#",
    "#.#llll#bbbbb#bbbbbbb#ttt#..#",
    "#.#llll#bbbbb#bbbbbbb#ttt#..#",
    "#.######################+#..#",
    "#.#wwwwwwww#sss#kkkllllll#..#",
    "#.#wwwwwwww#sss#kkkllllll#..#",
    "#.#wwwwwwww#sss#lllllllll#..#",
    "#.#wwwwwwww+sss#lll#######..#",
    "#.#wwwwwwww#sss#lll#bbbbb#..#",
    "#.#wwwwwwww#sss#lll+bbbbb#..#",
    "#.#wwwwwwww#####lll#bbbbb#..#",
    "#.#wwwwwwww+lllllll#bbbbb#..#",
    "#.###############+########..#",
    "#...........................#",
    "#############################",
    "#############################",
    "#...........................#",
    "#.########################..#",
    "#.#...............#......#..#",
    "#.#...............#......#..#",
    "#.###+#############......#..#",
    "#.#.........t...t.##+#####..#",
    "#.#......................#..#",
    "#.+..........#####+###...#..#",
    "#.#..........#.......#...#..#",
    "#.#..........#.......#...#..#",
    "#.####################+###..#",
    "#.#..................+...#..#",
    "#.#..................#...#..#",
    "#.#..................#...#..#",
    "#.#.........t...t....#...#..#",
    "#.#..................#...#..#",
    "#.#..................#.l.#..#",
    "#+...................#...#..#",
    "#.#..................#.t.#..#",
    "#.#..................#...#..#",
    "#.#####################.+##.#",
    "#.#......................#..#",
    "#.#......................#..#",
    "#.#......................#..#",
    "#.#.........t...t........#..#",
    "#.#......................#..#",
    "#.#......................+..#",
    "#.#......................#..#",
    "#.#......................#..#",
    "#.########################..#",
    "#...........................#",
    "#############################"
  ]
}
```

`basicrl/tile_mapper/test.txt`:

```txt
#############################
#...........................#
#.########################..#
#.#kkkkkkk#bbbbb#bbbbbbbb#..#
#.#kkkkkkk#bbbbb###bbbbbb#..#
#.#lllllll#bbbbb+l+bbbbbb#..#
#.#lllllll#######l########..#
#.#lllllll#sssss+l+wwwwww#..#
#.+lllllll#sssss#l#wwwwww#..#
#.#lllllll#######l########..#
#.#llllllllllllllllllllll#..#
#.####################+###..#
#.#..................+...#..#
#.#..................#...#..#
#.#..................#.T.#..#
#.#.....Apartment....#.o.#..#
#.#..................#.i.#..#
#.#..................#.l.#..#
#+...................#.e.#..#
#.#..................#.t.#..#
#.#..................#...#..#
#.######################+##.#
#.#......................#..#
#.#......................#..#
#.#......................#..#
#.#.....Apartment........#..#
#.#......................#..#
#.#......................+..#
#.#......................#..#
#.#......................#..#
#.########################..#
#...........................#
#############################



#############################
#...........................#
#.########################..#
#.#...WORKSHOP....#......#..#
#.#...............#..B...#..#
#.###+#############......#..#
#.#.....Apartment.##+#####..#
#.#......................#..#
#.+..........#####+###...#..#
#.#..........#.......#...#..#
#.#..........#...B...#...#..#
#.####################+###..#
#.#..................+...#..#
#.#..................#...#..#
#.#..................#.T.#..#
#.#.....Apartment....#.o.#..#
#.#..................#.i.#..#
#.#..................#.l.#..#
#+...................#.e.#..#
#.#..................#.t.#..#
#.#..................#...#..#
#.#####################.+##.#
#.#......................#..#
#.#......................#..#
#.#......................#..#
#.#.....Apartment........#..#
#.#......................#..#
#.#......................+..#
#.#......................#..#
#.#......................#..#
#.########################..#
#...........................#
#############################


```

`basicrl/tile_mapper/tile_editor_config.json`:

```json
{
    "format_version": 2,
    "grid_width": 80,
    "grid_height": 50,
    "tile_size": 16,
    "min_tile_size": 4,
    "max_tile_size": 64,
    "zoom_step": 1.2,
    "pan_step": 50,
    "default_tile": ".",
    "wall_tile": "#",
    "door_tile": "+",
    "window_title": "PySide6 Tile Map Editor (Configurable)",
    "preview_line_color": [
        255,
        0,
        0
    ],
    "preview_line_thickness": 2,
    "controls": {
        "place_tile_click": {
            "modifier": "None",
            "trigger": "LeftClick",
            "description": "Place selected tile (single click)"
        },
        "draw_line": {
            "modifier": "None",
            "trigger": "LeftDrag",
            "description": "Draw line of selected tile"
        },
        "erase_tile": {
            "modifier": "None",
            "trigger": "RightClick",
            "description": "Erase tile (set to default)"
        },
        "draw_rect": {
            "modifier": "Shift",
            "trigger": "LeftDrag",
            "description": "Draw rectangle of selected tile"
        },
        "fill_perimeter": {
            "modifier": "Ctrl",
            "trigger": "LeftClick",
            "description": "Fill perimeter of non-default area"
        },
        "wall_perimeter": {
            "modifier": "Ctrl+Shift",
            "trigger": "LeftClick",
            "description": "Wall perimeter of same-tile area (respects walls)"
        },
        "zoom_in": {
            "modifier": "Ctrl",
            "trigger": "ScrollUp",
            "description": "Zoom In"
        },
        "zoom_out": {
            "modifier": "Ctrl",
            "trigger": "ScrollDown",
            "description": "Zoom Out"
        },
        "pan_right": {
            "modifier": "Shift",
            "trigger": "ScrollUp",
            "description": "Pan Right"
        },
        "pan_left": {
            "modifier": "Shift",
            "trigger": "ScrollDown",
            "description": "Pan Left"
        },
        "show_help": {
            "modifier": "None",
            "trigger": "KeyPress",
            "key": "F1",
            "description": "Show this help message"
        },
        "select_tile_1": {
            "modifier": "None",
            "trigger": "KeyPress",
            "key": "1",
            "description": "Select Tile 1"
        },
        "select_tile_2": {
            "modifier": "None",
            "trigger": "KeyPress",
            "key": "2",
            "description": "Select Tile 2"
        },
        "select_tile_3": {
            "modifier": "None",
            "trigger": "KeyPress",
            "key": "3",
            "description": "Select Tile 3"
        },
        "select_tile_4": {
            "modifier": "None",
            "trigger": "KeyPress",
            "key": "4",
            "description": "Select Tile 4"
        },
        "select_tile_5": {
            "modifier": "None",
            "trigger": "KeyPress",
            "key": "5",
            "description": "Select Tile 5"
        },
        "select_tile_6": {
            "modifier": "None",
            "trigger": "KeyPress",
            "key": "6",
            "description": "Select Tile 6"
        },
        "select_tile_7": {
            "modifier": "None",
            "trigger": "KeyPress",
            "key": "7",
            "description": "Select Tile 7"
        },
        "select_tile_8": {
            "modifier": "None",
            "trigger": "KeyPress",
            "key": "8",
            "description": "Select Tile 8"
        },
        "select_tile_9": {
            "modifier": "None",
            "trigger": "KeyPress",
            "key": "9",
            "description": "Select Tile 9"
        },
        "flood_fill": {
            "modifier": "Alt",
            "trigger": "LeftClick",
            "description": "Flood fill area with selected tile"
        }
    },
    "tiles": {
        ".": {
            "color": [
                220,
                220,
                220
            ],
            "description": "Empty Floor"
        },
        "#": {
            "color": [
                100,
                100,
                100
            ],
            "description": "Wall"
        },
        "+": {
            "color": [
                200,
                150,
                100
            ],
            "description": "Door"
        },
        "k": {
            "color": [
                255,
                215,
                0
            ],
            "description": "Kitchen"
        },
        "b": {
            "color": [
                0,
                0,
                200
            ],
            "description": "Bedroom"
        },
        "l": {
            "color": [
                0,
                150,
                0
            ],
            "description": "Living Space"
        },
        "t": {
            "color": [
                150,
                150,
                255
            ],
            "description": "Toilet"
        },
        "s": {
            "color": [
                255,
                0,
                255
            ],
            "description": "Undefined Tile 's' (from map)"
        },
        "w": {
            "color": [
                145,
                65,
                172
            ],
            "description": "Workshop"
        }
    }
}
```

`basicrl/tile_mapper/tile_mapper_app.py`:

```py
# tile_mapper_app.py

import sys
import traceback

from PySide6.QtWidgets import QApplication, QMessageBox

# Import the main window class
# Assuming flat structure, adjust path if needed (e.g., from .tile_mapper_gui import ...)
from tile_mapper_gui import MainWindow

# --- Main Execution ---
if __name__ == "__main__":
    # Optional High DPI settings (consider platform specifics)
    # ... (Add DPI code here if needed, before QApplication) ...

    app = QApplication(sys.argv)

    # --- Catch startup errors ---
    main_window = None
    try:
        print("Initializing MainWindow...")
        main_window = MainWindow()  # Config is loaded inside MainWindow.__init__
        print("Showing MainWindow...")
        main_window.show()
        print("Starting application event loop...")
        exit_code = app.exec()
        print(f"Application finished with exit code {exit_code}.")
        sys.exit(exit_code)

    except Exception as e:
        print("\n--- CRITICAL STARTUP ERROR ---", file=sys.stderr)
        print(
            f"An error occurred during application initialization: {e}", file=sys.stderr
        )
        print("Traceback:", file=sys.stderr)
        traceback.print_exc(file=sys.stderr)  # Print traceback to stderr

        # Attempt to show error message box
        try:
            error_msg = QMessageBox()
            error_msg.setIcon(QMessageBox.Icon.Critical)
            error_msg.setWindowTitle("Application Startup Error")
            error_msg.setText(
                f"Failed to start Tile Mapper:\n\n{e}\n\nSee console/stderr for details."
            )
            # Limit detail length for QMessageBox
            tb_text = traceback.format_exc()
            if len(tb_text) > 4000:
                tb_text = tb_text[:4000] + "\n... (traceback truncated)"
            error_msg.setDetailedText(tb_text)
            error_msg.exec()
        except Exception as box_e:
            print(f"Could not display error message box: {box_e}", file=sys.stderr)

        sys.exit(1)  # Exit with error code

```

`basicrl/tile_mapper/tile_mapper_config.py`:

```py
# tile_mapper_config.py

import copy  # For deep copying defaults
import io
import os
import traceback

from PySide6.QtGui import QColor  # Needed for default color conversion

# --- Orjson/JSON Handling ---
try:
    import orjson

    JSON_HANDLER = orjson
    JSON_LOADS_KWARGS = {}
    JSON_DUMPS_KWARGS = {
        "option": orjson.OPT_INDENT_2 | orjson.OPT_APPEND_NEWLINE | orjson.OPT_SORT_KEYS
    }
    JSON_DecodeError = orjson.JSONDecodeError
    FILE_READ_MODE = "rb"
    FILE_WRITE_MODE = "wb"
    USE_ORJSON = True
    print("Using orjson for JSON operations.")
except ImportError:
    import json

    JSON_HANDLER = json
    JSON_LOADS_KWARGS = {}
    JSON_DUMPS_KWARGS = {"indent": 4}
    JSON_DecodeError = json.JSONDecodeError
    FILE_READ_MODE = "r"
    FILE_WRITE_MODE = "w"
    USE_ORJSON = False
    print("Warning: orjson not found. Falling back to standard json library (slower).")

# --- Configuration File Constants ---
CONFIG_FILE = "tile_editor_config.json"
CURRENT_FORMAT_VERSION = 2

# --- Default Configuration Structure ---
DEFAULT_CONFIG = {
    "format_version": CURRENT_FORMAT_VERSION,
    "grid_width": 40,
    "grid_height": 40,
    "tile_size": 16,
    "min_tile_size": 4,
    "max_tile_size": 64,
    "zoom_step": 1.2,
    "pan_step": 50,
    "default_tile": ".",
    "wall_tile": "#",
    "door_tile": "+",
    "window_title": "PySide6 Tile Map Editor (Configurable)",
    "preview_line_color": [255, 0, 0],
    "preview_line_thickness": 1,
    "tiles": {
        ".": {"color": [220, 220, 220], "description": "Empty Floor"},
        "#": {"color": [100, 100, 100], "description": "Wall"},
        "+": {"color": [200, 150, 100], "description": "Door"},
        "k": {"color": [255, 215, 0], "description": "Kitchen"},
        "b": {"color": [0, 0, 200], "description": "Bedroom"},
        "l": {"color": [0, 150, 0], "description": "Living Space"},
        "t": {"color": [150, 150, 255], "description": "Toilet"},
    },
    "controls": {
        "place_tile_click": {
            "modifier": "None",
            "trigger": "LeftClick",
            "description": "Place selected tile (single click)",
        },
        "draw_line": {
            "modifier": "None",
            "trigger": "LeftDrag",
            "description": "Draw line of selected tile",
        },
        "erase_tile": {
            "modifier": "None",
            "trigger": "RightClick",
            "description": "Erase tile (set to default)",
        },
        "draw_rect": {
            "modifier": "Shift",
            "trigger": "LeftDrag",
            "description": "Draw rectangle of selected tile",
        },
        "fill_perimeter": {
            "modifier": "Ctrl",
            "trigger": "LeftClick",
            "description": "Fill perimeter of non-default area",
        },
        "wall_perimeter": {
            "modifier": "Ctrl+Shift",
            "trigger": "LeftClick",
            "description": "Wall perimeter of same-tile area (respects walls/doors)",
        },
        "flood_fill": {
            "modifier": "Alt",
            "trigger": "LeftClick",
            "description": "Flood fill area with selected tile",
        },
        "zoom_in": {
            "modifier": "Ctrl",
            "trigger": "ScrollUp",
            "description": "Zoom In",
        },
        "zoom_out": {
            "modifier": "Ctrl",
            "trigger": "ScrollDown",
            "description": "Zoom Out",
        },
        "pan_right": {
            "modifier": "Shift",
            "trigger": "ScrollUp",
            "description": "Pan Right",
        },
        "pan_left": {
            "modifier": "Shift",
            "trigger": "ScrollDown",
            "description": "Pan Left",
        },
        "show_help": {
            "modifier": "None",
            "trigger": "KeyPress",
            "key": "F1",
            "description": "Show this help message",
        },
        "select_tile_1": {
            "modifier": "None",
            "trigger": "KeyPress",
            "key": "1",
            "description": "Select Tile 1",
        },
        # ... (add other select_tile_N entries if desired) ...
        "select_tile_9": {
            "modifier": "None",
            "trigger": "KeyPress",
            "key": "9",
            "description": "Select Tile 9",
        },
    },
}


def _validate_and_populate_config(loaded_config_dict: dict) -> tuple[dict, bool]:
    """Validates loaded config, populates defaults, converts colors. Returns (validated_config, was_modified)."""
    validated_config = loaded_config_dict
    config_was_modified = False

    # Use deepcopy of defaults to avoid modifying the original DEFAULT_CONFIG
    defaults = copy.deepcopy(DEFAULT_CONFIG)

    # Check format version first
    if validated_config.get("format_version") != CURRENT_FORMAT_VERSION:
        print("Warning: Config file format mismatch or missing. Applying defaults.")
        base_config = defaults  # Start with defaults
        base_config.update(validated_config)  # Overwrite defaults with loaded values
        validated_config = base_config
        config_was_modified = True

    # Ensure essential top-level keys exist
    for key, value in defaults.items():
        if key not in validated_config:
            print(
                f"Config Warning: Missing top-level key '{key}', adding from default."
            )
            validated_config[key] = value  # Add default value (already copied)
            config_was_modified = True

    # Ensure controls exist and have all sub-keys
    default_controls = defaults.get("controls", {})
    loaded_controls = validated_config.get("controls", {})
    if not isinstance(loaded_controls, dict):
        print(
            "Config Warning: 'controls' key is not a dictionary. Resetting to default."
        )
        loaded_controls = default_controls  # Use copied defaults
        validated_config["controls"] = loaded_controls
        config_was_modified = True

    for control_key, default_control_data in default_controls.items():
        if control_key not in loaded_controls:
            print(
                f"Config Warning: Missing control '{control_key}', adding from default."
            )
            loaded_controls[control_key] = default_control_data  # Use copied defaults
            config_was_modified = True
        elif isinstance(loaded_controls[control_key], dict):
            loaded_control_data = loaded_controls[control_key]
            for sub_key, default_sub_value in default_control_data.items():
                if sub_key not in loaded_control_data:
                    print(
                        f"Config Warning: Missing sub-key '{sub_key}' in control '{control_key}', adding."
                    )
                    loaded_control_data[sub_key] = default_sub_value
                    config_was_modified = True
        else:
            print(
                f"Config Warning: Control '{control_key}' is not a dictionary. Resetting."
            )
            loaded_controls[control_key] = default_control_data  # Use copied defaults
            config_was_modified = True

    # Convert/Validate Tile Colors and add QColor objects
    loaded_tiles = validated_config.get("tiles", {})
    if not isinstance(loaded_tiles, dict):
        print("Config Warning: 'tiles' key is not a dictionary. Resetting.")
        loaded_tiles = defaults["tiles"]  # Use copied defaults
        validated_config["tiles"] = loaded_tiles
        config_was_modified = True

    for tile_char, tile_data in loaded_tiles.items():
        if not isinstance(tile_data, dict):
            print(
                f"Config Warning: Data for tile '{tile_char}' is not dict. Using fallback."
            )
            loaded_tiles[tile_char] = {
                "color": [255, 0, 255],
                "description": f"Invalid Tile '{tile_char}'",
            }
            tile_data = loaded_tiles[tile_char]
            config_was_modified = True

        # Ensure color_qt is created if missing or invalid
        create_color = False
        if "color_qt" not in tile_data or not isinstance(tile_data["color_qt"], QColor):
            create_color = True

        if create_color:
            if (
                isinstance(tile_data.get("color"), list)
                and len(tile_data["color"]) == 3
            ):
                rgb = tile_data["color"]
                try:
                    tile_data["color_qt"] = QColor(rgb[0], rgb[1], rgb[2])
                except (TypeError, ValueError):
                    print(
                        f"Warning: Invalid color values for tile '{tile_char}'. Fallback."
                    )
                    tile_data["color_qt"] = QColor(255, 0, 255)
                    if tile_data.get("color") != [255, 0, 255]:
                        config_was_modified = True
                    tile_data["color"] = [255, 0, 255]
            else:
                print(
                    f"Warning: Invalid/Missing color for tile '{tile_char}'. Fallback."
                )
                tile_data["color_qt"] = QColor(255, 0, 255)
                if tile_data.get("color") != [255, 0, 255]:
                    config_was_modified = True
                tile_data["color"] = [255, 0, 255]

    # Convert/Validate Preview Color and add QColor
    preview_rgb = validated_config.get(
        "preview_line_color", defaults["preview_line_color"]
    )
    create_preview_color = False
    if "preview_line_color_qt" not in validated_config or not isinstance(
        validated_config["preview_line_color_qt"], QColor
    ):
        create_preview_color = True

    if create_preview_color:
        if isinstance(preview_rgb, list) and len(preview_rgb) == 3:
            try:
                validated_config["preview_line_color_qt"] = QColor(
                    preview_rgb[0], preview_rgb[1], preview_rgb[2]
                )
            except (TypeError, ValueError):
                print("Warning: Invalid preview_line_color value. Using default.")
                default_rgb = defaults["preview_line_color"]
                validated_config["preview_line_color_qt"] = QColor(*default_rgb)
                if validated_config.get("preview_line_color") != default_rgb:
                    config_was_modified = True
                validated_config["preview_line_color"] = default_rgb
        else:
            print("Warning: Invalid preview_line_color format. Using default.")
            default_rgb = defaults["preview_line_color"]
            validated_config["preview_line_color_qt"] = QColor(*default_rgb)
            if validated_config.get("preview_line_color") != default_rgb:
                config_was_modified = True
            validated_config["preview_line_color"] = default_rgb

    # Validate numeric settings
    for key in [
        "preview_line_thickness",
        "tile_size",
        "min_tile_size",
        "max_tile_size",
        "pan_step",
    ]:
        val = validated_config.get(key, defaults[key])
        if not isinstance(val, int) or val < 1:
            print(f"Config Warning: Invalid value for '{key}'. Using default.")
            validated_config[key] = defaults[key]
            config_was_modified = True
    zoom_val = validated_config.get("zoom_step", defaults["zoom_step"])
    if not isinstance(zoom_val, (float, int)) or zoom_val <= 1.0:
        print("Config Warning: Invalid value for 'zoom_step'. Using default.")
        validated_config["zoom_step"] = defaults["zoom_step"]
        config_was_modified = True

    # Validate min/max tile size relation and clamp current size
    if validated_config.get("min_tile_size", 1) >= validated_config.get(
        "max_tile_size", 64
    ):
        print("Config Warning: min_tile_size >= max_tile_size. Resetting.")
        validated_config["min_tile_size"] = defaults["min_tile_size"]
        validated_config["max_tile_size"] = defaults["max_tile_size"]
        config_was_modified = True
    validated_config["tile_size"] = max(
        validated_config["min_tile_size"],
        min(validated_config["tile_size"], validated_config["max_tile_size"]),
    )

    return validated_config, config_was_modified


def load_config(filepath: str = CONFIG_FILE) -> dict:
    """
    Loads configuration from JSON file.
    Returns a validated config dictionary (using defaults on failure/missing).
    """
    loaded_config_dict = None
    config_to_use = None
    config_was_modified = False

    try:
        if os.path.exists(filepath):
            with open(filepath, FILE_READ_MODE) as f:
                content = f.read()
                if not content:
                    print(f"Warning: Config file {filepath} is empty. Using defaults.")
                    # Proceed as if file doesn't exist
                elif USE_ORJSON:
                    loaded_config_dict = JSON_HANDLER.loads(
                        content, **JSON_LOADS_KWARGS
                    )
                else:
                    # Use StringIO for standard json from string
                    config_io = (
                        io.StringIO(content)
                        if isinstance(content, str)
                        else io.BytesIO(content)
                    )
                    loaded_config_dict = JSON_HANDLER.load(
                        config_io, **JSON_LOADS_KWARGS
                    )

                if isinstance(loaded_config_dict, dict):
                    config_to_use, config_was_modified = _validate_and_populate_config(
                        loaded_config_dict
                    )
                    print(f"Configuration loaded and validated from {filepath}")
                else:
                    print(
                        f"Warning: Invalid config format in {filepath}. Using defaults."
                    )
                    # Fall through to default handling

        else:  # File does not exist
            print(
                f"Warning: Config file {filepath} not found. Using defaults and creating file."
            )
            config_was_modified = True
            # Fall through to default handling

    except JSON_DecodeError as e:
        print(f"Error: Could not decode JSON from {filepath}: {e}. Using defaults.")
    except Exception as e:
        print(f"Error loading configuration: {e}. Using defaults.")
        traceback.print_exc()  # Show traceback for unexpected load errors

    # --- Default Handling ---
    # If config_to_use is still None, it means loading failed or file didn't exist
    if config_to_use is None:
        print("Using default configuration.")
        # Deepcopy ensures defaults are fresh each time
        config_to_use = copy.deepcopy(DEFAULT_CONFIG)
        # Populate QColor objects for the defaults
        config_to_use, _ = _validate_and_populate_config(config_to_use)
        # Mark as modified if we had to generate defaults (might trigger save)
        config_was_modified = True  # True if file didn't exist or load failed

    # Save if needed (e.g., file missing, format updated, defaults added)
    if config_was_modified:
        print("Attempting to save updated/default configuration...")
        if save_config(filepath, config_to_use):
            print("Configuration saved successfully.")
        else:
            print("Error: Failed to save configuration file.")

    return config_to_use


def save_config(filepath: str, config_data: dict) -> bool:
    """
    Saves the configuration dictionary to a JSON file.
    Removes temporary QColor objects before saving.
    Returns True on success, False on failure.
    """
    try:
        # Prepare data for serialization (remove non-serializable QColor)
        save_data = {}
        keys_to_skip = ["tiles"]  # Handle separately

        for key, value in config_data.items():
            if key.endswith("_qt") or key in keys_to_skip:
                continue
            save_data[key] = value  # Copy serializable data

        # Process 'tiles' to store only RGB lists
        save_data["tiles"] = {}
        for char, tile_info in config_data.get("tiles", {}).items():
            color_list = [255, 0, 255]  # Default fallback
            # Try getting color from list first, then QColor
            if (
                isinstance(tile_info.get("color"), list)
                and len(tile_info["color"]) == 3
            ):
                color_list = tile_info["color"]
            elif isinstance(tile_info.get("color_qt"), QColor):
                cq = tile_info["color_qt"]
                color_list = [cq.red(), cq.green(), cq.blue()]

            save_data["tiles"][char] = {
                "color": color_list,
                "description": tile_info.get("description", ""),
            }

        # Ensure essential keys are present (use DEFAULT_CONFIG as ultimate fallback)
        essential_keys = [
            "format_version",
            "grid_width",
            "grid_height",
            "tile_size",
            "min_tile_size",
            "max_tile_size",
            "zoom_step",
            "pan_step",
            "default_tile",
            "wall_tile",
            "door_tile",
            "window_title",
            "preview_line_color",
            "preview_line_thickness",
            "controls",
        ]
        for key in essential_keys:
            if key not in save_data:
                # Get value from current config or default config
                save_data[key] = config_data.get(key, DEFAULT_CONFIG.get(key))
                # Special case: ensure preview color list is correct
                if key == "preview_line_color" and isinstance(
                    config_data.get("preview_line_color_qt"), QColor
                ):
                    pvc = config_data["preview_line_color_qt"]
                    save_data[key] = [pvc.red(), pvc.green(), pvc.blue()]

        # Ensure format version is current
        save_data["format_version"] = CURRENT_FORMAT_VERSION

        # Write using the selected handler and mode
        with open(filepath, FILE_WRITE_MODE) as f:
            if USE_ORJSON:
                f.write(JSON_HANDLER.dumps(save_data, **JSON_DUMPS_KWARGS))
            else:
                JSON_HANDLER.dump(save_data, f, **JSON_DUMPS_KWARGS)

        # print(f"Configuration saved to {filepath}") # Keep print optional?
        return True
    except Exception as e:
        print(f"Error saving configuration to {filepath}: {e}")
        traceback.print_exc()  # Show traceback for save errors
        return False

```

`basicrl/tile_mapper/tile_mapper_core.py`:

```py
# tile_mapper_core.py

import os
import traceback

from PySide6.QtCore import QRect

# Assuming tile_mapper_config is in the same directory
from tile_mapper_config import (
    CURRENT_FORMAT_VERSION,
    FILE_READ_MODE,
    FILE_WRITE_MODE,
    JSON_DUMPS_KWARGS,
    JSON_HANDLER,
    JSON_LOADS_KWARGS,
    USE_ORJSON,
    JSON_DecodeError,
)


# --- TileMap Data Structure ---
class TileMap:
    """Stores and manages the grid data."""

    def __init__(self, width, height, default_tile):
        width = max(0, width)
        height = max(0, height)
        self.width = width
        self.height = height
        self.default_tile = default_tile
        # Initialize grid efficiently
        self.tiles = [[default_tile] * width for _ in range(height)]

    def set_tile(self, x, y, tile):
        """Sets the tile at the given grid coordinates. Returns True if changed."""
        if 0 <= x < self.width and 0 <= y < self.height:
            if self.tiles[y][x] != tile:  # Only change if different
                self.tiles[y][x] = tile
                return True
        return False

    def get_tile(self, x, y):
        """Gets the tile at the given grid coordinates."""
        if 0 <= x < self.width and 0 <= y < self.height:
            return self.tiles[y][x]
        return None  # Return None if out of bounds

    def get_unique_tiles(self):
        """Returns a set of unique tile characters used in the map."""
        unique_chars = set()
        for row in self.tiles:
            unique_chars.update(row)
        return unique_chars

    def export_map_data(self):
        """Exports just the map data part for multi-map saving."""
        return {
            "grid_width": self.width,
            "grid_height": self.height,
            "default_tile": self.default_tile,
            "rows": ["".join(row) for row in self.tiles],
        }

    def load_from_data(self, data, app_config):
        """Loads tile data from a dictionary, using app_config for default tile."""
        try:
            rows = data.get("rows", [])
            if not isinstance(rows, list):
                print("Error: Invalid map format - 'rows' key is not a list.")
                return False

            raw_height = data.get("grid_height")
            raw_width = data.get("grid_width")
            raw_default = data.get("default_tile")

            new_height = len(rows) if raw_height is None else int(raw_height)
            # Use passed app_config for default tile fallback
            map_default_tile = (
                app_config.get("default_tile", ".")
                if raw_default is None
                else str(raw_default)
            )
            if new_height < 0:
                new_height = 0

            new_width = 0
            if raw_width is not None:
                new_width = int(raw_width)
            elif new_height > 0 and rows and isinstance(rows[0], str):
                new_width = max(len(r) for r in rows) if rows else 0
            if new_width < 0:
                new_width = 0

            if not all(isinstance(row, str) for row in rows):
                print("Error: Invalid map format - not all rows are strings.")
                return False

            padded_rows = []
            row_lengths_consistent = True
            if new_width > 0:
                for row in rows:
                    row_len = len(row)
                    if row_len != new_width:
                        row_lengths_consistent = False
                        padded_rows.append(row.ljust(new_width, map_default_tile))
                    else:
                        padded_rows.append(row)
                if not row_lengths_consistent:
                    print(f"Warning: Rows padded to width {new_width}.")
            else:
                padded_rows = rows

            if len(padded_rows) != new_height:
                print(
                    f"Warning: Height mismatch. Using actual row count {len(padded_rows)}."
                )
                new_height = len(padded_rows)

            self.height = new_height
            self.width = new_width
            self.default_tile = map_default_tile
            self.tiles = [[map_default_tile] * new_width for _ in range(new_height)]

            copy_h = min(len(padded_rows), new_height)
            for y in range(copy_h):
                row_list = list(padded_rows[y])
                copy_w = min(len(row_list), new_width)
                self.tiles[y][:copy_w] = row_list[:copy_w]

            print(
                f"Loaded map data: {self.width}x{self.height}, Default: '{self.default_tile}'"
            )
            return True

        except (ValueError, TypeError) as e:
            print(f"Error processing map data values: {e}")
            return False
        except Exception as e:
            print(f"Error loading map data: {e}")
            traceback.print_exc()
            return False


# --- Core Map Logic Functions ---


def get_neighbors(x, y):
    """Returns 4-directional neighbors (up, down, left, right)."""
    return [(x - 1, y), (x + 1, y), (x, y - 1), (x, y + 1)]


def draw_line(tilemap: TileMap, start_pos, end_pos, tile: str) -> bool:
    """Draws a line of tiles using Bresenham's algorithm. Returns True if changed."""
    x1, y1 = start_pos.x(), start_pos.y()
    x2, y2 = end_pos.x(), end_pos.y()
    dx = abs(x2 - x1)
    dy = -abs(y2 - y1)
    sx = 1 if x1 < x2 else -1
    sy = 1 if y1 < y2 else -1
    err = dx + dy
    changed = False
    while True:
        if tilemap.set_tile(x1, y1, tile):
            changed = True
        if x1 == x2 and y1 == y2:
            break
        e2 = 2 * err
        if e2 >= dy:
            if x1 == x2:
                break  # Avoid infinite loop on vertical lines
            err += dy
            x1 += sx
        if e2 <= dx:
            if y1 == y2:
                break  # Avoid infinite loop on horizontal lines
            err += dx
            y1 += sy
    return changed


def fill_rectangle(tilemap: TileMap, start_pos, end_pos, tile: str) -> bool:
    """Fills a rectangle defined by start and end points. Returns True if changed."""
    x1, y1 = start_pos.x(), start_pos.y()
    x2, y2 = end_pos.x(), end_pos.y()
    min_x, max_x = min(x1, x2), max(x1, x2)
    min_y, max_y = min(y1, y2), max(y1, y2)
    changed = False
    for y in range(min_y, max_y + 1):
        for x in range(min_x, max_x + 1):
            if tilemap.set_tile(x, y, tile):
                changed = True
    return changed


def _flood_fill_find_area(
    tilemap: TileMap, start_x: int, start_y: int, match_tile_type: str | None = None
) -> set[tuple[int, int]]:
    """Helper: Finds contiguous area based on match_tile_type. Returns set of (x, y) tuples."""
    start_tile = tilemap.get_tile(start_x, start_y)
    if start_tile is None:
        return set()

    if match_tile_type is None:  # Mode 1: Fill non-default area
        if start_tile == tilemap.default_tile:
            return set()
        target_type = start_tile
    else:  # Mode 2: Fill specific type
        if start_tile != match_tile_type:
            return set()
        target_type = match_tile_type

    seen = set()
    frontier = [(start_x, start_y)]
    connected_area = set()

    while frontier:
        cx, cy = frontier.pop()
        if (
            not (0 <= cx < tilemap.width and 0 <= cy < tilemap.height)
            or (cx, cy) in seen
        ):
            continue

        current_tile = tilemap.get_tile(cx, cy)
        if current_tile == target_type:
            seen.add((cx, cy))
            connected_area.add((cx, cy))
            for nx, ny in get_neighbors(cx, cy):
                if (nx, ny) not in seen:
                    frontier.append((nx, ny))
        else:
            seen.add((cx, cy))

    return connected_area


def flood_fill_replace(
    tilemap: TileMap, start_x: int, start_y: int, fill_tile: str
) -> int:
    """Performs a classic flood fill replace. Returns number of tiles filled."""
    original_tile = tilemap.get_tile(start_x, start_y)
    if original_tile is None or original_tile == fill_tile:
        return 0

    q = [(start_x, start_y)]
    visited = set([(start_x, start_y)])
    filled_count = 0

    while q:
        x, y = q.pop(0)
        if tilemap.set_tile(x, y, fill_tile):
            filled_count += 1
            for nx, ny in get_neighbors(x, y):
                if (
                    0 <= nx < tilemap.width
                    and 0 <= ny < tilemap.height
                    and (nx, ny) not in visited
                    and tilemap.get_tile(nx, ny) == original_tile
                ):
                    visited.add((nx, ny))
                    q.append((nx, ny))

    print(
        f"Flood Fill: Replaced {filled_count} tiles of type '{original_tile}' with '{fill_tile}'."
    )
    return filled_count


def ctrl_click_fill(tilemap: TileMap, x: int, y: int, fill_tile: str) -> bool:
    """Fills perimeter of non-default area with fill_tile. Returns True if changed."""
    connected_area = _flood_fill_find_area(tilemap, x, y, match_tile_type=None)
    if not connected_area:
        print(f"Ctrl+Click: No non-default area found at ({x},{y}).")
        return False

    perimeter_to_fill = set()
    for cx, cy in connected_area:
        for nx, ny in get_neighbors(cx, cy):
            if 0 <= nx < tilemap.width and 0 <= ny < tilemap.height:
                neighbor_tile = tilemap.get_tile(nx, ny)
                if (
                    neighbor_tile == tilemap.default_tile
                    and (nx, ny) not in perimeter_to_fill
                ):
                    perimeter_to_fill.add((nx, ny))

    if not perimeter_to_fill:
        print("Ctrl+Click: Area found, but no default tile perimeter detected.")
        return False

    painted_count = 0
    for px, py in perimeter_to_fill:
        if tilemap.set_tile(px, py, fill_tile):
            painted_count += 1

    print(f"Ctrl+Click: Painted {painted_count} perimeter tiles with '{fill_tile}'.")
    return painted_count > 0


def ctrl_shift_click_wall(
    tilemap: TileMap, x: int, y: int, wall_fill_tile: str, app_config: dict
) -> bool:
    """Walls perimeter of same-tile area, respecting walls/doors. Returns True if changed."""
    clicked_tile_type = tilemap.get_tile(x, y)
    wall_char = app_config.get("wall_tile", "#")
    door_char = app_config.get("door_tile", "+")
    protected_chars = {wall_char, door_char}

    if clicked_tile_type is None or clicked_tile_type == tilemap.default_tile:
        print(
            f"Ctrl+Shift+Click: Cannot wall from default '{tilemap.default_tile}' or outside."
        )
        return False

    connected_area = _flood_fill_find_area(
        tilemap, x, y, match_tile_type=clicked_tile_type
    )
    if not connected_area:
        print(
            f"Ctrl+Shift+Click: No contiguous area of type '{clicked_tile_type}' found."
        )
        return False

    perimeter_to_wall = set()
    for cx, cy in connected_area:
        for nx, ny in get_neighbors(cx, cy):
            if 0 <= nx < tilemap.width and 0 <= ny < tilemap.height:
                if (
                    nx,
                    ny,
                ) not in connected_area:  # Add if neighbor is outside the area
                    perimeter_to_wall.add((nx, ny))

    if not perimeter_to_wall:
        print(
            f"Ctrl+Shift+Click: Area of '{clicked_tile_type}' found, but no perimeter detected."
        )
        return False

    painted_count = 0
    skipped_count = 0
    for px, py in perimeter_to_wall:
        existing_tile = tilemap.get_tile(px, py)
        if existing_tile not in protected_chars:
            if tilemap.set_tile(px, py, wall_fill_tile):
                painted_count += 1
        else:
            skipped_count += 1

    print(
        f"Ctrl+Shift+Click: Painted {painted_count} perimeter tiles with '{wall_fill_tile}'. Skipped {skipped_count} protected."
    )
    return painted_count > 0


# --- Region Extraction / Saving Logic ---


def extract_map_region(source_tilemap: TileMap, selection: QRect) -> dict | None:
    """
    Extracts tile data from a specified rectangular region of a TileMap.
    QRect coordinates are assumed to be grid coordinates.

    Returns:
        A dictionary containing the extracted map data ('width', 'height',
        'default_tile', 'rows'), or None if selection is invalid.
    """
    start_x, start_y = selection.left(), selection.top()
    # QRect width/height represent number of cells
    new_width = selection.width()
    new_height = selection.height()
    end_x = start_x + new_width  # Exclusive end for slicing
    end_y = start_y + new_height  # Exclusive end for slicing

    # Validate coordinates fully
    if not (
        0 <= start_x < source_tilemap.width
        and 0 <= start_y < source_tilemap.height
        and 0 < end_x <= source_tilemap.width
        and 0 < end_y <= source_tilemap.height
        and new_width > 0
        and new_height > 0
    ):
        print(f"Error: Invalid selection rectangle coordinates: {selection.getRect()}")
        return None

    new_rows = []
    try:
        for y in range(start_y, end_y):
            # Slice the row directly
            row_segment = source_tilemap.tiles[y][start_x:end_x]
            new_rows.append("".join(row_segment))
    except IndexError:
        print("Error: Index out of bounds during region extraction.")
        traceback.print_exc()
        return None

    # Use the source map's default tile for the extracted region
    new_default = source_tilemap.default_tile

    return {
        "grid_width": new_width,
        "grid_height": new_height,
        "default_tile": new_default,
        "rows": new_rows,
    }


def save_extracted_map(
    target_filepath: str, new_map_key: str, extracted_map_data: dict
) -> bool:
    """Loads target JSON, adds/updates the map entry for the new key, saves back."""
    if not new_map_key:
        print("Error: New map key cannot be empty.")
        return False
    if not extracted_map_data:
        print("Error: No extracted map data provided.")
        return False

    file_data = {"format_version": CURRENT_FORMAT_VERSION, "maps": {}}
    if os.path.exists(target_filepath):
        try:
            with open(target_filepath, FILE_READ_MODE) as f:
                content = f.read()
                if content:
                    existing_data = JSON_HANDLER.loads(content, **JSON_LOADS_KWARGS)
                    # Basic validation of existing format
                    if isinstance(existing_data, dict) and isinstance(
                        existing_data.get("maps"), dict
                    ):
                        file_data = existing_data
                        # Ensure format version is updated/present
                        file_data["format_version"] = CURRENT_FORMAT_VERSION
                    else:
                        print(
                            f"Warning: File '{target_filepath}' has invalid format. Overwriting."
                        )
                        # Keep file_data as the default new structure
                # else: file is empty, keep default structure
        except (JSON_DecodeError, IOError, Exception) as e:
            print(
                f"Warning: Could not read/parse existing file '{target_filepath}': {e}. Will overwrite."
            )
            # Keep file_data as the default new structure, existing data lost

    # Add/overwrite the extracted map data
    file_data["maps"][new_map_key] = extracted_map_data

    # Save back using appropriate handler
    try:
        with open(target_filepath, FILE_WRITE_MODE) as f:
            if USE_ORJSON:
                f.write(JSON_HANDLER.dumps(file_data, **JSON_DUMPS_KWARGS))
            else:
                JSON_HANDLER.dump(file_data, f, **JSON_DUMPS_KWARGS)
        print(f"Extracted map '{new_map_key}' saved successfully to {target_filepath}")
        return True
    except Exception as e:
        print(f"Error saving extracted map to {target_filepath}: {e}")
        traceback.print_exc()
        return False

```

`basicrl/tile_mapper/tile_mapper_dialogs.py`:

```py
# tile_mapper_dialogs.py

import re

from PySide6.QtGui import QColor
from PySide6.QtWidgets import (
    QAbstractItemView,
    QColorDialog,
    QComboBox,
    QDialog,
    QDialogButtonBox,
    QFormLayout,
    QHBoxLayout,
    QLabel,
    QLineEdit,
    QListWidget,
    QMessageBox,
    QPushButton,
    QSpinBox,
    QVBoxLayout,
)

# Import constants/functions from config if needed by dialogs (e.g., for default tile checks)
# Example: from .tile_mapper_config import CONFIG_FILE (adjust path as needed)
from tile_mapper_config import CONFIG_FILE  # Assuming flat structure for now


# --- Edit Tile Dialog ---
class EditTileDialog(QDialog):
    """Dialog for adding or editing a tile type."""

    def __init__(
        self,
        tile_char=None,
        tile_data=None,
        existing_chars=None,
        parent=None,
        app_config=None,
    ):
        """Requires app_config dict to check current default tile."""
        super().__init__(parent)
        self.setWindowTitle("Edit Tile" if tile_char else "Add New Tile")
        self.existing_chars = existing_chars if existing_chars is not None else set()
        self.original_char = tile_char
        self.is_editing = tile_char is not None
        self.app_config = app_config if app_config else {}  # Store config reference

        # Widgets
        self.char_edit = QLineEdit(tile_char if tile_char else "")
        self.char_edit.setMaxLength(1)
        self.desc_edit = QLineEdit(
            tile_data.get("description", "") if tile_data else ""
        )
        self.color_button = QPushButton()
        self.color_button.setFixedSize(40, 25)
        self.color_button.setFlat(False)

        initial_color = QColor(200, 200, 200)  # Default gray
        if tile_data:
            color_qt = tile_data.get("color_qt")
            if isinstance(color_qt, QColor):
                initial_color = color_qt
            elif (
                isinstance(tile_data.get("color"), list)
                and len(tile_data["color"]) == 3
            ):
                try:
                    initial_color = QColor(*tile_data["color"])
                except (TypeError, ValueError):
                    pass

        self.set_button_color(initial_color)
        self.color_button.clicked.connect(self.pick_color)

        # Layout
        form_layout = QFormLayout()
        form_layout.addRow("Character:", self.char_edit)
        form_layout.addRow("Description:", self.desc_edit)
        form_layout.addRow("Color:", self.color_button)

        # Dialog Buttons
        self.button_box = QDialogButtonBox(
            QDialogButtonBox.StandardButton.Ok | QDialogButtonBox.StandardButton.Cancel
        )
        self.button_box.accepted.connect(self.validate_and_accept)
        self.button_box.rejected.connect(self.reject)

        # Main Layout
        main_layout = QVBoxLayout()
        main_layout.addLayout(form_layout)
        main_layout.addWidget(self.button_box)
        self.setLayout(main_layout)
        self.setMinimumWidth(300)

    def set_button_color(self, color):
        """Sets the background color and stores the QColor."""
        self.current_color = color
        self.color_button.setStyleSheet(
            f"background-color: {color.name()}; border: 1px solid black;"
        )

    def pick_color(self):
        """Opens a color dialog to choose a new color."""
        new_color = QColorDialog.getColor(self.current_color, self, "Select Tile Color")
        if new_color.isValid():
            self.set_button_color(new_color)

    def validate_and_accept(self):
        """Validates input before accepting the dialog."""
        char = self.char_edit.text()
        if not char:
            QMessageBox.warning(
                self, "Validation Error", "Tile character cannot be empty."
            )
            return
        if len(char) > 1:
            QMessageBox.warning(
                self, "Validation Error", "Tile character must be a single character."
            )
            return
        if char != self.original_char and char in self.existing_chars:
            QMessageBox.warning(
                self, "Validation Error", f"Character '{char}' already used."
            )
            return

        # Use stored app_config reference
        current_default = self.app_config.get("default_tile", ".")
        if (
            self.is_editing
            and self.original_char == current_default
            and char != current_default
        ):
            reply = QMessageBox.warning(
                self,
                "Confirm Default Tile Change",
                f"Changing character ('{self.original_char}') designated as 'default_tile'.\n\n"
                f"Update 'default_tile' in '{CONFIG_FILE}' manually if needed.\n\n"
                f"Proceed?",
                QMessageBox.StandardButton.Yes | QMessageBox.StandardButton.No,
                QMessageBox.StandardButton.No,
            )
            if reply == QMessageBox.StandardButton.No:
                return

        self.accept()

    def get_tile_data(self):
        """Returns the entered tile data."""
        return {
            "char": self.char_edit.text(),
            "data": {
                "description": self.desc_edit.text(),
                "color_qt": self.current_color,
                "color": [
                    self.current_color.red(),
                    self.current_color.green(),
                    self.current_color.blue(),
                ],
            },
        }


# --- Map Selection Dialog ---
class MapSelectionDialog(QDialog):
    """Dialog for selecting maps from a multi-map file."""

    def __init__(self, map_keys, parent=None):
        super().__init__(parent)
        self.setWindowTitle("Select Maps to Load")
        self.map_keys = map_keys
        self.selected_keys = []
        self.tiling_mode = "Single"
        self.grid_rows = 1
        self.grid_cols = 1

        layout = QVBoxLayout()
        self.list_widget = QListWidget()
        self.list_widget.setSelectionMode(
            QAbstractItemView.SelectionMode.ExtendedSelection
        )
        self.list_widget.addItems(self.map_keys)
        layout.addWidget(QLabel("Available Maps:"))
        layout.addWidget(self.list_widget)

        self.selection_input = QLineEdit()
        self.selection_input.setPlaceholderText("Or enter e.g., 1, 3-5, lobby, all")
        layout.addWidget(QLabel("Selection String:"))
        layout.addWidget(self.selection_input)

        # Tiling Options
        tiling_layout = QHBoxLayout()
        tiling_layout.addWidget(QLabel("Tiling:"))
        self.tiling_combo = QComboBox()
        self.tiling_combo.addItems(["Single", "Vertical", "Horizontal", "Grid"])
        self.tiling_combo.currentTextChanged.connect(self.update_grid_options)
        tiling_layout.addWidget(self.tiling_combo)
        self.rows_label = QLabel("Rows:")
        self.rows_spin = QSpinBox()
        self.rows_spin.setMinimum(1)
        self.rows_spin.setValue(2)
        self.cols_label = QLabel("Cols:")
        self.cols_spin = QSpinBox()
        self.cols_spin.setMinimum(1)
        self.cols_spin.setValue(2)
        tiling_layout.addWidget(self.rows_label)
        tiling_layout.addWidget(self.rows_spin)
        tiling_layout.addWidget(self.cols_label)
        tiling_layout.addWidget(self.cols_spin)
        tiling_layout.addStretch()
        layout.addLayout(tiling_layout)
        self.update_grid_options("Single")  # Initial state

        # Dialog Buttons
        button_box = QDialogButtonBox(
            QDialogButtonBox.StandardButton.Ok | QDialogButtonBox.StandardButton.Cancel
        )
        button_box.accepted.connect(self.process_selection)
        button_box.rejected.connect(self.reject)
        layout.addWidget(button_box)

        self.setLayout(layout)
        self.setMinimumWidth(400)

    def update_grid_options(self, tiling_mode):
        is_grid = tiling_mode == "Grid"
        self.rows_label.setVisible(is_grid)
        self.rows_spin.setVisible(is_grid)
        self.cols_label.setVisible(is_grid)
        self.cols_spin.setVisible(is_grid)

    def parse_selection_string(self, selection_str):
        """Parses a selection string like '1, 3-5, lobby, all'."""
        selected = set()
        parts = selection_str.split(",")
        all_keys_set = set(self.map_keys)

        if "all" in [p.strip().lower() for p in parts]:
            return self.map_keys

        for part in parts:
            part = part.strip()
            if not part:
                continue

            range_match = re.match(r"^(\d+)\s*-\s*(\d+)$", part)
            if range_match:
                try:
                    start, end = int(range_match.group(1)), int(range_match.group(2))
                    if start <= end:
                        for key in self.map_keys:
                            try:
                                if start <= int(key) <= end:
                                    selected.add(key)
                            except ValueError:
                                continue
                    else:
                        print(f"Warning: Invalid range '{part}'.")
                except ValueError:
                    print(f"Warning: Could not parse range '{part}'.")
            elif part in all_keys_set:
                selected.add(part)
            else:
                print(f"Warning: Unknown map key or invalid format '{part}'.")

        return sorted(
            list(selected),
            key=lambda k: (
                self.map_keys.index(k) if k in self.map_keys else float("inf")
            ),
        )

    def process_selection(self):
        """Processes list selection and input string, validates."""
        input_str = self.selection_input.text().strip()
        list_selected_items = self.list_widget.selectedItems()

        self.selected_keys = []
        if input_str:
            self.selected_keys = self.parse_selection_string(input_str)
        elif list_selected_items:
            self.selected_keys = [item.text() for item in list_selected_items]

        if not self.selected_keys:
            QMessageBox.warning(
                self,
                "No Selection",
                "Please select maps or enter a valid selection string.",
            )
            return

        self.tiling_mode = self.tiling_combo.currentText()
        num_selected = len(self.selected_keys)

        if num_selected <= 1 and self.tiling_mode != "Single":
            print("Info: Tiling mode reset to 'Single' for single map selection.")
            self.tiling_mode = "Single"
            self.tiling_combo.setCurrentText("Single")
        elif num_selected > 1 and self.tiling_mode == "Single":
            QMessageBox.warning(
                self,
                "Invalid Tiling",
                "Please choose Vertical, Horizontal, or Grid for multiple maps.",
            )
            return

        self.grid_rows = self.rows_spin.value() if self.tiling_mode == "Grid" else 1
        self.grid_cols = self.cols_spin.value() if self.tiling_mode == "Grid" else 1

        if (
            self.tiling_mode == "Grid"
            and self.grid_rows * self.grid_cols < num_selected
        ):
            QMessageBox.warning(
                self,
                "Grid Too Small",
                f"Grid ({self.grid_rows}x{self.grid_cols}) too small for {num_selected} maps.",
            )
            return

        self.accept()

    def get_selection(self):
        """Returns the selected map keys and tiling options."""
        return self.selected_keys, self.tiling_mode, self.grid_rows, self.grid_cols

```

`basicrl/tile_mapper/tile_mapper_gui.py`:

```py
# tile_mapper_gui.py
# v6: Rigorous import check, including QDialog and others.

import math
import os
import traceback

from PySide6.QtCore import QRect, QSize, Qt, QTimer
from PySide6.QtGui import QAction, QColor, QIcon, QKeySequence, QPalette

# --- PySide6 Imports - Thoroughly Checked ---
from PySide6.QtWidgets import QColorDialog  # Added QColorDialog explicitly where used
from PySide6.QtWidgets import QDialog  # Added QDialog
from PySide6.QtWidgets import (
    QApplication,
    QFileDialog,
    QInputDialog,
    QMainWindow,
    QMessageBox,
    QScrollArea,
    QToolBar,
    QVBoxLayout,
    QWidget,
)

# --- Project Module Imports ---
from tile_mapper_config import (
    CONFIG_FILE,
    FILE_READ_MODE,
    JSON_HANDLER,
    JSON_DecodeError,
    load_config,
    save_config,
)
from tile_mapper_core import TileMap, extract_map_region, save_extracted_map
from tile_mapper_dialogs import (
    MapSelectionDialog,
)  # EditTileDialog used in palette, MapSelectionDialog used here
from tile_mapper_widgets import TileEditorWidget, TilePaletteWidget


# --- Main Application Window ---
class MainWindow(QMainWindow):
    """The main application window."""

    def __init__(self):
        super().__init__()
        self.app_config = load_config(CONFIG_FILE)
        self.setWindowTitle(self.app_config.get("window_title", "Tile Editor"))
        self.tilemap = TileMap(
            self.app_config.get("grid_width", 40),
            self.app_config.get("grid_height", 40),
            self.app_config.get("default_tile", "."),
        )
        self.current_filepath = None

        # --- UI Setup ---
        self.scroll_area = QScrollArea()
        self.scroll_area.setBackgroundRole(QPalette.ColorRole.Dark)
        self.scroll_area.setWidgetResizable(False)
        self.scroll_area.setAlignment(Qt.AlignmentFlag.AlignCenter)

        self.editor_widget = TileEditorWidget(
            self.tilemap, self.scroll_area, self.app_config, self
        )
        self.palette_widget = TilePaletteWidget(
            self.editor_widget, self.app_config, self
        )
        self.scroll_area.setWidget(self.editor_widget)

        main_layout = QVBoxLayout()
        main_layout.addWidget(self.palette_widget)
        main_layout.addWidget(self.scroll_area, 1)
        central_widget = QWidget()
        central_widget.setLayout(main_layout)
        self.setCentralWidget(central_widget)

        self.create_actions()
        self.create_menu_bar()
        self.create_tool_bar()
        self.statusBar()  # Ensure status bar exists

        self.resize(800, 650)

        # --- Signal Connections ---
        self.editor_widget.map_changed.connect(self.update_window_title)
        self.editor_widget.map_changed.connect(self.center_map_view_if_needed)
        self.palette_widget.palette_updated.connect(
            self.editor_widget.update_widget_size
        )
        self.editor_widget.selection_rect_changed.connect(
            self._update_selection_actions
        )

        # --- Final Init Steps ---
        self.editor_widget.setFocus()
        self.update_window_title()
        self._update_selection_actions(QRect())  # Init action state
        QTimer.singleShot(0, self.center_map_view)  # Initial center

    # --- Window Title ---
    def update_window_title(self):
        """Updates the window title with map dimensions and filename."""
        base_title = self.app_config.get("window_title", "Tile Editor")
        filename_part = (
            f" - {os.path.basename(self.current_filepath)}"
            if self.current_filepath
            else ""
        )
        dims_part = f" ({self.tilemap.width}x{self.tilemap.height})"
        self.setWindowTitle(f"{base_title}{filename_part}{dims_part}")

    # --- Actions, Menus, Toolbar ---
    def create_actions(self):
        """Creates QAction objects for menu items and toolbar."""
        # File Actions
        self.load_action = QAction(
            QIcon.fromTheme("document-open"), "&Load Map...", self
        )
        self.load_action.setShortcut(QKeySequence.StandardKey.Open)
        self.load_action.setStatusTip("Load maps from JSON")
        self.load_action.triggered.connect(self.load_map)

        self.load_text_action = QAction(
            QIcon.fromTheme("document-open"), "Load &Text Layout...", self
        )
        self.load_text_action.setStatusTip("Import map from text")
        self.load_text_action.triggered.connect(self.load_text_layout)

        self.save_action = QAction(
            QIcon.fromTheme("document-save"), "&Save Map...", self
        )
        self.save_action.setShortcut(QKeySequence.StandardKey.Save)
        self.save_action.setStatusTip("Save current map to named entry in JSON")
        self.save_action.triggered.connect(self.save_map)

        self.save_selection_action = QAction(
            QIcon.fromTheme("document-save-as"), "Save Selection As Map...", self
        )
        self.save_selection_action.setStatusTip(
            "Save selected region as new named map entry"
        )
        self.save_selection_action.triggered.connect(self.save_selection_as_map)
        self.save_selection_action.setEnabled(False)

        self.exit_action = QAction(QIcon.fromTheme("application-exit"), "E&xit", self)
        self.exit_action.setShortcut(QKeySequence.StandardKey.Quit)
        self.exit_action.setStatusTip("Exit")
        self.exit_action.triggered.connect(self.close)

        # Edit Actions
        self.select_tool_action = QAction(
            QIcon.fromTheme("edit-select"), "Select Region Tool", self
        )
        self.select_tool_action.setStatusTip("Activate region selection (click-drag)")
        self.select_tool_action.setCheckable(True)
        self.select_tool_action.triggered.connect(self.toggle_selection_tool)

        # Help Action
        help_ctrl = self._find_control_by_action("show_help")
        help_key = help_ctrl.get("key", "F1") if help_ctrl else "F1"
        self.help_action = QAction(QIcon.fromTheme("help-contents"), "&Help...", self)
        self.help_action.setStatusTip("Show controls")
        try:
            std_key = getattr(QKeySequence.StandardKey, help_key, None)
            self.help_action.setShortcut(std_key or QKeySequence(help_key))
        except Exception:
            self.help_action.setShortcut(QKeySequence("F1"))
        self.help_action.triggered.connect(self.show_help_dialog)

    def create_menu_bar(self):
        """Creates the main menu bar."""
        menu_bar = self.menuBar()
        file_menu = menu_bar.addMenu("&File")
        file_menu.addAction(self.load_action)
        file_menu.addAction(self.load_text_action)
        file_menu.addAction(self.save_action)
        file_menu.addAction(self.save_selection_action)
        file_menu.addSeparator()
        file_menu.addAction(self.exit_action)
        edit_menu = menu_bar.addMenu("&Edit")
        edit_menu.addAction(self.select_tool_action)
        help_menu = menu_bar.addMenu("&Help")
        help_menu.addAction(self.help_action)

    def create_tool_bar(self):
        """Creates the main toolbar."""
        toolbar = QToolBar("Main Toolbar")
        toolbar.setIconSize(QSize(16, 16))
        self.addToolBar(toolbar)
        toolbar.addAction(self.load_action)
        toolbar.addAction(self.save_action)
        toolbar.addSeparator()
        toolbar.addAction(self.select_tool_action)
        toolbar.addAction(self.save_selection_action)

    # --- Action Handlers / Slots ---
    def toggle_selection_tool(self, checked):
        """Activates/deactivates the selection tool in the editor widget."""
        if checked:
            self.editor_widget.start_selection()
        else:
            self.editor_widget.stop_selection()

    def _update_selection_actions(self, selection_rect: QRect):
        """Updates action states based on selection validity."""
        self.save_selection_action.setEnabled(selection_rect.isValid())

    def _find_control_by_action(self, action_name_to_find):
        """Helper using self.app_config."""
        return self.app_config.get("controls", {}).get(action_name_to_find)

    def _format_control_string(self, control_data):
        """Helper using self.app_config."""
        mod = control_data.get("modifier", "None")
        trig = control_data.get("trigger", "?")
        key = control_data.get("key")
        desc = control_data.get("description", "-")
        parts = []
        if mod and mod.lower() != "none":
            parts.append(mod)
        trig_map = {
            "LeftClick": "L Click",
            "RightClick": "R Click",
            "LeftDrag": "L Drag",
            "ScrollUp": "Scroll Up",
            "ScrollDown": "Scroll Down",
        }
        if trig == "KeyPress" and key:
            parts.append(f"'{key}' Key")
        else:
            parts.append(trig_map.get(trig, trig))
        return f"{' + '.join(parts)}: {desc}"

    def show_help_dialog(self):
        """Displays controls help."""
        help_text = "<h2>Controls Help</h2>"
        controls = self.app_config.get("controls", {})
        groups = {"Mouse": [], "Scroll": [], "Keyboard": []}
        sorted_ctrls = sorted(
            controls.items(), key=lambda item: item[1].get("description", "")
        )
        for name, data in sorted_ctrls:
            fmt = self._format_control_string(data)
            trig = data.get("trigger", "").lower()
            if "click" in trig or "drag" in trig:
                groups["Mouse"].append(fmt)
            elif "scroll" in trig:
                groups["Scroll"].append(fmt)
            elif "key" in trig:
                groups["Keyboard"].append(fmt)
        for group, items in groups.items():
            if items:
                help_text += (
                    f"<b>{group}:</b><ul>{''.join(f'<li>{c}</li>' for c in items)}</ul>"
                )
        # Use QMessageBox directly
        msg = QMessageBox(self)
        msg.setWindowTitle("Help")
        msg.setTextFormat(Qt.TextFormat.RichText)
        msg.setText(help_text)
        msg.setIcon(QMessageBox.Icon.Information)
        msg.setStandardButtons(QMessageBox.StandardButton.Ok)
        msg.exec()

    def save_map(self):
        """Saves the *entire current* map to a named entry in a JSON file."""
        default_dir = os.path.dirname(self.current_filepath or "")
        default_fname = os.path.basename(self.current_filepath or "map.json")
        # Use QFileDialog directly
        fpath, sel_filter = QFileDialog.getSaveFileName(
            self, "Save Map", os.path.join(default_dir, default_fname), "*.json"
        )
        if not fpath:
            return
        if "*.json" in sel_filter and not fpath.lower().endswith(".json"):
            fpath += ".json"

        # Use QInputDialog directly
        key, ok = QInputDialog.getText(self, "Map Key", "Enter name/key for this map:")
        if not ok or not key.strip():
            QMessageBox.warning(self, "Save", "Key empty.")
            return
            key = key.strip()

        map_data = self.tilemap.export_map_data()
        if save_extracted_map(fpath, key, map_data):  # Use core save function
            self.current_filepath = fpath
            self.update_window_title()
            self.statusBar().showMessage(f"Map '{key}' saved to {fpath}", 3000)
        else:
            QMessageBox.critical(self, "Error", f"Could not save to {fpath}")
            self.statusBar().showMessage("Save error.", 5000)

    def save_selection_as_map(self):
        """Saves the selected region as a new map entry."""
        selection = self.editor_widget.get_current_selection()
        if not selection:
            QMessageBox.warning(self, "Select", "Select region first.")
            return

        extracted = extract_map_region(self.tilemap, selection)
        if not extracted:
            QMessageBox.critical(self, "Error", "Could not extract region.")
            return

        default_dir = os.path.dirname(self.current_filepath or "")
        default_fname = os.path.basename(self.current_filepath or "map.json")
        # Use QFileDialog directly
        fpath, sel_filter = QFileDialog.getSaveFileName(
            self,
            "Save Selection To",
            os.path.join(default_dir, default_fname),
            "*.json",
        )
        if not fpath:
            return
        if "*.json" in sel_filter and not fpath.lower().endswith(".json"):
            fpath += ".json"

        # Use QInputDialog directly
        new_key, ok = QInputDialog.getText(
            self, "New Map Key", "Enter unique key for extracted map:"
        )
        if not ok or not new_key.strip():
            QMessageBox.warning(self, "Save", "Key empty.")
            return
            new_key = new_key.strip()

        if save_extracted_map(fpath, new_key, extracted):  # Use core save function
            self.statusBar().showMessage(
                f"Selection saved as '{new_key}' to {fpath}", 3000
            )
        else:
            QMessageBox.critical(
                self, "Error", f"Could not save extracted map to {fpath}"
            )
            self.statusBar().showMessage("Save error.", 5000)

    def load_map(self):
        """Loads map(s) from JSON."""
        # Use QFileDialog directly
        fpath, _ = QFileDialog.getOpenFileName(self, "Load Map(s)", "", "*.json")
        if not fpath:
            return

        try:
            # Use config module imports directly now
            with open(fpath, FILE_READ_MODE) as f:
                content = f.read()
            if not content:
                QMessageBox.critical(self, "Error", f"File empty: {fpath}")
                return
            file_content = JSON_HANDLER.loads(content)

            maps_to_load = {}
            mode, rows, cols = "Single", 1, 1
            sel_keys = []
            is_new = isinstance(file_content, dict) and isinstance(
                file_content.get("maps"), dict
            )

            if is_new:
                avail = file_content.get("maps", {})
                if not avail:
                    QMessageBox.information(self, "Empty", "No maps in file.")
                    return
                # Use MapSelectionDialog directly
                dialog = MapSelectionDialog(list(avail.keys()), self)
                if dialog.exec() == QDialog.DialogCode.Accepted:
                    sel_keys, mode, rows, cols = dialog.get_selection()
                    if not sel_keys:
                        return
                    maps_to_load = {
                        key: avail.get(key) for key in sel_keys if key in avail
                    }
                else:
                    return
            else:  # Old format
                if isinstance(file_content, dict) and "rows" in file_content:
                    maps_to_load["map_1"] = file_content
                    sel_keys = ["map_1"]
                else:
                    QMessageBox.critical(self, "Error", "Invalid map format.")
                    return

            if not maps_to_load:
                QMessageBox.warning(self, "Load", "No valid map data selected/found.")
                return

            # Validate maps & check tiles
            all_chars, temp_maps, valid_keys = set(), {}, []
            keys_proc = sel_keys if sel_keys else list(maps_to_load.keys())
            for k in keys_proc:
                data = maps_to_load.get(k)
                if not data:
                    continue
                temp = TileMap(0, 0, ".")
                if temp.load_from_data(data, self.app_config):  # Pass config
                    all_chars.update(temp.get_unique_tiles())
                    temp_maps[k] = temp
                    valid_keys.append(k)
                else:
                    QMessageBox.warning(self, "Warn", f"Skipping '{k}' (load error).")
            if not temp_maps:
                QMessageBox.critical(self, "Error", "No maps loaded.")
                return

            # Handle undefined tiles
            defined = set(self.app_config.get("tiles", {}).keys())
            undefined = all_chars - defined
            if undefined:
                modified = False
                added = []
                fb_color = [255, 0, 255]
                fb_q = QColor(*fb_color)  # Use QColor import
                for c in sorted(list(undefined)):
                    if c not in self.app_config.get("tiles", {}):
                        if "tiles" not in self.app_config:
                            self.app_config["tiles"] = {}
                        self.app_config["tiles"][c] = {
                            "color": fb_color,
                            "color_qt": fb_q,
                            "description": f"Undef '{c}'",
                        }
                        modified = True
                        added.append(c)
                if modified:
                    if save_config(
                        CONFIG_FILE, self.app_config
                    ):  # save_config imported
                        self.palette_widget.rebuild_palette()
                        QMessageBox.warning(
                            self,
                            "Tiles",
                            f"Added defaults: {', '.join(added)}\nConfig saved.",
                        )
                    else:
                        QMessageBox.critical(self, "Error", "Failed saving config.")

            # Combine maps
            valid_maps = {k: temp_maps[k] for k in valid_keys}
            combined = self._combine_maps(valid_maps, mode, rows, cols)

            # Load into editor
            self.editor_widget.selection_rect = None
            self.editor_widget.selection_rect_changed.emit(QRect())
            if self.select_tool_action.isChecked():
                self.select_tool_action.setChecked(False)
            self.editor_widget.resize_map(
                combined["width"],
                combined["height"],
                combined["default_tile"],
                combined["tiles"],
            )

            self.current_filepath = fpath
            self.update_window_title()
            self.statusBar().showMessage(f"Map(s) loaded from {fpath}", 3000)
            # Centering via signal

        except FileNotFoundError:
            QMessageBox.critical(self, "Error", f"File not found:\n{fpath}")
        except JSON_DecodeError as e:
            QMessageBox.critical(
                self, "Error", f"Invalid JSON:\n{fpath}\n{e}"
            )  # Use imported alias
        except Exception as e:
            QMessageBox.critical(self, "Error", f"Load error:\n{e}")
            traceback.print_exc()

    def _combine_maps(self, loaded_maps_dict, tiling_mode, grid_rows=1, grid_cols=1):
        """Combines multiple maps. Uses self.app_config for default tile."""
        map_keys = list(loaded_maps_dict.keys())
        if not map_keys:
            return {
                "width": 0,
                "height": 0,
                "default_tile": self.app_config.get("default_tile", "."),
                "tiles": [],
            }

        combined_default = self.app_config.get("default_tile", ".")
        total_w, total_h = 0, 0
        map_dims = {k: (m.width, m.height) for k, m in loaded_maps_dict.items()}
        cs, rs = [], []
        actual_cols = max(1, grid_cols)
        actual_rows = max(1, grid_rows)

        if tiling_mode == "Single":
            k = map_keys[0]
            m = loaded_maps_dict[k]
            return {
                "width": m.width,
                "height": m.height,
                "default_tile": m.default_tile,
                "tiles": [r[:] for r in m.tiles],
            }
        elif tiling_mode == "Vertical":
            total_w = max((d[0] for d in map_dims.values()), default=0)
            total_h = sum(d[1] for d in map_dims.values())
        elif tiling_mode == "Horizontal":
            total_w = sum(d[0] for d in map_dims.values())
            total_h = max((d[1] for d in map_dims.values()), default=0)
        elif tiling_mode == "Grid":
            n = len(map_keys)
            actual_rows = max(1, math.ceil(n / actual_cols))
            cw, rh = [0] * actual_cols, [0] * actual_rows
            for i, key in enumerate(map_keys):
                row, col = i // actual_cols, i % actual_cols
                if row < actual_rows:
                    w, h = map_dims[key]
                    if col < len(cw):
                        cw[col] = max(cw[col], w)
                    if row < len(rh):
                        rh[row] = max(rh[row], h)
            total_w, total_h = sum(cw), sum(rh)
            cs, rs = [sum(cw[:i]) for i in range(actual_cols)], [
                sum(rh[:i]) for i in range(actual_rows)
            ]

        total_w, total_h = max(0, total_w), max(0, total_h)
        combined = [[combined_default] * total_w for _ in range(total_h)]
        off_x, off_y = 0, 0
        for i, k in enumerate(map_keys):
            m = loaded_maps_dict[k]
            w, h = map_dims[k]
            px, py = 0, 0
            if tiling_mode == "Vertical":
                py = off_y
                off_y += h
            elif tiling_mode == "Horizontal":
                px = off_x
                off_x += w
            elif tiling_mode == "Grid":
                r, c = i // actual_cols, i % actual_cols
                if r < len(rs) and c < len(cs):
                    px, py = cs[c], rs[r]
                else:
                    print(f"Warn: Skipping map '{k}' (grid index error).")
                    continue

            # Efficient copy
            for r_idx in range(h):
                tr = py + r_idx
                if 0 <= tr < total_h:
                    src_s, src_e = 0, w
                    tgt_s, tgt_e = px, px + w
                    if tgt_s < 0:
                        src_s -= tgt_s
                        tgt_s = 0
                    if tgt_e > total_w:
                        src_e -= tgt_e - total_w
                        tgt_e = total_w
                    if tgt_s < tgt_e and 0 <= src_s < src_e <= w:
                        combined[tr][tgt_s:tgt_e] = m.tiles[r_idx][src_s:src_e]
        return {
            "width": total_w,
            "height": total_h,
            "default_tile": combined_default,
            "tiles": combined,
        }

    def load_text_layout(self):
        """Loads map from text file."""
        # Use QFileDialog directly
        fpath, _ = QFileDialog.getOpenFileName(self, "Load Text Layout", "", "*.txt")
        if not fpath:
            return

        try:
            with open(fpath, "r", encoding="utf-8") as f:
                lines = [ln.rstrip("\n") for ln in f]
            while lines and not lines[0].strip():
                lines.pop(0)
            while lines and not lines[-1].strip():
                lines.pop()
            if not lines:
                QMessageBox.warning(self, "Empty", "Text file empty.")
                return

            width = max(len(ln) for ln in lines) if lines else 0
            height = len(lines)
            default = self.app_config.get("default_tile", ".")
            norm_rows = [ln.ljust(width, default) for ln in lines]
            unique = set("".join(norm_rows))
            known = set(self.app_config.get("tiles", {}).keys())
            unknown = sorted(list(unique - known))
            modified = False
            replace = {}
            added = []

            for tile in unknown:
                if tile == default:
                    continue
                # Use QMessageBox directly
                reply = QMessageBox.question(
                    self,
                    "New",
                    f"Undef tile:'{tile}'.Define?",
                    QMessageBox.Ok | QMessageBox.Cancel,
                    QMessageBox.Ok,
                )
                if reply == QMessageBox.Ok:
                    # Use QInputDialog and QColorDialog directly
                    desc, ok = QInputDialog.getText(
                        self, "Desc", f"Desc for '{tile}':", text=f"Tile '{tile}'"
                    )
                    desc = desc if ok else f"Tile '{tile}'"
                    color = QColorDialog.getColor(
                        QColor(200, 200, 200), self, f"Color '{tile}'"
                    )
                    color = color if color.isValid() else QColor(200, 200, 200)
                    if "tiles" not in self.app_config:
                        self.app_config["tiles"] = {}
                    self.app_config["tiles"][tile] = {
                        "description": desc,
                        "color_qt": color,
                        "color": [color.red(), color.green(), color.blue()],
                    }
                    modified = True
                    added.append(tile)
                else:
                    replace[tile] = default

            final_rows = [
                [replace.get(c, c) for c in list(row_s)] for row_s in norm_rows
            ]

            if modified:
                if save_config(CONFIG_FILE, self.app_config):  # save_config imported
                    self.palette_widget.rebuild_palette()
                    self.statusBar().showMessage("Config saved.", 3000)
                else:
                    QMessageBox.critical(self, "Error", "Failed save config.")

            # Load into editor
            self.editor_widget.selection_rect = None
            self.editor_widget.selection_rect_changed.emit(QRect())
            if self.select_tool_action.isChecked():
                self.select_tool_action.setChecked(False)
            self.editor_widget.resize_map(
                width, height, default, new_tiles_data=final_rows
            )

            self.current_filepath = fpath
            self.update_window_title()
            self.statusBar().showMessage(f"Text loaded from {fpath}", 3000)
            # Centering via signal

        except FileNotFoundError:
            QMessageBox.critical(self, "Error", f"Not found: {fpath}")
        except Exception as e:
            QMessageBox.critical(self, "Error", f"Load text error: {e}")
            traceback.print_exc()

    def center_map_view(self):
        """Centers the map view."""
        try:
            QApplication.processEvents()
            ws, vps = self.editor_widget.size(), self.scroll_area.viewport().size()
            h_bar, v_bar = (
                self.scroll_area.horizontalScrollBar(),
                self.scroll_area.verticalScrollBar(),
            )
            cx = max(0, (ws.width() - vps.width()) / 2)
            cy = max(0, (ws.height() - vps.height()) / 2)
            h_bar.setValue(min(int(cx), h_bar.maximum()))
            v_bar.setValue(min(int(cy), v_bar.maximum()))
        except Exception as e:
            print(f"Error centering: {e}")

    def center_map_view_if_needed(self):
        """Calls center_map_view via QTimer."""
        QTimer.singleShot(0, self.center_map_view)

    def update_palette_selection(self):
        """Triggers palette visual update."""
        if hasattr(self, "palette_widget") and self.palette_widget:
            self.palette_widget.update_selection_visuals()
            self.palette_widget.update_selected_tile_info()

```

`basicrl/tile_mapper/tile_mapper_utils.py`:

```py
# tile_mapper_utils.py

from PySide6.QtCore import Qt


# --- Helper to parse modifier strings ---
def parse_modifier(modifier_str: str | None) -> Qt.KeyboardModifier:
    """Parses a modifier string (e.g., 'Ctrl+Shift') into Qt.KeyboardModifiers."""
    modifier = Qt.KeyboardModifier.NoModifier
    if not modifier_str or modifier_str.lower() == "none":
        return modifier
    # Normalize and split
    parts = [
        part.strip().lower()
        for part in modifier_str.replace("control", "ctrl").split("+")
    ]
    if "ctrl" in parts:
        modifier |= Qt.KeyboardModifier.ControlModifier
    if "shift" in parts:
        modifier |= Qt.KeyboardModifier.ShiftModifier
    if "alt" in parts:
        modifier |= Qt.KeyboardModifier.AltModifier
    # Add Meta/Command key if needed in the future
    # if "meta" in parts or "cmd" in parts or "command" in parts:
    #     modifier |= Qt.KeyboardModifier.MetaModifier
    return modifier


# --- Helper to get Qt.Key from string ---
def parse_key(key_str: str | None) -> Qt.Key | None:
    """Parses a key string (e.g., 'F1', '1', 'A', 'Enter') into Qt.Key enum."""
    if not key_str:
        return None

    key_str_upper = key_str.upper()
    # Handle function keys (F1-F35)
    if key_str_upper.startswith("F") and key_str_upper[1:].isdigit():
        f_num = int(key_str_upper[1:])
        if 1 <= f_num <= 35:
            return getattr(Qt.Key, f"Key_F{f_num}", None)

    # Handle single digits (0-9)
    if key_str.isdigit() and len(key_str) == 1:
        return getattr(Qt.Key, f"Key_{key_str}", None)

    # Handle single letters (A-Z)
    if len(key_str) == 1 and key_str.isalpha():
        return getattr(Qt.Key, f"Key_{key_str_upper}", None)

    # Handle common key names (case-insensitive)
    key_map = {
        "esc": Qt.Key.Key_Escape,
        "escape": Qt.Key.Key_Escape,
        "tab": Qt.Key.Key_Tab,
        "enter": Qt.Key.Key_Enter,
        "return": Qt.Key.Key_Return,
        "space": Qt.Key.Key_Space,
        "spacebar": Qt.Key.Key_Space,
        "backspace": Qt.Key.Key_Backspace,
        "delete": Qt.Key.Key_Delete,
        "del": Qt.Key.Key_Delete,
        "insert": Qt.Key.Key_Insert,
        "ins": Qt.Key.Key_Insert,
        "home": Qt.Key.Key_Home,
        "end": Qt.Key.Key_End,
        "pageup": Qt.Key.Key_PageUp,
        "pgup": Qt.Key.Key_PageUp,
        "pagedown": Qt.Key.Key_PageDown,
        "pgdn": Qt.Key.Key_PageDown,
        "up": Qt.Key.Key_Up,
        "uparrow": Qt.Key.Key_Up,
        "down": Qt.Key.Key_Down,
        "downarrow": Qt.Key.Key_Down,
        "left": Qt.Key.Key_Left,
        "leftarrow": Qt.Key.Key_Left,
        "right": Qt.Key.Key_Right,
        "rightarrow": Qt.Key.Key_Right,
        # Add more mappings as needed (e.g., +, -, =, etc.)
        "+": Qt.Key.Key_Plus,
        "plus": Qt.Key.Key_Plus,
        "-": Qt.Key.Key_Minus,
        "minus": Qt.Key.Key_Minus,
        "=": Qt.Key.Key_Equal,
        "equals": Qt.Key.Key_Equal,
    }
    return key_map.get(key_str.lower())

```

`basicrl/tile_mapper/tile_mapper_widgets.py`:

```py
# tile_mapper_widgets.py

import math

from PySide6.QtCore import QPoint, QRect, QSize, Qt, QTimer, Signal
from PySide6.QtGui import QPixmap  # Now QKeyEvent is imported here
from PySide6.QtGui import (
    QColor,
    QFont,
    QIcon,
    QKeyEvent,
    QMouseEvent,
    QPainter,
    QPaintEvent,
    QPalette,
    QPen,
    QWheelEvent,
)
from PySide6.QtWidgets import (
    QApplication,
    QFrame,
    QGridLayout,
    QHBoxLayout,
    QLabel,
    QLineEdit,
    QMenu,
    QPushButton,
    QScrollArea,
    QSizePolicy,
    QSpacerItem,
    QVBoxLayout,
    QWidget,
)

# Import necessary components from other modules
# Assuming flat structure for now, adjust paths like 'from .tile_mapper_core ...' if needed
from tile_mapper_core import (
    TileMap,
    ctrl_click_fill,
    ctrl_shift_click_wall,
    draw_line,
    fill_rectangle,
    flood_fill_replace,
)
from tile_mapper_dialogs import EditTileDialog  # Import needed dialog
from tile_mapper_utils import (  # Assuming utils module exists/will exist
    parse_key,
    parse_modifier,
)


# --- Tile Editor Widget ---
class TileEditorWidget(QWidget):
    """The main widget for drawing and interacting with the tile map."""

    map_changed = Signal()
    zoom_changed = Signal()
    selected_tile_changed = Signal(str)
    selection_rect_changed = Signal(QRect)  # Signal for selection tool

    def __init__(
        self, tilemap: TileMap, scroll_area: QScrollArea, app_config: dict, parent=None
    ):
        super().__init__(parent)
        self.tilemap = tilemap
        self.scroll_area = scroll_area
        self.app_config = app_config  # Store config reference
        self._selected_tile = self._get_initial_selected_tile()
        self.start_drag_pos: QPoint | None = None
        self.current_mouse_pos = QPoint(0, 0)
        self.drawing_line = False
        self.drawing_rect = False
        self._tile_size = self.app_config.get("tile_size", 16)

        # Add state for selection tool
        self.selecting_region = False
        self.selection_start_pos: QPoint | None = None
        self.selection_rect: QRect | None = None

        self.setMouseTracking(True)
        self.setFocusPolicy(Qt.FocusPolicy.StrongFocus)
        self.update_widget_size()
        self.setSizePolicy(QSizePolicy.Policy.Preferred, QSizePolicy.Policy.Preferred)
        self.setAutoFillBackground(True)
        pal = self.palette()
        pal.setColor(QPalette.ColorRole.Window, QColor(Qt.GlobalColor.darkGray))
        self.setPalette(pal)

    def _get_initial_selected_tile(self):
        """Determines a valid initial tile selection from config."""
        tiles = self.app_config.get("tiles", {})
        default_tile = self.app_config.get("default_tile", ".")
        wall_tile = self.app_config.get("wall_tile", "#")
        for char in tiles:
            if char != default_tile and char != wall_tile:
                return char
        for char in tiles:
            if char != default_tile:
                return char
        return (
            default_tile
            if default_tile in tiles
            else (list(tiles.keys())[0] if tiles else ".")
        )

    # --- Selection Tool Methods ---
    def start_selection(self):
        """Activates the region selection tool."""
        self.selecting_region = True
        self.setCursor(Qt.CursorShape.CrossCursor)
        print("Selection tool activated.")
        # Clear previous selection visually
        if self.selection_rect:
            self.selection_rect = None
            self.selection_rect_changed.emit(QRect())  # Emit empty rect
            self.update()

    def stop_selection(self):
        """Deactivates the region selection tool."""
        self.selecting_region = False
        self.selection_start_pos = None
        # Don't clear self.selection_rect here, keep it until next selection starts
        self.setCursor(Qt.CursorShape.ArrowCursor)
        print("Selection tool deactivated.")

    def get_current_selection(self) -> QRect | None:
        """Returns the current valid selection rectangle (in grid coords)."""
        return (
            self.selection_rect
            if self.selection_rect and self.selection_rect.isValid()
            else None
        )

    # --- Standard Widget Methods ---
    def update_widget_size(self):
        """Updates minimum and preferred size based on map and tile size."""
        self._tile_size = self.app_config.get("tile_size", 16)
        width = self.tilemap.width * self._tile_size
        height = self.tilemap.height * self._tile_size
        self.setMinimumSize(max(1, width), max(1, height))
        self.updateGeometry()
        self.update()

    def sizeHint(self):
        """Provide a preferred size based on current tile size."""
        current_tile_size = self.app_config.get("tile_size", 16)
        width = self.tilemap.width * current_tile_size
        height = self.tilemap.height * current_tile_size
        return QSize(max(1, width), max(1, height))

    def resize_map(self, new_width, new_height, new_default_tile, new_tiles_data=None):
        """Resizes the underlying tilemap instance and redraws."""
        # Logic remains mostly the same, just uses self.tilemap
        # ... (resize logic from previous version) ...
        new_width = max(0, new_width)
        new_height = max(0, new_height)
        old_tiles = (
            [row[:] for row in self.tilemap.tiles] if new_tiles_data is None else None
        )
        old_width = self.tilemap.width
        old_height = self.tilemap.height

        self.tilemap.width = new_width
        self.tilemap.height = new_height
        self.tilemap.default_tile = new_default_tile

        if new_tiles_data is not None:
            if len(new_tiles_data) == new_height and (
                new_height == 0 or all(len(row) == new_width for row in new_tiles_data)
            ):
                self.tilemap.tiles = new_tiles_data
            else:
                print(
                    "Error: Provided new_tiles_data dimensions mismatch. Re-initializing."
                )
                self.tilemap.tiles = [
                    [new_default_tile] * new_width for _ in range(new_height)
                ]
        else:  # Preserve old data
            new_grid = [[new_default_tile] * new_width for _ in range(new_height)]
            if old_tiles:
                copy_height = min(old_height, new_height)
                copy_width = min(old_width, new_width)
                for y in range(copy_height):
                    if y < len(old_tiles) and x < len(old_tiles[y]):  # Bounds check
                        new_grid[y][:copy_width] = old_tiles[y][
                            :copy_width
                        ]  # Slice assignment
            self.tilemap.tiles = new_grid

        self.update_widget_size()
        self.map_changed.emit()  # Signal size change

    @property
    def selected_tile(self):
        return self._selected_tile

    @selected_tile.setter
    def selected_tile(self, tile_char):
        if tile_char in self.app_config.get("tiles", {}):
            if self._selected_tile != tile_char:
                self._selected_tile = tile_char
                print(f"Selected tile: {self._selected_tile}")
                self.selected_tile_changed.emit(self._selected_tile)
        else:
            # Existing revert logic...
            print(f"Warning: Attempted unknown tile '{tile_char}'.")
            safe_tile = self._get_initial_selected_tile()
            if self._selected_tile != safe_tile:
                self._selected_tile = safe_tile
                print(f"Reverted to: {self._selected_tile}")
                self.selected_tile_changed.emit(self._selected_tile)

    def pixel_to_grid(self, pos: QPoint) -> QPoint:
        """Converts pixel coordinates (QWidget) to grid coordinates."""
        current_tile_size = self.app_config.get("tile_size", 16)
        if current_tile_size <= 0:
            return QPoint(-1, -1)  # Indicate invalid
        x = pos.x() // current_tile_size
        y = pos.y() // current_tile_size
        # Clamp to valid grid indices, return invalid (-1) if map is zero size
        if self.tilemap.width <= 0 or self.tilemap.height <= 0:
            return QPoint(-1, -1)
        x = max(0, min(x, self.tilemap.width - 1))
        y = max(0, min(y, self.tilemap.height - 1))
        return QPoint(x, y)

    def grid_to_pixel(self, grid_pos: QPoint) -> QPoint:
        """Converts grid coordinates to top-left pixel coordinates."""
        current_tile_size = self.app_config.get("tile_size", 16)
        return QPoint(
            grid_pos.x() * current_tile_size, grid_pos.y() * current_tile_size
        )

    def paintEvent(self, event: QPaintEvent):
        """Handles painting the widget."""
        painter = QPainter(self)
        painter.setRenderHint(QPainter.RenderHint.Antialiasing, False)

        tile_configs = self.app_config.get("tiles", {})
        unknown_color = QColor(255, 0, 255)
        current_tile_size = self.app_config.get("tile_size", 16)
        if current_tile_size <= 0:
            return

        paint_rect = event.rect()
        start_col = max(0, paint_rect.left() // current_tile_size)
        end_col = min(
            self.tilemap.width,
            (paint_rect.right() + current_tile_size - 1) // current_tile_size,
        )
        start_row = max(0, paint_rect.top() // current_tile_size)
        end_row = min(
            self.tilemap.height,
            (paint_rect.bottom() + current_tile_size - 1) // current_tile_size,
        )

        # Draw Tiles
        for y in range(start_row, end_row):
            for x in range(start_col, end_col):
                tile_char = self.tilemap.get_tile(x, y)
                tile_data = tile_configs.get(tile_char)
                color = (
                    tile_data.get("color_qt", unknown_color)
                    if tile_data
                    else unknown_color
                )
                rect = QRect(
                    x * current_tile_size,
                    y * current_tile_size,
                    current_tile_size,
                    current_tile_size,
                )
                if rect.intersects(paint_rect):
                    painter.fillRect(rect, color)

        # Draw Grid
        if current_tile_size > 4:
            pen = QPen(QColor(180, 180, 180), 1, Qt.PenStyle.SolidLine)
            painter.setPen(pen)
            left = start_col * current_tile_size
            right = end_col * current_tile_size
            top = start_row * current_tile_size
            bottom = end_row * current_tile_size
            for x_coord in range(start_col, end_col + 1):
                px = x_coord * current_tile_size
                painter.drawLine(
                    px, max(top, paint_rect.top()), px, min(bottom, paint_rect.bottom())
                )
            for y_coord in range(start_row, end_row + 1):
                py = y_coord * current_tile_size
                painter.drawLine(
                    max(left, paint_rect.left()), py, min(right, paint_rect.right()), py
                )

        # Draw Previews (Line/Rect)
        if self.start_drag_pos and self.current_mouse_pos and not self.selecting_region:
            # ... (drawing preview logic - unchanged) ...
            end_pos = self.pixel_to_grid(self.current_mouse_pos)
            preview_color = self.app_config.get(
                "preview_line_color_qt", QColor(255, 0, 0)
            )
            preview_thickness = self.app_config.get("preview_line_thickness", 1)
            preview_pen = QPen(preview_color, preview_thickness, Qt.PenStyle.DotLine)
            painter.setPen(preview_pen)
            if self.drawing_rect:
                x1, y1 = self.start_drag_pos.x(), self.start_drag_pos.y()
                x2, y2 = end_pos.x(), end_pos.y()
                min_x, max_x = min(x1, x2), max(x1, x2)
                min_y, max_y = min(y1, y2), max(y1, y2)
                preview_rect = QRect(
                    min_x * current_tile_size,
                    min_y * current_tile_size,
                    (max_x - min_x + 1) * current_tile_size,
                    (max_y - min_y + 1) * current_tile_size,
                )
                if preview_thickness > 1:
                    offset = preview_thickness / 2.0
                    preview_rect.adjust(offset, offset, -offset, -offset)
                painter.drawRect(preview_rect)
            elif self.drawing_line:
                start_pixel = QPoint(
                    self.start_drag_pos.x() * current_tile_size
                    + current_tile_size // 2,
                    self.start_drag_pos.y() * current_tile_size
                    + current_tile_size // 2,
                )
                painter.drawLine(start_pixel, self.current_mouse_pos)

        # Draw Selection Rectangle
        temp_selection_rect = None
        if (
            self.selecting_region
            and self.selection_start_pos
            and self.current_mouse_pos
        ):
            # Calculate temporary rect during drag
            end_pos = self.pixel_to_grid(self.current_mouse_pos)
            temp_selection_rect = QRect(self.selection_start_pos, end_pos).normalized()
        elif self.selection_rect and self.selection_rect.isValid():
            # Use finalized selection rect if valid
            temp_selection_rect = self.selection_rect

        if temp_selection_rect:
            pen = QPen(
                QColor(50, 150, 255), 2, Qt.PenStyle.DashLine
            )  # Blue dashed line
            painter.setPen(pen)
            painter.setBrush(Qt.BrushStyle.NoBrush)
            # Convert grid rect to pixel rect
            pixel_rect = QRect(
                temp_selection_rect.left() * current_tile_size,
                temp_selection_rect.top() * current_tile_size,
                temp_selection_rect.width() * current_tile_size,
                temp_selection_rect.height() * current_tile_size,
            )
            painter.drawRect(pixel_rect)

    def mousePressEvent(self, event: QMouseEvent):
        """Handles mouse button presses, including selection start."""
        self.current_mouse_pos = event.position().toPoint()
        grid_pos = self.pixel_to_grid(self.current_mouse_pos)
        if grid_pos.x() < 0 or grid_pos.y() < 0:  # Check valid grid pos
            event.ignore()
            return

        # Handle Selection Tool first if active
        if self.selecting_region:
            if event.button() == Qt.MouseButton.LeftButton:
                self.selection_start_pos = grid_pos
                self.selection_rect = None  # Clear old finalized rect
                self.update()  # Redraw to show selection start/clear old
                event.accept()
            else:  # Ignore other buttons in selection mode
                event.ignore()
            return  # Don't process other tools if selecting

        # --- Normal Tool Handling ---
        # ... (Existing mousePressEvent logic using self.app_config) ...
        current_modifiers = event.modifiers()
        controls = self.app_config.get("controls", {})
        action_handled = False

        # Left Button
        if event.button() == Qt.MouseButton.LeftButton:
            self.start_drag_pos = grid_pos
            self.drawing_line = False
            self.drawing_rect = False
            action_found = False

            for action_name, control in controls.items():
                if control.get("trigger") == "LeftClick":
                    required_modifier = parse_modifier(control.get("modifier", "None"))
                    if current_modifiers == required_modifier:
                        print(f"Debug: Matched Press '{action_name}'")
                        action_found = True
                        redraw_needed = False
                        if action_name == "flood_fill":
                            filled = flood_fill_replace(
                                self.tilemap,
                                grid_pos.x(),
                                grid_pos.y(),
                                self.selected_tile,
                            )
                            if filled > 0:
                                redraw_needed = True
                            self.start_drag_pos = None
                        elif action_name == "fill_perimeter":
                            if ctrl_click_fill(
                                self.tilemap,
                                grid_pos.x(),
                                grid_pos.y(),
                                self.selected_tile,
                            ):
                                redraw_needed = True
                            self.start_drag_pos = None
                        elif action_name == "wall_perimeter":
                            if ctrl_shift_click_wall(
                                self.tilemap,
                                grid_pos.x(),
                                grid_pos.y(),
                                self.selected_tile,
                                self.app_config,
                            ):
                                redraw_needed = True
                            self.start_drag_pos = None
                        else:  # Start drag actions
                            if required_modifier == parse_modifier("Shift"):
                                self.drawing_rect = True
                            elif required_modifier == Qt.KeyboardModifier.NoModifier:
                                self.drawing_line = True
                        if redraw_needed:
                            self.update()
                        action_handled = True
                        break

            if not action_found and current_modifiers == Qt.KeyboardModifier.NoModifier:
                if self.start_drag_pos:
                    self.drawing_line = True
                    action_handled = True

            if action_handled:
                event.accept()
            else:
                event.ignore()

        # Right Button
        elif event.button() == Qt.MouseButton.RightButton:
            # ... (Existing Right Button logic using self.app_config) ...
            for action_name, control in controls.items():
                if control.get("trigger") == "RightClick":
                    required_modifier = parse_modifier(control.get("modifier", "None"))
                    if current_modifiers == required_modifier:
                        print(f"Debug: Matched Press '{action_name}'")
                        if action_name == "erase_tile":
                            if self.tilemap.set_tile(
                                grid_pos.x(), grid_pos.y(), self.tilemap.default_tile
                            ):
                                self.update()
                                action_handled = True
                        break
            if action_handled:
                event.accept()
            else:
                event.ignore()

        else:
            event.ignore()

    def mouseMoveEvent(self, event: QMouseEvent):
        """Handles mouse movement for drag previews and selection."""
        self.current_mouse_pos = event.position().toPoint()

        # Handle selection drag
        if (
            self.selecting_region
            and event.buttons() & Qt.MouseButton.LeftButton
            and self.selection_start_pos
        ):
            self.update()  # Update to show temporary selection rect
            event.accept()
            return

        # Handle tool drag previews
        if event.buttons() & Qt.MouseButton.LeftButton and self.start_drag_pos:
            if self.drawing_line or self.drawing_rect:
                self.update()
                event.accept()
            else:
                event.ignore()
        else:
            event.ignore()

    def mouseReleaseEvent(self, event: QMouseEvent):
        """Handles mouse button releases, including selection end."""
        self.current_mouse_pos = (
            event.position().toPoint()
        )  # Ensure current pos is updated
        end_pos = self.pixel_to_grid(self.current_mouse_pos)
        if end_pos.x() < 0 or end_pos.y() < 0:  # Check valid grid pos
            event.ignore()
            return

        # Handle Selection Tool end
        if (
            self.selecting_region
            and event.button() == Qt.MouseButton.LeftButton
            and self.selection_start_pos
        ):
            self.selection_rect = QRect(self.selection_start_pos, end_pos).normalized()
            self.selection_start_pos = None  # End drag
            print(f"Selected Region (Grid Coords): {self.selection_rect.getRect()}")
            self.selection_rect_changed.emit(self.selection_rect)  # Emit final rect
            self.update()  # Redraw finalized selection
            event.accept()
            # Optionally deactivate tool after selection? Depends on desired workflow.
            # self.stop_selection()
            return  # Don't process other tools

        # --- Normal Tool Handling ---
        # ... (Existing mouseReleaseEvent logic using self.app_config) ...
        current_modifiers = QApplication.keyboardModifiers()
        controls = self.app_config.get("controls", {})
        action_handled = False

        if event.button() == Qt.MouseButton.LeftButton and self.start_drag_pos:
            is_drag = self.start_drag_pos != end_pos
            start_x, start_y = self.start_drag_pos.x(), self.start_drag_pos.y()
            end_x, end_y = end_pos.x(), end_pos.y()

            action_to_perform = None
            trigger_type = "LeftDrag" if is_drag else "LeftClick"
            for action_name, control in controls.items():
                if control.get("trigger") == trigger_type:
                    required_modifier = parse_modifier(control.get("modifier", "None"))
                    if current_modifiers == required_modifier:
                        if action_name not in [
                            "flood_fill",
                            "fill_perimeter",
                            "wall_perimeter",
                        ]:
                            action_to_perform = action_name
                            break

            place_tile_control = self._find_control_by_action("place_tile_click")
            if (
                not is_drag
                and action_to_perform is None
                and place_tile_control
                and parse_modifier(place_tile_control.get("modifier", "None"))
                == Qt.KeyboardModifier.NoModifier
                and current_modifiers == Qt.KeyboardModifier.NoModifier
            ):
                action_to_perform = "place_tile_click"

            print(
                f"Debug: Release - Action: {action_to_perform}, Drag: {is_drag}, Mods: {current_modifiers}"
            )
            redraw_needed = False
            if action_to_perform == "draw_rect":
                if fill_rectangle(
                    self.tilemap, self.start_drag_pos, end_pos, self.selected_tile
                ):
                    redraw_needed = True
            elif action_to_perform == "draw_line":
                if draw_line(
                    self.tilemap, self.start_drag_pos, end_pos, self.selected_tile
                ):
                    redraw_needed = True
            elif action_to_perform == "place_tile_click":
                if self.tilemap.set_tile(end_x, end_y, self.selected_tile):
                    redraw_needed = True

            self.start_drag_pos = None
            self.drawing_line = False
            self.drawing_rect = False
            if redraw_needed:
                self.update()
            action_handled = True

        if action_handled:
            event.accept()
        else:
            event.ignore()

    def _find_control_by_action(self, action_name_to_find):
        """Helper to find a control definition by its name."""
        return self.app_config.get("controls", {}).get(action_name_to_find)

    def wheelEvent(self, event: QWheelEvent):
        """Handles mouse wheel events for zooming and panning."""
        # ... (Existing wheelEvent logic using self.app_config) ...
        self.current_mouse_pos = event.position().toPoint()
        current_modifiers = event.modifiers()
        controls = self.app_config.get("controls", {})
        angle = event.angleDelta().y()
        action_handled = False

        action_to_perform = None
        trigger_type = "ScrollUp" if angle > 0 else "ScrollDown"
        for action_name, control in controls.items():
            if control.get("trigger") == trigger_type:
                required_modifier = parse_modifier(control.get("modifier", "None"))
                if current_modifiers == required_modifier:
                    action_to_perform = action_name
                    break

        print(f"Debug: Wheel - Action: {action_to_perform}, Mods: {current_modifiers}")
        if not self.scroll_area:
            event.ignore()
            return

        if action_to_perform in ["zoom_in", "zoom_out"]:
            zoom_factor = self.app_config.get("zoom_step", 1.2)
            min_size = self.app_config.get("min_tile_size", 4)
            max_size = self.app_config.get("max_tile_size", 64)
            old_tile_size = self.app_config.get("tile_size", 16)

            if action_to_perform == "zoom_in":
                new_tile_size = math.ceil(old_tile_size * zoom_factor)
            else:
                new_tile_size = math.floor(old_tile_size / zoom_factor)
            new_tile_size = max(min_size, min(new_tile_size, max_size))

            if new_tile_size != old_tile_size:
                widget_point = self.mapFromGlobal(event.globalPosition().toPoint())
                rel_x = widget_point.x() / self.width() if self.width() > 0 else 0.5
                rel_y = widget_point.y() / self.height() if self.height() > 0 else 0.5

                self.app_config["tile_size"] = new_tile_size  # Update config directly
                print(f"Zooming: New tile size = {new_tile_size}")
                self.update_widget_size()  # Resizes widget
                self.zoom_changed.emit()  # Notify palette

                def adjust_scrollbars():  # Closure to adjust scrollbars after resize
                    new_w, new_h = self.width(), self.height()
                    target_wx, target_wy = rel_x * new_w, rel_y * new_h
                    vp_mouse_pos = self.scroll_area.viewport().mapFromGlobal(
                        event.globalPosition().toPoint()
                    )
                    new_sx = int(target_wx - vp_mouse_pos.x())
                    new_sy = int(target_wy - vp_mouse_pos.y())
                    h_bar = self.scroll_area.horizontalScrollBar()
                    v_bar = self.scroll_area.verticalScrollBar()
                    h_bar.setValue(max(h_bar.minimum(), min(new_sx, h_bar.maximum())))
                    v_bar.setValue(max(v_bar.minimum(), min(new_sy, v_bar.maximum())))

                QTimer.singleShot(0, adjust_scrollbars)

            action_handled = True
            event.accept()

        elif action_to_perform in ["pan_left", "pan_right"]:
            h_bar = self.scroll_area.horizontalScrollBar()
            step = self.app_config.get("pan_step", 50)
            if action_to_perform == "pan_left":
                h_bar.setValue(h_bar.value() - step)
            else:
                h_bar.setValue(h_bar.value() + step)
            action_handled = True
            event.accept()

        if not action_handled:
            event.ignore()

    def keyPressEvent(self, event: QKeyEvent):
        """Handles key presses for changing tiles and other actions."""
        # ... (Existing keyPressEvent logic using self.app_config and parse_key/parse_modifier) ...
        current_modifiers = event.modifiers()
        current_key = event.key()
        controls = self.app_config.get("controls", {})
        available_tiles = sorted(self.app_config.get("tiles", {}).keys())
        action_handled = False

        for action_name, control in controls.items():
            if control.get("trigger") == "KeyPress":
                required_modifier = parse_modifier(control.get("modifier", "None"))
                required_key_str = control.get("key")
                required_key_enum = parse_key(required_key_str)

                if (
                    required_key_enum is not None
                    and current_key == required_key_enum
                    and current_modifiers == required_modifier
                ):
                    print(f"Debug: Matched KeyPress '{action_name}'")
                    if action_name.startswith("select_tile_"):
                        try:
                            idx = int(action_name.split("_")[-1]) - 1
                            if 0 <= idx < len(available_tiles):
                                self.selected_tile = available_tiles[idx]
                                action_handled = True
                        except (ValueError, IndexError):
                            pass
                    # Add other KeyPress actions here if needed (e.g., toggle selection tool?)

                    if action_handled:
                        event.accept()
                        return

        if not action_handled:
            event.ignore()


# --- Tile Palette Widget ---
class TilePaletteWidget(QWidget):
    """Widget for tile selection, search, and info display."""

    palette_updated = Signal()

    def __init__(self, editor_widget: TileEditorWidget, app_config: dict, parent=None):
        super().__init__(parent)
        self.editor_widget = editor_widget
        self.app_config = app_config  # Store config reference
        self.buttons = {}  # {tile_char: QPushButton}
        self.init_ui()
        self.rebuild_palette()  # Initial population

        # Connect signals
        self.editor_widget.zoom_changed.connect(self.rebuild_palette)
        self.editor_widget.selected_tile_changed.connect(self.update_selection_visuals)
        self.editor_widget.selected_tile_changed.connect(self.update_selected_tile_info)
        self.search_edit.textChanged.connect(self._filter_palette)

    def init_ui(self):
        """Sets up the palette UI including search and info."""
        # ... (Layout setup from previous version) ...
        main_layout = QVBoxLayout(self)
        main_layout.setContentsMargins(2, 2, 2, 2)
        main_layout.setSpacing(3)
        top_layout = QHBoxLayout()
        top_layout.addWidget(QLabel("Filter:"))
        self.search_edit = QLineEdit()
        self.search_edit.setPlaceholderText("Char or desc...")
        self.search_edit.setClearButtonEnabled(True)
        top_layout.addWidget(self.search_edit)
        self.add_button = QPushButton("+")
        self.add_button.setFixedSize(QSize(25, 25))
        self.add_button.setToolTip("Add new tile")
        self.add_button.clicked.connect(self.add_new_tile)
        top_layout.addWidget(self.add_button)
        main_layout.addLayout(top_layout)

        self.scroll_area = QScrollArea()
        self.scroll_area.setWidgetResizable(True)
        self.scroll_area.setFrameShape(QFrame.Shape.StyledPanel)
        self.button_container = QWidget()
        self.button_grid_layout = QGridLayout(self.button_container)
        self.button_grid_layout.setSpacing(2)
        self.button_grid_layout.setAlignment(
            Qt.AlignmentFlag.AlignTop | Qt.AlignmentFlag.AlignLeft
        )
        self.button_container.setLayout(self.button_grid_layout)
        self.scroll_area.setWidget(self.button_container)
        self.scroll_area.setMinimumHeight(60)
        self.scroll_area.setSizePolicy(
            QSizePolicy.Policy.Expanding, QSizePolicy.Policy.Expanding
        )
        main_layout.addWidget(self.scroll_area, 1)

        self.selected_tile_label = QLabel("Selected: -")
        font = self.selected_tile_label.font()
        font.setPointSize(font.pointSize() - 1)
        self.selected_tile_label.setFont(font)
        self.selected_tile_label.setStyleSheet(
            "QLabel { padding: 3px; background-color: #f0f0f0; border-radius: 3px; border: 1px solid #cccccc; }"
        )
        self.selected_tile_label.setAlignment(Qt.AlignmentFlag.AlignCenter)
        main_layout.addWidget(self.selected_tile_label)
        self.setLayout(main_layout)

    def _create_tile_icon(self, tile_char, tile_data, icon_size):
        """Creates a QPixmap icon."""
        # ... (Icon creation logic - unchanged, uses tile_data['color_qt']) ...
        if (
            not isinstance(icon_size, QSize)
            or not icon_size.isValid()
            or icon_size.width() <= 0
        ):
            icon_size = QSize(16, 16)
        pixmap = QPixmap(icon_size)
        color = tile_data.get("color_qt", QColor(255, 0, 255))
        pixmap.fill(color)
        painter = QPainter(pixmap)
        lumi = 0.299 * color.redF() + 0.587 * color.greenF() + 0.114 * color.blueF()
        text_color = Qt.GlobalColor.black if lumi > 0.5 else Qt.GlobalColor.white
        painter.setPen(text_color)
        font_size = max(6, int(icon_size.height() * 0.6))
        font = QFont()
        font.setPointSize(font_size)
        font.setBold(True)
        painter.setFont(font)
        painter.drawText(pixmap.rect(), Qt.AlignmentFlag.AlignCenter, tile_char)
        painter.end()
        return QIcon(pixmap)

    def _filter_palette(self):
        """Hides/Shows tile buttons based on search text."""
        # ... (Filtering logic - unchanged, uses self.app_config) ...
        filter_text = self.search_edit.text().strip().lower()
        tile_configs = self.app_config.get("tiles", {})
        buttons_visible = 0
        total_buttons = len(self.buttons)
        for tile_char, button in self.buttons.items():
            if button:
                tile_data = tile_configs.get(tile_char, {})
                desc = tile_data.get("description", "").lower()
                match = (
                    not filter_text
                    or filter_text in tile_char.lower()
                    or filter_text in desc
                )
                button.setVisible(match)
                if match:
                    buttons_visible += 1
        self.search_edit.setStyleSheet(
            "QLineEdit { color: red; }"
            if (filter_text and buttons_visible == 0 and total_buttons > 0)
            else ""
        )

    def rebuild_palette(self):
        """Clears and rebuilds tile buttons based on config, respecting filter."""
        # ... (Rebuild logic - unchanged, uses self.app_config) ...
        print("Debug: Rebuilding palette...")
        while self.button_grid_layout.count():
            item = self.button_grid_layout.takeAt(0)
            if item:
                widget = item.widget()
            if widget:
                widget.deleteLater()
        self.buttons.clear()

        tile_size = self.app_config.get("tile_size", 16)
        icon_qsize = QSize(tile_size, tile_size)
        button_width = max(32, tile_size + 10)
        button_height = max(32, tile_size + 10)
        button_qsize = QSize(button_width, button_height)
        tile_chars = sorted(self.app_config.get("tiles", {}).keys())
        row, col = 0, 0
        container_width = self.button_container.width()
        est_button_w = button_width + self.button_grid_layout.spacing()
        max_cols = (
            max(1, container_width // est_button_w)
            if container_width > est_button_w
            else 8
        )

        for tile_char in tile_chars:
            tile_data = self.app_config["tiles"].get(
                tile_char,
                {
                    "color_qt": QColor(255, 0, 255),
                    "description": f"Undef '{tile_char}'",
                },
            )
            btn = QPushButton()
            btn.setFixedSize(button_qsize)
            btn.setCheckable(True)
            btn.setAutoExclusive(True)
            icon = self._create_tile_icon(tile_char, tile_data, icon_qsize)
            btn.setIcon(icon)
            btn.setIconSize(icon_qsize)
            desc = tile_data.get("description", "No description")
            btn.setToolTip(f"'{tile_char}': {desc}")
            btn.clicked.connect(lambda checked, tc=tile_char: self.select_tile(tc))
            btn.setProperty("tile_char", tile_char)
            btn.setContextMenuPolicy(Qt.ContextMenuPolicy.CustomContextMenu)
            btn.customContextMenuRequested.connect(self.show_context_menu)
            self.button_grid_layout.addWidget(btn, row, col)
            self.buttons[tile_char] = btn
            col += 1
            if col >= max_cols:
                col = 0
                row += 1

        while col < max_cols and col != 0:  # Fill last row
            self.button_grid_layout.addItem(
                QSpacerItem(
                    button_width,
                    button_height,
                    QSizePolicy.Policy.Fixed,
                    QSizePolicy.Policy.Fixed,
                ),
                row,
                col,
            )
            col += 1
        self.button_grid_layout.setRowStretch(row + 1, 1)  # Push up

        self._filter_palette()
        self.update_selection_visuals()
        self.update_selected_tile_info()
        self.palette_updated.emit()

    def select_tile(self, tile_char):
        """Slot for button clicks."""
        self.editor_widget.selected_tile = tile_char

    def update_selection_visuals(self, tile_char: str | None = None):
        """Updates button check state."""
        # ... (Logic unchanged) ...
        current_tile = (
            tile_char if tile_char is not None else self.editor_widget.selected_tile
        )
        button_to_check = self.buttons.get(current_tile)
        if button_to_check:
            if not button_to_check.isChecked():
                button_to_check.setChecked(True)
        else:  # Fallback
            default_button = self.buttons.get(self.app_config.get("default_tile", "."))
            if default_button and not default_button.isChecked():
                default_button.setChecked(True)

    def update_selected_tile_info(self, tile_char: str | None = None):
        """Updates info label."""
        # ... (Logic unchanged, uses self.app_config) ...
        current_tile = (
            tile_char if tile_char is not None else self.editor_widget.selected_tile
        )
        tile_data = self.app_config.get("tiles", {}).get(current_tile)
        if tile_data:
            desc = tile_data.get("description", "No description")
            self.selected_tile_label.setText(f"'{current_tile}': {desc}")
            self.selected_tile_label.setToolTip(f"Char: {current_tile}\nDesc: {desc}")
        else:
            self.selected_tile_label.setText(f"'{current_tile}': (Unknown)")
            self.selected_tile_label.setToolTip(
                f"Char: {current_tile}\nDesc: Unknown tile"
            )

    def show_context_menu(self, pos):
        """Shows context menu for tile buttons."""
        # ... (Logic unchanged, uses self.app_config for default check) ...
        button = self.sender()
        if not isinstance(button, QPushButton):
            return
        tile_char = button.property("tile_char")
        if not tile_char:
            return
        menu = QMenu(self)
        edit_action = menu.addAction(f"Edit '{tile_char}'...")
        delete_action = menu.addAction(f"Delete '{tile_char}'")
        if tile_char == self.app_config.get("default_tile"):
            delete_action.setText(f"Delete Default '{tile_char}'...")
        action = menu.exec(button.mapToGlobal(pos))
        if action == edit_action:
            self.edit_tile(tile_char)
        elif action == delete_action:
            self.delete_tile(tile_char)

    # Edit/Delete/Add methods now need to handle config update and trigger rebuild
    # They will need access to save_config and load_config (passed via MainWindow or imported)

    def edit_tile(self, tile_char):
        """Opens EditTileDialog, updates config, triggers rebuild."""
        # Needs access to save_config, load_config
        from tile_mapper_config import CONFIG_FILE  # Import locally
        from tile_mapper_config import load_config, save_config

        if tile_char not in self.app_config.get("tiles", {}):
            return
        tile_data = self.app_config["tiles"][tile_char]
        existing_chars = set(self.app_config.get("tiles", {}).keys())

        # Pass app_config to dialog
        dialog = EditTileDialog(
            tile_char, tile_data, existing_chars, self, app_config=self.app_config
        )
        if dialog.exec() == QDialog.DialogCode.Accepted:
            result = dialog.get_tile_data()
            new_char, new_data = result["char"], result["data"]
            original_selected = self.editor_widget.selected_tile
            is_default = tile_char == self.app_config.get("default_tile")
            config_changed = False

            if new_char != tile_char:  # Renaming
                if new_char in self.app_config["tiles"]:
                    QMessageBox.warning(
                        self, "Rename Error", f"Char '{new_char}' exists."
                    )
                    return
                self.app_config["tiles"][new_char] = self.app_config["tiles"][
                    tile_char
                ].copy()
                self.app_config["tiles"][new_char].update(new_data)
                del self.app_config["tiles"][tile_char]
                if is_default:
                    self.app_config["default_tile"] = new_char
                if original_selected == tile_char:
                    self.editor_widget.selected_tile = new_char
                config_changed = True
            else:  # Just updating data
                if self.app_config["tiles"][tile_char].get(
                    "description"
                ) != new_data.get("description") or self.app_config["tiles"][
                    tile_char
                ].get(
                    "color"
                ) != new_data.get(
                    "color"
                ):
                    self.app_config["tiles"][tile_char].update(new_data)
                    config_changed = True

            if config_changed:
                if save_config(CONFIG_FILE, self.app_config):
                    self.rebuild_palette()
                    self.editor_widget.update()
                    QApplication.instance().statusBar().showMessage(
                        "Tile updated & saved.", 3000
                    )
                else:
                    QMessageBox.critical(self, "Error", f"Failed save: {CONFIG_FILE}")
                    # Reload config to revert in-memory changes
                    self.app_config.clear()  # Clear current dict
                    self.app_config.update(load_config(CONFIG_FILE))  # Reload
                    self.rebuild_palette()  # Rebuild with reloaded state

    def delete_tile(self, tile_char):
        """Deletes tile, updates config, triggers rebuild."""
        # Needs access to save_config, load_config
        from tile_mapper_config import CONFIG_FILE  # Import locally
        from tile_mapper_config import load_config, save_config

        # ... (Confirmation logic unchanged) ...
        if tile_char not in self.app_config.get("tiles", {}):
            return
        is_default = tile_char == self.app_config.get("default_tile")
        if is_default and len(self.app_config.get("tiles", {})) <= 1:
            QMessageBox.critical(self, "Cannot Delete", "Cannot delete last tile.")
            return
        warning = "\n\nWARNING: Deleting default!" if is_default else ""
        reply = QMessageBox.question(
            self,
            "Confirm",
            f"Delete '{tile_char}'?{warning}\n(Affects maps)",
            QMessageBox.StandardButton.Yes | QMessageBox.StandardButton.No,
            QMessageBox.StandardButton.No,
        )

        if reply == QMessageBox.StandardButton.Yes:
            original_selected = self.editor_widget.selected_tile
            del self.app_config["tiles"][tile_char]
            new_default_selected = None
            if is_default:
                remaining = list(self.app_config.get("tiles", {}).keys())
                new_default = remaining[0] if remaining else "."
                self.app_config["default_tile"] = new_default
                print(f"New default: '{new_default}'.")
                new_default_selected = new_default

            if save_config(CONFIG_FILE, self.app_config):
                if original_selected == tile_char or new_default_selected:
                    select_tile = (
                        new_default_selected
                        if new_default_selected
                        else self.app_config.get("default_tile", ".")
                    )
                    # Check if target tile still exists before selecting
                    if select_tile not in self.app_config.get("tiles", {}):
                        select_tile = (
                            self.editor_widget._get_initial_selected_tile()
                        )  # Ultimate fallback
                    self.editor_widget.selected_tile = select_tile

                self.rebuild_palette()
                self.editor_widget.update()
                QApplication.instance().statusBar().showMessage(
                    f"Tile '{tile_char}' deleted.", 3000
                )
            else:
                QMessageBox.critical(self, "Error", f"Failed save: {CONFIG_FILE}")
                self.app_config.clear()
                self.app_config.update(load_config(CONFIG_FILE))
                self.rebuild_palette()

    def add_new_tile(self):
        """Opens dialog to add tile, updates config, triggers rebuild."""
        # Needs access to save_config, load_config
        from tile_mapper_config import CONFIG_FILE  # Import locally
        from tile_mapper_config import load_config, save_config

        existing_chars = set(self.app_config.get("tiles", {}).keys())
        dialog = EditTileDialog(
            existing_chars=existing_chars, parent=self, app_config=self.app_config
        )
        if dialog.exec() == QDialog.DialogCode.Accepted:
            result = dialog.get_tile_data()
            new_char, new_data = result["char"], result["data"]
            self.app_config["tiles"][new_char] = new_data
            if save_config(CONFIG_FILE, self.app_config):
                self.rebuild_palette()
                QApplication.instance().statusBar().showMessage("New tile added.", 3000)
            else:
                QMessageBox.critical(self, "Error", f"Failed save: {CONFIG_FILE}")
                self.app_config.clear()
                self.app_config.update(load_config(CONFIG_FILE))
                self.rebuild_palette()

```

`basicrl/to implement.txt`:

```txt
this is the start of our AI system for our cave dwelling species

# --- Core Libraries ---
import numpy as np          # For map grids, spatial calculations
import polars as pl         # For managing mob state data efficiently
import ray                  # For parallel AI processing [cite: 7]
from numba import njit      # For accelerating critical functions [cite: 5]
from enum import Enum, auto # For state/type definitions
import orjson               # For fast serialization/persistence [cite: 5]
# Assume flow field calculation modules (e.g., pathfinding.flowfields) exist

# --- Enums ---
class AIType(Enum):
    NONE = auto()
    STAYHOME = auto() # Uses HOME logic + stays put
    HOME = auto()     # Moves towards home, basic combat/wander
    ORTHO = auto()    # Orthogonal movement only
    CHARGE = auto()   # Direct charge (uses flow field towards target)
    PATHTO = auto()   # General pathing (uses flow field towards target)
    FLANK = auto()    # Tries to move perpendicular to target vector (complex flow field lookup)
    RANGECOWARD = auto()
    COWARD = auto()   # Uses flee flow field primarily
    MOUSE = auto()
    STRAIGHTLINE = auto()
    SMARTKOBOLD = auto()

class StrategyState(Enum):
    SAMEROOM = auto()
    FETCHITEMS = auto()
    AMBUSH = auto()
    KILL = auto()
    KILLCHASE = auto()
    PARTY = auto()
    # ... other states

class YellType(Enum):
    # ... define yell types
    pass

# --- Data Structures ---
# World Map: Managed via NumPy arrays
# Example:
# terrain_map: np.ndarray (dtype=uint8, representing tile types)
# item_map: np.ndarray (dtype=int32/uint32, representing item IDs or indices)
# flow_field_player: np.ndarray (dtype=float32, shape=(height, width, 2), vectors towards player)
# flow_field_flee_player: np.ndarray (dtype=float32, shape=(height, width, 2), vectors away from player)
# flow_field_home[mob_faction_id]: np.ndarray (Dict mapping faction/group to home flow field)

# Mob State: Managed via Polars DataFrame (mobs_df)
# Columns: entity_id, x, y, hp, ai_type (Enum), strategy_state (Enum), target_entity_id, home_x, home_y,
#          flee_timer, inventory_items (list/struct?), saw_murder (bool), heard_yell_flags (bitmask?), ...,
#          current_flow_field (string/enum referencing which field to use)

# --- Core Parallel Processing Entry Point ---

@ray.remote # Define a Ray actor or task for processing a chunk of mobs
def process_mob_ai_chunk(mobs_chunk_df: pl.DataFrame, world_map_data: dict, global_state: dict) -> pl.DataFrame:
    """
    Processes AI for a subset of mobs. Operates on Polars DataFrame chunk.
    Receives necessary world data (NumPy arrays, global info like player pos).
    Returns DataFrame chunk with updated states and actions to take.
    """
    actions = [] # List to store actions generated by this chunk
    updated_rows = [] # List to store updated mob data rows for merging back

    avatar_pos = global_state['avatar_pos'] # Example global state

    for mob_row in mobs_chunk_df.iter_rows(named=True):
        # Extract necessary data from mob_row (dict)
        mob_id = mob_row['entity_id']
        ai_type = mob_row['ai_type']

        # --- AI Logic Execution ---
        # 1. Handle fleeing override
        if mob_row['flee_timer'] > 0:
             mob_row['flee_timer'] -= 1
             action = ai_flee_from_avatar(mob_row, avatar_pos, world_map_data['flow_field_flee_player'])
             if action:
                 actions.append((mob_id, action))
                 updated_rows.append(mob_row) # Append potentially modified row
                 continue # Skip rest of AI if fled

        # 2. Dispatch to specific AI handler
        # Using a dictionary for dispatch is cleaner than a large if/elif
        ai_handler = AI_DISPATCH_TABLE.get(ai_type, ai_default_handler)
        action, updated_mob_row = ai_handler(mob_row, mobs_chunk_df, world_map_data, global_state)

        if action:
            actions.append((mob_id, action))
        if updated_mob_row: # If handler modified state
             updated_rows.append(updated_mob_row)
        else: # If handler only produced action, still need original row context if merging later
             # This depends on how results are merged. Maybe always return the row.
             updated_rows.append(mob_row)


    # Combine updated rows back into a DataFrame chunk
    # How actions are returned/merged needs careful design (e.g., list of tuples, or action columns in DF)
    updated_chunk_df = pl.DataFrame(updated_rows) # Simplified merge
    return updated_chunk_df, actions


FUNCTION process_all_mob_ai(mobs_df: pl.DataFrame, world_map_data: dict, global_state: dict):
    """
    Main function to update AI for all mobs in parallel using Ray.
    """
    num_chunks = ray.available_resources().get("CPU", 1) # Determine chunks based on cores
    mob_chunks = np.array_split(mobs_df, num_chunks) # Split DataFrame

    # --- Pre-calculate Flow Fields (can also be done less frequently) ---
    # Example: Update player-centric fields every turn if player moved
    if global_state['player_moved']:
        # These functions operate on NumPy grids, potentially @njit accelerated
        world_map_data['flow_field_player'] = pathfinding.flowfields.calculate_flow_field(
            target_pos=global_state['avatar_pos'],
            walkable_map=world_map_data['terrain_map'], # Pass NumPy array
            # ... other params
        )
        world_map_data['flow_field_flee_player'] = pathfinding.flowfields.calculate_flee_field(
             source_pos=global_state['avatar_pos'],
             walkable_map=world_map_data['terrain_map'],
             # ... other params
        )
        # TODO: Update home fields if needed

    # --- Distribute AI processing tasks ---
    # Ensure world_map_data and global_state are efficiently shared (Ray object store)
    world_map_ref = ray.put(world_map_data)
    global_state_ref = ray.put(global_state)

    futures = [process_mob_ai_chunk.remote(chunk, world_map_ref, global_state_ref) for chunk in mob_chunks]
    results = ray.get(futures)

    # --- Merge Results ---
    updated_mob_chunks = [res[0] for res in results]
    all_actions = [action for res in results for action in res[1]] # Flatten actions list

    # Concatenate updated DataFrame chunks using Polars
    updated_mobs_df = pl.concat(updated_mob_chunks)

    # TODO: Apply actions to the game state (e.g., update positions in main mobs_df based on movement actions)
    # This action application step might involve complex logic and needs careful design
    # to handle conflicts and interactions based on 'all_actions'.

    RETURN updated_mobs_df # Return the DataFrame with potentially updated internal AI states


# --- AI Handler Function Examples (using Polars row data) ---

FUNCTION ai_handle_charge(mob_row: dict, all_mobs_df: pl.DataFrame, world_map_data: dict, global_state: dict):
    """ Handler for AI_CHARGE type mobs. """
    action = None
    updated_row = mob_row.copy() # Work on a copy to update state

    # 1. Ranged Attack Check (if capable)
    if mob_can_range_attack(updated_row): # Check capability based on row data
        target_entity_id = updated_row.get('target_entity_id') # Usually avatar
        if target_entity_id is not None:
            # Query target position (potentially from all_mobs_df or global_state)
            target_pos = get_entity_pos(target_entity_id, all_mobs_df, global_state)
            if target_pos:
                 action = attempt_range_attack(updated_row, target_pos, world_map_data['terrain_map'])
                 if action: return action, updated_row

    # 2. Movement using Flow Field
    # Determine target (e.g., avatar)
    target_pos = global_state['avatar_pos'] # Simplified: always target avatar
    flow_field = world_map_data['flow_field_player'] # Use player flow field

    # Get move direction from flow field at mob's current position
    dx, dy = get_flow_direction(mob_row['x'], mob_row['y'], flow_field)

    if dx != 0 or dy != 0:
        # Generate 'bump' action (handles move or melee if target is adjacent)
        action = {'type': 'bump', 'dx': dx, 'dy': dy}
    else:
        # No movement direction or already at target, maybe wait?
        action = {'type': 'wait'}

    return action, updated_row # Return action and potentially updated state row

FUNCTION ai_handle_home(mob_row: dict, all_mobs_df: pl.DataFrame, world_map_data: dict, global_state: dict):
     """ Handler for AI_HOME type mobs. """
     action = None
     updated_row = mob_row.copy()
     home_pos = (mob_row['home_x'], mob_row['home_y'])
     current_pos = (mob_row['x'], mob_row['y'])

     # 1. Ranged Attack (if possible)
     # ... (similar to ai_handle_charge) ...
     if action: return action, updated_row

     # 2. Basic Charge (optional, based on original logic)
     # ... (could call ai_handle_charge logic here if needed) ...

     # 3. Random Wait
     # Need access to RNG state associated with this mob/thread if deterministic per mob
     # Or use a simpler global RNG (less deterministic per mob)
     # Assume get_random_float() exists and is context-aware
     if get_random_float() < 0.7:
          return {'type': 'wait'}, updated_row

     # 4. Move Towards Home using Flow Field
     # Need faction/group ID to select correct home flow field
     faction_id = mob_row.get('faction_id', 'default') # Example
     home_flow_field = world_map_data['flow_field_home'].get(faction_id)

     if home_flow_field is not None and current_pos != home_pos:
          dx, dy = get_flow_direction(mob_row['x'], mob_row['y'], home_flow_field)
          if dx != 0 or dy != 0:
               action = {'type': 'walk', 'dx': dx, 'dy': dy} # Use 'walk' if avoiding combat
     else:
          # At home or no field, wander randomly (simple adjacent move)
          dx, dy = get_random_adjacent_move()
          action = {'type': 'walk', 'dx': dx, 'dy': dy}

     return action, updated_row


FUNCTION ai_handle_smartkobold(mob_row: dict, all_mobs_df: pl.DataFrame, world_map_data: dict, global_state: dict):
     """ Handler for SMARTKOBOLD AI using its state machine. """
     action = None
     updated_row = mob_row.copy() # IMPORTANT: Work on a copy

     # Cache avatar visibility/position
     visible_enemies = find_visible_enemies(updated_row, all_mobs_df, world_map_data['terrain_map'], global_state) # Returns list or None
     avatar_visible_row = None # Polars row/dict if avatar visible
     if visible_enemies:
         # Find avatar specifically if needed
         avatar_entity_id = global_state['avatar_entity_id']
         for enemy in visible_enemies: # Assuming visible_enemies are rows/dicts
             if enemy['entity_id'] == avatar_entity_id:
                 avatar_visible_row = enemy
                 break

     # --- 1. Twitch Reactions ---
     action_taken, updated_row = process_twitch_reactions(updated_row, avatar_visible_row, global_state)
     if action_taken:
         return action_taken, updated_row # Return immediately if twitch resulted in action

     # --- 2. Tactical Combat ---
     if avatar_visible_row: # Only run tactics if avatar (primary enemy) is visible
         action_taken, updated_row = process_tactics(updated_row, avatar_visible_row, all_mobs_df, world_map_data, global_state)
         if action_taken:
             return action_taken, updated_row

     # --- 3. Strategy State Execution ---
     strategy_state = updated_row['strategy_state']

     # Dispatch to strategy state handler (using dict mapping StrategyState Enum to function)
     strategy_handler = STRATEGY_DISPATCH_TABLE.get(strategy_state, strategy_default_handler)
     action_taken, updated_row = strategy_handler(updated_row, avatar_visible_row, all_mobs_df, world_map_data, global_state)

     return action_taken, updated_row


# --- Helper Function Signatures (Illustrative) ---

@njit # Accelerate grid operations
FUNCTION get_flow_direction(x: int, y: int, flow_field: np.ndarray) -> tuple[int, int]:
    """ Looks up the vector direction from a pre-calculated NumPy flow field array. """
    # Bounds checks needed
    vec_x, vec_y = flow_field[y, x]
    # Convert float vector to integer direction (e.g., dominant axis)
    # ... logic to determine best dx, dy in [-1, 0, 1] ...
    dx = int(np.sign(vec_x)) if abs(vec_x) > abs(vec_y) * 0.5 else 0 # Example heuristic
    dy = int(np.sign(vec_y)) if abs(vec_y) > abs(vec_x) * 0.5 else 0 # Example heuristic
    # Refine to ensure only one is non-zero if needed, or allow diagonals
    # Handle zero vectors (at target or obstacles)
    return dx, dy

@njit # Accelerate grid operations
FUNCTION is_walkable(x: int, y: int, terrain_map: np.ndarray) -> bool:
    """ Checks terrain map (NumPy array) for walkability. """
    # Bounds check + terrain type check
    pass

@njit # Accelerate grid operations
FUNCTION line_of_sight(x0, y0, x1, y1, terrain_map: np.ndarray) -> bool:
     """ Numba-accelerated LOS check using Bresenham/raycasting on NumPy grid. """
     pass

FUNCTION attempt_range_attack(mob_row: dict, target_pos: tuple, terrain_map: np.ndarray) -> dict | None:
     """ Checks LOS using Numba func, range, ammo etc. Returns fire action or None. """
     # Needs mob range/weapon data from mob_row
     # Calls line_of_sight()
     pass

FUNCTION ai_flee_from_avatar(mob_row: dict, avatar_pos: tuple, flee_flow_field: np.ndarray) -> dict | None:
     """ Uses the flee flow field to move away from the avatar. """
     dx, dy = get_flow_direction(mob_row['x'], mob_row['y'], flee_flow_field)
     if dx != 0 or dy != 0:
         # Check if move is valid (don't flee into walls)
         next_x, next_y = mob_row['x'] + dx, mob_row['y'] + dy
         if is_walkable(next_x, next_y, flee_flow_field.shape, terrain_map): # Pass map shape too
             return {'type': 'walk', 'dx': dx, 'dy': dy}
     return {'type': 'wait'} # Cannot flee, wait.


FUNCTION find_visible_enemies(mob_row, all_mobs_df, terrain_map, global_state) -> list[dict] | None:
     """
     Finds enemies within sight range and LOS.
     Uses Polars to filter nearby mobs, then Numba LOS checks.
     """
     # 1. Rough filter using Polars based on distance (squared distance is faster)
     sight_range_sq = mob_row['sight_range'] ** 2
     potential_targets = all_mobs_df.filter(
          ((pl.col('x') - mob_row['x'])**2 + (pl.col('y') - mob_row['y'])**2 <= sight_range_sq) &
          (pl.col('faction_id') != mob_row['faction_id']) # Example faction check
     )
     # 2. Precise LOS check on potential targets using Numba function
     visible = []
     for target_row in potential_targets.iter_rows(named=True):
          if line_of_sight(mob_row['x'], mob_row['y'], target_row['x'], target_row['y'], terrain_map):
               visible.append(target_row)
     return visible if visible else None


# --- State Saving/Loading ---
FUNCTION save_game_state(filename: str, mobs_df: pl.DataFrame, world_map_data: dict, global_state: dict, rng_state: dict):
     """ Saves game state using orjson for speed and NumPy/Polars compatibility. """
     state = {
         'mobs_df_ipc': mobs_df.write_ipc(None), # Serialize DataFrame to IPC format bytes
         'world_map_data': {k: v.tolist() if isinstance(v, np.ndarray) else v for k, v in world_map_data.items()}, # Convert NumPy arrays for JSON
         'global_state': global_state,
         'rng_state': rng_state,
         # Add versioning info
     }
     with open(filename, "wb") as f:
          # orjson handles bytes and basic types efficiently
          f.write(orjson.dumps(state, option=orjson.OPT_SERIALIZE_NUMPY)) # Use NumPy option if available


FUNCTION load_game_state(filename: str) -> tuple[pl.DataFrame, dict, dict, dict]:
     """ Loads game state using orjson. """
     with open(filename, "rb") as f:
          state = orjson.loads(f.read())

     # Deserialize DataFrame from IPC bytes
     mobs_df = pl.read_ipc(state['mobs_df_ipc'])

     # Convert lists back to NumPy arrays
     world_map_data = {k: np.array(v) if isinstance(v, list) else v for k, v in state['world_map_data'].items()}

     global_state = state['global_state']
     rng_state = state['rng_state']

     # TODO: Version checking

     return mobs_df, world_map_data, global_state, rng_state

# --- Dispatch Tables (Populate at initialization) ---
AI_DISPATCH_TABLE = {
    AIType.CHARGE: ai_handle_charge,
    AIType.HOME: ai_handle_home,
    AIType.SMARTKOBOLD: ai_handle_smartkobold,
    # ... map other AIType enums to their handler functions ...
}

STRATEGY_DISPATCH_TABLE = {
    # StrategyState.FETCHITEMS: handle_fetch_items_strategy,
    # ... map StrategyState enums to their handler functions ...
}

# Default handlers if needed
FUNCTION ai_default_handler(mob_row, all_mobs_df, world_map_data, global_state): return {'type': 'wait'}, mob_row
FUNCTION strategy_default_handler(mob_row, avatar_visible_row, all_mobs_df, world_map_data, global_state): return {'type': 'wait'}, mob_row


A pathfinding system we're working on for our cave dwelling species.

import heapq
import time
from typing import List, Tuple, Optional, Set

import numpy as np

# --- Numba Acceleration (Install Numba: pip install numba) ---
try:
    from numba import njit
except ImportError:
    print("Warning: Numba not installed. Pathfinding will be significantly slower.")
    # Define a dummy decorator if Numba is not available
    def njit(func=None, **options):
        if func:
            return func
        else:
            def decorator(f):
                return f
            return decorator

# --- Type Aliases ---
GridPosition = Tuple[int, int]

# --- Constants ---
# Define direction vectors (dy, dx) for easier indexing (y first)
#                 N      NE     E      SE     S      SW     W      NW
DIRECTIONS_8: np.ndarray = np.array([
    [-1, 0], [-1, 1], [0, 1], [1, 1], [1, 0], [1, -1], [0, -1], [-1, -1]
], dtype=np.int8)

# Cost for moving diagonally (sqrt(2)) - use approximation or exact
DIAGONAL_MOVE_COST: float = np.sqrt(2.0) # Or 1.414






# --- Core Pathfinding Logic ---

Remember to Integrate Height Cost into Pathfinding


@njit(cache=True, fastmath=True)
def _dijkstra_integration_numba(
    passable_map: np.ndarray, # bool[:]
    terrain_cost_map: np.ndarray, # float[:]
    integration_field: np.ndarray, # float[:] - Modified in place
    initial_sources: List[GridPosition]
) -> bool:
    """
    Performs Dijkstra's algorithm to compute the integration field (cost_so_far).
    Operates directly on NumPy arrays for Numba acceleration.

    Args:
        passable_map: 2D boolean array (True if passable).
        terrain_cost_map: 2D float array of base cost to enter each cell.
        integration_field: 2D float array, initialized to infinity, filled with costs.
        initial_sources: List of (y, x) tuples for starting points.

    Returns:
        True if the algorithm ran, False otherwise (e.g., no valid sources).
    """
    height, width = passable_map.shape
    if not initial_sources:
        return False # No sources to start from

    # Priority Queue: stores (cost, y, x)
    # Numba doesn't directly support heapq with tuples easily in nopython mode yet (as of late 2023/early 2024).
    # Workaround: Use a list-based min-heap manually or pass heapq back to object mode,
    # or use a Numba-compatible priority queue library if available.
    # For simplicity here, we'll use a standard Python list and sort/find min manually inside the loop,
    # which is *less efficient* than heapq but Numba-compatible.
    # A *better* Numba approach would use more complex heap logic.
    # OR: Structure the main loop in Python, calling Numba helpers for neighbor checks.

    # --- Simplified Numba PQ Workaround (Less efficient than heapq!) ---
    # This demonstrates the array logic but sacrifices PQ efficiency in pure Numba.
    # Consider structuring the main loop in Python if heapq is critical.
    pq = [] # Using list as a proxy PQ: [(cost, y, x)]

    # Initialize sources
    for y_s, x_s in initial_sources:
        if 0 <= y_s < height and 0 <= x_s < width and passable_map[y_s, x_s]:
            integration_field[y_s, x_s] = 0.0
            # Using negative index for quick find-min later (less ideal)
            pq.append((-0.0, y_s, x_s))
        else:
            # Optionally print a warning for invalid sources
            pass

    if not pq:
        return False # No valid sources found

    pq.sort(reverse=True) # Sort initially to pop the smallest cost (largest neg index)

    while pq:
        # --- Manual Min-Heap Pop (Inefficient but Numba compatible) ---
        cost_neg, y, x = pq.pop() # Get highest cost (lowest neg)
        cost = -cost_neg
        # --- End Workaround ---

        # If we found a shorter path already, skip
        if cost > integration_field[y, x]:
            continue

        # Explore neighbors
        for i in range(DIRECTIONS_8.shape[0]):
            dy, dx = DIRECTIONS_8[i]
            ny, nx = y + dy, x + dx

            # Check bounds
            if 0 <= ny < height and 0 <= nx < width:
                # Check passability
                if passable_map[ny, nx]:
                    # Calculate move cost
                    move_cost = terrain_cost_map[ny, nx] # Base cost to enter neighbor
                    if dy != 0 and dx != 0: # Diagonal move
                        move_cost *= DIAGONAL_MOVE_COST

                    new_cost = cost + move_cost

                    # If found a cheaper path to the neighbor
                    if new_cost < integration_field[ny, nx]:
                        integration_field[ny, nx] = new_cost
                        # --- Manual Min-Heap Push Workaround ---
                        # Find insertion point and insert (or just append and resort later)
                        # Appending and resorting periodically is simpler for Numba
                        pq.append((-new_cost, ny, nx))
                        # --- End Workaround ---

        # Resort PQ periodically (very inefficient substitute for proper heapq)
        # Only resort if list grows large, e.g. every 100 iterations, reduces overhead slightly
        # This is a major simplification for Numba compatibility; real use might
        # need a different structure or a Numba-compatible heap library.
        if len(pq) > 100 and len(pq) % 100 == 0: # Heuristic resort trigger
             pq.sort(reverse=True)


    return True


@njit(cache=True, fastmath=True)
def _calculate_flow_vectors_numba(
    integration_field: np.ndarray,
    passable_map: np.ndarray, # Need this to avoid flowing into walls
    flow_x: np.ndarray, # int8[:] - Modified in place
    flow_y: np.ndarray, # int8[:] - Modified in place
):
    """
    Calculates the flow vectors based on the integration field.
    Points each cell towards the neighbour with the lowest integration cost.

    Args:
        integration_field: Completed integration cost field.
        passable_map: Boolean map of passable terrain.
        flow_x: 2D int8 array to store dx flow component.
        flow_y: 2D int8 array to store dy flow component.
    """
    height, width = integration_field.shape
    infinity = np.inf # Or a sufficiently large number if inf causes issues

    for y in range(height):
        for x in range(width):
            # Skip impassable cells or cells with no path
            if not passable_map[y, x] or integration_field[y, x] == infinity:
                flow_x[y, x] = 0
                flow_y[y, x] = 0
                continue

            min_cost = integration_field[y, x] # Start with current cell's cost
            best_dx, best_dy = 0, 0

            # Check all 8 neighbours
            for i in range(DIRECTIONS_8.shape[0]):
                dy, dx = DIRECTIONS_8[i]
                ny, nx = y + dy, x + dx

                # Check bounds
                if 0 <= ny < height and 0 <= nx < width:
                    neighbor_cost = integration_field[ny, nx]
                    # Check if neighbor is reachable and has lower cost
                    if neighbor_cost < min_cost:
                        min_cost = neighbor_cost
                        best_dx, best_dy = dx, dy
                # Implicitly handles flowing into impassable neighbours because their
                # integration_field cost will remain infinity (or very high).

            flow_x[y, x] = best_dx
            flow_y[y, x] = best_dy


class FlowFieldPathfinder:
    """
    Manages creation of Integration and Flow Fields using NumPy and Numba.
    Suitable for roguelike environments with non-visual navigation.
    """
    def __init__(self, passable_map: np.ndarray, terrain_cost_map: np.ndarray):
        """
        Initializes the pathfinder with static map data.

        Args:
            passable_map: 2D NumPy boolean array (True=passable).
            terrain_cost_map: 2D NumPy float array (cost to enter cell).
                              Impassable cells should ideally have cost inf or NaN,
                              or rely solely on passable_map checks. Cost > 0.
        """
        if passable_map.shape != terrain_cost_map.shape:
            raise ValueError("Passable map and terrain cost map must have the same shape.")
        if not np.issubdtype(passable_map.dtype, np.bool_):
             raise TypeError("passable_map must be a boolean NumPy array.")
        if not np.issubdtype(terrain_cost_map.dtype, np.floating):
             raise TypeError("terrain_cost_map must be a floating-point NumPy array.")

        self.passable: np.ndarray = passable_map.copy()
        self.terrain_cost: np.ndarray = terrain_cost_map.copy()
        # Ensure costs are positive
        self.terrain_cost[self.terrain_cost <= 0] = 1.0 # Set non-positive costs to 1

        self.height, self.width = self.passable.shape

        # Initialize fields - these will be computed on demand
        self.integration_field: np.ndarray = np.full(self.passable.shape, np.inf, dtype=np.float32)
        self.flow_x: np.ndarray = np.zeros(self.passable.shape, dtype=np.int8)
        self.flow_y: np.ndarray = np.zeros(self.passable.shape, dtype=np.int8)

        self._last_sources: Optional[List[GridPosition]] = None


    def compute_field(self, stimulus_sources: List[GridPosition]) -> bool:
        """
        Computes the Integration and Flow Fields based on stimulus source locations.

        Args:
            stimulus_sources: A list of (y, x) tuples representing the source(s)
                             of the sound, scent, etc.

        Returns:
            True if the field was successfully computed, False otherwise.
        """
        if not stimulus_sources:
            print("Warning: No stimulus sources provided.")
            # Reset fields? Or leave them as they were? Resetting seems safer.
            self.integration_field.fill(np.inf)
            self.flow_x.fill(0)
            self.flow_y.fill(0)
            self._last_sources = None
            return False

        # --- Optimization: Check if sources haven't changed ---
        # Simple check, could be more robust (e.g., checking content hash)
        if self._last_sources and set(stimulus_sources) == set(self._last_sources):
             print("Skipping field computation: sources unchanged.")
             return True

        print(f"Computing flow field from {len(stimulus_sources)} sources...")
        start_time = time.time()

        # 1. Reset and Initialize Integration Field
        self.integration_field.fill(np.inf)
        valid_sources = [s for s in stimulus_sources if 0 <= s[0] < self.height and 0 <= s[1] < self.width]
        if not valid_sources:
             print("Warning: All provided stimulus sources are out of bounds.")
             self._last_sources = list(stimulus_sources) # Store attempted sources
             return False

        # --- Use Python heapq for Dijkstra's main loop for efficiency ---
        # The Numba function is kept for the neighbor logic if needed,
        # but driving the PQ from Python is often better.
        pq = [] # List acting as min-heap: [(cost, y, x)]

        for y_s, x_s in valid_sources:
             if self.passable[y_s, x_s]:
                  cost = 0.0
                  self.integration_field[y_s, x_s] = cost
                  heapq.heappush(pq, (cost, y_s, x_s))
             else:
                  print(f"Warning: Source at ({y_s}, {x_s}) is on impassable terrain.")

        if not pq:
             print("Warning: No valid stimulus sources on passable terrain.")
             self._last_sources = list(stimulus_sources)
             return False


        # 2. Run Dijkstra to create Integration Field
        processed_count = 0
        while pq:
            cost, y, x = heapq.heappop(pq)
            processed_count += 1

            # If we found a shorter path already (due to duplicates in PQ), skip
            if cost > self.integration_field[y, x]:
                continue

            # Explore neighbors
            for i in range(DIRECTIONS_8.shape[0]):
                dy, dx = DIRECTIONS_8[i]
                ny, nx = y + dy, x + dx

                # Check bounds and passability
                if 0 <= ny < self.height and 0 <= nx < self.width and self.passable[ny, nx]:
                    move_cost = self.terrain_cost[ny, nx] # Cost to enter neighbor
                    if dy != 0 and dx != 0: # Diagonal move
                        move_cost *= DIAGONAL_MOVE_COST

                    new_cost = cost + move_cost

                    if new_cost < self.integration_field[ny, nx]:
                        self.integration_field[ny, nx] = new_cost
                        heapq.heappush(pq, (new_cost, ny, nx))

        integration_time = time.time()
        print(f"  Integration field computed ({processed_count} nodes processed) in {integration_time - start_time:.4f}s")


        # 3. Calculate Flow Vectors using Numba helper
        self.flow_x.fill(0) # Reset flow field
        self.flow_y.fill(0)
        _calculate_flow_vectors_numba(
            self.integration_field, self.passable, self.flow_x, self.flow_y
        )

        flow_time = time.time()
        print(f"  Flow vectors calculated in {flow_time - integration_time:.4f}s")
        print(f"Total field computation time: {flow_time - start_time:.4f}s")

        self._last_sources = list(stimulus_sources) # Store successfully used sources
        return True

    def get_flow_vector(self, y: int, x: int) -> GridPosition:
        """Returns the optimal flow vector (dx, dy) for a given cell."""
        if 0 <= y < self.height and 0 <= x < self.width:
            return (int(self.flow_x[y, x]), int(self.flow_y[y, x])) # Cast necessary? int8 stored
        else:
            # Out of bounds, return no movement
            return (0, 0)

    def get_flow_field(self) -> Tuple[np.ndarray, np.ndarray]:
        """Returns the complete flow field arrays (dx, dy components)."""
        return self.flow_x, self.flow_y

    def get_integration_field(self) -> np.ndarray:
         """Returns the computed integration field (cost to reach source)."""
         return self.integration_field


# --- Example Usage ---
if __name__ == "__main__":

    # 1. Create Map Data (NumPy arrays)
    map_h, map_w = 50, 70
    passable = np.ones((map_h, map_w), dtype=bool)
    costs = np.ones((map_h, map_w), dtype=np.float32)

    # Add some walls
    passable[map_h // 2, map_w // 4 : map_w * 3 // 4] = False
    passable[map_h // 4 : map_h * 3 // 4, map_w // 2] = False
    passable[10:15, 10:15] = False # Box wall

    # Add some high-cost terrain (mud)
    costs[20:30, 40:60] = 5.0 # Mud costs 5x

    print(f"Created map: {map_w}x{map_h}")

    # 2. Initialize Pathfinder
    pathfinder = FlowFieldPathfinder(passable, costs)

    # 3. Define Stimulus Source(s) (e.g., player position, sound event)
    # Remember: (y, x) format
    sources: List[GridPosition] = [(map_h // 2, map_w // 2 + 5)]

    # Check source validity
    if not pathfinder.passable[sources[0]]:
         print(f"Warning: Source {sources[0]} is initially impassable!")
         # Example: Find nearest passable tile if needed
         # sources = find_nearest_passable(sources, pathfinder.passable)


    # 4. Compute the field
    success = pathfinder.compute_field(sources)

    # 5. Get Flow Vector for an Agent
    if success:
        agent_pos_y, agent_pos_x = 10, 10
        if pathfinder.passable[agent_pos_y, agent_pos_x]:
            flow_dx, flow_dy = pathfinder.get_flow_vector(agent_pos_y, agent_pos_x)
            print(f"Agent at ({agent_pos_y}, {agent_pos_x}) should move by: ({flow_dx}, {flow_dy})")

            # Example: Check cost from agent position
            cost_from_agent = pathfinder.get_integration_field()[agent_pos_y, agent_pos_x]
            print(f"Cost from agent position to source: {cost_from_agent:.2f}")
        else:
            print(f"Agent at ({agent_pos_y}, {agent_pos_x}) is on impassable terrain.")


        # --- Optional: Simple Text Visualization ---
        print("\nVisualizing Flow Field (Sample):")
        flow_x_field, flow_y_field = pathfinder.get_flow_field()
        viz_step = 3 # Draw arrow every N cells
        dir_symbols = {
            (-1, 0): '^', (-1, 1): '/', (0, 1): '>', (1, 1): '\\',
            (1, 0): 'v', (1, -1): '/', (0, -1): '<', (-1, -1): '\\',
            (0, 0): '·' # No movement / source / unreachable
        }
        for y in range(0, map_h, viz_step):
            row_str = ""
            for x in range(0, map_w, viz_step):
                if not passable[y, x]:
                    row_str += "###"
                elif (y,x) in sources:
                     row_str += " S "
                else:
                    dy = int(flow_y_field[y, x])
                    dx = int(flow_x_field[y, x])
                    symbol = dir_symbols.get((dy, dx), '?')
                    # Add space for alignment
                    row_str += f" {symbol} "
            print(row_str)

        # --- Example: Recompute with different source ---
        print("\nRecomputing with source at (5, 5)...")
        success_new = pathfinder.compute_field([(5, 5)])
        if success_new:
             flow_dx_new, flow_dy_new = pathfinder.get_flow_vector(agent_pos_y, agent_pos_x)
             print(f"Agent at ({agent_pos_y}, {agent_pos_x}) should now move by: ({flow_dx_new}, {flow_dy_new})")


This is the to-implement for physics/pathfinding/map gen

# Deferred Features & Complexity: Height System (Initial Implementation Focus)

This document outlines features related to the height/ceiling map system that are intentionally **deferred** from the initial implementation phase. The focus is first on establishing the core data structures (`height_map`, `ceiling_map`) and integrating them into basic movement, FOV, and pathfinding cost.

## 1. Wall Representation

* **Variable Wall Heights (Option B):** Deferring the implementation where wall tiles (`TILE_ID_WALL`) have distinct `height_map` (bottom) and `ceiling_map` (top) values.
    * *Initial approach:* Wall tiles block implicitly; adjacent floor/ceiling heights are used.

## 2. Traversal & Movement Costs

* **Complex Movement Cost Calculation:** Deferring combined cost calculations involving both terrain type (e.g., mud) *and* slope (`delta_h`).
    * *Initial approach:* Basic `max_traversable_step` check. Pathfinding cost will use base terrain cost + diagonal penalty initially; height cost added separately later.
* **Falling Mechanics:** Deferring the implementation of allowing movement down steep drops (`abs(delta_h) > max_traversable_step`) and applying falling damage.
    * *Initial approach:* Drops exceeding `max_traversable_step` block movement.
* **Skill/Item-Based Traversal:** Deferring modifications to `max_traversable_step` based on player/NPC skills (Climbing) or items (Rope, Pitons).

## 3. Entity Variations

* **Entity-Specific `max_traversable_step`:** Deferring storing and using traversal limits per entity type via a component in the `EntityRegistry`.
    * *Initial approach:* All entities use the global default from `config.yaml`.
* **Entity-Specific Height & Headroom:** While standard entity height (e.g., 4 units / 2m) will be assumed for headroom checks *if* implemented, detailed per-entity height components and rigorous headroom logic are deferred.
    * *Initial approach:* Implement basic headroom check later if needed, assuming a standard height first.
* **Special Movement Rules (Flying, Phasing, Climbing):** Deferring the detailed rules and implementation for entities that don't adhere to standard ground-based movement and height constraints.

## 4. Advanced Physics & Environment Interaction

* **Projectile Trajectories:** Deferring calculations for projectile arcs affected by height differences and ceiling obstructions.
* **Fluid Dynamics:** Deferring simulation of water flow based on `height_map` gradients.
* **Gas/Temperature Propagation:** Deferring effects of height/ceilings on atmospheric simulations.
* **Other Physics:** Any physics simulation directly interacting with the height/ceiling data beyond basic blocking.

## 5. Generation Refinements

* **Complex Height Heuristics:** While basic room/corridor heights will be implemented, advanced heuristics (e.g., multi-level rooms, complex cavern ceilings, detailed erosion) are deferred.
* **Post-Generation Smoothing:** Optional smoothing passes on the `height_map` are deferred unless initial results are visually jarring.

## 6. Visualization Refinements

* **Advanced Blending Modes:** Deferring experimentation with blend modes beyond simple linear interpolation for the height visualization.
* **Non-Color Indicators:** Deferring alternative height indicators (e.g., glyph modification) for accessibility.

```

`basicrl/utils/README.md`:

```md
# simple_rl/rng_utils - Deterministic Random Number Generator

## Purpose

This module provides the `GameRNG` class, a high-performance, deterministic Random Number Generator (RNG) specifically designed for simulation and game development needs within the `simple_rl` project. It replaces the standard `random` module to ensure reproducibility, offer advanced features, and optimize performance for random number generation tasks.

This is a foundational component used by various parts of the project (e.g., `simple_rl/Dungeon`, AI systems) to ensure that procedural generation and stochastic events are consistent and repeatable given the same initial seed and sequence of operations.

## Key Features

* **Determinism & Reproducibility:** Designed to produce the exact same sequence of random numbers given the same initial seed. This is crucial for debugging, testing, and consistent gameplay experiences.
* **State Management:** Supports saving and loading the complete internal state of the generator (`save_state_to_file`, `load_state_from_file`, `get_state`, `set_state`). This allows simulations to be paused and resumed perfectly, or specific scenarios to be replayed.
* **Multiple PRNG Algorithms:** Allows selection between different underlying Pseudo-Random Number Generators (PRNGs), currently supporting NumPy's PCG64 (default) and Xorshift128+ via Numba.
* **Performance:**
    * **Bit Buffering (`CircularBitBuffer`):** Generates random bits in larger chunks and serves requests from an efficient buffer, reducing the overhead of calling the underlying PRNG frequently for small requests (e.g., individual boolean flags).
    * **Numba Acceleration:** Includes Numba-accelerated implementations for Perlin noise generation (`noise_1d`, `noise_2d`).
* **Game-Specific Utilities:** Provides common functions needed in game development:
    * Dice rolling (`dice`).
    * Dealing cards from a standard deck (`deal_cards`).
    * Weighted sampling using A-Res algorithm (`weighted_sample_ares`).
    * Generating version 4 UUIDs (`uuid4`).
    * Standard distributions (`randint`, `choice`, `shuffle`, `uniform`, `normal`, etc.).
* **Thread Safety:** Uses `threading.RLock` to ensure safe usage across multiple threads if needed (though the primary usage pattern involves passing a single instance).
* **Metrics & Self-Tests:** Includes optional performance metrics collection (`MetricsCollector`) and internal self-tests to verify correctness.

## Usage Pattern

The intended usage is to instantiate `GameRNG` once at a high level (e.g., at the start of the main application or simulation) with a specific seed. This instance should then be passed down to any component or function that requires random numbers.

```python
# Example Usage (in a main script)
from simple_rl.rng_utils.game_rng import GameRNG

# Initialize with a seed (e.g., from config or system time)
main_rng = GameRNG(seed=12345)

# Pass the same instance to different components
dungeon_map = generate_dungeon(..., rng=main_rng)
npc_behavior = update_npc(..., rng=main_rng)

# Save state if needed
main_rng.save_state_to_file("game_rng_state.json")

```

`basicrl/utils/helpers.py`:

```py
# utils/helpers.py
import re
from typing import TYPE_CHECKING, Union # *** MODIFIED: Added Union ***

import structlog  # Added for logging potential errors

# Assuming GameRNG might be defined elsewhere, handle potential import
try:
    # Adjust import path based on actual location of GameRNG
    from game_rng import GameRNG
except ImportError:
    # Fallback if GameRNG is not directly importable this way
    # This might happen if game_rng.py is not in python path correctly
    # Or if it's intended to be passed explicitly always.
    # For now, we add a check in _roll_dice.
    GameRNG = None

if TYPE_CHECKING:
    # Conditional import for type checkers
    if GameRNG is None:
        from typing import Any

        GameRNG = Any  # Provide a fallback type hint

log = structlog.get_logger(__name__)  # Use module logger

# --- Dice Rolling Utility (Moved from effects.handlers) ---
DICE_PATTERN = re.compile(r"(\d+)?d(\d+)(?:([+-])(\d+))?")


# Make it a public function
# *** MODIFIED: Replaced | with Union[] ***
def roll_dice(dice_str: Union[str, None], rng: Union["GameRNG", None]) -> int:
    """
    Rolls dice based on a string format (e.g., '1d6', '2d4+1').
    Requires a GameRNG instance.
    """
    if not dice_str:
        return 0
    if rng is None:
        # Check if GameRNG was imported successfully, otherwise raise error
        if GameRNG is None:
            log.critical(
                "GameRNG type could not be imported, cannot roll dice without RNG instance."
            )
            raise TypeError("GameRNG instance is required for roll_dice.")
        else:
            log.error("Dice roll attempted without RNG instance!")
            # Consider raising an error instead of returning 0? Depends on expected usage.
            # raise ValueError("RNG instance is required for roll_dice.")
            return 0  # Returning 0 for now, but this indicates an issue.

    match = DICE_PATTERN.match(dice_str)
    if match:
        num_dice_str, sides_str, operator, bonus_str = match.groups()
        num_dice = int(num_dice_str) if num_dice_str else 1
        sides = int(sides_str)
        bonus = int(f"{operator}{bonus_str}") if operator and bonus_str else 0
        if sides <= 0:
            return bonus
        if num_dice <= 0:
            return bonus
        # Use the passed RNG instance
        try:
            roll_total = sum(rng.get_int(1, sides) for _ in range(num_dice))
            return roll_total + bonus
        except AttributeError:
            log.error(
                "Passed rng object does not have expected 'get_int' method.",
                rng_type=type(rng),
            )
            raise  # Re-raise the error as this is unexpected
        except Exception as e:
            log.error("Error during RNG dice roll", error=str(e), exc_info=True)
            raise  # Re-raise other RNG errors

    else:
        try:
            return int(dice_str)  # Allow plain numbers
        except ValueError:
            log.error("Invalid dice string format", dice_str=dice_str)
            return 0

```